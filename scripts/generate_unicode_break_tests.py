#!/usr/bin/env python
# -*- coding: utf-8 -*-

prop_lookup_test_form = decls = '''\
// Warning! This file is autogenerated.
#include <boost/text/{0}_break.hpp>

#include <gtest/gtest.h>


TEST({0}, prop_lookups_{2})
{{{1}
}}
'''

break_test_form = decls = '''\
// Warning! This file is autogenerated.
#include <boost/text/{0}_break.hpp>

#include <gtest/gtest.h>

#include <algorithm>


TEST({0}, breaks_{2})
{{{1}
}}
'''

grapheme_iterator_test_form = decls = '''\
// Warning! This file is autogenerated.
#include <boost/text/grapheme_iterator.hpp>

#include <gtest/gtest.h>

#include <algorithm>


TEST(grapheme, iterator_{1})
{{{0}
}}
'''

# TODO: Add iterator tests that use utf8::to_utf32_iterator.
# TODO: Test reverse iteration.
# TODO: Test mixed forward and reverse iteration.

def extract_cps_and_breaks(filename):
    current_batch = []
    retval = []
    lines = open(filename, 'r').readlines()
    num_lines = 0
    for line in lines:
        if num_lines == 200:
            retval.append(current_batch)
            current_batch = []
            num_lines = 0
        line = line[:-1]
        if not line.startswith('#') and len(line) != 0:
            comment_start = line.find('#')
            comment = ''
            if comment_start != -1:
                comment = line[comment_start + 1:].strip()
                line = line[:comment_start]
            fields = line.split(' ')[1:-1]
            cps = []
            active_break = True
            for i in range(len(fields)):
                f = fields[i]
                if f[0] in '0123456789ABCDEF':
                    cps.append((f, active_break))
                else:
                    active_break = f == 'รท'
            current_batch.append((cps, line, comment))
        num_lines += 1
    if len(current_batch):
        retval.append(current_batch)
    return retval

def generate_prop_lookup_tests(cps_and_breaks, prop_, prop_names):
    for i in range(len(cps_and_breaks)):
        prop_lookup_tests = ''
        chunk = cps_and_breaks[i]
        for elem in chunk:
            (cps, line, comment) = elem
            comment_fields = comment.split(' ')
            j = 0
            for f in comment_fields:
                if f.startswith('(') and f.endswith(')'):
                    prop_lookup_tests += \
                        '\n    EXPECT_EQ(boost::text::{0}_prop(0x{1}), {2});'.format(
                            prop_, cps[j][0], prop_names[f[1:-1]]
                        )
                    j += 1
        cpp_file = open('{}_prop_lookup_{}.cpp'.format(prop_, i), 'w')
        cpp_file.write(prop_lookup_test_form.format(prop_, prop_lookup_tests, i))

def generate_break_tests(cps_and_breaks, prop_):
    for i in range(len(cps_and_breaks)):
        break_tests = ''
        chunk = cps_and_breaks[i]
        for elem in chunk:
            (cps, line, comment) = elem
            comment_fields = comment.split(' ')
            break_tests += '''
    // {0}
    // {1}
    {{
        boost::text::{2}_break_t prev_break;
'''.format(line, comment, prop_)
            if 'word' in prop_:
                break_tests += '\n        prev_break.prop_ = boost::text::{}_prop(0x{});\n'.format(
                    prop_, cps[0][0]
                )
            for j in range(len(cps)):
                cp = cps[j]
                if 'word' in prop_:
                    next_cp = j == len(cps) - 1 and '0' or cps[j + 1][0]
                    break_tests += '''
        prev_break = boost::text::{}_break(prev_break.fsm_, prev_break.prev_prop_, prev_break.prop_, 0x{});
        EXPECT_EQ(prev_break.break_, {});'''.format(prop_, next_cp, cp[1] and 'true' or 'false')
                else:
                    break_tests += '''
        prev_break = boost::text::{}_break(prev_break.fsm_, prev_break.prop_, 0x{});
        EXPECT_EQ(prev_break.break_, {});'''.format(prop_, cp[0], cp[1] and 'true' or 'false')
            break_tests += '\n    }\n'
        cpp_file = open('{}_break_{}.cpp'.format(prop_, i), 'w')
        cpp_file.write(break_test_form.format(prop_, break_tests, i))

def one_break(cps):
    breaks = 0
    for cp in cps:
        if cp[1]:
            breaks += 1
    return breaks == 1

def generate_iterator_tests(cps_and_breaks, prop_):
    for i in range(len(cps_and_breaks)):
        iterator_tests = ''
        chunk = cps_and_breaks[i]
        for elem in chunk:
            (cps, line, comment) = elem
            comment_fields = comment.split(' ')

            break_cp_indices = []
            for j in range(len(cps)):
                if cps[j][1]: # if break
                    break_cp_indices.append(j)

            # forward
            iterator_tests += '''
    // {0}
    // {1}
    {{
        uint32_t const cps[] = {{ {2} }};
        boost::text::{3}_iterator<uint32_t const *> it(cps, cps, cps + {4});
'''.format(line, comment, '0x' + ', 0x'.join(map(lambda x: x[0], cps)), prop_, len(cps))
            for j in range(len(break_cp_indices)):
                first = break_cp_indices[j]
                last = j == len(break_cp_indices) - 1 and len(cps) or break_cp_indices[j + 1]
                iterator_tests += '''
        EXPECT_EQ(it.base(), cps + {0});
        EXPECT_EQ((*it).begin(), cps + {0});
        EXPECT_EQ((*it).end(), cps + {1});

        ++it;
'''.format(first, last)
            iterator_tests += '''\
        EXPECT_EQ(it.base(), cps + {});
        EXPECT_EQ((*it).begin(), (*it).end());
    }}
'''.format(len(cps))

            # reverse
            iterator_tests += '''\
    {{
        // reverse
        uint32_t const cps[] = {{ {0} }};
        boost::text::{1}_iterator<uint32_t const *> it(cps, cps + {2}, cps + {2});

        EXPECT_EQ(it.base(), cps + {2});
        EXPECT_EQ((*it).begin(), (*it).end());
'''.format('0x' + ', 0x'.join(map(lambda x: x[0], cps)), prop_, len(cps))
            for j in reversed(range(len(break_cp_indices))):
                first = break_cp_indices[j]
                last = j == len(break_cp_indices) - 1 and len(cps) or break_cp_indices[j + 1]
                iterator_tests += '''
        --it;

        EXPECT_EQ(it.base(), cps + {0});
        EXPECT_EQ((*it).begin(), cps + {0});
        EXPECT_EQ((*it).end(), cps + {1});
'''.format(first, last)
            iterator_tests += '    }\n'

        cpp_file = open('{}_iterator_{}.cpp'.format(prop_, i), 'w')
        cpp_file.write(grapheme_iterator_test_form.format(iterator_tests, i))


grapheme_prop_names = {
    'Other': 'boost::text::grapheme_prop_t::Other',
    'Prepend': 'boost::text::grapheme_prop_t::Prepend',
    'CR': 'boost::text::grapheme_prop_t::CR',
    'LF': 'boost::text::grapheme_prop_t::LF',
    'Control': 'boost::text::grapheme_prop_t::Control',
    'Extend': 'boost::text::grapheme_prop_t::Extend',
    'RI': 'boost::text::grapheme_prop_t::Regional_Indicator',
    'SpacingMark': 'boost::text::grapheme_prop_t::SpacingMark',
    'L': 'boost::text::grapheme_prop_t::L',
    'V': 'boost::text::grapheme_prop_t::V',
    'T': 'boost::text::grapheme_prop_t::T',
    'LV': 'boost::text::grapheme_prop_t::LV',
    'LVT': 'boost::text::grapheme_prop_t::LVT',
    'E_Base': 'boost::text::grapheme_prop_t::E_Base',
    'E_Modifier': 'boost::text::grapheme_prop_t::E_Modifier',
    'ZWJ': 'boost::text::grapheme_prop_t::ZWJ',
    'Glue_After_Zwj': 'boost::text::grapheme_prop_t::Glue_After_Zwj',
    'EBG': 'boost::text::grapheme_prop_t::E_Base_GAZ'
}

grapheme_cps_and_breaks = extract_cps_and_breaks('GraphemeBreakTest.txt')
generate_prop_lookup_tests(grapheme_cps_and_breaks, 'grapheme', grapheme_prop_names)
generate_break_tests(grapheme_cps_and_breaks, 'grapheme')
generate_iterator_tests(grapheme_cps_and_breaks, 'grapheme')

word_prop_names = {
    'Other': 'boost::text::word_prop_t::Other',
    'Double_Quote': 'boost::text::word_prop_t::Double_Quote',
    'Single_Quote': 'boost::text::word_prop_t::Single_Quote',
    'Hebrew_Letter': 'boost::text::word_prop_t::Hebrew_Letter',
    'CR': 'boost::text::word_prop_t::CR',
    'LF': 'boost::text::word_prop_t::LF',
    'Newline': 'boost::text::word_prop_t::Newline',
    'Extend_FE': 'boost::text::word_prop_t::Extend',
    'RI': 'boost::text::word_prop_t::Regional_Indicator',
    'Format_FE': 'boost::text::word_prop_t::Format',
    'Katakana': 'boost::text::word_prop_t::Katakana',
    'ALetter': 'boost::text::word_prop_t::ALetter',
    'MidLetter': 'boost::text::word_prop_t::MidLetter',
    'MidNum': 'boost::text::word_prop_t::MidNum',
    'MidNumLet': 'boost::text::word_prop_t::MidNumLet',
    'Numeric': 'boost::text::word_prop_t::Numeric',
    'ExtendNumLet': 'boost::text::word_prop_t::ExtendNumLet',
    'E_Base': 'boost::text::word_prop_t::E_Base',
    'E_Modifier': 'boost::text::word_prop_t::E_Modifier',
    'ZWJ_FE': 'boost::text::word_prop_t::ZWJ',
    'Glue_After_Zwj': 'boost::text::word_prop_t::Glue_After_Zwj',
    'EBG': 'boost::text::word_prop_t::E_Base_GAZ'
}

word_cps_and_breaks = extract_cps_and_breaks('WordBreakTest.txt')
generate_prop_lookup_tests(word_cps_and_breaks, 'word', word_prop_names)
generate_break_tests(word_cps_and_breaks, 'word')

# TODO: Add sentence breaks?
