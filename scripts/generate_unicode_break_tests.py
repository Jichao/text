#!/usr/bin/env python
# -*- coding: utf-8 -*-

prop_lookup_test_form = decls = '''\
// Warning! This file is autogenerated.
#include <boost/text/{0}_break.hpp>

#include <gtest/gtest.h>


TEST({0}, prop_lookups_{2})
{{{1}
}}
'''

grapheme_break_test_form = decls = '''\
// Warning! This file is autogenerated.
#include <boost/text/grapheme_break.hpp>

#include <gtest/gtest.h>

#include <algorithm>


TEST(grapheme, breaks_{1})
{{{0}
}}
'''

grapheme_iterator_test_form = decls = '''\
// Warning! This file is autogenerated.
#include <boost/text/grapheme_iterator.hpp>

#include <gtest/gtest.h>

#include <algorithm>


TEST(grapheme, iterator_{1})
{{{0}
}}
'''

word_break_test_form = decls = '''\
// Warning! This file is autogenerated.
#include <boost/text/word_break.hpp>

#include <gtest/gtest.h>

#include <algorithm>


TEST(word, breaks_{1})
{{{0}
}}
'''


def extract_break_tests(filename, prop_, prop_names):
    prop_lookup_test = ''
    prop_lookup_tests = []
    break_test = ''
    break_tests = []
    iterator_test_lines = ''
    iterator_test = ''
    iterator_tests = []
    lines = open(filename, 'r').readlines()
    num_lines = 0
    for line in lines:
        if num_lines == 200:
            prop_lookup_tests.append(prop_lookup_test)
            prop_lookup_test = ''
            break_tests.append(break_test)
            break_test = ''
            iterator_tests.append(iterator_test)
            iterator_test = ''
            num_lines = 0
        line = line[:-1]
        if not line.startswith('#') and len(line) != 0:
            comment_start = line.find('#')
            comment = ''
            if comment_start != -1:
                comment = line[comment_start + 1:].strip()
                line = line[:comment_start]
            fields = line.split(' ')[1:-1]
            cps = []
            active_break = True
            break_test += '''
    // {0}
    // {1}
    {{
        boost::text::{2}_break_t prev_break;
'''.format(line, comment, prop_)
            iterator_test_lines = ''
            iterator_test += '''
    // {0}
    // {1}
    {{
        uint32_t const cps[] = {{ '''.format(line, comment)
            if 'word' in prop_:
                break_test += '\n        prev_break.prop_ = boost::text::{}_prop(0x{});\n'.format(
                    prop_, fields[0]
                )
            breaks = 0
            for i in range(len(fields)):
                f = fields[i]
                if f[0] in '0123456789ABCDEF':
                    cps.append(f)
                    if active_break:
                        breaks += 1
                        if i != 0:
                            iterator_test_lines += '''
        EXPECT_EQ((*it).end(), cps + {});

        ++it;
'''.format(i / 2)
                        iterator_test_lines += '''
        EXPECT_EQ(it.base(), cps + {0});
        EXPECT_EQ((*it).begin(), cps + {0});'''.format(i / 2)
                        if i == len(fields) - 1:
                            iterator_test_lines += '''
        EXPECT_EQ((*it).end(), cps + {});'''.format(len(cps))
                    if 'grapheme' in prop_:
                        break_test += '''
        prev_break = boost::text::{}_break(prev_break.fsm_, prev_break.prop_, 0x{});
        EXPECT_EQ(prev_break.break_, {});'''.format(prop_, f, active_break and 'true' or 'false')
                    else:
                        next_cp = i == len(fields) - 1 and '0' or fields[i + 2]
                        break_test += '''
        prev_break = boost::text::{}_break(prev_break.fsm_, prev_break.prev_prop_, prev_break.prop_, 0x{});
        EXPECT_EQ(prev_break.break_, {});'''.format(prop_, next_cp, active_break and 'true' or 'false')
                else:
                    active_break = f == 'รท'
            if breaks == 1:
                iterator_test_lines += '''
        EXPECT_EQ((*it).end(), cps + {});'''.format(len(cps))
            break_test += '\n    }\n'
            iterator_test_lines += '''

        ++it;
        EXPECT_EQ(it.base(), cps + {});
        EXPECT_EQ((*it).begin(), (*it).end());'''.format(len(cps))

            iterator_test += '''{0} }};
        boost::text::{1}_iterator<uint32_t const *> it(cps, cps, cps + {2});
{3}
    }}
'''.format('0x' + ', 0x'.join(cps), prop_, len(cps), iterator_test_lines)
            iterator_test_lines = ''

            comment_fields = comment.split(' ')
            i = 0
            for f in comment_fields:
                if f.startswith('(') and f.endswith(')'):
                    prop_lookup_test += \
                        '\n    EXPECT_EQ(boost::text::{0}_prop(0x{1}), {2});'.format(
                            prop_, cps[i], prop_names[f[1:-1]]
                        )
                    i += 1
        num_lines += 1
    return (prop_lookup_tests, break_tests, iterator_tests)

grapheme_prop_names = {
    'Other': 'boost::text::grapheme_prop_t::Other',
    'Prepend': 'boost::text::grapheme_prop_t::Prepend',
    'CR': 'boost::text::grapheme_prop_t::CR',
    'LF': 'boost::text::grapheme_prop_t::LF',
    'Control': 'boost::text::grapheme_prop_t::Control',
    'Extend': 'boost::text::grapheme_prop_t::Extend',
    'RI': 'boost::text::grapheme_prop_t::Regional_Indicator',
    'SpacingMark': 'boost::text::grapheme_prop_t::SpacingMark',
    'L': 'boost::text::grapheme_prop_t::L',
    'V': 'boost::text::grapheme_prop_t::V',
    'T': 'boost::text::grapheme_prop_t::T',
    'LV': 'boost::text::grapheme_prop_t::LV',
    'LVT': 'boost::text::grapheme_prop_t::LVT',
    'E_Base': 'boost::text::grapheme_prop_t::E_Base',
    'E_Modifier': 'boost::text::grapheme_prop_t::E_Modifier',
    'ZWJ': 'boost::text::grapheme_prop_t::ZWJ',
    'Glue_After_Zwj': 'boost::text::grapheme_prop_t::Glue_After_Zwj',
    'EBG': 'boost::text::grapheme_prop_t::E_Base_GAZ'
}

(grapheme_prop_lookup_tests, grapheme_break_tests, grapheme_iterator_tests) = \
    extract_break_tests('GraphemeBreakTest.txt', 'grapheme', grapheme_prop_names)
for i in range(len(grapheme_prop_lookup_tests)):
    cpp_file = open('grapheme_prop_lookup_{}.cpp'.format(i), 'w')
    cpp_file.write(prop_lookup_test_form.format('grapheme', grapheme_prop_lookup_tests[i], i))
    cpp_file = open('grapheme_break_{}.cpp'.format(i), 'w')
    cpp_file.write(grapheme_break_test_form.format(grapheme_break_tests[i], i))
    cpp_file = open('grapheme_iterator_{}.cpp'.format(i), 'w')
    cpp_file.write(grapheme_iterator_test_form.format(grapheme_iterator_tests[i], i))


word_prop_names = {
    'Other': 'boost::text::word_prop_t::Other',
    'Double_Quote': 'boost::text::word_prop_t::Double_Quote',
    'Single_Quote': 'boost::text::word_prop_t::Single_Quote',
    'Hebrew_Letter': 'boost::text::word_prop_t::Hebrew_Letter',
    'CR': 'boost::text::word_prop_t::CR',
    'LF': 'boost::text::word_prop_t::LF',
    'Newline': 'boost::text::word_prop_t::Newline',
    'Extend_FE': 'boost::text::word_prop_t::Extend',
    'RI': 'boost::text::word_prop_t::Regional_Indicator',
    'Format_FE': 'boost::text::word_prop_t::Format',
    'Katakana': 'boost::text::word_prop_t::Katakana',
    'ALetter': 'boost::text::word_prop_t::ALetter',
    'MidLetter': 'boost::text::word_prop_t::MidLetter',
    'MidNum': 'boost::text::word_prop_t::MidNum',
    'MidNumLet': 'boost::text::word_prop_t::MidNumLet',
    'Numeric': 'boost::text::word_prop_t::Numeric',
    'ExtendNumLet': 'boost::text::word_prop_t::ExtendNumLet',
    'E_Base': 'boost::text::word_prop_t::E_Base',
    'E_Modifier': 'boost::text::word_prop_t::E_Modifier',
    'ZWJ_FE': 'boost::text::word_prop_t::ZWJ',
    'Glue_After_Zwj': 'boost::text::word_prop_t::Glue_After_Zwj',
    'EBG': 'boost::text::word_prop_t::E_Base_GAZ'
}

(word_prop_lookup_tests, word_break_tests, word_iterator_tests) = \
    extract_break_tests('WordBreakTest.txt', 'word', word_prop_names)
for i in range(len(word_prop_lookup_tests)):
    cpp_file = open('word_prop_lookup_{}.cpp'.format(i), 'w')
    cpp_file.write(prop_lookup_test_form.format('word', word_prop_lookup_tests[i], i))
    cpp_file = open('word_break_{}.cpp'.format(i), 'w')
    cpp_file.write(word_break_test_form.format(word_break_tests[i], i))

# TODO: Add sentence breaks?
