#!/usr/bin/env python

ccc_file_form = decls = '''\
// Warning! This file is autogenerated.
#include <boost/text/normalization_data.hpp>

#include <boost/container/static_vector.hpp>

#include <unordered_map>


namespace boost {{ namespace text {{

static const std::unordered_map<uint32_t, int> g_ccc_map = {{
{0}
}};

int ccc(uint32_t cp) noexcept
{{
    auto const it = g_ccc_map.find(cp);
    if (it == g_ccc_map.end())
        return 0;
    return it->second;
}}

}}}}
'''

canonical_file_form = decls = '''\
// Warning! This file is autogenerated.
#include <boost/text/normalization_data.hpp>

#include <boost/container/static_vector.hpp>

#include <array>
#include <unordered_map>


namespace boost {{ namespace text {{

static const std::unordered_map<uint32_t, canonical_decomposition>
g_canonical_decomposition_map = {{
{0}
}};

canonical_decomposition canonical_decompose(uint32_t cp) noexcept
{{
    auto const it = g_canonical_decomposition_map.find(cp);
    if (it == g_canonical_decomposition_map.end()) {{
        return canonical_decomposition{{{{{{cp}}}}, 1}};
    }}
    return it->second;
}}

}}}}
'''


def cccs(filename):
    intervals = []
    lines = open(filename, 'r').readlines()
    for line in lines:
        line = line[:-1]
        if not line.startswith('#') and len(line) != 0:
            comment_start = line.find('#')
            comment = ''
            if comment_start != -1:
                comment = line[comment_start + 1:].strip()
                line = line[:comment_start]
            fields = map(lambda x: x.strip(), line.split(';'))
            ccc = fields[1]
            if ccc == '0':
                continue
            code_points = fields[0]
            if '..' in code_points:
                cps = code_points.split('.')
                interval = (int(cps[0], 16), int(cps[2], 16) + 1, ccc)
            else:
                cp = int(code_points, 16)
                interval = (cp, cp + 1, ccc)
            intervals.append(interval)

    intervals = sorted(intervals)
    intervals_list = ''
    cccs_dict = {}
    num_intervals = 0
    for interval in intervals:
        if False: #128 < interval[1] - interval[0]:
            num_intervals += 1
            intervals_list += '    ccc_interval{{{}, {}, {}}},\n'.format(
                hex(interval[0]), hex(interval[1]), interval[2]
            )
        else:
            for i in range(interval[0], interval[1]):
                cccs_dict[i] = interval[2]
    return cccs_dict

def get_decompositions(filename, cccs_dict):
    decomps = {}

    # Pass 1: Find top-level decompositions
    lines = open(filename, 'r').readlines()
    for line in lines:
        line = line[:-1]
        if not line.startswith('#') and len(line) != 0:
            comment_start = line.find('#')
            comment = ''
            if comment_start != -1:
                comment = line[comment_start + 1:].strip()
                line = line[:comment_start]
            fields = map(lambda x: x.strip(), line.split(';'))
            if fields[5] == '':
                continue
            decomp_cps = fields[5].split(' ')
            canonical = True
            if decomp_cps[0].startswith('<'):
                decomp_cps = decomp_cps[1:]
                canonical = False
            decomp_cps = map(lambda x: int(x, 16), decomp_cps)
            cp = int(fields[0], 16)
            decomp = (decomp_cps, canonical)
            decomps[cp] = decomp

    def expand_decomp(decomp, all_decomps):
        first_cp = decomp[0][0]
        if decomp[1] and first_cp in all_decomps:
            return expand_decomp((all_decomps[first_cp][0] + decomp[0][1:], True), all_decomps)
        return decomp

    # Pass 2: Expand Pass-1 decompositions
    expanded_decomps = map(
        lambda item: (item[0], expand_decomp(item[1], decomps)),
        sorted(decomps.items())
    )

    def reorder_cps(cps, cccs_dict):
        for i in range(1, len(cps) - 1):
            cp_a = cps[i]
            cp_b = cps[i + 1]
            # Each must be nonzero....
            if cp_a not in cccs_dict or cp_b not in cccs_dict:
                continue
            ccc_a = cccs_dict[cp_a]
            ccc_b = cccs_dict[cp_b]
            if ccc_b < ccc_a:
                cps[i] = cp_b
                cps[i + 1] = cp_a
        return cps

    # Pass 3: Reorder Pass-2 decompositions uing cccs
    decomps = map(
        lambda x: (x[0], (reorder_cps(x[1][0], cccs_dict), x[1][1])),
        expanded_decomps
    )

    return decomps

cccs_dict = cccs('DerivedCombiningClass.txt')
item_strings = map(lambda x : '{}, {}'.format(hex(x[0]), x[1]), sorted(cccs_dict.items()))
ccc_intervals_map = '    { ' + ' },\n    { '.join(item_strings) + ' },\n'
cpp_file = open('normalization_data_ccc.cpp', 'w')
cpp_file.write(ccc_file_form.format(ccc_intervals_map))

def cps_to_vec(cps):
    return '{ {{ ' + ', '.join(map(lambda x: hex(x), cps)) + ' }}}}, {} }}'.format(len(cps))
decomposition_mapping = get_decompositions('UnicodeData.txt', cccs_dict)
item_strings = map(
    lambda x : '{}, {}'.format(hex(x[0]), cps_to_vec(x[1][0])),
    filter(lambda x: x[1][1], decomposition_mapping)
)
canonical_decompositions_map = '    { ' + ' },\n    { '.join(item_strings) + ' },\n'

cpp_file = open('normalization_data_canonical.cpp', 'w')
cpp_file.write(canonical_file_form.format(canonical_decompositions_map, len(item_strings)))
