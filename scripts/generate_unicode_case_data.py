#!/usr/bin/env python

constants_header_form = '''\
// Warning! This file is autogenerated.
#ifndef BOOST_TEXT_DETAIL_CASE_CONSTANTS_HPP
#define BOOST_TEXT_DETAIL_CASE_CONSTANTS_HPP

#include <array>

#include <cstdint>


namespace boost {{ namespace text {{ namespace detail {{

    enum class case_condition : uint8_t {{
{0}
    }};

}}}}}}

#endif
'''

case_impl_file_form = '''\
// Warning! This file is autogenerated.
#include <boost/text/trie_map.hpp>

#include <boost/text/detail/case_mapping_data.hpp>


namespace boost {{ namespace text {{ namespace detail {{

    std::array<uint32_t, {1}> const g_case_cps = {{{{
        {0}
    }}}};

    std::array<uint32_t, {3}> const g_cased_cps = {{{{
        {2}
    }}}};

    std::array<uint32_t, {5}> const g_case_ignorable_cps = {{{{
        {4}
    }}}};

    std::array<uint32_t, {7}> const g_soft_dotted_cps = {{{{
        {6}
    }}}};

    std::array<case_mapping, {9}> const g_to_lower = {{{{
        {8}
    }}}};

    std::array<case_mapping, {11}> const g_to_title = {{{{
        {10}
    }}}};

    std::array<case_mapping, {13}> const g_to_upper = {{{{
        {12}
    }}}};

    uint32_t const * g_case_cps_first = &g_case_cps[0];


    case_trie_t make_to_lower_trie()
    {{
        case_trie_t retval;
        for (auto datum : g_to_lower) {{
            retval.insert(
                &g_case_cps[0] + datum.from_.first_,
                &g_case_cps[0] + datum.from_.last_,
                case_elements{{
                    datum.to_.first_, datum.to_.last_, datum.conditions_}});
        }}
        return retval;
    }}

    case_trie_t make_to_title_trie()
    {{
        case_trie_t retval;
        for (auto datum : g_to_title) {{
            retval.insert(
                &g_case_cps[0] + datum.from_.first_,
                &g_case_cps[0] + datum.from_.last_,
                case_elements{{
                    datum.to_.first_, datum.to_.last_, datum.conditions_}});
        }}
        return retval;
    }}

    case_trie_t make_to_upper_trie()
    {{
        case_trie_t retval;
        for (auto datum : g_to_upper) {{
            retval.insert(
                &g_case_cps[0] + datum.from_.first_,
                &g_case_cps[0] + datum.from_.last_,
                case_elements{{
                    datum.to_.first_, datum.to_.last_, datum.conditions_}});
        }}
        return retval;
    }}

    std::vector<uint32_t> make_soft_dotted_cps()
    {{
        return std::vector<uint32_t>(g_soft_dotted_cps.begin(), g_soft_dotted_cps.end());
    }}

    std::unordered_set<uint32_t> make_cased_cps()
    {{
        return std::unordered_set<uint32_t>(g_cased_cps.begin(), g_cased_cps.end());
    }}

    std::unordered_set<uint32_t> make_case_ignorable_cps()
    {{
        return std::unordered_set<uint32_t>(
            g_case_ignorable_cps.begin(), g_case_ignorable_cps.end());
    }}

}}}}}}
'''

def get_case_mappings(unicode_data, special_casing, prop_list, derived_core_props):
    to_lower = {}
    to_title = {}
    to_upper = {}

    all_tuples = set()
    conditions = set()

    lines = open(unicode_data, 'r').readlines()
    for line in lines:
        line = line[:-1]
        if not line.startswith('#') and len(line) != 0:
            comment_start = line.find('#')
            comment = ''
            if comment_start != -1:
                comment = line[comment_start + 1:].strip()
                line = line[:comment_start]
            fields = map(lambda x: x.strip(), line.split(';'))
            cp = fields[0]
            upper = fields[12]
            lower = fields[13]
            title = fields[14]
            if lower != '':
                to_lower[(cp, None, None)] = ([lower], [])
                all_tuples.add((cp, None, None))
                all_tuples.add((lower, None, None))
            if title != '':
                to_title[(cp, None, None)] = ([title], [])
                all_tuples.add((cp, None, None))
                all_tuples.add((title, None, None))
            if upper != '':
                to_upper[(cp, None, None)] = ([upper], [])
                all_tuples.add((cp, None, None))
                all_tuples.add((upper, None, None))

    def to_tuple_2(l):
        if len(l) == 1:
            return (l[0], None)
        if len(l) == 2:
            return (l[0], l[1])
        return None

    def to_tuple_3(l):
        if len(l) == 1:
            return (l[0], None, None)
        if len(l) == 2:
            return (l[0], l[1], None)
        if len(l) == 3:
            return (l[0], l[1], l[2])
        return None

    def from_tuple(t):
        retval = []
        retval.append(t[0])
        if t[1] != None:
            retval.append(t[1])
        if 2 < len(t) and t[2] != None:
            retval.append(t[2])
        return retval

    lines = open(special_casing, 'r').readlines()
    for line in lines:
        line = line[:-1]
        if not line.startswith('#') and len(line) != 0:
            fields = map(lambda x: x.strip(), line.split(';'))
            lower = fields[1].strip().split(' ')
            if lower == ['']:
                lower = []
            title = fields[2].strip().split(' ')
            if title == ['']:
                title = []
            upper = fields[3].strip().split(' ')
            if upper == ['']:
                upper = []
            conditions_ = []
            if 3 < len(fields) and '#' not in fields[4]:
                conditions_ = fields[4].strip().split(' ')
                for c in conditions_:
                    conditions.add(c)
            if len(lower):
                if len(title):
                    to_lower[to_tuple_3(title)] = (lower, conditions_)
                    to_title[to_tuple_3(lower)] = (title, conditions_)
                    all_tuples.add(to_tuple_3(title))
                    all_tuples.add(to_tuple_3(lower))
                if len(upper):
                    to_lower[to_tuple_3(upper)] = (lower, conditions_)
                    to_upper[to_tuple_3(lower)] = (upper, conditions_)
                    all_tuples.add(to_tuple_3(upper))
                    all_tuples.add(to_tuple_3(lower))
            if len(title) and len(upper):
                to_title[to_tuple_3(upper)] = (title, conditions_)
                to_upper[to_tuple_3(title)] = (upper, conditions_)
                all_tuples.add(to_tuple_3(upper))
                all_tuples.add(to_tuple_3(title))

    all_tuples = sorted(map(from_tuple, all_tuples))
    conditions = sorted(conditions)

    cps = []
    tuple_offsets = []
    tuple_offset = 0
    for i in range(len(all_tuples)):
        cps += all_tuples[i]
        lo = tuple_offset
        tuple_offset += len(all_tuples[i])
        hi = tuple_offset
        tuple_offsets.append((lo, hi))
    def cp_indices(t):
        return tuple_offsets[all_tuples.index(from_tuple(t))]

    def to_cond_bitset(conds):
        retval = ''
        first = True
        for c in conds:
            if not first:
                retval += ' | '
            first = False
            retval += '(uint8_t)case_condition::' + c
        if retval == '':
            retval = '0'
        return retval

    to_lower = map(
        lambda x: (cp_indices(x[0]), (cp_indices(to_tuple_3(x[1][0])), to_cond_bitset(x[1][1]))),
        to_lower.items()
    )
    to_title = map(
        lambda x: (cp_indices(x[0]), (cp_indices(to_tuple_3(x[1][0])), to_cond_bitset(x[1][1]))),
        to_title.items()
    )
    to_upper = map(
        lambda x: (cp_indices(x[0]), (cp_indices(to_tuple_3(x[1][0])), to_cond_bitset(x[1][1]))),
        to_upper.items()
    )

    soft_dotteds = []
    lines = open(prop_list, 'r').readlines()
    for line in lines:
        line = line[:-1]
        if not line.startswith('#') and len(line) != 0:
            fields = map(lambda x: x.strip(), line.split(';'))
            if fields[1].startswith('Soft_Dotted'):
                cps_ = fields[0].split('.')
                soft_dotteds.append(cps_[0])
                if 1 < len(cps_):
                    for i in range(int(cps_[0], 16) + 1, int(cps_[2], 16) + 1):
                         soft_dotteds.append(hex(i).upper()[2:])

    cased_cps = []
    cased_ignorable_cps = []
    lines = open(derived_core_props, 'r').readlines()
    for line in lines:
        line = line[:-1]
        if not line.startswith('#') and len(line) != 0:
            fields = map(lambda x: x.strip(), line.split(';'))
            if fields[1].startswith('Cased') or fields[1].startswith('Case_Ignorable'):
                cps_ = fields[0].split('.')
                if fields[1].startswith('Cased'):
                    cased_cps.append(cps_[0])
                else:
                    cased_ignorable_cps.append(cps_[0])
                if 1 < len(cps_):
                    for i in range(int(cps_[0], 16) + 1, int(cps_[2], 16) + 1):
                         if fields[1].startswith('Cased'):
                             cased_cps.append(hex(i).upper()[2:])
                         else:
                             cased_ignorable_cps.append(hex(i).upper()[2:])

    return to_lower, to_title, to_upper, cps, conditions, soft_dotteds, \
        cased_cps, cased_ignorable_cps

to_lower, to_title, to_upper, cps, conditions, soft_dotteds, \
    cased_cps, cased_ignorable_cps = \
    get_case_mappings('UnicodeData.txt', 'SpecialCasing.txt', \
                      'PropList.txt', 'DerivedCoreProperties.txt')

hpp_file = open('case_constants.hpp', 'w')
condition_enums = []
for i in range(len(conditions)):
    c = conditions[i]
    condition_enums.append('        {} = {},'.format(c, i))
hpp_file.write(constants_header_form.format('\n'.join(condition_enums)))

def make_case_mapping(t):
    from_ = '{{{}, {}}}'.format(t[0][0], t[0][1])
    to_ = '{{{}, {}}}'.format(t[1][0][0], t[1][0][1])
    return '{{ {}, {}, {} }}'.format(from_, to_, t[1][1])

cpp_file = open('case_mapping.cpp', 'w')
cpp_file.write(case_impl_file_form.format(
    ',\n        '.join(map(lambda x: '0x' + x, cps)),
    len(cps),
    ',\n        '.join(map(lambda x: '0x' + x, cased_cps)),
    len(cased_cps),
    ',\n        '.join(map(lambda x: '0x' + x, cased_ignorable_cps)),
    len(cased_ignorable_cps),
    ',\n        '.join(map(lambda x: '0x' + x, soft_dotteds)),
    len(soft_dotteds),
    ',\n        '.join(map(lambda x: make_case_mapping(x), to_lower)),
    len(to_lower),
    ',\n        '.join(map(lambda x: make_case_mapping(x), to_title)),
    len(to_title),
    ',\n        '.join(map(lambda x: make_case_mapping(x), to_upper)),
    len(to_upper)))
