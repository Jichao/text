#!/usr/bin/env python

test_file_form = '''\
// Warning! This file is autogenerated.
#include <boost/text/case_mapping.hpp>

#include <gtest/gtest.h>


using namespace boost::text;

{0}
'''

test_form = '''\
TEST(case_mapping, {0:03})
{{
{1}
}}
'''

test_block = '''\
    {{ // to_{0}
{1}
{2}
    }}
'''


condition_prefixes = {
    'Final_Sigma': {
        'valid': [
            ['0345', '0345'], # 0345 is cased and case-ignorable
            ['0069'],         # 0069 is cased only
            ['0069', '0345'],
            ['0069', '1DFE']  # 1DFE is case-ignorable only
        ],
        'invalid': [
            ['0345'],
            ['1DFE'],
            ['1DFE', '1DFE'],
            ['']
        ]
    },
    'After_Soft_Dotted': {
        'valid': [
            ['006A', '006A'], # 006A is soft-dotted (and thus also ccc=0)
            ['006A', '07F3']  # 07F3 is ccc=230 and not soft-dotted
        ],
        'invalid': [
            ['006A'],
            ['07F3'],
            ['07F3', '07F3'],
            ['']
        ]
    },
    'More_Above': {           # none
        'valid': [''],
        'invalid': ['']
    },
    'Not_Before_Dot': {       # none
        'valid': [''],
        'invalid': ['']
    },
    'After_I': {
        'valid': [
            ['0049', '0049'], # 'I' (ccc=0)
            ['0049', '0737']  # 0737 is ccc=220
        ],
        'invalid': [
            ['0049'],
            ['004A'],         # 'J' (ccc=0)
            ['']
        ]
    }
}
condition_suffixes = {
    'Final_Sigma': {
        'valid': [
            ['0345'],
            ['1dfe'],
            ['1dfe', '1dfe'],
            ['']
        ],
        'invalid': [
            ['0345', '0345'],
            ['0069'],
            ['0345', '0069'],
            ['1dfe', '0069']
        ]
    },
    'After_Soft_Dotted': {    # none
        'valid': [''],
        'invalid': ['']
    },
    'More_Above': {
        'valid': [
            ['0737', '07F3'], # 0737 is ccc=220, 07F3 is ccc=230
            ['07F3']
        ],
        'invalid': [
            ['0737', '0737'],
            ['0737', '006A'], # 006A is ccc=0
            ['006A', '07F3'],
            ['']
        ]
    },
    'Not_Before_Dot': {
        'valid': [
            ['0737', '0737'],
            ['0737', '006A'], # 006A is ccc=0
            ['006A', '0307'],
            ['']
        ],
        'invalid': [
            ['0737', '0307'], # 0737 is ccc=220
            ['0307']
        ]
    },
    'After_I': {              # none
        'valid': [''],
        'invalid': ['']
    }
}

def to_array(name, l):
    return 'std::vector<uint32_t> {}({{{}}});'.format(
        name, ', '.join(map(lambda x: '0x' + x, l))
    )

def decls(name, l):
    return '''\
        {}
        std::vector<uint32_t> result;
'''.format(to_array(name, l))

def decls_with_from(from_l, name, l):
    return '''\
        {}
        {}
        std::vector<uint32_t> result;
'''.format(to_array('from', from_l), to_array(name, l))

def checks(name_1, name_2):
    return '''\
        to_{1}({0}, std::back_inserter(result));
        EXPECT_EQ(result, {1});'''.format(name_1, name_2)

title_prefixes = [
    ([], []),
    (['0020', '0020', '0020'], ['0020', '0020', '0020']),
    (['0061', '0061', '0061'], ['0041', '0061', '0061'])
]

title_suffixes = [
    [],
    ['0020', '0020', '0020'],
    ['0061', '0061', '0061']
]

def case_mapping_tests(special_casing):
    tests = []
    test_idx = 0

    lines = open(special_casing, 'r').readlines()
    for line in lines:
        line = line[:-1]
        if not line.startswith('#') and len(line) != 0:
            fields = map(lambda x: x.strip(), line.split(';'))
            cp = fields[0].strip()
            lower = fields[1].strip().split(' ')
            if lower == ['']:
                lower = []
            title = fields[2].strip().split(' ')
            if title == ['']:
                title = []
            upper = fields[3].strip().split(' ')
            if upper == ['']:
                upper = []
            conditions_ = []
            if 3 < len(fields) and '#' not in fields[4]:
                conditions_ = fields[4].strip().split(' ')
            blocks = '''\
    // {}
    std::array<uint32_t, 1> const cp = {{0x{}}};

'''.format(line, cp)
            if len(lower):
                if len(conditions_) == 0:
                    blocks += test_block.format(
                        'lower',
                        decls('lower', lower),
                        checks('cp', 'lower')
                    )
            if len(title):
                if len(conditions_) == 0:
                    for n in range(len(title_prefixes) * len(title_suffixes)):
                        pref = n / len(title_prefixes)
                        suff = n % len(title_prefixes)
                        to = title
                        if title_prefixes[pref][0] != title_prefixes[pref][1]:
                            to = lower
                        blocks += test_block.format(
                            'title',
                            decls_with_from(
                                title_prefixes[pref][0] + [cp] + title_suffixes[suff],
                                'title',
                                title_prefixes[pref][1] + to + title_suffixes[suff]
                            ),
                            checks('from', 'title')
                        )
            if len(upper):
                if len(conditions_) == 0:
                    blocks += test_block.format(
                        'upper',
                        decls('upper', upper),
                        checks('cp', 'upper')
                    )
            test = test_form.format(test_idx, blocks)
            test_idx += 1
            tests.append(test)

    cpp_file = open('case_mapping.cpp', 'w')
    cpp_file.write(test_file_form.format('\n'.join(tests)))

case_mapping_tests('SpecialCasing.txt')
