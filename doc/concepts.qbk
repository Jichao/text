[section:concepts Concepts]

[heading CharRange]

A _CharRng_ is a possibly-discontiguous sequence of `char`.

Example: _ur_.

Requirements on _CharRng_.  In the table below, `R` is a type that models
_CharRng_; `r` is an object of type `R`; `Iter` is an iterator type whose
value type is (possibly cv-qualified) `char`; and `Sentinel` is a type
equality comparable to `Iter`.

[table Expression Requirements
    [[Expression]    [Type]     [Description]]
    [
        [ `std::begin(r)` ]
        [ Iter ]
        [ The begin-iterator for `r`. ]
    ]
    [
        [ `std::end(r)` ]
        [ Sentinel ]
        [ The end-iterator or end-sentinel for `r`. ]
    ]
    [
        [ `typename std::iterator_traits<decltype(std::begin(r))>::iterator_category` ]
        [ std::bidirectional_iterator_tag ]
        [ `decltype(std::begin(r))` must be a bidirectional iterator. ]
    ]
    [
        [ `*std::begin(r)` ]
        [ `char` ]
        [ It must be possible to access the `char` sequence underlying `r`. ]
    ]
]


[heading ContigCharRange]

A _ContCharRng_ is a contiguous sequence of `char`.

Example: _s_.

Requirements on _ContCharRng_.  All the requirements on _CharRng_ apply, in
addition to the following table.  In the table, `R` is a type that models
_ContCharRng_; `r` is an object of type `R`; and `Iter` is an iterator type
whose value type is (possibly cv-qualified) `char`.

[table Expression Requirements
    [[Expression]    [Type]     [Description]                      [Notes]]
    [
        [ `std::addressof(*std::begin(r))` ]
        [ `char *` ]
        [ It must be possible to access the `char` sequence underlying `r` as an array. ]
        [ The result will be `char const *` if `r` is `const`. ]
    ]
]

Additionally, `Iter` must be a contiguous random access iterator.


[heading GraphemeRange]

A _GrRng_ is a sequence of graphemes over an underlying possibly-discontiguous
sequence of UTF-8-encoded `char`.

Example: _r_.

Requirements on _GrRng_.  In the table below, `R` is a type that models
_GrRng_; `r` is an object of type `R`; `CPIter` is an iterator type whose
(possibly cv-qualified) value type is convertible to `uint32_t`; `Iter` is an
iterator type whose value type is (possibly cv-qualified) `char`; and `it` is
an object of type `Iter`.

[table Expression Requirements
    [[Expression]    [Type]     [Description]]
    [
        [ `std::begin(r).base()` ]
        [ CPIter ]
        [ The begin-iterator for the underlying sequence of `uint32_t` delimited by `r`. ]
    ]
    [
        [ `std::end(r).base()` ]
        [ CPIter or some sentinel type equality comparable to `std::begin(r).base()` ]
        [ The end-iterator or end-sentinel for the underlying sequence of `uint32_t` delimited by `r`. ]
    ]
    [
        [ `std::begin(r).base().base()` ]
        [ Iter ]
        [ The begin-iterator for the underlying sequence of `char` delimited by `r`. ]
    ]
    [
        [ `std::end(r).base().base()` ]
        [ Sentinel ]
        [ The end-iterator or end-sentinel for the underlying sequence of `char` delimited by `r`. ]
    ]
    [
        [ `typename std::iterator_traits<decltype(std::begin(r))>::iterator_category` ]
        [ std::bidirectional_iterator_tag ]
        [ `Iter` must be a bidirectional iterator. ]
    ]
    [
        [ `*std::begin(r).base()` ]
        [ any type convertible to `uint32_t` ]
        [ It must be possible to access the `char` sequence underlying `r`. ]
    ]
    [
        [ `*std::begin(r).base().base()` ]
        [ `char` ]
        [ It must be possible to access the `char` sequence underlying `r`. ]
    ]
]


[heading ContigGraphemeRange]

A _ContGrRng_ is a sequence of graphemes over an underlying contiguous
sequence of UTF-8-encoded `char`.

Example: _t_.

Requirements on _ContGrRng_.  All the requirements on _GrRng_ apply, in
addition to the following table.  In the table, `R` is a type that models
_ContGrRng_; `r` is an object of type `R`; and `Iter` is an iterator type
whose value type is (possibly cv-qualified) `char`.

[table Expression Requirements
    [[Expression]    [Type]     [Description]                      [Notes]]
    [
        [ `std::addressof(*std::begin(r).base().base())` ]
        [ `char *` ]
        [ It must be possible to access the `char` sequence underlying `r` as an array. ]
        [ The result will be `char const *` if `R` is `const`. ]
    ]
]

Additionally, `Iter` must be a contiguous random access iterator.


[heading CharIter]

A _CharIter_ is a bidirectional iterator over a sequence of `char`.

Example: _r_`::iterator`.

Requirements on _CharIter_.  In the table below, `Iter` is a type that models
_CharIter_.

[table Expression Requirements
    [[Expression]    [Type]     [Description]]
    [
        [
``typename std::remove_cv<
    typename std::remove_reference<
        typename std::iterator_traits<Iter>::value_type
    >::type
>::type`` ]
        [ `char` ]
        [ The value_type of `Iter` must be convertible to `char`. ]
    ]
]

_CharIter_ does *not* need to be a contiguous iterator.


[heading CPIter]

A _CPIter_ is a bidirectional iterator over a sequence whose element type is
an unsigned 32-bit integral type.

Example: `std::array<uint32_t, 5>::iterator`.

Requirements on _CPIter_.  In the table below, `Iter` is a type that models
_CPIter_.

[table Expression Requirements
    [[Expression]    [Type]     [Description]]
    [
        [
``typename std::remove_cv<
    typename std::remove_reference<
        typename std::iterator_traits<Iter>::value_type
    >::type
>::type`` ]
        [ any unsigned 32-bit integral convertible to `uint32_t` ]
        [ The `value_type` of `Iter` must be convertible to `uint32_t`. ]
    ]
]

_CPIter_ does not need to be a contiguous iterator.


[heading CPRange]

A _CPRng_ is a possibly-discontiguous sequence whose element type is an
unsigned 32-bit integral type.

Example: _cpr_.

Requirements on _CPRng_.  In the table below, `R` is a type that models
_CPRng_; `r` is an object of type `R`; `Iter` is an iterator type whose
(possibly cv-qualified) value type is convertible to `uint32_t`; and
`Sentinel` is a type equality comparable to `Iter`.

[table Expression Requirements
    [[Expression]    [Type]     [Description]]
    [
        [ `std::begin(r)` ]
        [ Iter ]
        [ The begin-iterator for `r`. ]
    ]
    [
        [ `std::end(r)` ]
        [ Sentinel ]
        [ The end-iterator or end-sentinel for `r`. ]
    ]
    [
        [ `typename std::iterator_traits<decltype(std::begin(r))>::iterator_category` ]
        [ std::bidirectional_iterator_tag ]
        [ `decltype(std::begin(r))` must be a bidirectional iterator. ]
    ]
    [
        [ `*decltype(std::begin(r))` ]
        [ any unsigned 32-bit integral convertible to `uint32_t` ]
        [ It must be possible to access the sequence underlying `r`. ]
    ]
]

[endsect]
