<html>
<head>
<meta http-equiv="Content-Type" content="text/html; charset=US-ASCII">
<title>The String Layer</title>
<link rel="stylesheet" href="../boostbook.css" type="text/css">
<meta name="generator" content="DocBook XSL Stylesheets V1.79.1">
<link rel="home" href="../index.html" title="Chapter&#160;1.&#160;Boost.Text (Proposed)">
<link rel="up" href="../index.html" title="Chapter&#160;1.&#160;Boost.Text (Proposed)">
<link rel="prev" href="a_big__fat_warning_about_proxy_iterators.html" title="A Big, Fat Warning About Proxy Iterators">
<link rel="next" href="the_unicode_layer.html" title="The Unicode Layer">
</head>
<body bgcolor="white" text="black" link="#0000FF" vlink="#840084" alink="#0000FF">
<div class="spirit-nav">
<a accesskey="p" href="a_big__fat_warning_about_proxy_iterators.html"><img src="../images/prev.png" alt="Prev"></a><a accesskey="u" href="../index.html"><img src="../images/up.png" alt="Up"></a><a accesskey="h" href="../index.html"><img src="../images/home.png" alt="Home"></a><a accesskey="n" href="the_unicode_layer.html"><img src="../images/next.png" alt="Next"></a>
</div>
<div class="section">
<div class="titlepage"><div><div><h2 class="title" style="clear: both">
<a name="boost_text__proposed_.the_string_layer"></a><a class="link" href="the_string_layer.html" title="The String Layer">The String Layer</a>
</h2></div></div></div>
<h4>
<a name="boost_text__proposed_.the_string_layer.h0"></a>
      <span class="phrase"><a name="boost_text__proposed_.the_string_layer.the__code__phrase_role__identifier__string_view__phrase___code__type"></a></span><a class="link" href="the_string_layer.html#boost_text__proposed_.the_string_layer.the__code__phrase_role__identifier__string_view__phrase___code__type">The
      <code class="computeroutput"><span class="identifier">string_view</span></code> Type</a>
    </h4>
<p>
      <code class="computeroutput"><a class="link" href="../boost/text/string_view.html" title="Struct string_view">string_view</a></code>
      is the type at the center of Boost.Text. It is used everywhere you would have
      used <code class="computeroutput"><span class="keyword">char</span> <span class="keyword">const</span>
      <span class="special">*</span></code> before C++17, and everywhere you would
      use <code class="computeroutput"><span class="identifier">std</span><span class="special">::</span><span class="identifier">string_view</span></code> in C++17 and later.
    </p>
<p>
      Analogouly to <code class="computeroutput"><span class="identifier">std</span><span class="special">::</span><span class="identifier">string_view</span></code>, it defines implicit conversions
      from <code class="computeroutput"><span class="keyword">char</span> <span class="keyword">const</span>
      <span class="special">*</span></code> and <code class="computeroutput"><a class="link" href="../boost/text/string.html" title="Struct string">string</a></code>, so it can be used in
      interfaces that accept either.
    </p>
<p>
      <code class="computeroutput"><a class="link" href="../boost/text/string_view.html" title="Struct string_view">string_view</a></code>
      is fully <code class="computeroutput"><span class="keyword">constexpr</span></code> in everything
      it does, if you have the compiler support (C++14 <code class="computeroutput"><span class="keyword">constexpr</span></code>).
      You can write very extensive compile-time operations using <code class="computeroutput"><a class="link" href="../boost/text/string_view.html" title="Struct string_view">string_view</a></code>.
    </p>
<p>
      [string_view_lotsa_constexpr]
    </p>
<p>
      <code class="computeroutput"><a class="link" href="../boost/text/string_view.html" title="Struct string_view">string_view</a></code>
      is a nearly immutable type; there are no mutating member functions, besides
      assignment and <code class="computeroutput"><span class="identifier">swap</span><span class="special">()</span></code>.
      It is small (the size of two pointers on most modern architectures) and cheap
      to copy.
    </p>
<p>
      Its underlying sequence is always a sequence of <code class="computeroutput"><span class="keyword">char</span></code>.
      It is not a template.
    </p>
<p>
      It has a signed size and index type, and since contiguous unowned sequences
      of <code class="computeroutput"><span class="keyword">char</span></code> cannot efficiently be
      huge, its size/index type is <code class="computeroutput"><span class="keyword">int</span></code>.
    </p>
<p>
      It is also slice-able. There are two slice operations, each using an overloaded
      call operator. The first one is very much like the Python slicing index syntax.
      Positive and negative indices are allowed. Negative indices count from the
      end -- they are converted to positive indices by adding <code class="computeroutput"><span class="identifier">size</span><span class="special">()</span></code>.
    </p>
<p>
</p>
<pre class="programlisting"><span class="identifier">boost</span><span class="special">::</span><span class="identifier">text</span><span class="special">::</span><span class="identifier">string_view</span> <span class="identifier">tv1</span> <span class="special">=</span> <span class="string">"some text"</span><span class="special">;</span>

<span class="identifier">boost</span><span class="special">::</span><span class="identifier">text</span><span class="special">::</span><span class="identifier">string_view</span> <span class="identifier">tv2</span> <span class="special">=</span> <span class="identifier">tv1</span><span class="special">(</span><span class="number">0</span><span class="special">,</span> <span class="number">4</span><span class="special">);</span>
<span class="identifier">assert</span><span class="special">(</span><span class="identifier">tv2</span> <span class="special">==</span> <span class="string">"some"</span><span class="special">);</span>

<span class="identifier">boost</span><span class="special">::</span><span class="identifier">text</span><span class="special">::</span><span class="identifier">string_view</span> <span class="identifier">tv3</span> <span class="special">=</span> <span class="identifier">tv1</span><span class="special">(-</span><span class="number">3</span><span class="special">,</span> <span class="special">-</span><span class="number">1</span><span class="special">);</span>
<span class="identifier">assert</span><span class="special">(</span><span class="identifier">tv3</span> <span class="special">==</span> <span class="string">"ex"</span><span class="special">);</span>
</pre>
<p>
    </p>
<p>
      The second slice operation takes a single index value, which may be positive
      or negative. A positive value <code class="computeroutput"><span class="identifier">x</span></code>
      create a prefix substring of length <code class="computeroutput"><span class="identifier">x</span></code>,
      and a negative one creates a suffix substring of length <code class="computeroutput"><span class="special">-</span><span class="identifier">x</span></code>.
    </p>
<p>
</p>
<pre class="programlisting"><span class="identifier">boost</span><span class="special">::</span><span class="identifier">text</span><span class="special">::</span><span class="identifier">string_view</span> <span class="identifier">tv1</span> <span class="special">=</span> <span class="string">"some text"</span><span class="special">;</span>

<span class="identifier">boost</span><span class="special">::</span><span class="identifier">text</span><span class="special">::</span><span class="identifier">string_view</span> <span class="identifier">tv2</span> <span class="special">=</span> <span class="identifier">tv1</span><span class="special">(</span><span class="number">4</span><span class="special">);</span>
<span class="identifier">assert</span><span class="special">(</span><span class="identifier">tv2</span> <span class="special">==</span> <span class="string">"some"</span><span class="special">);</span>

<span class="identifier">boost</span><span class="special">::</span><span class="identifier">text</span><span class="special">::</span><span class="identifier">string_view</span> <span class="identifier">tv3</span> <span class="special">=</span> <span class="identifier">tv1</span><span class="special">(-</span><span class="number">4</span><span class="special">);</span>
<span class="identifier">assert</span><span class="special">(</span><span class="identifier">tv3</span> <span class="special">==</span> <span class="string">"text"</span><span class="special">);</span>
</pre>
<p>
    </p>
<p>
      In keeping with the slicing operations, the index operator (<code class="computeroutput"><span class="keyword">operator</span><span class="special">[]</span></code>) takes negative indices. Negative indices
      are counted from the end of the sequence.
    </p>
<p>
      Of course, there is a user-defined literal for <code class="computeroutput"><a class="link" href="../boost/text/string_view.html" title="Struct string_view">string_view</a></code>:
    </p>
<p>
      [string_view_literal]
    </p>
<p>
      Also, there is an <code class="computeroutput"><span class="keyword">explicit</span></code> conversion
      from any value of a type that models <a class="link" href="concepts.html#boost_text__proposed_.concepts.contigcharrange">ContigCharRange</a>.
      <a class="link" href="concepts.html#boost_text__proposed_.concepts.contigcharrange">ContigCharRange</a>
      is any contiguous sequence of <code class="computeroutput"><span class="keyword">char</span></code>
      that provides <code class="computeroutput"><span class="keyword">char</span> <span class="keyword">const</span>
      <span class="special">*</span></code> pointer access to its <code class="computeroutput"><span class="keyword">char</span></code>s. This gives us conversions from <code class="computeroutput"><span class="identifier">std</span><span class="special">::</span><span class="identifier">string</span></code>
      and other types that <code class="computeroutput"><a class="link" href="../boost/text/string_view.html" title="Struct string_view">string_view</a></code> does not explicitly
      know about.
    </p>
<p>
      Finally, there is an <code class="computeroutput"><span class="keyword">explicit</span></code>
      conversion from any value of a type that models <a class="link" href="concepts.html#boost_text__proposed_.concepts.contiggraphemerange">ContigGraphemeRange</a>.
      <a class="link" href="concepts.html#boost_text__proposed_.concepts.contiggraphemerange">ContigGraphemeRange</a>
      is a sequence of graphemes over an underlying contiguous sequence of <code class="computeroutput"><span class="keyword">char</span></code> for which there is pointer access to the
      <code class="computeroutput"><span class="keyword">char</span></code>s. This provides conversions
      from <code class="computeroutput"><a class="link" href="../boost/text/text.html" title="Struct text">text</a></code>
      and other grapheme-oriented types that <code class="computeroutput"><a class="link" href="../boost/text/string_view.html" title="Struct string_view">string_view</a></code> does not explicitly
      know about.
    </p>
<h4>
<a name="boost_text__proposed_.the_string_layer.h1"></a>
      <span class="phrase"><a name="boost_text__proposed_.the_string_layer.the__code__phrase_role__identifier__string__phrase___code__type"></a></span><a class="link" href="the_string_layer.html#boost_text__proposed_.the_string_layer.the__code__phrase_role__identifier__string__phrase___code__type">The
      <code class="computeroutput"><span class="identifier">string</span></code> Type</a>
    </h4>
<p>
      <code class="computeroutput"><a class="link" href="../boost/text/string.html" title="Struct string">string</a></code>
      is a contiguous sequence of <code class="computeroutput"><span class="keyword">char</span></code>.
      The sequence of <code class="computeroutput"><span class="keyword">char</span></code> is either
      stored in the <code class="computeroutput"><a class="link" href="../boost/text/string.html" title="Struct string">string</a></code>
      (if it is small) or is heap-allocated. <code class="computeroutput"><a class="link" href="../boost/text/string.html" title="Struct string">string</a></code> is also strongly exception-safe.
      Its purpose is to be a better <code class="computeroutput"><span class="identifier">std</span><span class="special">::</span><span class="identifier">string</span></code>.
    </p>
<p>
      <code class="computeroutput"><a class="link" href="../boost/text/string.html" title="Struct string">string</a></code>'s
      element type is <code class="computeroutput"><span class="keyword">char</span></code> and its size/index
      type is <code class="computeroutput"><span class="keyword">int</span></code>, for the same reasons
      given for <code class="computeroutput"><a class="link" href="../boost/text/string_view.html" title="Struct string_view">string_view</a></code>.
      It is also slice-able in the same way that <code class="computeroutput"><a class="link" href="../boost/text/string_view.html" title="Struct string_view">string_view</a></code> is.
    </p>
<p>
      <code class="computeroutput"><a class="link" href="../boost/text/string.html" title="Struct string">string</a></code>
      is always kept null-terminated, and its iterator type is (possibly <code class="computeroutput"><span class="keyword">const</span></code>) <code class="computeroutput"><span class="keyword">char</span>
      <span class="special">*</span></code>. This means that getting a null-terminated
      C-style string out of a <code class="computeroutput"><a class="link" href="../boost/text/string.html" title="Struct string">string</a></code> is done by calling <code class="computeroutput"><span class="identifier">str</span><span class="special">.</span><span class="identifier">begin</span><span class="special">()</span></code>.
    </p>
<p>
      <code class="computeroutput"><a class="link" href="../boost/text/string.html" title="Struct string">string</a></code>
      has its own user-defined literals:
    </p>
<p>
      [string_literal]
    </p>
<p>
      Unlike <code class="computeroutput"><a class="link" href="../boost/text/string_view.html" title="Struct string_view">string_view</a></code>
      though, <code class="computeroutput"><a class="link" href="../boost/text/string.html" title="Struct string">string</a></code>
      is mutable.
    </p>
<p>
      There are <code class="computeroutput"><span class="keyword">explicit</span></code> conversions
      from <a class="link" href="concepts.html#boost_text__proposed_.concepts.charrange">CharRange</a>
      and <a class="link" href="concepts.html#boost_text__proposed_.concepts.graphemerange">GraphemeRange</a>.
    </p>
<h4>
<a name="boost_text__proposed_.the_string_layer.h2"></a>
      <span class="phrase"><a name="boost_text__proposed_.the_string_layer.the__code__phrase_role__identifier__repeated_string_view__phrase___code__type"></a></span><a class="link" href="the_string_layer.html#boost_text__proposed_.the_string_layer.the__code__phrase_role__identifier__repeated_string_view__phrase___code__type">The
      <code class="computeroutput"><span class="identifier">repeated_string_view</span></code> Type</a>
    </h4>
<p>
      One of the things that differs between <code class="computeroutput"><span class="identifier">std</span><span class="special">::</span><span class="identifier">string</span></code>
      and <code class="computeroutput"><a class="link" href="../boost/text/string.html" title="Struct string">string</a></code>
      is that <code class="computeroutput"><a class="link" href="../boost/text/string.html" title="Struct string">string</a></code>
      is missing all those overloads (including constructors) that take a number
      of elements to repeat. For example, <code class="computeroutput"><a class="link" href="../boost/text/string.html" title="Struct string">string</a></code> has no function for inserting
      a single element N times. Instead of having all those overloads and using a
      heap-allocating type like <code class="computeroutput"><a class="link" href="../boost/text/string.html" title="Struct string">string</a></code> to represent repeated
      elements, Boost.Text introduces a new non-allocating type for this, <code class="computeroutput"><a class="link" href="../boost/text/repeated_string_view.html" title="Struct repeated_string_view">repeated_string_view</a></code>.
    </p>
<p>
      <code class="computeroutput"><a class="link" href="../boost/text/repeated_string_view.html" title="Struct repeated_string_view">repeated_string_view</a></code>
      has semantics and an interface much like <code class="computeroutput"><a class="link" href="../boost/text/string_view.html" title="Struct string_view">string_view</a></code>: it is near-immutable;
      it uses a signed size/index type (though a typically-larger one, <code class="computeroutput"><span class="identifier">std</span><span class="special">::</span><span class="identifier">ptrdiff_t</span></code>);
      it uses <code class="computeroutput"><span class="keyword">char</span></code> as its element type;
      and it is slice-able in the same way.
    </p>
<p>
      With <code class="computeroutput"><a class="link" href="../boost/text/repeated_string_view.html" title="Struct repeated_string_view">repeated_string_view</a></code>
      in hand, this code which allocates:
    </p>
<pre class="programlisting"><span class="identifier">std</span><span class="special">::</span><span class="identifier">cout</span> <span class="special">&lt;&lt;</span> <span class="identifier">std</span><span class="special">::</span><span class="identifier">string</span><span class="special">(</span><span class="identifier">indent</span><span class="special">,</span> <span class="char">' '</span><span class="special">);</span>
</pre>
<p>
      becomes this code, which does not:
    </p>
<pre class="programlisting"><span class="identifier">std</span><span class="special">::</span><span class="identifier">cout</span> <span class="special">&lt;&lt;</span> <span class="identifier">boost</span><span class="special">::</span><span class="identifier">text</span><span class="special">::</span><span class="identifier">repeated_string_view</span><span class="special">(</span><span class="string">" "</span><span class="special">,</span> <span class="identifier">indent</span><span class="special">);</span>
</pre>
<p>
      There's also a more terse function that returns a <code class="computeroutput"><a class="link" href="../boost/text/repeated_string_view.html" title="Struct repeated_string_view">repeated_string_view</a></code>:
    </p>
<pre class="programlisting"><span class="identifier">std</span><span class="special">::</span><span class="identifier">cout</span> <span class="special">&lt;&lt;</span> <span class="identifier">boost</span><span class="special">::</span><span class="identifier">text</span><span class="special">::</span><span class="identifier">repeat</span><span class="special">(</span><span class="string">" "</span><span class="special">,</span> <span class="identifier">indent</span><span class="special">);</span>
</pre>
<h4>
<a name="boost_text__proposed_.the_string_layer.h3"></a>
      <span class="phrase"><a name="boost_text__proposed_.the_string_layer.the__code__phrase_role__identifier__unencoded_rope__phrase___code__type"></a></span><a class="link" href="the_string_layer.html#boost_text__proposed_.the_string_layer.the__code__phrase_role__identifier__unencoded_rope__phrase___code__type">The
      <code class="computeroutput"><span class="identifier">unencoded_rope</span></code> Type</a>
    </h4>
<p>
      In general, a <a href="https://en.wikipedia.org/wiki/Rope_(data_structure)" target="_top">Rope</a>
      is a heavyweight string; whereas a string is a simple array of contiguous storage,
      a <a href="https://en.wikipedia.org/wiki/Rope_(data_structure)" target="_top">Rope</a>
      is much more complicated and is typically a tree whose leaves are contiguous
      strings.
    </p>
<p>
      The user's view of Boost.Text's <code class="computeroutput"><a class="link" href="../boost/text/unencoded_rope.html" title="Struct unencoded_rope">unencoded_rope</a></code> is that it is
      a string that is inexpensive to insert into at any point -- even the middle
      or front -- no matter how large it is. In addition, substrings within the
      <code class="computeroutput"><a class="link" href="../boost/text/unencoded_rope.html" title="Struct unencoded_rope">unencoded_rope</a></code>
      have copy-on-write semantics. This means that often a copy of a very large
      <code class="computeroutput"><a class="link" href="../boost/text/unencoded_rope.html" title="Struct unencoded_rope">unencoded_rope</a></code>
      is nearly free, and that a mutated copy of a <code class="computeroutput"><a class="link" href="../boost/text/unencoded_rope.html" title="Struct unencoded_rope">unencoded_rope</a></code> often shares much
      of its data with the <code class="computeroutput"><a class="link" href="../boost/text/unencoded_rope.html" title="Struct unencoded_rope">unencoded_rope</a></code> from which it
      was copied.
    </p>
<p>
      <code class="computeroutput"><a class="link" href="../boost/text/unencoded_rope.html" title="Struct unencoded_rope">unencoded_rope</a></code>'s
      implementation uses a tree structure similar to a B-tree, and each subtree
      is copy-on-write. The tree consists of interior nodes that contain structural
      information, and leaf nodes which contain the data. <code class="computeroutput"><a class="link" href="../boost/text/unencoded_rope.html" title="Struct unencoded_rope">unencoded_rope</a></code> only contains
      a single pointer to a root node. Here is one of the simplest nonempty <code class="computeroutput"><a class="link" href="../boost/text/unencoded_rope.html" title="Struct unencoded_rope">unencoded_ropes</a></code>
      you can have:
    </p>
<p>
      <span class="inlinemediaobject"><object type="image/svg+xml" data="../../../doc/rope_text_leaf.svg" width="160" height="144"></object></span>
    </p>
<p>
      This <code class="computeroutput"><a class="link" href="../boost/text/unencoded_rope.html" title="Struct unencoded_rope">unencoded_rope</a></code>
      is just a single leaf node, containing the super-useful string <code class="computeroutput"><span class="string">"text"</span></code>. In this case, the leaf was
      a <code class="computeroutput"><a class="link" href="../boost/text/string.html" title="Struct string">string</a></code>
      node, labeled here with <code class="computeroutput"><span class="identifier">s</span></code>.
      There can also be leaf nodes for <code class="computeroutput"><a class="link" href="../boost/text/repeated_string_view.html" title="Struct repeated_string_view">repeated_string_views</a></code>, labeled
      in these diagrams with <code class="computeroutput"><span class="identifier">rsv</span></code>.
      The final leaf node type is a reference-to-<code class="computeroutput"><a class="link" href="../boost/text/string.html" title="Struct string">string</a></code> leaf, labeled as <code class="computeroutput"><span class="identifier">ref</span></code>. More on that in a bit.
    </p>
<p>
      If we copy the <code class="computeroutput"><a class="link" href="../boost/text/unencoded_rope.html" title="Struct unencoded_rope">unencoded_rope</a></code>
      above, we get something like this:
    </p>
<p>
      <span class="inlinemediaobject"><object type="image/svg+xml" data="../../../doc/rope_text_leaf_extra_ref.svg" width="202" height="143"></object></span>
    </p>
<p>
      No copying was done, nor allocations performed. Copying an entire tree only
      requires copying a pointer and incrementing a reference count. The string in
      this <code class="computeroutput"><a class="link" href="../boost/text/string.html" title="Struct string">string</a></code>
      leaf is only four elements, but let's suppose it was megabytes instead. Inserting
      even a small sequence near the beginning of the string would be costly, since
      we'd have to copy all the elements after the insertion point. And since the
      <code class="computeroutput"><a class="link" href="../boost/text/string.html" title="Struct string">string</a></code>
      leaf may be shared, we would have to copy everything <span class="emphasis"><em>before</em></span>
      the insertion, too! For large <code class="computeroutput"><a class="link" href="../boost/text/string.html" title="Struct string">string</a></code> leaves, insertions into
      them result in something like this:
    </p>
<p>
      <span class="inlinemediaobject"><object type="image/svg+xml" data="../../../doc/rope_text_refs_after_insert.svg" width="534" height="242"></object></span>
    </p>
<div class="note"><table border="0" summary="Note">
<tr>
<td rowspan="2" align="center" valign="top" width="25"><img alt="[Note]" src="../images/note.png"></td>
<th align="left">Note</th>
</tr>
<tr><td align="left" valign="top"><p>
        This is <span class="bold"><strong>not</strong></span> what actually happens to small
        <code class="computeroutput"><a class="link" href="../boost/text/string.html" title="Struct string">string</a></code>
        leaves with a reference count of 1! Those are mutated in place.
      </p></td></tr>
</table></div>
<p>
      Here, we see that we've made two new reference nodes, each of which refers
      to part of the original <code class="computeroutput"><a class="link" href="../boost/text/string.html" title="Struct string">string</a></code>, and we've put the inserted
      string in between, forming <code class="computeroutput"><span class="string">"text text"</span></code>,
      which everyone knows is the <span class="bold"><strong>best</strong></span> string.
    </p>
<p>
      And now we see our first interior node. Each interior node has a key and a
      pointer for each child, and a fixed maximum number of children. Each key <code class="computeroutput"><span class="identifier">Ki</span></code> is the cumulative size of all children
      in the range <code class="computeroutput"><span class="special">[</span><span class="number">0</span><span class="special">,</span> <span class="identifier">i</span><span class="special">]</span></code>.
    </p>
<p>
      To make the images smaller, each interior node in these diagrams has a maximum
      of four children (the actual number is an implementation detail, but it's a
      lot higher).
    </p>
<p>
      Now let's take a look at a more complicated <code class="computeroutput"><a class="link" href="../boost/text/unencoded_rope.html" title="Struct unencoded_rope">unencoded_rope</a></code>:
    </p>
<p>
      <span class="inlinemediaobject"><object type="image/svg+xml" data="../../../doc/rope_tree_structure.svg" width="748" height="363"></object></span>
    </p>
<p>
      In this tree, we have three interior nodes: the root and its two children.
      We also have at least one of each type of leaf node.
    </p>
<p>
      Copying even this <code class="computeroutput"><a class="link" href="../boost/text/unencoded_rope.html" title="Struct unencoded_rope">unencoded_rope</a></code> is very cheap,
      requiring only copying a pointer and incrementing a reference count:
    </p>
<p>
      <span class="inlinemediaobject"><object type="image/svg+xml" data="../../../doc/rope_copy_add_ref.svg" width="748" height="363"></object></span>
    </p>
<p>
      Let's say we wanted to erase part of this <code class="computeroutput"><a class="link" href="../boost/text/unencoded_rope.html" title="Struct unencoded_rope">unencoded_rope</a></code>. We'll erase a
      substring that matches a whole leaf exactly, to keep things simpler. Let's
      erase the <code class="computeroutput"><span class="identifier">ref</span></code> node on the left:
    </p>
<p>
      <span class="inlinemediaobject"><object type="image/svg+xml" data="../../../doc/rope_erase.svg" width="878" height="363"></object></span>
    </p>
<p>
      Simple, right? In this case, we did the erasure by creating a copy of each
      node on the path from the root to the erased <code class="computeroutput"><span class="identifier">ref</span></code>
      leaf, and just referring to all the other nodes that did not change. Again,
      most of the string data and even interior nodes are shared among the three
      ropes in the diagram. This same principle applies to <code class="computeroutput"><span class="identifier">insert</span><span class="special">()</span></code>, <code class="computeroutput"><span class="identifier">erase</span><span class="special">()</span></code>, and <code class="computeroutput"><span class="identifier">replace</span><span class="special">()</span></code>.
    </p>
<div class="note"><table border="0" summary="Note">
<tr>
<td rowspan="2" align="center" valign="top" width="25"><img alt="[Note]" src="../images/note.png"></td>
<th align="left">Note</th>
</tr>
<tr><td align="left" valign="top"><p>
        We don't make new nodes every time we need to do an insert, erase, or other
        mutation. If the reference counts on the root-to-leaf path are all <code class="computeroutput"><span class="number">1</span></code>, we will mutate the tree in place.
      </p></td></tr>
</table></div>
<p>
      Besides the segmented nature of <code class="computeroutput"><a class="link" href="../boost/text/unencoded_rope.html" title="Struct unencoded_rope">unencoded_rope</a></code>, there are some
      other properties you need to know about. A <code class="computeroutput"><a class="link" href="../boost/text/unencoded_rope.html" title="Struct unencoded_rope">unencoded_rope</a></code> as a whole is
      copy-on-write; it is also therefore thread-safe for reading and writing; it
      is not null-terminated; it uses a signed size/index type (<code class="computeroutput"><span class="identifier">std</span><span class="special">::</span><span class="identifier">ptrdiff_t</span></code>);
      it uses <code class="computeroutput"><span class="keyword">char</span></code> as its element type;
      and it is slice-able.
    </p>
<p>
      Insertions, erasures, and indexing each happen in <code class="computeroutput"><span class="identifier">O</span><span class="special">(</span><span class="identifier">log_B</span><span class="special">(</span><span class="identifier">N</span><span class="special">))</span></code> time,
      where B is the branching factor (maximum number of children per interior node).
      As mentioned before, B is an implementation detail, and thus subject to change,
      but it is unlikely to be less than 16. That means very little pointer chasing
      is required to access an arbitrary element of a <code class="computeroutput"><a class="link" href="../boost/text/unencoded_rope.html" title="Struct unencoded_rope">unencoded_rope</a></code>, because its tree
      is very shallow.
    </p>
<p>
      In fact, with a branching factor of 16, the maximum depth of the tree is also
      16, since the <code class="computeroutput"><span class="identifier">max_size</span><span class="special">()</span></code>
      of the tree is <code class="computeroutput"><span class="identifier">PTRDIFF_MAX</span></code>.
      This means that <code class="computeroutput"><span class="identifier">O</span><span class="special">(</span><span class="identifier">log_B</span><span class="special">(</span><span class="identifier">N</span><span class="special">))</span></code> time has a fixed upper bound, making it
      <code class="computeroutput"><span class="identifier">O</span><span class="special">(</span><span class="number">1</span><span class="special">)</span></code>!
    </p>
<p>
      As mentioned previously, mutations to a <code class="computeroutput"><a class="link" href="../boost/text/unencoded_rope.html" title="Struct unencoded_rope">unencoded_rope</a></code> are done in-place
      if the mutations do not affect nodes that are shared with other <code class="computeroutput"><a class="link" href="../boost/text/unencoded_rope.html" title="Struct unencoded_rope">unencoded_ropes</a></code>.
    </p>
<p>
      If a mutation can be done in place, and the point of mutation falls within
      a <code class="computeroutput"><a class="link" href="../boost/text/string.html" title="Struct string">string</a></code>
      leaf, the <code class="computeroutput"><a class="link" href="../boost/text/string.html" title="Struct string">string</a></code>
      object is directly mutated if: the inserted string fits within the <code class="computeroutput"><span class="identifier">capacity</span><span class="special">()</span></code>
      of the <code class="computeroutput"><a class="link" href="../boost/text/string.html" title="Struct string">string</a></code>,
      <span class="bold"><strong>or</strong></span>
    </p>
<div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; ">
<li class="listitem">
          the <code class="computeroutput"><a class="link" href="../boost/text/string.html" title="Struct string">string</a></code>
          object is not too large (there is a maximum size that is an implementation
          detail, but is likely to be hundreds or thousands, not tens or tens of
          thousands), <span class="bold"><strong>and</strong></span>
        </li>
<li class="listitem">
          the inserted object would cause an allocation if copied (i.e. it is a
          <code class="computeroutput"><a class="link" href="../boost/text/string.html" title="Struct string">string</a></code>).
        </li>
</ul></div>
<p>
      One more thing. <code class="computeroutput"><a class="link" href="../boost/text/unencoded_rope.html" title="Struct unencoded_rope">unencoded_ropes</a></code> are meant to
      be passed by value. Some of their thread-safety guarantees may not be fulfilled
      if they are <span class="bold"><strong>not</strong></span> passed by value. If you do
      not care about thread-safe use of <code class="computeroutput"><a class="link" href="../boost/text/unencoded_rope.html" title="Struct unencoded_rope">unencoded_rope</a></code>, you can pass
      <code class="computeroutput"><a class="link" href="../boost/text/unencoded_rope.html" title="Struct unencoded_rope">unencoded_ropes</a></code>
      by <code class="computeroutput"><span class="keyword">const</span> <span class="special">&amp;</span></code>
      if you like. If you care about thread-safety, <span class="bold"><strong>always</strong></span>
      pass them by value.
    </p>
<p>
      <code class="computeroutput"><a class="link" href="../boost/text/unencoded_rope.html" title="Struct unencoded_rope">unencoded_rope</a></code>
      contains logic like the pseudocode below to determine when to create a partial
      copy of a <code class="computeroutput"><a class="link" href="../boost/text/unencoded_rope.html" title="Struct unencoded_rope">unencoded_rope</a></code>'s
      tree, or when to mutate the tree in-place when performing inserts or erases
      on a <code class="computeroutput"><a class="link" href="../boost/text/unencoded_rope.html" title="Struct unencoded_rope">unencoded_rope</a></code>:
    </p>
<pre class="programlisting"><span class="identifier">path</span> <span class="special">=</span> <span class="identifier">find_path_from_root_to_mutation_point</span><span class="special">()</span>
<span class="identifier">in_place</span> <span class="special">=</span> <span class="keyword">true</span>
<span class="keyword">for</span> <span class="special">(</span><span class="identifier">node</span> <span class="special">:</span> <span class="identifier">path</span><span class="special">)</span>
    <span class="keyword">if</span> <span class="special">(</span><span class="identifier">node</span><span class="special">.</span><span class="identifier">references</span><span class="special">()</span> <span class="special">==</span> <span class="number">1</span><span class="special">)</span>
        <span class="identifier">in_place</span> <span class="special">=</span> <span class="keyword">false</span>
</pre>
<p>
      Let's call the <code class="computeroutput"><a class="link" href="../boost/text/unencoded_rope.html" title="Struct unencoded_rope">unencoded_rope</a></code>
      <code class="computeroutput"><span class="identifier">R</span></code>, and the thread on which
      the operation is being performed <code class="computeroutput"><span class="identifier">T</span></code>.
      Also, assume that all references to <code class="computeroutput"><span class="identifier">R</span></code>'s
      root node exist in copies of <code class="computeroutput"><span class="identifier">R</span></code>,
      and no reference (C++ reference/pointer) to <code class="computeroutput"><span class="identifier">R</span></code>
      or any of its copies exists.
    </p>
<p>
      With this assumption, we know at the end of the pseudocode <code class="computeroutput"><span class="keyword">for</span></code>
      loop above, that there is still exactly one reference to each node in <code class="computeroutput"><span class="identifier">path</span></code>. For this not to be true, we would need
      to either:
    </p>
<div class="orderedlist"><ol class="orderedlist" type="1">
<li class="listitem">
          Create a copy of one of the nodes on thread <code class="computeroutput"><span class="identifier">T</span></code>.
          Clearly we cannot, since we're currently executing <code class="computeroutput"><span class="identifier">insert</span><span class="special">()</span></code> or <code class="computeroutput"><span class="identifier">erase</span><span class="special">()</span></code> instead.
        </li>
<li class="listitem">
          Create a copy of one of the nodes on a thread other than <code class="computeroutput"><span class="identifier">T</span></code>. We can't do this either, since we
          have no reference to <code class="computeroutput"><span class="identifier">R</span></code>
          that can be used by another thread, and we know that there are no other
          copies on any other threads either &#8212; since each node's reference
          count is <code class="computeroutput"><span class="number">1</span></code>.
        </li>
</ol></div>
<p>
      Were we to write references/pointers to <code class="computeroutput"><span class="identifier">R</span></code>
      into our code, a thread other than <code class="computeroutput"><span class="identifier">T</span></code>
      could create a copy of <code class="computeroutput"><span class="identifier">R</span></code> between
      when we read the reference count of one of its nodes, and when we decided to
      mutate <code class="computeroutput"><span class="identifier">R</span></code> in place or not.
    </p>
<div class="important"><table border="0" summary="Important">
<tr>
<td rowspan="2" align="center" valign="top" width="25"><img alt="[Important]" src="../images/important.png"></td>
<th align="left">Important</th>
</tr>
<tr><td align="left" valign="top"><p>
        Therefore, if you care about using <code class="computeroutput"><a class="link" href="../boost/text/unencoded_rope.html" title="Struct unencoded_rope">unencoded_ropes</a></code> in a thread-safe
        manner, always pass them by value.
      </p></td></tr>
</table></div>
<div class="note"><table border="0" summary="Note">
<tr>
<td rowspan="2" align="center" valign="top" width="25"><img alt="[Note]" src="../images/note.png"></td>
<th align="left">Note</th>
</tr>
<tr><td align="left" valign="top"><p>
        A major use case for <code class="computeroutput"><a class="link" href="../boost/text/unencoded_rope.html" title="Struct unencoded_rope">unencoded_ropes</a></code> is for building
        undo/redo systems for text editing that are simple and performant. See the
        example in the <a class="link" href="segmented_vector_.html" title="segmented_vector"><code class="computeroutput"><span class="identifier">segmented_vector</span> <span class="identifier">documentation</span></code></a>
        for details &#8212; just imagine <code class="computeroutput"><a class="link" href="../boost/text/unencoded_rope.html" title="Struct unencoded_rope">unencoded_ropes</a></code> instead of
        <code class="computeroutput"><span class="identifier">segmented_vector</span><span class="special">&lt;</span><span class="keyword">int</span><span class="special">&gt;</span></code>s.
      </p></td></tr>
</table></div>
<p>
      <code class="computeroutput"><a class="link" href="../boost/text/unencoded_rope.html" title="Struct unencoded_rope">unencoded_rope</a></code>
      has the same <code class="computeroutput"><span class="keyword">explicit</span></code> conversions
      from <a class="link" href="concepts.html#boost_text__proposed_.concepts.charrange">CharRange</a>
      and <a class="link" href="concepts.html#boost_text__proposed_.concepts.graphemerange">GraphemeRange</a>
      that <code class="computeroutput"><a class="link" href="../boost/text/string.html" title="Struct string">string</a></code>
      does.
    </p>
<h4>
<a name="boost_text__proposed_.the_string_layer.h4"></a>
      <span class="phrase"><a name="boost_text__proposed_.the_string_layer.the__code__phrase_role__identifier__unencoded_rope_view__phrase___code__type"></a></span><a class="link" href="the_string_layer.html#boost_text__proposed_.the_string_layer.the__code__phrase_role__identifier__unencoded_rope_view__phrase___code__type">The
      <code class="computeroutput"><span class="identifier">unencoded_rope_view</span></code> Type</a>
    </h4>
<p>
      Just as you can think of a <a href="https://en.wikipedia.org/wiki/Rope_(data_structure)" target="_top">Rope</a>
      as a heavyweight string, you can think of a <code class="computeroutput"><a class="link" href="../boost/text/unencoded_rope_view.html" title="Struct unencoded_rope_view">unencoded_rope_view</a></code> is a heavyweight
      <code class="computeroutput"><a class="link" href="../boost/text/string_view.html" title="Struct string_view">string_view</a></code>.
      It can bind to a <code class="computeroutput"><a class="link" href="../boost/text/unencoded_rope.html" title="Struct unencoded_rope">unencoded_rope</a></code>, but also to any
      of <code class="computeroutput"><a class="link" href="../boost/text/string.html" title="Struct string">string</a></code>,
      <code class="computeroutput"><a class="link" href="../boost/text/string_view.html" title="Struct string_view">string_view</a></code>,
      and even <code class="computeroutput"><a class="link" href="../boost/text/repeated_string_view.html" title="Struct repeated_string_view">repeated_string_view</a></code>.
    </p>
<p>
      <code class="computeroutput"><a class="link" href="../boost/text/unencoded_rope_view.html" title="Struct unencoded_rope_view">unencoded_rope_view</a></code>
      has semantics and an interface much like <code class="computeroutput"><a class="link" href="../boost/text/string_view.html" title="Struct string_view">string_view</a></code>: it is near-immutable;
      it uses a signed size/index type (<code class="computeroutput"><span class="identifier">std</span><span class="special">::</span><span class="identifier">ptrdiff_t</span></code>);
      it uses <code class="computeroutput"><span class="keyword">char</span></code> as its element type;
      and it is slice-able.
    </p>
<p>
      A key use of <code class="computeroutput"><a class="link" href="../boost/text/unencoded_rope_view.html" title="Struct unencoded_rope_view">unencoded_rope_view</a></code> is that it
      can bind to all the other Boost.Text string types. If your code expects to
      handle only <code class="computeroutput"><a class="link" href="../boost/text/string.html" title="Struct string">strings</a></code>,
      <code class="computeroutput"><span class="keyword">char</span> <span class="keyword">const</span>
      <span class="special">*</span></code>s, and <code class="computeroutput"><a class="link" href="../boost/text/string_view.html" title="Struct string_view">string_views</a></code> as function parameters,
      use <code class="computeroutput"><a class="link" href="../boost/text/string_view.html" title="Struct string_view">string_view</a></code>
      in your interfaces. If you also expect to handle <code class="computeroutput"><a class="link" href="../boost/text/unencoded_rope.html" title="Struct unencoded_rope">unencoded_ropes</a></code> and <code class="computeroutput"><a class="link" href="../boost/text/repeated_string_view.html" title="Struct repeated_string_view">repeated_string_views</a></code>,
      use <code class="computeroutput"><a class="link" href="../boost/text/unencoded_rope_view.html" title="Struct unencoded_rope_view">unencoded_rope_view</a></code>
      in your interfaces instead.
    </p>
<p>
      <code class="computeroutput"><a class="link" href="../boost/text/unencoded_rope_view.html" title="Struct unencoded_rope_view">unencoded_rope_view</a></code>
      has the same <code class="computeroutput"><span class="keyword">explicit</span></code> conversions
      from <a class="link" href="concepts.html#boost_text__proposed_.concepts.contigcharrange">ContigCharRange</a>
      and <a class="link" href="concepts.html#boost_text__proposed_.concepts.contiggraphemerange">ContigGraphemeRange</a>
      that <code class="computeroutput"><a class="link" href="../boost/text/string_view.html" title="Struct string_view">string_view</a></code>
      does.
    </p>
<h4>
<a name="boost_text__proposed_.the_string_layer.h5"></a>
      <span class="phrase"><a name="boost_text__proposed_.the_string_layer.common_operations"></a></span><a class="link" href="the_string_layer.html#boost_text__proposed_.the_string_layer.common_operations">Common Operations</a>
    </h4>
<p>
      There are some operations that are common to all the Boost.Text string layer
      types.
    </p>
<div class="orderedlist"><ol class="orderedlist" type="1">
<li class="listitem">
          Implicit conversions to view types are the norm.
        </li>
<li class="listitem">
          Explicit conversions to non-view types are the norm.
        </li>
<li class="listitem">
          View types are explicitly constructible from <a class="link" href="concepts.html#boost_text__proposed_.concepts.contigcharrange">ContigCharRange</a>
          and <a class="link" href="concepts.html#boost_text__proposed_.concepts.contiggraphemerange">ContigGraphemeRange</a>.
        </li>
<li class="listitem">
          Non-view types are explicitly constructible from <a class="link" href="concepts.html#boost_text__proposed_.concepts.charrange">CharRange</a>
          and <a class="link" href="concepts.html#boost_text__proposed_.concepts.graphemerange">GraphemeRange</a>.
        </li>
<li class="listitem">
          Each has the slicing call operators. Each slicing call operator returns
          a view, and so does not allocate.
        </li>
<li class="listitem">
          Each has an index operator with the signature <code class="computeroutput"><span class="keyword">char</span>
          <span class="keyword">operator</span><span class="special">[](</span><span class="identifier">size_type</span><span class="special">)</span>
          <span class="keyword">const</span> <span class="keyword">noexcept</span></code>.
        </li>
<li class="listitem">
          Taking text layer types and using them with string layer types works, but
          often requires more verbosity.
        </li>
<li class="listitem">
          Allocating <code class="computeroutput"><span class="keyword">operator</span><span class="special">+()</span></code>
          is defined for almost all types, but not between pairs of view types.
        </li>
<li class="listitem">
          Non-allocating slice operations are defined for all types.
        </li>
<li class="listitem">
          Unformatted-output operator&lt;&lt; is defined for all types.
        </li>
<li class="listitem">
          All variants of <code class="computeroutput"><span class="identifier">begin</span><span class="special">()</span></code>,
          <code class="computeroutput"><span class="identifier">end</span><span class="special">()</span></code>,
          <code class="computeroutput"><span class="identifier">rbegin</span><span class="special">()</span></code>,
          and <code class="computeroutput"><span class="identifier">rend</span><span class="special">()</span></code>
          are defined for all types.
        </li>
<li class="listitem">
          <code class="computeroutput"><span class="keyword">operator</span><span class="special">+=()</span></code>,
          <code class="computeroutput"><span class="identifier">insert</span><span class="special">()</span></code>,
          <code class="computeroutput"><span class="identifier">erase</span><span class="special">()</span></code>,
          and <code class="computeroutput"><span class="identifier">replace</span><span class="special">()</span></code>
          are defined for the non-view types (<code class="computeroutput"><a class="link" href="../boost/text/string.html" title="Struct string">string</a></code> and <code class="computeroutput"><a class="link" href="../boost/text/unencoded_rope.html" title="Struct unencoded_rope">unencoded_rope</a></code>).
        </li>
<li class="listitem">
          <code class="computeroutput"><span class="identifier">std</span><span class="special">::</span><span class="identifier">hash</span></code> is specialized for all the string
          layer types.
        </li>
</ol></div>
<h4>
<a name="boost_text__proposed_.the_string_layer.h6"></a>
      <span class="phrase"><a name="boost_text__proposed_.the_string_layer.picking_the_right_string_type"></a></span><a class="link" href="the_string_layer.html#boost_text__proposed_.the_string_layer.picking_the_right_string_type">Picking
      the Right String Type</a>
    </h4>
<div class="table">
<a name="boost_text__proposed_.the_string_layer.t0"></a><p class="title"><b>Table&#160;1.1.&#160;Picking the Right String Type</b></p>
<div class="table-contents"><table class="table" summary="Picking the Right String Type">
<colgroup>
<col>
<col>
</colgroup>
<thead><tr>
<th>
              <p>
                If I need ...
              </p>
            </th>
<th>
              <p>
                ... my string type is:
              </p>
            </th>
</tr></thead>
<tbody>
<tr>
<td>
              <p>
                to manipulate strings entirely at compile time
              </p>
            </td>
<td>
              <p>
                <code class="computeroutput"><a class="link" href="../boost/text/string_view.html" title="Struct string_view">string_view</a></code>
              </p>
            </td>
</tr>
<tr>
<td>
              <p>
                to capture a reference to a string that will outlive the reference,
                without allocating
              </p>
            </td>
<td>
              <p>
                <code class="computeroutput"><a class="link" href="../boost/text/string_view.html" title="Struct string_view">string_view</a></code>
              </p>
            </td>
</tr>
<tr>
<td>
              <p>
                a mutable string with efficient mutation at the end of the string
              </p>
            </td>
<td>
              <p>
                <code class="computeroutput"><a class="link" href="../boost/text/string.html" title="Struct string">string</a></code>
              </p>
            </td>
</tr>
<tr>
<td>
              <p>
                a mutable string with efficient mutation at any point in the string
              </p>
            </td>
<td>
              <p>
                <code class="computeroutput"><a class="link" href="../boost/text/unencoded_rope.html" title="Struct unencoded_rope">unencoded_rope</a></code>
              </p>
            </td>
</tr>
<tr>
<td>
              <p>
                a string with contiguous storage
              </p>
            </td>
<td>
              <p>
                <code class="computeroutput"><a class="link" href="../boost/text/string_view.html" title="Struct string_view">string_view</a></code>
                or <code class="computeroutput"><a class="link" href="../boost/text/string.html" title="Struct string">string</a></code>
              </p>
            </td>
</tr>
<tr>
<td>
              <p>
                a null-terminated string
              </p>
            </td>
<td>
              <p>
                <code class="computeroutput"><a class="link" href="../boost/text/string.html" title="Struct string">string</a></code>
              </p>
            </td>
</tr>
<tr>
<td>
              <p>
                a mutable string the size of a single pointer
              </p>
            </td>
<td>
              <p>
                <code class="computeroutput"><a class="link" href="../boost/text/unencoded_rope.html" title="Struct unencoded_rope">unencoded_rope</a></code>
              </p>
            </td>
</tr>
<tr>
<td>
              <p>
                a thread-safe string
              </p>
            </td>
<td>
              <p>
                <code class="computeroutput"><a class="link" href="../boost/text/unencoded_rope.html" title="Struct unencoded_rope">unencoded_rope</a></code>
              </p>
            </td>
</tr>
<tr>
<td>
              <p>
                a string with the small-object optimization
              </p>
            </td>
<td>
              <p>
                <code class="computeroutput"><a class="link" href="../boost/text/string.html" title="Struct string">string</a></code>
              </p>
            </td>
</tr>
<tr>
<td>
              <p>
                a string with copy-on-write semantics
              </p>
            </td>
<td>
              <p>
                <code class="computeroutput"><a class="link" href="../boost/text/unencoded_rope.html" title="Struct unencoded_rope">unencoded_rope</a></code>
              </p>
            </td>
</tr>
<tr>
<td>
              <p>
                to represent the repetition of a snippet of text, without allocating
              </p>
            </td>
<td>
              <p>
                <code class="computeroutput"><a class="link" href="../boost/text/repeated_string_view.html" title="Struct repeated_string_view">repeated_string_view</a></code>
              </p>
            </td>
</tr>
<tr>
<td>
              <p>
                to capture <code class="computeroutput"><span class="keyword">char</span> <span class="keyword">const</span>
                <span class="special">*</span></code>s, <code class="computeroutput"><a class="link" href="../boost/text/string_view.html" title="Struct string_view">string_views</a></code>, and
                <code class="computeroutput"><a class="link" href="../boost/text/string.html" title="Struct string">strings</a></code>
                in a function parameter
              </p>
            </td>
<td>
              <p>
                <code class="computeroutput"><a class="link" href="../boost/text/string_view.html" title="Struct string_view">string_view</a></code>
              </p>
            </td>
</tr>
<tr>
<td>
              <p>
                to capture <code class="computeroutput"><span class="keyword">char</span> <span class="keyword">const</span>
                <span class="special">*</span></code>s, <code class="computeroutput"><a class="link" href="../boost/text/string_view.html" title="Struct string_view">string_views</a></code>, <code class="computeroutput"><a class="link" href="../boost/text/string.html" title="Struct string">strings</a></code>,
                <code class="computeroutput"><a class="link" href="../boost/text/repeated_string_view.html" title="Struct repeated_string_view">repeated_string_views</a></code>,
                <code class="computeroutput"><a class="link" href="../boost/text/unencoded_rope.html" title="Struct unencoded_rope">unencoded_ropes</a></code>,
                and <code class="computeroutput"><a class="link" href="../boost/text/rope_view.html" title="Struct rope_view">rope_views</a></code>
                in a function parameter
              </p>
            </td>
<td>
              <p>
                <code class="computeroutput"><a class="link" href="../boost/text/unencoded_rope_view.html" title="Struct unencoded_rope_view">unencoded_rope_view</a></code>
              </p>
            </td>
</tr>
</tbody>
</table></div>
</div>
<br class="table-break"><div class="tip"><table border="0" summary="Tip">
<tr>
<td rowspan="2" align="center" valign="top" width="25"><img alt="[Tip]" src="../images/tip.png"></td>
<th align="left">Tip</th>
</tr>
<tr><td align="left" valign="top"><p>
        For an overloaded function <code class="computeroutput"><span class="identifier">foo</span><span class="special">()</span></code>, providing an overload for each of <code class="computeroutput"><span class="identifier">foo</span><span class="special">(</span><span class="identifier">string_view</span><span class="special">)</span></code> and <code class="computeroutput"><span class="identifier">foo</span><span class="special">(</span><span class="identifier">unencoded_rope_view</span><span class="special">)</span></code> will create an ambiguity, since they are
        each implicitly constructible from <code class="computeroutput"><span class="keyword">char</span>
        <span class="keyword">const</span> <span class="special">*</span></code>.
        This will require you also to add a third overload <code class="computeroutput"><span class="identifier">foo</span><span class="special">(</span><span class="keyword">char</span> <span class="keyword">const</span>
        <span class="special">*)</span></code>, so try to stick to one view type
        or the other when you can.
      </p></td></tr>
</table></div>
<h4>
<a name="boost_text__proposed_.the_string_layer.h7"></a>
      <span class="phrase"><a name="boost_text__proposed_.the_string_layer.string_builders"></a></span><a class="link" href="the_string_layer.html#boost_text__proposed_.the_string_layer.string_builders">String Builders</a>
    </h4>
<p>
      Sometimes you need to build a string in a hot code path. The default behavior
      of <code class="computeroutput"><a class="link" href="../boost/text/string.html" title="Struct string">string</a></code>
      is not quite optimal. It must write a null-terminator during almost any mutating
      operation, even if that null terminator will be overwritten in the next operation.
      It may also allocate memory multiple times during a series of append operations.
    </p>
<p>
      Boost.Text provides two types to make optimal string building easier: <code class="computeroutput"><a class="link" href="../boost/text/string_builder.html" title="Struct string_builder">string_builder</a></code>
      and <code class="computeroutput"><a class="link" href="../boost/text/static_string_builder.html" title="Struct static_string_builder">static_string_builder</a></code>.
    </p>
<p>
      <code class="computeroutput"><a class="link" href="../boost/text/string_builder.html" title="Struct string_builder">string_builder</a></code>
      builds strings dynamically, much like <code class="computeroutput"><a class="link" href="../boost/text/string.html" title="Struct string">string</a></code> does, except that it is
      append-only. It allocates memory as it you append to it, but it skips writing
      the terminating null. This can make it measurably faster in string building
      operations that involve a high number of small appends:
    </p>
<p>
</p>
<pre class="programlisting"><span class="identifier">boost</span><span class="special">::</span><span class="identifier">text</span><span class="special">::</span><span class="identifier">string_builder</span> <span class="identifier">builder</span><span class="special">;</span>
<span class="identifier">builder</span> <span class="special">+=</span> <span class="string">"some"</span><span class="special">;</span>
<span class="identifier">builder</span> <span class="special">+=</span> <span class="string">" "</span><span class="special">;</span>
<span class="identifier">builder</span> <span class="special">+=</span> <span class="string">"text"</span><span class="special">;</span>

<span class="comment">// Null termination fianlly happens here, and the array owned by builder is</span>
<span class="comment">// moved into result.</span>
<span class="identifier">boost</span><span class="special">::</span><span class="identifier">text</span><span class="special">::</span><span class="identifier">string</span> <span class="keyword">const</span> <span class="identifier">result</span> <span class="special">=</span> <span class="identifier">builder</span><span class="special">.</span><span class="identifier">to_string</span><span class="special">();</span>

<span class="comment">// Prints "some text".</span>
<span class="identifier">std</span><span class="special">::</span><span class="identifier">cout</span> <span class="special">&lt;&lt;</span> <span class="identifier">result</span> <span class="special">&lt;&lt;</span> <span class="string">"\n"</span><span class="special">;</span>
</pre>
<p>
    </p>
<p>
      <code class="computeroutput"><a class="link" href="../boost/text/static_string_builder.html" title="Struct static_string_builder">static_string_builder</a></code>
      can avoid allocations entirely until the final step. The type of the builder
      object changes with each operation, though, so <code class="computeroutput"><a class="link" href="../boost/text/static_string_builder.html" title="Struct static_string_builder">static_string_builder</a></code> cannot
      be used in some contexts, for example in a loop. <code class="computeroutput"><a class="link" href="../boost/text/static_string_builder.html" title="Struct static_string_builder">static_string_builder</a></code> is <code class="computeroutput"><span class="keyword">constexpr</span></code>-friendly in C++14 and later. Here
      it is in action:
    </p>
<p>
</p>
<pre class="programlisting"><span class="preprocessor">#ifndef</span> <span class="identifier">BOOST_TEXT_NO_CXX14_CONSTEXPR</span>

<span class="keyword">constexpr</span> <span class="identifier">boost</span><span class="special">::</span><span class="identifier">text</span><span class="special">::</span><span class="identifier">static_string_builder</span> <span class="identifier">builder</span><span class="special">;</span>   <span class="comment">// Empty builder.</span>
<span class="keyword">constexpr</span> <span class="keyword">auto</span> <span class="identifier">builder_1</span> <span class="special">=</span> <span class="identifier">builder</span> <span class="special">+</span> <span class="string">"some"</span><span class="special">;</span>            <span class="comment">// A builder containing one string_view.</span>
<span class="keyword">constexpr</span> <span class="keyword">char</span> <span class="keyword">const</span> <span class="special">*</span> <span class="identifier">space</span> <span class="special">=</span> <span class="string">" "</span><span class="special">;</span>
<span class="keyword">constexpr</span> <span class="keyword">auto</span> <span class="identifier">builder_2</span> <span class="special">=</span> <span class="identifier">builder_1</span> <span class="special">+</span> <span class="identifier">space</span><span class="special">;</span>           <span class="comment">// A builder containing two string_views.</span>
<span class="keyword">constexpr</span> <span class="keyword">auto</span> <span class="identifier">builder_3</span> <span class="special">=</span> <span class="identifier">builder_2</span> <span class="special">+</span> <span class="string">"text"</span><span class="special">;</span>          <span class="comment">// A builder containing three string_views.</span>

<span class="comment">// A single allocation happens here.</span>
<span class="identifier">boost</span><span class="special">::</span><span class="identifier">text</span><span class="special">::</span><span class="identifier">string</span> <span class="keyword">const</span> <span class="identifier">result</span> <span class="special">=</span> <span class="identifier">builder_3</span><span class="special">.</span><span class="identifier">to_string</span><span class="special">();</span>

<span class="comment">// Prints "some text".</span>
<span class="identifier">std</span><span class="special">::</span><span class="identifier">cout</span> <span class="special">&lt;&lt;</span> <span class="identifier">result</span> <span class="special">&lt;&lt;</span> <span class="string">"\n"</span><span class="special">;</span>

<span class="preprocessor">#endif</span>
</pre>
<p>
    </p>
</div>
<table xmlns:rev="http://www.cs.rpi.edu/~gregod/boost/tools/doc/revision" width="100%"><tr>
<td align="left"></td>
<td align="right"><div class="copyright-footer">Copyright &#169; 2018 T. Zachary Laine<p>
        Distributed under the Boost Software License, Version 1.0. (See accompanying
        file LICENSE_1_0.txt or copy at <a href="http://www.boost.org/LICENSE_1_0.txt" target="_top">http://www.boost.org/LICENSE_1_0.txt</a>)
      </p>
</div></td>
</tr></table>
<hr>
<div class="spirit-nav">
<a accesskey="p" href="a_big__fat_warning_about_proxy_iterators.html"><img src="../images/prev.png" alt="Prev"></a><a accesskey="u" href="../index.html"><img src="../images/up.png" alt="Up"></a><a accesskey="h" href="../index.html"><img src="../images/home.png" alt="Home"></a><a accesskey="n" href="the_unicode_layer.html"><img src="../images/next.png" alt="Next"></a>
</div>
</body>
</html>
