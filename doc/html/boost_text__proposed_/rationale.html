<html>
<head>
<meta http-equiv="Content-Type" content="text/html; charset=US-ASCII">
<title>Rationale</title>
<link rel="stylesheet" href="../boostbook.css" type="text/css">
<meta name="generator" content="DocBook XSL Stylesheets V1.79.1">
<link rel="home" href="../index.html" title="Chapter&#160;1.&#160;Boost.Text (Proposed)">
<link rel="up" href="../index.html" title="Chapter&#160;1.&#160;Boost.Text (Proposed)">
<link rel="prev" href="../index/s14.html" title="Macro Index">
<link rel="next" href="future_work.html" title="Future Work">
</head>
<body bgcolor="white" text="black" link="#0000FF" vlink="#840084" alink="#0000FF">
<div class="spirit-nav">
<a accesskey="p" href="../index/s14.html"><img src="../images/prev.png" alt="Prev"></a><a accesskey="u" href="../index.html"><img src="../images/up.png" alt="Up"></a><a accesskey="h" href="../index.html"><img src="../images/home.png" alt="Home"></a><a accesskey="n" href="future_work.html"><img src="../images/next.png" alt="Next"></a>
</div>
<div class="section">
<div class="titlepage"><div><div><h2 class="title" style="clear: both">
<a name="boost_text__proposed_.rationale"></a><a class="link" href="rationale.html" title="Rationale">Rationale</a>
</h2></div></div></div>
<h4>
<a name="boost_text__proposed_.rationale.h0"></a>
      <span class="phrase"><a name="boost_text__proposed_.rationale.size_and_index_types"></a></span><a class="link" href="rationale.html#boost_text__proposed_.rationale.size_and_index_types">Size
      and Index Types</a>
    </h4>
<p>
      Signed values as sizes are advantageous for a number of reasons:
    </p>
<div class="orderedlist"><ol class="orderedlist" type="1">
<li class="listitem">
          When doing math with sizes, intermediate values can be negative (which
          makes sense), instead of wrapping around to a very large value (which does
          not).
        </li>
<li class="listitem">
          Optimizers produce better code generation in more situations for signed
          values.
        </li>
<li class="listitem">
          Signed values lead naturally to the negative-indexable slicing that Boost.Text
          uses.
        </li>
</ol></div>
<p>
      This last point is particularly important. I think that negative indexing should
      be allowed on all random access ranges.
    </p>
<h4>
<a name="boost_text__proposed_.rationale.h1"></a>
      <span class="phrase"><a name="boost_text__proposed_.rationale._code__phrase_role__keyword__char__phrase___phrase_role__keyword__const__phrase___phrase_role__special_____phrase___code__iterators"></a></span><a class="link" href="rationale.html#boost_text__proposed_.rationale._code__phrase_role__keyword__char__phrase___phrase_role__keyword__const__phrase___phrase_role__special_____phrase___code__iterators"><code class="computeroutput"><span class="keyword">char</span> <span class="keyword">const</span> <span class="special">*</span></code> Iterators</a>
    </h4>
<p>
      <code class="computeroutput"><a class="link" href="../boost/text/string.html" title="Struct string">string</a></code>
      and <code class="computeroutput"><a class="link" href="../boost/text/string_view.html" title="Struct string_view">string_view</a></code>
      both use <code class="computeroutput"><span class="keyword">char</span> <span class="keyword">const</span>
      <span class="special">*</span></code> as their forward iterator types. This
      allows interoperability with C strings and arrays of <code class="computeroutput"><span class="keyword">char</span></code>.
    </p>
<h4>
<a name="boost_text__proposed_.rationale.h2"></a>
      <span class="phrase"><a name="boost_text__proposed_.rationale.where_are__code__phrase_role__identifier__data__phrase__phrase_role__special______phrase___code____code__phrase_role__identifier__c_str__phrase__phrase_role__special______phrase___code____code__phrase_role__identifier__front__phrase__phrase_role__special______phrase___code___and__code__phrase_role__identifier__back__phrase__phrase_role__special______phrase___code__"></a></span><a class="link" href="rationale.html#boost_text__proposed_.rationale.where_are__code__phrase_role__identifier__data__phrase__phrase_role__special______phrase___code____code__phrase_role__identifier__c_str__phrase__phrase_role__special______phrase___code____code__phrase_role__identifier__front__phrase__phrase_role__special______phrase___code___and__code__phrase_role__identifier__back__phrase__phrase_role__special______phrase___code__">Where
      Are <code class="computeroutput"><span class="identifier">data</span><span class="special">()</span></code>,
      <code class="computeroutput"><span class="identifier">c_str</span><span class="special">()</span></code>,
      <code class="computeroutput"><span class="identifier">front</span><span class="special">()</span></code>,
      and <code class="computeroutput"><span class="identifier">back</span><span class="special">()</span></code>?</a>
    </h4>
<p>
      <code class="computeroutput"><a class="link" href="../boost/text/string.html" title="Struct string">string</a></code>
      does not have any of these, even though <code class="computeroutput"><span class="identifier">std</span><span class="special">::</span><span class="identifier">string</span></code>
      does. Here's why:
    </p>
<div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; ">
<li class="listitem">
          Since <code class="computeroutput"><span class="identifier">string</span><span class="special">::</span><span class="identifier">iterator</span></code> is just <code class="computeroutput"><span class="keyword">char</span>
          <span class="keyword">const</span> <span class="special">*</span></code>,
          and <code class="computeroutput"><a class="link" href="../boost/text/string.html" title="Struct string">string</a></code>
          is always null-terminated, <code class="computeroutput"><span class="identifier">data</span><span class="special">()</span></code>, <code class="computeroutput"><span class="identifier">c_str</span><span class="special">()</span></code>, and <code class="computeroutput"><span class="identifier">begin</span><span class="special">()</span></code> are synonyms.
        </li>
<li class="listitem">
          <code class="computeroutput"><span class="identifier">front</span><span class="special">()</span></code>
          and <code class="computeroutput"><span class="identifier">back</span><span class="special">()</span></code>
          have no reason to be members, so they are now free functions. This makes
          them usable on many types of sequences of <code class="computeroutput"><span class="keyword">char</span></code>,
          not just <code class="computeroutput"><a class="link" href="../boost/text/string.html" title="Struct string">string</a></code>.
        </li>
</ul></div>
<h4>
<a name="boost_text__proposed_.rationale.h3"></a>
      <span class="phrase"><a name="boost_text__proposed_.rationale.inserting_null_terminated_sequences"></a></span><a class="link" href="rationale.html#boost_text__proposed_.rationale.inserting_null_terminated_sequences">Inserting
      Null Terminated Sequences</a>
    </h4>
<p>
      The <code class="computeroutput"><a class="link" href="../boost/text/string.html" title="Struct string">string</a></code>
      inserting interfaces (<code class="computeroutput"><span class="identifier">insert</span><span class="special">()</span></code> and <code class="computeroutput"><span class="identifier">replace</span><span class="special">()</span></code>) remove explicit null terminators from inserted
      <code class="computeroutput"><a class="link" href="../boost/text/string_view.html" title="Struct string_view">string_views</a></code>
      and <code class="computeroutput"><a class="link" href="../boost/text/repeated_string_view.html" title="Struct repeated_string_view">repeated_string_views</a></code>,
      because leaving them in is almost certainly an error. This can still be accomplished
      by directly writing through the index operator or or an iterator, or by inserting
      <code class="computeroutput"><span class="identifier">string_view</span><span class="special">(</span><span class="string">"\0"</span><span class="special">)</span></code>.
    </p>
<h4>
<a name="boost_text__proposed_.rationale.h4"></a>
      <span class="phrase"><a name="boost_text__proposed_.rationale.none_of_the_boost_text_string_types_does_formatted_output"></a></span><a class="link" href="rationale.html#boost_text__proposed_.rationale.none_of_the_boost_text_string_types_does_formatted_output">None
      of the Boost.Text String Types Does Formatted Output</a>
    </h4>
<p>
      This is necessary because a single <code class="computeroutput"><span class="keyword">char</span></code>
      is not a code point, and a even single code point does not correspond to a
      single formatted output glyph. This means that the layout/spacing of the output
      is not something Boost.Text can determine. Higher-level code must deal with
      such issues.
    </p>
<h4>
<a name="boost_text__proposed_.rationale.h5"></a>
      <span class="phrase"><a name="boost_text__proposed_.rationale.boost_text_does_not_use_allocators"></a></span><a class="link" href="rationale.html#boost_text__proposed_.rationale.boost_text_does_not_use_allocators">Boost.Text
      Does Not Use allocators</a>
    </h4>
<p>
      Allocators are too low gain for the cost they impose. How many <code class="computeroutput"><span class="identifier">std</span><span class="special">::</span><span class="identifier">basic_string</span></code>
      template instantations in the code bases of the world involve a non-default
      allocator? I would be surprised if it was as high as 1%. Allocators may once
      have served an important function, but in modern C++ are a perfect example
      of not sticking to "Don't pay for what you don't use."
    </p>
</div>
<table xmlns:rev="http://www.cs.rpi.edu/~gregod/boost/tools/doc/revision" width="100%"><tr>
<td align="left"></td>
<td align="right"><div class="copyright-footer">Copyright &#169; 2018 T. Zachary Laine<p>
        Distributed under the Boost Software License, Version 1.0. (See accompanying
        file LICENSE_1_0.txt or copy at <a href="http://www.boost.org/LICENSE_1_0.txt" target="_top">http://www.boost.org/LICENSE_1_0.txt</a>)
      </p>
</div></td>
</tr></table>
<hr>
<div class="spirit-nav">
<a accesskey="p" href="../index/s14.html"><img src="../images/prev.png" alt="Prev"></a><a accesskey="u" href="../index.html"><img src="../images/up.png" alt="Up"></a><a accesskey="h" href="../index.html"><img src="../images/home.png" alt="Home"></a><a accesskey="n" href="future_work.html"><img src="../images/next.png" alt="Next"></a>
</div>
</body>
</html>
