// Warning! This file is autogenerated.
#include "collation_tests.hpp"

#include <boost/algorithm/cxx14/equal.hpp>

#include <gtest/gtest.h>



TEST(collation, non_ignorable_111_000)
{
    // 1D62C 003F;	
    // (ùò¨) MATHEMATICAL SANS-SERIF ITALIC SMALL K	[1DCB 0267 | 0020 0020 | 0005 0002 |]

    uint32_t cps[2] = { 0x1D62C, 0x003F };
    uint32_t const ces[9] = { 0x1DCB, 0x0267, 0x0000, 0x0020, 0x0020, 0x0000, 0x0005, 0x0002, 0x0000 };

    auto collation = collate_for_tests(
        cps, cps + 2, boost::text::variable_weighting::non_ignorable);

    EXPECT_EQ(collation.size(), 9);
    EXPECT_TRUE(boost::algorithm::equal(collation.begin(), collation.end(), ces, ces + 9))
        << "from:     " << ce_dumper(cps)
        << "expected: " << ce_dumper(ces)
        << "got:      " << ce_dumper(collation);
}

TEST(collation, non_ignorable_111_001)
{
    // 1D660 003F;	
    // (ùô†) MATHEMATICAL SANS-SERIF BOLD ITALIC SMALL K	[1DCB 0267 | 0020 0020 | 0005 0002 |]

    uint32_t cps[2] = { 0x1D660, 0x003F };
    uint32_t const ces[9] = { 0x1DCB, 0x0267, 0x0000, 0x0020, 0x0020, 0x0000, 0x0005, 0x0002, 0x0000 };

    auto collation = collate_for_tests(
        cps, cps + 2, boost::text::variable_weighting::non_ignorable);

    EXPECT_EQ(collation.size(), 9);
    EXPECT_TRUE(boost::algorithm::equal(collation.begin(), collation.end(), ces, ces + 9))
        << "from:     " << ce_dumper(cps)
        << "expected: " << ce_dumper(ces)
        << "got:      " << ce_dumper(collation);
}

TEST(collation, non_ignorable_111_002)
{
    // 1D694 003F;	
    // (ùöî) MATHEMATICAL MONOSPACE SMALL K	[1DCB 0267 | 0020 0020 | 0005 0002 |]

    uint32_t cps[2] = { 0x1D694, 0x003F };
    uint32_t const ces[9] = { 0x1DCB, 0x0267, 0x0000, 0x0020, 0x0020, 0x0000, 0x0005, 0x0002, 0x0000 };

    auto collation = collate_for_tests(
        cps, cps + 2, boost::text::variable_weighting::non_ignorable);

    EXPECT_EQ(collation.size(), 9);
    EXPECT_TRUE(boost::algorithm::equal(collation.begin(), collation.end(), ces, ces + 9))
        << "from:     " << ce_dumper(cps)
        << "expected: " << ce_dumper(ces)
        << "got:      " << ce_dumper(collation);
}

TEST(collation, non_ignorable_111_003)
{
    // 24DA 003F;	
    // (‚ìö) CIRCLED LATIN SMALL LETTER K	[1DCB 0267 | 0020 0020 | 0006 0002 |]

    uint32_t cps[2] = { 0x24DA, 0x003F };
    uint32_t const ces[9] = { 0x1DCB, 0x0267, 0x0000, 0x0020, 0x0020, 0x0000, 0x0006, 0x0002, 0x0000 };

    auto collation = collate_for_tests(
        cps, cps + 2, boost::text::variable_weighting::non_ignorable);

    EXPECT_EQ(collation.size(), 9);
    EXPECT_TRUE(boost::algorithm::equal(collation.begin(), collation.end(), ces, ces + 9))
        << "from:     " << ce_dumper(cps)
        << "expected: " << ce_dumper(ces)
        << "got:      " << ce_dumper(collation);
}

TEST(collation, non_ignorable_111_004)
{
    // 004B 003F;	
    // (K) LATIN CAPITAL LETTER K	[1DCB 0267 | 0020 0020 | 0008 0002 |]

    uint32_t cps[2] = { 0x004B, 0x003F };
    uint32_t const ces[9] = { 0x1DCB, 0x0267, 0x0000, 0x0020, 0x0020, 0x0000, 0x0008, 0x0002, 0x0000 };

    auto collation = collate_for_tests(
        cps, cps + 2, boost::text::variable_weighting::non_ignorable);

    EXPECT_EQ(collation.size(), 9);
    EXPECT_TRUE(boost::algorithm::equal(collation.begin(), collation.end(), ces, ces + 9))
        << "from:     " << ce_dumper(cps)
        << "expected: " << ce_dumper(ces)
        << "got:      " << ce_dumper(collation);
}

TEST(collation, non_ignorable_111_005)
{
    // 212A 003F;	
    // (K) KELVIN SIGN	[1DCB 0267 | 0020 0020 | 0008 0002 |]

    uint32_t cps[2] = { 0x212A, 0x003F };
    uint32_t const ces[9] = { 0x1DCB, 0x0267, 0x0000, 0x0020, 0x0020, 0x0000, 0x0008, 0x0002, 0x0000 };

    auto collation = collate_for_tests(
        cps, cps + 2, boost::text::variable_weighting::non_ignorable);

    EXPECT_EQ(collation.size(), 9);
    EXPECT_TRUE(boost::algorithm::equal(collation.begin(), collation.end(), ces, ces + 9))
        << "from:     " << ce_dumper(cps)
        << "expected: " << ce_dumper(ces)
        << "got:      " << ce_dumper(collation);
}

TEST(collation, non_ignorable_111_006)
{
    // FF2B 003F;	
    // (Ôº´) FULLWIDTH LATIN CAPITAL LETTER K	[1DCB 0267 | 0020 0020 | 0009 0002 |]

    uint32_t cps[2] = { 0xFF2B, 0x003F };
    uint32_t const ces[9] = { 0x1DCB, 0x0267, 0x0000, 0x0020, 0x0020, 0x0000, 0x0009, 0x0002, 0x0000 };

    auto collation = collate_for_tests(
        cps, cps + 2, boost::text::variable_weighting::non_ignorable);

    EXPECT_EQ(collation.size(), 9);
    EXPECT_TRUE(boost::algorithm::equal(collation.begin(), collation.end(), ces, ces + 9))
        << "from:     " << ce_dumper(cps)
        << "expected: " << ce_dumper(ces)
        << "got:      " << ce_dumper(collation);
}

TEST(collation, non_ignorable_111_007)
{
    // 1D40A 003F;	
    // (ùêä) MATHEMATICAL BOLD CAPITAL K	[1DCB 0267 | 0020 0020 | 000B 0002 |]

    uint32_t cps[2] = { 0x1D40A, 0x003F };
    uint32_t const ces[9] = { 0x1DCB, 0x0267, 0x0000, 0x0020, 0x0020, 0x0000, 0x000B, 0x0002, 0x0000 };

    auto collation = collate_for_tests(
        cps, cps + 2, boost::text::variable_weighting::non_ignorable);

    EXPECT_EQ(collation.size(), 9);
    EXPECT_TRUE(boost::algorithm::equal(collation.begin(), collation.end(), ces, ces + 9))
        << "from:     " << ce_dumper(cps)
        << "expected: " << ce_dumper(ces)
        << "got:      " << ce_dumper(collation);
}

TEST(collation, non_ignorable_111_008)
{
    // 1D43E 003F;	
    // (ùêæ) MATHEMATICAL ITALIC CAPITAL K	[1DCB 0267 | 0020 0020 | 000B 0002 |]

    uint32_t cps[2] = { 0x1D43E, 0x003F };
    uint32_t const ces[9] = { 0x1DCB, 0x0267, 0x0000, 0x0020, 0x0020, 0x0000, 0x000B, 0x0002, 0x0000 };

    auto collation = collate_for_tests(
        cps, cps + 2, boost::text::variable_weighting::non_ignorable);

    EXPECT_EQ(collation.size(), 9);
    EXPECT_TRUE(boost::algorithm::equal(collation.begin(), collation.end(), ces, ces + 9))
        << "from:     " << ce_dumper(cps)
        << "expected: " << ce_dumper(ces)
        << "got:      " << ce_dumper(collation);
}

TEST(collation, non_ignorable_111_009)
{
    // 1D472 003F;	
    // (ùë≤) MATHEMATICAL BOLD ITALIC CAPITAL K	[1DCB 0267 | 0020 0020 | 000B 0002 |]

    uint32_t cps[2] = { 0x1D472, 0x003F };
    uint32_t const ces[9] = { 0x1DCB, 0x0267, 0x0000, 0x0020, 0x0020, 0x0000, 0x000B, 0x0002, 0x0000 };

    auto collation = collate_for_tests(
        cps, cps + 2, boost::text::variable_weighting::non_ignorable);

    EXPECT_EQ(collation.size(), 9);
    EXPECT_TRUE(boost::algorithm::equal(collation.begin(), collation.end(), ces, ces + 9))
        << "from:     " << ce_dumper(cps)
        << "expected: " << ce_dumper(ces)
        << "got:      " << ce_dumper(collation);
}

TEST(collation, non_ignorable_111_010)
{
    // 1D4A6 003F;	
    // (ùí¶) MATHEMATICAL SCRIPT CAPITAL K	[1DCB 0267 | 0020 0020 | 000B 0002 |]

    uint32_t cps[2] = { 0x1D4A6, 0x003F };
    uint32_t const ces[9] = { 0x1DCB, 0x0267, 0x0000, 0x0020, 0x0020, 0x0000, 0x000B, 0x0002, 0x0000 };

    auto collation = collate_for_tests(
        cps, cps + 2, boost::text::variable_weighting::non_ignorable);

    EXPECT_EQ(collation.size(), 9);
    EXPECT_TRUE(boost::algorithm::equal(collation.begin(), collation.end(), ces, ces + 9))
        << "from:     " << ce_dumper(cps)
        << "expected: " << ce_dumper(ces)
        << "got:      " << ce_dumper(collation);
}

TEST(collation, non_ignorable_111_011)
{
    // 1D4DA 003F;	
    // (ùìö) MATHEMATICAL BOLD SCRIPT CAPITAL K	[1DCB 0267 | 0020 0020 | 000B 0002 |]

    uint32_t cps[2] = { 0x1D4DA, 0x003F };
    uint32_t const ces[9] = { 0x1DCB, 0x0267, 0x0000, 0x0020, 0x0020, 0x0000, 0x000B, 0x0002, 0x0000 };

    auto collation = collate_for_tests(
        cps, cps + 2, boost::text::variable_weighting::non_ignorable);

    EXPECT_EQ(collation.size(), 9);
    EXPECT_TRUE(boost::algorithm::equal(collation.begin(), collation.end(), ces, ces + 9))
        << "from:     " << ce_dumper(cps)
        << "expected: " << ce_dumper(ces)
        << "got:      " << ce_dumper(collation);
}

TEST(collation, non_ignorable_111_012)
{
    // 1D50E 003F;	
    // (ùîé) MATHEMATICAL FRAKTUR CAPITAL K	[1DCB 0267 | 0020 0020 | 000B 0002 |]

    uint32_t cps[2] = { 0x1D50E, 0x003F };
    uint32_t const ces[9] = { 0x1DCB, 0x0267, 0x0000, 0x0020, 0x0020, 0x0000, 0x000B, 0x0002, 0x0000 };

    auto collation = collate_for_tests(
        cps, cps + 2, boost::text::variable_weighting::non_ignorable);

    EXPECT_EQ(collation.size(), 9);
    EXPECT_TRUE(boost::algorithm::equal(collation.begin(), collation.end(), ces, ces + 9))
        << "from:     " << ce_dumper(cps)
        << "expected: " << ce_dumper(ces)
        << "got:      " << ce_dumper(collation);
}

TEST(collation, non_ignorable_111_013)
{
    // 1D542 003F;	
    // (ùïÇ) MATHEMATICAL DOUBLE-STRUCK CAPITAL K	[1DCB 0267 | 0020 0020 | 000B 0002 |]

    uint32_t cps[2] = { 0x1D542, 0x003F };
    uint32_t const ces[9] = { 0x1DCB, 0x0267, 0x0000, 0x0020, 0x0020, 0x0000, 0x000B, 0x0002, 0x0000 };

    auto collation = collate_for_tests(
        cps, cps + 2, boost::text::variable_weighting::non_ignorable);

    EXPECT_EQ(collation.size(), 9);
    EXPECT_TRUE(boost::algorithm::equal(collation.begin(), collation.end(), ces, ces + 9))
        << "from:     " << ce_dumper(cps)
        << "expected: " << ce_dumper(ces)
        << "got:      " << ce_dumper(collation);
}

TEST(collation, non_ignorable_111_014)
{
    // 1D576 003F;	
    // (ùï∂) MATHEMATICAL BOLD FRAKTUR CAPITAL K	[1DCB 0267 | 0020 0020 | 000B 0002 |]

    uint32_t cps[2] = { 0x1D576, 0x003F };
    uint32_t const ces[9] = { 0x1DCB, 0x0267, 0x0000, 0x0020, 0x0020, 0x0000, 0x000B, 0x0002, 0x0000 };

    auto collation = collate_for_tests(
        cps, cps + 2, boost::text::variable_weighting::non_ignorable);

    EXPECT_EQ(collation.size(), 9);
    EXPECT_TRUE(boost::algorithm::equal(collation.begin(), collation.end(), ces, ces + 9))
        << "from:     " << ce_dumper(cps)
        << "expected: " << ce_dumper(ces)
        << "got:      " << ce_dumper(collation);
}

TEST(collation, non_ignorable_111_015)
{
    // 1D5AA 003F;	
    // (ùñ™) MATHEMATICAL SANS-SERIF CAPITAL K	[1DCB 0267 | 0020 0020 | 000B 0002 |]

    uint32_t cps[2] = { 0x1D5AA, 0x003F };
    uint32_t const ces[9] = { 0x1DCB, 0x0267, 0x0000, 0x0020, 0x0020, 0x0000, 0x000B, 0x0002, 0x0000 };

    auto collation = collate_for_tests(
        cps, cps + 2, boost::text::variable_weighting::non_ignorable);

    EXPECT_EQ(collation.size(), 9);
    EXPECT_TRUE(boost::algorithm::equal(collation.begin(), collation.end(), ces, ces + 9))
        << "from:     " << ce_dumper(cps)
        << "expected: " << ce_dumper(ces)
        << "got:      " << ce_dumper(collation);
}

TEST(collation, non_ignorable_111_016)
{
    // 1D5DE 003F;	
    // (ùóû) MATHEMATICAL SANS-SERIF BOLD CAPITAL K	[1DCB 0267 | 0020 0020 | 000B 0002 |]

    uint32_t cps[2] = { 0x1D5DE, 0x003F };
    uint32_t const ces[9] = { 0x1DCB, 0x0267, 0x0000, 0x0020, 0x0020, 0x0000, 0x000B, 0x0002, 0x0000 };

    auto collation = collate_for_tests(
        cps, cps + 2, boost::text::variable_weighting::non_ignorable);

    EXPECT_EQ(collation.size(), 9);
    EXPECT_TRUE(boost::algorithm::equal(collation.begin(), collation.end(), ces, ces + 9))
        << "from:     " << ce_dumper(cps)
        << "expected: " << ce_dumper(ces)
        << "got:      " << ce_dumper(collation);
}

TEST(collation, non_ignorable_111_017)
{
    // 1D612 003F;	
    // (ùòí) MATHEMATICAL SANS-SERIF ITALIC CAPITAL K	[1DCB 0267 | 0020 0020 | 000B 0002 |]

    uint32_t cps[2] = { 0x1D612, 0x003F };
    uint32_t const ces[9] = { 0x1DCB, 0x0267, 0x0000, 0x0020, 0x0020, 0x0000, 0x000B, 0x0002, 0x0000 };

    auto collation = collate_for_tests(
        cps, cps + 2, boost::text::variable_weighting::non_ignorable);

    EXPECT_EQ(collation.size(), 9);
    EXPECT_TRUE(boost::algorithm::equal(collation.begin(), collation.end(), ces, ces + 9))
        << "from:     " << ce_dumper(cps)
        << "expected: " << ce_dumper(ces)
        << "got:      " << ce_dumper(collation);
}

TEST(collation, non_ignorable_111_018)
{
    // 1D646 003F;	
    // (ùôÜ) MATHEMATICAL SANS-SERIF BOLD ITALIC CAPITAL K	[1DCB 0267 | 0020 0020 | 000B 0002 |]

    uint32_t cps[2] = { 0x1D646, 0x003F };
    uint32_t const ces[9] = { 0x1DCB, 0x0267, 0x0000, 0x0020, 0x0020, 0x0000, 0x000B, 0x0002, 0x0000 };

    auto collation = collate_for_tests(
        cps, cps + 2, boost::text::variable_weighting::non_ignorable);

    EXPECT_EQ(collation.size(), 9);
    EXPECT_TRUE(boost::algorithm::equal(collation.begin(), collation.end(), ces, ces + 9))
        << "from:     " << ce_dumper(cps)
        << "expected: " << ce_dumper(ces)
        << "got:      " << ce_dumper(collation);
}

TEST(collation, non_ignorable_111_019)
{
    // 1D67A 003F;	
    // (ùô∫) MATHEMATICAL MONOSPACE CAPITAL K	[1DCB 0267 | 0020 0020 | 000B 0002 |]

    uint32_t cps[2] = { 0x1D67A, 0x003F };
    uint32_t const ces[9] = { 0x1DCB, 0x0267, 0x0000, 0x0020, 0x0020, 0x0000, 0x000B, 0x0002, 0x0000 };

    auto collation = collate_for_tests(
        cps, cps + 2, boost::text::variable_weighting::non_ignorable);

    EXPECT_EQ(collation.size(), 9);
    EXPECT_TRUE(boost::algorithm::equal(collation.begin(), collation.end(), ces, ces + 9))
        << "from:     " << ce_dumper(cps)
        << "expected: " << ce_dumper(ces)
        << "got:      " << ce_dumper(collation);
}

TEST(collation, non_ignorable_111_020)
{
    // 24C0 003F;	
    // (‚ìÄ) CIRCLED LATIN CAPITAL LETTER K	[1DCB 0267 | 0020 0020 | 000C 0002 |]

    uint32_t cps[2] = { 0x24C0, 0x003F };
    uint32_t const ces[9] = { 0x1DCB, 0x0267, 0x0000, 0x0020, 0x0020, 0x0000, 0x000C, 0x0002, 0x0000 };

    auto collation = collate_for_tests(
        cps, cps + 2, boost::text::variable_weighting::non_ignorable);

    EXPECT_EQ(collation.size(), 9);
    EXPECT_TRUE(boost::algorithm::equal(collation.begin(), collation.end(), ces, ces + 9))
        << "from:     " << ce_dumper(cps)
        << "expected: " << ce_dumper(ces)
        << "got:      " << ce_dumper(collation);
}

TEST(collation, non_ignorable_111_021)
{
    // 1F15A 003F;	
    // (üÖö) NEGATIVE CIRCLED LATIN CAPITAL LETTER K	[1DCB 0267 | 0020 0020 | 000C 0002 |]

    uint32_t cps[2] = { 0x1F15A, 0x003F };
    uint32_t const ces[9] = { 0x1DCB, 0x0267, 0x0000, 0x0020, 0x0020, 0x0000, 0x000C, 0x0002, 0x0000 };

    auto collation = collate_for_tests(
        cps, cps + 2, boost::text::variable_weighting::non_ignorable);

    EXPECT_EQ(collation.size(), 9);
    EXPECT_TRUE(boost::algorithm::equal(collation.begin(), collation.end(), ces, ces + 9))
        << "from:     " << ce_dumper(cps)
        << "expected: " << ce_dumper(ces)
        << "got:      " << ce_dumper(collation);
}

TEST(collation, non_ignorable_111_022)
{
    // 1D4F 003F;	
    // (·µè) MODIFIER LETTER SMALL K	[1DCB 0267 | 0020 0020 | 0014 0002 |]

    uint32_t cps[2] = { 0x1D4F, 0x003F };
    uint32_t const ces[9] = { 0x1DCB, 0x0267, 0x0000, 0x0020, 0x0020, 0x0000, 0x0014, 0x0002, 0x0000 };

    auto collation = collate_for_tests(
        cps, cps + 2, boost::text::variable_weighting::non_ignorable);

    EXPECT_EQ(collation.size(), 9);
    EXPECT_TRUE(boost::algorithm::equal(collation.begin(), collation.end(), ces, ces + 9))
        << "from:     " << ce_dumper(cps)
        << "expected: " << ce_dumper(ces)
        << "got:      " << ce_dumper(collation);
}

TEST(collation, non_ignorable_111_023)
{
    // 2096 003F;	
    // (‚Çñ) LATIN SUBSCRIPT SMALL LETTER K	[1DCB 0267 | 0020 0020 | 0015 0002 |]

    uint32_t cps[2] = { 0x2096, 0x003F };
    uint32_t const ces[9] = { 0x1DCB, 0x0267, 0x0000, 0x0020, 0x0020, 0x0000, 0x0015, 0x0002, 0x0000 };

    auto collation = collate_for_tests(
        cps, cps + 2, boost::text::variable_weighting::non_ignorable);

    EXPECT_EQ(collation.size(), 9);
    EXPECT_TRUE(boost::algorithm::equal(collation.begin(), collation.end(), ces, ces + 9))
        << "from:     " << ce_dumper(cps)
        << "expected: " << ce_dumper(ces)
        << "got:      " << ce_dumper(collation);
}

TEST(collation, non_ignorable_111_024)
{
    // 1D37 003F;	
    // (·¥∑) MODIFIER LETTER CAPITAL K	[1DCB 0267 | 0020 0020 | 001D 0002 |]

    uint32_t cps[2] = { 0x1D37, 0x003F };
    uint32_t const ces[9] = { 0x1DCB, 0x0267, 0x0000, 0x0020, 0x0020, 0x0000, 0x001D, 0x0002, 0x0000 };

    auto collation = collate_for_tests(
        cps, cps + 2, boost::text::variable_weighting::non_ignorable);

    EXPECT_EQ(collation.size(), 9);
    EXPECT_TRUE(boost::algorithm::equal(collation.begin(), collation.end(), ces, ces + 9))
        << "from:     " << ce_dumper(cps)
        << "expected: " << ce_dumper(ces)
        << "got:      " << ce_dumper(collation);
}

TEST(collation, non_ignorable_111_025)
{
    // 1F13A 003F;	
    // (üÑ∫) SQUARED LATIN CAPITAL LETTER K	[1DCB 0267 | 0020 0020 | 001D 0002 |]

    uint32_t cps[2] = { 0x1F13A, 0x003F };
    uint32_t const ces[9] = { 0x1DCB, 0x0267, 0x0000, 0x0020, 0x0020, 0x0000, 0x001D, 0x0002, 0x0000 };

    auto collation = collate_for_tests(
        cps, cps + 2, boost::text::variable_weighting::non_ignorable);

    EXPECT_EQ(collation.size(), 9);
    EXPECT_TRUE(boost::algorithm::equal(collation.begin(), collation.end(), ces, ces + 9))
        << "from:     " << ce_dumper(cps)
        << "expected: " << ce_dumper(ces)
        << "got:      " << ce_dumper(collation);
}

TEST(collation, non_ignorable_111_026)
{
    // 1F17A 003F;	
    // (üÖ∫) NEGATIVE SQUARED LATIN CAPITAL LETTER K	[1DCB 0267 | 0020 0020 | 001D 0002 |]

    uint32_t cps[2] = { 0x1F17A, 0x003F };
    uint32_t const ces[9] = { 0x1DCB, 0x0267, 0x0000, 0x0020, 0x0020, 0x0000, 0x001D, 0x0002, 0x0000 };

    auto collation = collate_for_tests(
        cps, cps + 2, boost::text::variable_weighting::non_ignorable);

    EXPECT_EQ(collation.size(), 9);
    EXPECT_TRUE(boost::algorithm::equal(collation.begin(), collation.end(), ces, ces + 9))
        << "from:     " << ce_dumper(cps)
        << "expected: " << ce_dumper(ces)
        << "got:      " << ce_dumper(collation);
}

TEST(collation, non_ignorable_111_027)
{
    // 1E31 003F;	
    // (·∏±) LATIN SMALL LETTER K WITH ACUTE	[1DCB 0267 | 0020 0024 0020 | 0002 0002 0002 |]

    uint32_t cps[2] = { 0x1E31, 0x003F };
    uint32_t const ces[11] = { 0x1DCB, 0x0267, 0x0000, 0x0020, 0x0024, 0x0020, 0x0000, 0x0002, 0x0002, 0x0002, 0x0000 };

    auto collation = collate_for_tests(
        cps, cps + 2, boost::text::variable_weighting::non_ignorable);

    EXPECT_EQ(collation.size(), 11);
    EXPECT_TRUE(boost::algorithm::equal(collation.begin(), collation.end(), ces, ces + 11))
        << "from:     " << ce_dumper(cps)
        << "expected: " << ce_dumper(ces)
        << "got:      " << ce_dumper(collation);
}

TEST(collation, non_ignorable_111_028)
{
    // 1E30 003F;	
    // (·∏∞) LATIN CAPITAL LETTER K WITH ACUTE	[1DCB 0267 | 0020 0024 0020 | 0008 0002 0002 |]

    uint32_t cps[2] = { 0x1E30, 0x003F };
    uint32_t const ces[11] = { 0x1DCB, 0x0267, 0x0000, 0x0020, 0x0024, 0x0020, 0x0000, 0x0008, 0x0002, 0x0002, 0x0000 };

    auto collation = collate_for_tests(
        cps, cps + 2, boost::text::variable_weighting::non_ignorable);

    EXPECT_EQ(collation.size(), 11);
    EXPECT_TRUE(boost::algorithm::equal(collation.begin(), collation.end(), ces, ces + 11))
        << "from:     " << ce_dumper(cps)
        << "expected: " << ce_dumper(ces)
        << "got:      " << ce_dumper(collation);
}

TEST(collation, non_ignorable_111_029)
{
    // 01E9 003F;	
    // («©) LATIN SMALL LETTER K WITH CARON	[1DCB 0267 | 0020 0028 0020 | 0002 0002 0002 |]

    uint32_t cps[2] = { 0x01E9, 0x003F };
    uint32_t const ces[11] = { 0x1DCB, 0x0267, 0x0000, 0x0020, 0x0028, 0x0020, 0x0000, 0x0002, 0x0002, 0x0002, 0x0000 };

    auto collation = collate_for_tests(
        cps, cps + 2, boost::text::variable_weighting::non_ignorable);

    EXPECT_EQ(collation.size(), 11);
    EXPECT_TRUE(boost::algorithm::equal(collation.begin(), collation.end(), ces, ces + 11))
        << "from:     " << ce_dumper(cps)
        << "expected: " << ce_dumper(ces)
        << "got:      " << ce_dumper(collation);
}

TEST(collation, non_ignorable_111_030)
{
    // 01E8 003F;	
    // («®) LATIN CAPITAL LETTER K WITH CARON	[1DCB 0267 | 0020 0028 0020 | 0008 0002 0002 |]

    uint32_t cps[2] = { 0x01E8, 0x003F };
    uint32_t const ces[11] = { 0x1DCB, 0x0267, 0x0000, 0x0020, 0x0028, 0x0020, 0x0000, 0x0008, 0x0002, 0x0002, 0x0000 };

    auto collation = collate_for_tests(
        cps, cps + 2, boost::text::variable_weighting::non_ignorable);

    EXPECT_EQ(collation.size(), 11);
    EXPECT_TRUE(boost::algorithm::equal(collation.begin(), collation.end(), ces, ces + 11))
        << "from:     " << ce_dumper(cps)
        << "expected: " << ce_dumper(ces)
        << "got:      " << ce_dumper(collation);
}

TEST(collation, non_ignorable_111_031)
{
    // 0137 003F;	
    // (ƒ∑) LATIN SMALL LETTER K WITH CEDILLA	[1DCB 0267 | 0020 0030 0020 | 0002 0002 0002 |]

    uint32_t cps[2] = { 0x0137, 0x003F };
    uint32_t const ces[11] = { 0x1DCB, 0x0267, 0x0000, 0x0020, 0x0030, 0x0020, 0x0000, 0x0002, 0x0002, 0x0002, 0x0000 };

    auto collation = collate_for_tests(
        cps, cps + 2, boost::text::variable_weighting::non_ignorable);

    EXPECT_EQ(collation.size(), 11);
    EXPECT_TRUE(boost::algorithm::equal(collation.begin(), collation.end(), ces, ces + 11))
        << "from:     " << ce_dumper(cps)
        << "expected: " << ce_dumper(ces)
        << "got:      " << ce_dumper(collation);
}

TEST(collation, non_ignorable_111_032)
{
    // 0136 003F;	
    // (ƒ∂) LATIN CAPITAL LETTER K WITH CEDILLA	[1DCB 0267 | 0020 0030 0020 | 0008 0002 0002 |]

    uint32_t cps[2] = { 0x0136, 0x003F };
    uint32_t const ces[11] = { 0x1DCB, 0x0267, 0x0000, 0x0020, 0x0030, 0x0020, 0x0000, 0x0008, 0x0002, 0x0002, 0x0000 };

    auto collation = collate_for_tests(
        cps, cps + 2, boost::text::variable_weighting::non_ignorable);

    EXPECT_EQ(collation.size(), 11);
    EXPECT_TRUE(boost::algorithm::equal(collation.begin(), collation.end(), ces, ces + 11))
        << "from:     " << ce_dumper(cps)
        << "expected: " << ce_dumper(ces)
        << "got:      " << ce_dumper(collation);
}

TEST(collation, non_ignorable_111_033)
{
    // A7A3 003F;	
    // (Íû£) LATIN SMALL LETTER K WITH OBLIQUE STROKE	[1DCB 0267 | 0020 0035 0020 | 0004 0004 0002 |]

    uint32_t cps[2] = { 0xA7A3, 0x003F };
    uint32_t const ces[11] = { 0x1DCB, 0x0267, 0x0000, 0x0020, 0x0035, 0x0020, 0x0000, 0x0004, 0x0004, 0x0002, 0x0000 };

    auto collation = collate_for_tests(
        cps, cps + 2, boost::text::variable_weighting::non_ignorable);

    EXPECT_EQ(collation.size(), 11);
    EXPECT_TRUE(boost::algorithm::equal(collation.begin(), collation.end(), ces, ces + 11))
        << "from:     " << ce_dumper(cps)
        << "expected: " << ce_dumper(ces)
        << "got:      " << ce_dumper(collation);
}

TEST(collation, non_ignorable_111_034)
{
    // A7A2 003F;	
    // (Íû¢) LATIN CAPITAL LETTER K WITH OBLIQUE STROKE	[1DCB 0267 | 0020 0035 0020 | 000A 0004 0002 |]

    uint32_t cps[2] = { 0xA7A2, 0x003F };
    uint32_t const ces[11] = { 0x1DCB, 0x0267, 0x0000, 0x0020, 0x0035, 0x0020, 0x0000, 0x000A, 0x0004, 0x0002, 0x0000 };

    auto collation = collate_for_tests(
        cps, cps + 2, boost::text::variable_weighting::non_ignorable);

    EXPECT_EQ(collation.size(), 11);
    EXPECT_TRUE(boost::algorithm::equal(collation.begin(), collation.end(), ces, ces + 11))
        << "from:     " << ce_dumper(cps)
        << "expected: " << ce_dumper(ces)
        << "got:      " << ce_dumper(collation);
}

TEST(collation, non_ignorable_111_035)
{
    // 1E33 003F;	
    // (·∏≥) LATIN SMALL LETTER K WITH DOT BELOW	[1DCB 0267 | 0020 0042 0020 | 0002 0002 0002 |]

    uint32_t cps[2] = { 0x1E33, 0x003F };
    uint32_t const ces[11] = { 0x1DCB, 0x0267, 0x0000, 0x0020, 0x0042, 0x0020, 0x0000, 0x0002, 0x0002, 0x0002, 0x0000 };

    auto collation = collate_for_tests(
        cps, cps + 2, boost::text::variable_weighting::non_ignorable);

    EXPECT_EQ(collation.size(), 11);
    EXPECT_TRUE(boost::algorithm::equal(collation.begin(), collation.end(), ces, ces + 11))
        << "from:     " << ce_dumper(cps)
        << "expected: " << ce_dumper(ces)
        << "got:      " << ce_dumper(collation);
}

TEST(collation, non_ignorable_111_036)
{
    // 1E32 003F;	
    // (·∏≤) LATIN CAPITAL LETTER K WITH DOT BELOW	[1DCB 0267 | 0020 0042 0020 | 0008 0002 0002 |]

    uint32_t cps[2] = { 0x1E32, 0x003F };
    uint32_t const ces[11] = { 0x1DCB, 0x0267, 0x0000, 0x0020, 0x0042, 0x0020, 0x0000, 0x0008, 0x0002, 0x0002, 0x0000 };

    auto collation = collate_for_tests(
        cps, cps + 2, boost::text::variable_weighting::non_ignorable);

    EXPECT_EQ(collation.size(), 11);
    EXPECT_TRUE(boost::algorithm::equal(collation.begin(), collation.end(), ces, ces + 11))
        << "from:     " << ce_dumper(cps)
        << "expected: " << ce_dumper(ces)
        << "got:      " << ce_dumper(collation);
}

TEST(collation, non_ignorable_111_037)
{
    // 1E35 003F;	
    // (·∏µ) LATIN SMALL LETTER K WITH LINE BELOW	[1DCB 0267 | 0020 0049 0020 | 0002 0002 0002 |]

    uint32_t cps[2] = { 0x1E35, 0x003F };
    uint32_t const ces[11] = { 0x1DCB, 0x0267, 0x0000, 0x0020, 0x0049, 0x0020, 0x0000, 0x0002, 0x0002, 0x0002, 0x0000 };

    auto collation = collate_for_tests(
        cps, cps + 2, boost::text::variable_weighting::non_ignorable);

    EXPECT_EQ(collation.size(), 11);
    EXPECT_TRUE(boost::algorithm::equal(collation.begin(), collation.end(), ces, ces + 11))
        << "from:     " << ce_dumper(cps)
        << "expected: " << ce_dumper(ces)
        << "got:      " << ce_dumper(collation);
}

TEST(collation, non_ignorable_111_038)
{
    // 1E34 003F;	
    // (·∏¥) LATIN CAPITAL LETTER K WITH LINE BELOW	[1DCB 0267 | 0020 0049 0020 | 0008 0002 0002 |]

    uint32_t cps[2] = { 0x1E34, 0x003F };
    uint32_t const ces[11] = { 0x1DCB, 0x0267, 0x0000, 0x0020, 0x0049, 0x0020, 0x0000, 0x0008, 0x0002, 0x0002, 0x0000 };

    auto collation = collate_for_tests(
        cps, cps + 2, boost::text::variable_weighting::non_ignorable);

    EXPECT_EQ(collation.size(), 11);
    EXPECT_TRUE(boost::algorithm::equal(collation.begin(), collation.end(), ces, ces + 11))
        << "from:     " << ce_dumper(cps)
        << "expected: " << ce_dumper(ces)
        << "got:      " << ce_dumper(collation);
}

TEST(collation, non_ignorable_111_039)
{
    // 006B 0061;	
    // (k) LATIN SMALL LETTER K	[1DCB 1CAD | 0020 0020 | 0002 0002 |]

    uint32_t cps[2] = { 0x006B, 0x0061 };
    uint32_t const ces[9] = { 0x1DCB, 0x1CAD, 0x0000, 0x0020, 0x0020, 0x0000, 0x0002, 0x0002, 0x0000 };

    auto collation = collate_for_tests(
        cps, cps + 2, boost::text::variable_weighting::non_ignorable);

    EXPECT_EQ(collation.size(), 9);
    EXPECT_TRUE(boost::algorithm::equal(collation.begin(), collation.end(), ces, ces + 9))
        << "from:     " << ce_dumper(cps)
        << "expected: " << ce_dumper(ces)
        << "got:      " << ce_dumper(collation);
}

TEST(collation, non_ignorable_111_040)
{
    // 006B 0041;	
    // (k) LATIN SMALL LETTER K	[1DCB 1CAD | 0020 0020 | 0002 0008 |]

    uint32_t cps[2] = { 0x006B, 0x0041 };
    uint32_t const ces[9] = { 0x1DCB, 0x1CAD, 0x0000, 0x0020, 0x0020, 0x0000, 0x0002, 0x0008, 0x0000 };

    auto collation = collate_for_tests(
        cps, cps + 2, boost::text::variable_weighting::non_ignorable);

    EXPECT_EQ(collation.size(), 9);
    EXPECT_TRUE(boost::algorithm::equal(collation.begin(), collation.end(), ces, ces + 9))
        << "from:     " << ce_dumper(cps)
        << "expected: " << ce_dumper(ces)
        << "got:      " << ce_dumper(collation);
}

TEST(collation, non_ignorable_111_041)
{
    // FF4B 0061;	
    // (ÔΩã) FULLWIDTH LATIN SMALL LETTER K	[1DCB 1CAD | 0020 0020 | 0003 0002 |]

    uint32_t cps[2] = { 0xFF4B, 0x0061 };
    uint32_t const ces[9] = { 0x1DCB, 0x1CAD, 0x0000, 0x0020, 0x0020, 0x0000, 0x0003, 0x0002, 0x0000 };

    auto collation = collate_for_tests(
        cps, cps + 2, boost::text::variable_weighting::non_ignorable);

    EXPECT_EQ(collation.size(), 9);
    EXPECT_TRUE(boost::algorithm::equal(collation.begin(), collation.end(), ces, ces + 9))
        << "from:     " << ce_dumper(cps)
        << "expected: " << ce_dumper(ces)
        << "got:      " << ce_dumper(collation);
}

TEST(collation, non_ignorable_111_042)
{
    // FF4B 0041;	
    // (ÔΩã) FULLWIDTH LATIN SMALL LETTER K	[1DCB 1CAD | 0020 0020 | 0003 0008 |]

    uint32_t cps[2] = { 0xFF4B, 0x0041 };
    uint32_t const ces[9] = { 0x1DCB, 0x1CAD, 0x0000, 0x0020, 0x0020, 0x0000, 0x0003, 0x0008, 0x0000 };

    auto collation = collate_for_tests(
        cps, cps + 2, boost::text::variable_weighting::non_ignorable);

    EXPECT_EQ(collation.size(), 9);
    EXPECT_TRUE(boost::algorithm::equal(collation.begin(), collation.end(), ces, ces + 9))
        << "from:     " << ce_dumper(cps)
        << "expected: " << ce_dumper(ces)
        << "got:      " << ce_dumper(collation);
}

TEST(collation, non_ignorable_111_043)
{
    // 1DDC 0061;	
    // (·∑ú) COMBINING LATIN SMALL LETTER K	[1DCB 1CAD | 0020 0020 | 0004 0002 |]

    uint32_t cps[2] = { 0x1DDC, 0x0061 };
    uint32_t const ces[9] = { 0x1DCB, 0x1CAD, 0x0000, 0x0020, 0x0020, 0x0000, 0x0004, 0x0002, 0x0000 };

    auto collation = collate_for_tests(
        cps, cps + 2, boost::text::variable_weighting::non_ignorable);

    EXPECT_EQ(collation.size(), 9);
    EXPECT_TRUE(boost::algorithm::equal(collation.begin(), collation.end(), ces, ces + 9))
        << "from:     " << ce_dumper(cps)
        << "expected: " << ce_dumper(ces)
        << "got:      " << ce_dumper(collation);
}

TEST(collation, non_ignorable_111_044)
{
    // 1DDC 0041;	
    // (·∑ú) COMBINING LATIN SMALL LETTER K	[1DCB 1CAD | 0020 0020 | 0004 0008 |]

    uint32_t cps[2] = { 0x1DDC, 0x0041 };
    uint32_t const ces[9] = { 0x1DCB, 0x1CAD, 0x0000, 0x0020, 0x0020, 0x0000, 0x0004, 0x0008, 0x0000 };

    auto collation = collate_for_tests(
        cps, cps + 2, boost::text::variable_weighting::non_ignorable);

    EXPECT_EQ(collation.size(), 9);
    EXPECT_TRUE(boost::algorithm::equal(collation.begin(), collation.end(), ces, ces + 9))
        << "from:     " << ce_dumper(cps)
        << "expected: " << ce_dumper(ces)
        << "got:      " << ce_dumper(collation);
}

TEST(collation, non_ignorable_111_045)
{
    // 1D424 0061;	
    // (ùê§) MATHEMATICAL BOLD SMALL K	[1DCB 1CAD | 0020 0020 | 0005 0002 |]

    uint32_t cps[2] = { 0x1D424, 0x0061 };
    uint32_t const ces[9] = { 0x1DCB, 0x1CAD, 0x0000, 0x0020, 0x0020, 0x0000, 0x0005, 0x0002, 0x0000 };

    auto collation = collate_for_tests(
        cps, cps + 2, boost::text::variable_weighting::non_ignorable);

    EXPECT_EQ(collation.size(), 9);
    EXPECT_TRUE(boost::algorithm::equal(collation.begin(), collation.end(), ces, ces + 9))
        << "from:     " << ce_dumper(cps)
        << "expected: " << ce_dumper(ces)
        << "got:      " << ce_dumper(collation);
}

TEST(collation, non_ignorable_111_046)
{
    // 1D458 0061;	
    // (ùëò) MATHEMATICAL ITALIC SMALL K	[1DCB 1CAD | 0020 0020 | 0005 0002 |]

    uint32_t cps[2] = { 0x1D458, 0x0061 };
    uint32_t const ces[9] = { 0x1DCB, 0x1CAD, 0x0000, 0x0020, 0x0020, 0x0000, 0x0005, 0x0002, 0x0000 };

    auto collation = collate_for_tests(
        cps, cps + 2, boost::text::variable_weighting::non_ignorable);

    EXPECT_EQ(collation.size(), 9);
    EXPECT_TRUE(boost::algorithm::equal(collation.begin(), collation.end(), ces, ces + 9))
        << "from:     " << ce_dumper(cps)
        << "expected: " << ce_dumper(ces)
        << "got:      " << ce_dumper(collation);
}

TEST(collation, non_ignorable_111_047)
{
    // 1D48C 0061;	
    // (ùíå) MATHEMATICAL BOLD ITALIC SMALL K	[1DCB 1CAD | 0020 0020 | 0005 0002 |]

    uint32_t cps[2] = { 0x1D48C, 0x0061 };
    uint32_t const ces[9] = { 0x1DCB, 0x1CAD, 0x0000, 0x0020, 0x0020, 0x0000, 0x0005, 0x0002, 0x0000 };

    auto collation = collate_for_tests(
        cps, cps + 2, boost::text::variable_weighting::non_ignorable);

    EXPECT_EQ(collation.size(), 9);
    EXPECT_TRUE(boost::algorithm::equal(collation.begin(), collation.end(), ces, ces + 9))
        << "from:     " << ce_dumper(cps)
        << "expected: " << ce_dumper(ces)
        << "got:      " << ce_dumper(collation);
}

TEST(collation, non_ignorable_111_048)
{
    // 1D4C0 0061;	
    // (ùìÄ) MATHEMATICAL SCRIPT SMALL K	[1DCB 1CAD | 0020 0020 | 0005 0002 |]

    uint32_t cps[2] = { 0x1D4C0, 0x0061 };
    uint32_t const ces[9] = { 0x1DCB, 0x1CAD, 0x0000, 0x0020, 0x0020, 0x0000, 0x0005, 0x0002, 0x0000 };

    auto collation = collate_for_tests(
        cps, cps + 2, boost::text::variable_weighting::non_ignorable);

    EXPECT_EQ(collation.size(), 9);
    EXPECT_TRUE(boost::algorithm::equal(collation.begin(), collation.end(), ces, ces + 9))
        << "from:     " << ce_dumper(cps)
        << "expected: " << ce_dumper(ces)
        << "got:      " << ce_dumper(collation);
}

TEST(collation, non_ignorable_111_049)
{
    // 1D4F4 0061;	
    // (ùì¥) MATHEMATICAL BOLD SCRIPT SMALL K	[1DCB 1CAD | 0020 0020 | 0005 0002 |]

    uint32_t cps[2] = { 0x1D4F4, 0x0061 };
    uint32_t const ces[9] = { 0x1DCB, 0x1CAD, 0x0000, 0x0020, 0x0020, 0x0000, 0x0005, 0x0002, 0x0000 };

    auto collation = collate_for_tests(
        cps, cps + 2, boost::text::variable_weighting::non_ignorable);

    EXPECT_EQ(collation.size(), 9);
    EXPECT_TRUE(boost::algorithm::equal(collation.begin(), collation.end(), ces, ces + 9))
        << "from:     " << ce_dumper(cps)
        << "expected: " << ce_dumper(ces)
        << "got:      " << ce_dumper(collation);
}

TEST(collation, non_ignorable_111_050)
{
    // 1D528 0061;	
    // (ùî®) MATHEMATICAL FRAKTUR SMALL K	[1DCB 1CAD | 0020 0020 | 0005 0002 |]

    uint32_t cps[2] = { 0x1D528, 0x0061 };
    uint32_t const ces[9] = { 0x1DCB, 0x1CAD, 0x0000, 0x0020, 0x0020, 0x0000, 0x0005, 0x0002, 0x0000 };

    auto collation = collate_for_tests(
        cps, cps + 2, boost::text::variable_weighting::non_ignorable);

    EXPECT_EQ(collation.size(), 9);
    EXPECT_TRUE(boost::algorithm::equal(collation.begin(), collation.end(), ces, ces + 9))
        << "from:     " << ce_dumper(cps)
        << "expected: " << ce_dumper(ces)
        << "got:      " << ce_dumper(collation);
}

TEST(collation, non_ignorable_111_051)
{
    // 1D55C 0061;	
    // (ùïú) MATHEMATICAL DOUBLE-STRUCK SMALL K	[1DCB 1CAD | 0020 0020 | 0005 0002 |]

    uint32_t cps[2] = { 0x1D55C, 0x0061 };
    uint32_t const ces[9] = { 0x1DCB, 0x1CAD, 0x0000, 0x0020, 0x0020, 0x0000, 0x0005, 0x0002, 0x0000 };

    auto collation = collate_for_tests(
        cps, cps + 2, boost::text::variable_weighting::non_ignorable);

    EXPECT_EQ(collation.size(), 9);
    EXPECT_TRUE(boost::algorithm::equal(collation.begin(), collation.end(), ces, ces + 9))
        << "from:     " << ce_dumper(cps)
        << "expected: " << ce_dumper(ces)
        << "got:      " << ce_dumper(collation);
}

TEST(collation, non_ignorable_111_052)
{
    // 1D590 0061;	
    // (ùñê) MATHEMATICAL BOLD FRAKTUR SMALL K	[1DCB 1CAD | 0020 0020 | 0005 0002 |]

    uint32_t cps[2] = { 0x1D590, 0x0061 };
    uint32_t const ces[9] = { 0x1DCB, 0x1CAD, 0x0000, 0x0020, 0x0020, 0x0000, 0x0005, 0x0002, 0x0000 };

    auto collation = collate_for_tests(
        cps, cps + 2, boost::text::variable_weighting::non_ignorable);

    EXPECT_EQ(collation.size(), 9);
    EXPECT_TRUE(boost::algorithm::equal(collation.begin(), collation.end(), ces, ces + 9))
        << "from:     " << ce_dumper(cps)
        << "expected: " << ce_dumper(ces)
        << "got:      " << ce_dumper(collation);
}

TEST(collation, non_ignorable_111_053)
{
    // 1D5C4 0061;	
    // (ùóÑ) MATHEMATICAL SANS-SERIF SMALL K	[1DCB 1CAD | 0020 0020 | 0005 0002 |]

    uint32_t cps[2] = { 0x1D5C4, 0x0061 };
    uint32_t const ces[9] = { 0x1DCB, 0x1CAD, 0x0000, 0x0020, 0x0020, 0x0000, 0x0005, 0x0002, 0x0000 };

    auto collation = collate_for_tests(
        cps, cps + 2, boost::text::variable_weighting::non_ignorable);

    EXPECT_EQ(collation.size(), 9);
    EXPECT_TRUE(boost::algorithm::equal(collation.begin(), collation.end(), ces, ces + 9))
        << "from:     " << ce_dumper(cps)
        << "expected: " << ce_dumper(ces)
        << "got:      " << ce_dumper(collation);
}

TEST(collation, non_ignorable_111_054)
{
    // 1D5F8 0061;	
    // (ùó∏) MATHEMATICAL SANS-SERIF BOLD SMALL K	[1DCB 1CAD | 0020 0020 | 0005 0002 |]

    uint32_t cps[2] = { 0x1D5F8, 0x0061 };
    uint32_t const ces[9] = { 0x1DCB, 0x1CAD, 0x0000, 0x0020, 0x0020, 0x0000, 0x0005, 0x0002, 0x0000 };

    auto collation = collate_for_tests(
        cps, cps + 2, boost::text::variable_weighting::non_ignorable);

    EXPECT_EQ(collation.size(), 9);
    EXPECT_TRUE(boost::algorithm::equal(collation.begin(), collation.end(), ces, ces + 9))
        << "from:     " << ce_dumper(cps)
        << "expected: " << ce_dumper(ces)
        << "got:      " << ce_dumper(collation);
}

TEST(collation, non_ignorable_111_055)
{
    // 1D62C 0061;	
    // (ùò¨) MATHEMATICAL SANS-SERIF ITALIC SMALL K	[1DCB 1CAD | 0020 0020 | 0005 0002 |]

    uint32_t cps[2] = { 0x1D62C, 0x0061 };
    uint32_t const ces[9] = { 0x1DCB, 0x1CAD, 0x0000, 0x0020, 0x0020, 0x0000, 0x0005, 0x0002, 0x0000 };

    auto collation = collate_for_tests(
        cps, cps + 2, boost::text::variable_weighting::non_ignorable);

    EXPECT_EQ(collation.size(), 9);
    EXPECT_TRUE(boost::algorithm::equal(collation.begin(), collation.end(), ces, ces + 9))
        << "from:     " << ce_dumper(cps)
        << "expected: " << ce_dumper(ces)
        << "got:      " << ce_dumper(collation);
}

TEST(collation, non_ignorable_111_056)
{
    // 1D660 0061;	
    // (ùô†) MATHEMATICAL SANS-SERIF BOLD ITALIC SMALL K	[1DCB 1CAD | 0020 0020 | 0005 0002 |]

    uint32_t cps[2] = { 0x1D660, 0x0061 };
    uint32_t const ces[9] = { 0x1DCB, 0x1CAD, 0x0000, 0x0020, 0x0020, 0x0000, 0x0005, 0x0002, 0x0000 };

    auto collation = collate_for_tests(
        cps, cps + 2, boost::text::variable_weighting::non_ignorable);

    EXPECT_EQ(collation.size(), 9);
    EXPECT_TRUE(boost::algorithm::equal(collation.begin(), collation.end(), ces, ces + 9))
        << "from:     " << ce_dumper(cps)
        << "expected: " << ce_dumper(ces)
        << "got:      " << ce_dumper(collation);
}

TEST(collation, non_ignorable_111_057)
{
    // 1D694 0061;	
    // (ùöî) MATHEMATICAL MONOSPACE SMALL K	[1DCB 1CAD | 0020 0020 | 0005 0002 |]

    uint32_t cps[2] = { 0x1D694, 0x0061 };
    uint32_t const ces[9] = { 0x1DCB, 0x1CAD, 0x0000, 0x0020, 0x0020, 0x0000, 0x0005, 0x0002, 0x0000 };

    auto collation = collate_for_tests(
        cps, cps + 2, boost::text::variable_weighting::non_ignorable);

    EXPECT_EQ(collation.size(), 9);
    EXPECT_TRUE(boost::algorithm::equal(collation.begin(), collation.end(), ces, ces + 9))
        << "from:     " << ce_dumper(cps)
        << "expected: " << ce_dumper(ces)
        << "got:      " << ce_dumper(collation);
}

TEST(collation, non_ignorable_111_058)
{
    // 1D424 0041;	
    // (ùê§) MATHEMATICAL BOLD SMALL K	[1DCB 1CAD | 0020 0020 | 0005 0008 |]

    uint32_t cps[2] = { 0x1D424, 0x0041 };
    uint32_t const ces[9] = { 0x1DCB, 0x1CAD, 0x0000, 0x0020, 0x0020, 0x0000, 0x0005, 0x0008, 0x0000 };

    auto collation = collate_for_tests(
        cps, cps + 2, boost::text::variable_weighting::non_ignorable);

    EXPECT_EQ(collation.size(), 9);
    EXPECT_TRUE(boost::algorithm::equal(collation.begin(), collation.end(), ces, ces + 9))
        << "from:     " << ce_dumper(cps)
        << "expected: " << ce_dumper(ces)
        << "got:      " << ce_dumper(collation);
}

TEST(collation, non_ignorable_111_059)
{
    // 1D458 0041;	
    // (ùëò) MATHEMATICAL ITALIC SMALL K	[1DCB 1CAD | 0020 0020 | 0005 0008 |]

    uint32_t cps[2] = { 0x1D458, 0x0041 };
    uint32_t const ces[9] = { 0x1DCB, 0x1CAD, 0x0000, 0x0020, 0x0020, 0x0000, 0x0005, 0x0008, 0x0000 };

    auto collation = collate_for_tests(
        cps, cps + 2, boost::text::variable_weighting::non_ignorable);

    EXPECT_EQ(collation.size(), 9);
    EXPECT_TRUE(boost::algorithm::equal(collation.begin(), collation.end(), ces, ces + 9))
        << "from:     " << ce_dumper(cps)
        << "expected: " << ce_dumper(ces)
        << "got:      " << ce_dumper(collation);
}

TEST(collation, non_ignorable_111_060)
{
    // 1D48C 0041;	
    // (ùíå) MATHEMATICAL BOLD ITALIC SMALL K	[1DCB 1CAD | 0020 0020 | 0005 0008 |]

    uint32_t cps[2] = { 0x1D48C, 0x0041 };
    uint32_t const ces[9] = { 0x1DCB, 0x1CAD, 0x0000, 0x0020, 0x0020, 0x0000, 0x0005, 0x0008, 0x0000 };

    auto collation = collate_for_tests(
        cps, cps + 2, boost::text::variable_weighting::non_ignorable);

    EXPECT_EQ(collation.size(), 9);
    EXPECT_TRUE(boost::algorithm::equal(collation.begin(), collation.end(), ces, ces + 9))
        << "from:     " << ce_dumper(cps)
        << "expected: " << ce_dumper(ces)
        << "got:      " << ce_dumper(collation);
}

TEST(collation, non_ignorable_111_061)
{
    // 1D4C0 0041;	
    // (ùìÄ) MATHEMATICAL SCRIPT SMALL K	[1DCB 1CAD | 0020 0020 | 0005 0008 |]

    uint32_t cps[2] = { 0x1D4C0, 0x0041 };
    uint32_t const ces[9] = { 0x1DCB, 0x1CAD, 0x0000, 0x0020, 0x0020, 0x0000, 0x0005, 0x0008, 0x0000 };

    auto collation = collate_for_tests(
        cps, cps + 2, boost::text::variable_weighting::non_ignorable);

    EXPECT_EQ(collation.size(), 9);
    EXPECT_TRUE(boost::algorithm::equal(collation.begin(), collation.end(), ces, ces + 9))
        << "from:     " << ce_dumper(cps)
        << "expected: " << ce_dumper(ces)
        << "got:      " << ce_dumper(collation);
}

TEST(collation, non_ignorable_111_062)
{
    // 1D4F4 0041;	
    // (ùì¥) MATHEMATICAL BOLD SCRIPT SMALL K	[1DCB 1CAD | 0020 0020 | 0005 0008 |]

    uint32_t cps[2] = { 0x1D4F4, 0x0041 };
    uint32_t const ces[9] = { 0x1DCB, 0x1CAD, 0x0000, 0x0020, 0x0020, 0x0000, 0x0005, 0x0008, 0x0000 };

    auto collation = collate_for_tests(
        cps, cps + 2, boost::text::variable_weighting::non_ignorable);

    EXPECT_EQ(collation.size(), 9);
    EXPECT_TRUE(boost::algorithm::equal(collation.begin(), collation.end(), ces, ces + 9))
        << "from:     " << ce_dumper(cps)
        << "expected: " << ce_dumper(ces)
        << "got:      " << ce_dumper(collation);
}

TEST(collation, non_ignorable_111_063)
{
    // 1D528 0041;	
    // (ùî®) MATHEMATICAL FRAKTUR SMALL K	[1DCB 1CAD | 0020 0020 | 0005 0008 |]

    uint32_t cps[2] = { 0x1D528, 0x0041 };
    uint32_t const ces[9] = { 0x1DCB, 0x1CAD, 0x0000, 0x0020, 0x0020, 0x0000, 0x0005, 0x0008, 0x0000 };

    auto collation = collate_for_tests(
        cps, cps + 2, boost::text::variable_weighting::non_ignorable);

    EXPECT_EQ(collation.size(), 9);
    EXPECT_TRUE(boost::algorithm::equal(collation.begin(), collation.end(), ces, ces + 9))
        << "from:     " << ce_dumper(cps)
        << "expected: " << ce_dumper(ces)
        << "got:      " << ce_dumper(collation);
}

TEST(collation, non_ignorable_111_064)
{
    // 1D55C 0041;	
    // (ùïú) MATHEMATICAL DOUBLE-STRUCK SMALL K	[1DCB 1CAD | 0020 0020 | 0005 0008 |]

    uint32_t cps[2] = { 0x1D55C, 0x0041 };
    uint32_t const ces[9] = { 0x1DCB, 0x1CAD, 0x0000, 0x0020, 0x0020, 0x0000, 0x0005, 0x0008, 0x0000 };

    auto collation = collate_for_tests(
        cps, cps + 2, boost::text::variable_weighting::non_ignorable);

    EXPECT_EQ(collation.size(), 9);
    EXPECT_TRUE(boost::algorithm::equal(collation.begin(), collation.end(), ces, ces + 9))
        << "from:     " << ce_dumper(cps)
        << "expected: " << ce_dumper(ces)
        << "got:      " << ce_dumper(collation);
}

TEST(collation, non_ignorable_111_065)
{
    // 1D590 0041;	
    // (ùñê) MATHEMATICAL BOLD FRAKTUR SMALL K	[1DCB 1CAD | 0020 0020 | 0005 0008 |]

    uint32_t cps[2] = { 0x1D590, 0x0041 };
    uint32_t const ces[9] = { 0x1DCB, 0x1CAD, 0x0000, 0x0020, 0x0020, 0x0000, 0x0005, 0x0008, 0x0000 };

    auto collation = collate_for_tests(
        cps, cps + 2, boost::text::variable_weighting::non_ignorable);

    EXPECT_EQ(collation.size(), 9);
    EXPECT_TRUE(boost::algorithm::equal(collation.begin(), collation.end(), ces, ces + 9))
        << "from:     " << ce_dumper(cps)
        << "expected: " << ce_dumper(ces)
        << "got:      " << ce_dumper(collation);
}

TEST(collation, non_ignorable_111_066)
{
    // 1D5C4 0041;	
    // (ùóÑ) MATHEMATICAL SANS-SERIF SMALL K	[1DCB 1CAD | 0020 0020 | 0005 0008 |]

    uint32_t cps[2] = { 0x1D5C4, 0x0041 };
    uint32_t const ces[9] = { 0x1DCB, 0x1CAD, 0x0000, 0x0020, 0x0020, 0x0000, 0x0005, 0x0008, 0x0000 };

    auto collation = collate_for_tests(
        cps, cps + 2, boost::text::variable_weighting::non_ignorable);

    EXPECT_EQ(collation.size(), 9);
    EXPECT_TRUE(boost::algorithm::equal(collation.begin(), collation.end(), ces, ces + 9))
        << "from:     " << ce_dumper(cps)
        << "expected: " << ce_dumper(ces)
        << "got:      " << ce_dumper(collation);
}

TEST(collation, non_ignorable_111_067)
{
    // 1D5F8 0041;	
    // (ùó∏) MATHEMATICAL SANS-SERIF BOLD SMALL K	[1DCB 1CAD | 0020 0020 | 0005 0008 |]

    uint32_t cps[2] = { 0x1D5F8, 0x0041 };
    uint32_t const ces[9] = { 0x1DCB, 0x1CAD, 0x0000, 0x0020, 0x0020, 0x0000, 0x0005, 0x0008, 0x0000 };

    auto collation = collate_for_tests(
        cps, cps + 2, boost::text::variable_weighting::non_ignorable);

    EXPECT_EQ(collation.size(), 9);
    EXPECT_TRUE(boost::algorithm::equal(collation.begin(), collation.end(), ces, ces + 9))
        << "from:     " << ce_dumper(cps)
        << "expected: " << ce_dumper(ces)
        << "got:      " << ce_dumper(collation);
}

TEST(collation, non_ignorable_111_068)
{
    // 1D62C 0041;	
    // (ùò¨) MATHEMATICAL SANS-SERIF ITALIC SMALL K	[1DCB 1CAD | 0020 0020 | 0005 0008 |]

    uint32_t cps[2] = { 0x1D62C, 0x0041 };
    uint32_t const ces[9] = { 0x1DCB, 0x1CAD, 0x0000, 0x0020, 0x0020, 0x0000, 0x0005, 0x0008, 0x0000 };

    auto collation = collate_for_tests(
        cps, cps + 2, boost::text::variable_weighting::non_ignorable);

    EXPECT_EQ(collation.size(), 9);
    EXPECT_TRUE(boost::algorithm::equal(collation.begin(), collation.end(), ces, ces + 9))
        << "from:     " << ce_dumper(cps)
        << "expected: " << ce_dumper(ces)
        << "got:      " << ce_dumper(collation);
}

TEST(collation, non_ignorable_111_069)
{
    // 1D660 0041;	
    // (ùô†) MATHEMATICAL SANS-SERIF BOLD ITALIC SMALL K	[1DCB 1CAD | 0020 0020 | 0005 0008 |]

    uint32_t cps[2] = { 0x1D660, 0x0041 };
    uint32_t const ces[9] = { 0x1DCB, 0x1CAD, 0x0000, 0x0020, 0x0020, 0x0000, 0x0005, 0x0008, 0x0000 };

    auto collation = collate_for_tests(
        cps, cps + 2, boost::text::variable_weighting::non_ignorable);

    EXPECT_EQ(collation.size(), 9);
    EXPECT_TRUE(boost::algorithm::equal(collation.begin(), collation.end(), ces, ces + 9))
        << "from:     " << ce_dumper(cps)
        << "expected: " << ce_dumper(ces)
        << "got:      " << ce_dumper(collation);
}

TEST(collation, non_ignorable_111_070)
{
    // 1D694 0041;	
    // (ùöî) MATHEMATICAL MONOSPACE SMALL K	[1DCB 1CAD | 0020 0020 | 0005 0008 |]

    uint32_t cps[2] = { 0x1D694, 0x0041 };
    uint32_t const ces[9] = { 0x1DCB, 0x1CAD, 0x0000, 0x0020, 0x0020, 0x0000, 0x0005, 0x0008, 0x0000 };

    auto collation = collate_for_tests(
        cps, cps + 2, boost::text::variable_weighting::non_ignorable);

    EXPECT_EQ(collation.size(), 9);
    EXPECT_TRUE(boost::algorithm::equal(collation.begin(), collation.end(), ces, ces + 9))
        << "from:     " << ce_dumper(cps)
        << "expected: " << ce_dumper(ces)
        << "got:      " << ce_dumper(collation);
}

TEST(collation, non_ignorable_111_071)
{
    // 24DA 0061;	
    // (‚ìö) CIRCLED LATIN SMALL LETTER K	[1DCB 1CAD | 0020 0020 | 0006 0002 |]

    uint32_t cps[2] = { 0x24DA, 0x0061 };
    uint32_t const ces[9] = { 0x1DCB, 0x1CAD, 0x0000, 0x0020, 0x0020, 0x0000, 0x0006, 0x0002, 0x0000 };

    auto collation = collate_for_tests(
        cps, cps + 2, boost::text::variable_weighting::non_ignorable);

    EXPECT_EQ(collation.size(), 9);
    EXPECT_TRUE(boost::algorithm::equal(collation.begin(), collation.end(), ces, ces + 9))
        << "from:     " << ce_dumper(cps)
        << "expected: " << ce_dumper(ces)
        << "got:      " << ce_dumper(collation);
}

TEST(collation, non_ignorable_111_072)
{
    // 24DA 0041;	
    // (‚ìö) CIRCLED LATIN SMALL LETTER K	[1DCB 1CAD | 0020 0020 | 0006 0008 |]

    uint32_t cps[2] = { 0x24DA, 0x0041 };
    uint32_t const ces[9] = { 0x1DCB, 0x1CAD, 0x0000, 0x0020, 0x0020, 0x0000, 0x0006, 0x0008, 0x0000 };

    auto collation = collate_for_tests(
        cps, cps + 2, boost::text::variable_weighting::non_ignorable);

    EXPECT_EQ(collation.size(), 9);
    EXPECT_TRUE(boost::algorithm::equal(collation.begin(), collation.end(), ces, ces + 9))
        << "from:     " << ce_dumper(cps)
        << "expected: " << ce_dumper(ces)
        << "got:      " << ce_dumper(collation);
}

TEST(collation, non_ignorable_111_073)
{
    // 004B 0061;	
    // (K) LATIN CAPITAL LETTER K	[1DCB 1CAD | 0020 0020 | 0008 0002 |]

    uint32_t cps[2] = { 0x004B, 0x0061 };
    uint32_t const ces[9] = { 0x1DCB, 0x1CAD, 0x0000, 0x0020, 0x0020, 0x0000, 0x0008, 0x0002, 0x0000 };

    auto collation = collate_for_tests(
        cps, cps + 2, boost::text::variable_weighting::non_ignorable);

    EXPECT_EQ(collation.size(), 9);
    EXPECT_TRUE(boost::algorithm::equal(collation.begin(), collation.end(), ces, ces + 9))
        << "from:     " << ce_dumper(cps)
        << "expected: " << ce_dumper(ces)
        << "got:      " << ce_dumper(collation);
}

TEST(collation, non_ignorable_111_074)
{
    // 212A 0061;	
    // (K) KELVIN SIGN	[1DCB 1CAD | 0020 0020 | 0008 0002 |]

    uint32_t cps[2] = { 0x212A, 0x0061 };
    uint32_t const ces[9] = { 0x1DCB, 0x1CAD, 0x0000, 0x0020, 0x0020, 0x0000, 0x0008, 0x0002, 0x0000 };

    auto collation = collate_for_tests(
        cps, cps + 2, boost::text::variable_weighting::non_ignorable);

    EXPECT_EQ(collation.size(), 9);
    EXPECT_TRUE(boost::algorithm::equal(collation.begin(), collation.end(), ces, ces + 9))
        << "from:     " << ce_dumper(cps)
        << "expected: " << ce_dumper(ces)
        << "got:      " << ce_dumper(collation);
}

TEST(collation, non_ignorable_111_075)
{
    // 004B 0041;	
    // (K) LATIN CAPITAL LETTER K	[1DCB 1CAD | 0020 0020 | 0008 0008 |]

    uint32_t cps[2] = { 0x004B, 0x0041 };
    uint32_t const ces[9] = { 0x1DCB, 0x1CAD, 0x0000, 0x0020, 0x0020, 0x0000, 0x0008, 0x0008, 0x0000 };

    auto collation = collate_for_tests(
        cps, cps + 2, boost::text::variable_weighting::non_ignorable);

    EXPECT_EQ(collation.size(), 9);
    EXPECT_TRUE(boost::algorithm::equal(collation.begin(), collation.end(), ces, ces + 9))
        << "from:     " << ce_dumper(cps)
        << "expected: " << ce_dumper(ces)
        << "got:      " << ce_dumper(collation);
}

TEST(collation, non_ignorable_111_076)
{
    // 212A 0041;	
    // (K) KELVIN SIGN	[1DCB 1CAD | 0020 0020 | 0008 0008 |]

    uint32_t cps[2] = { 0x212A, 0x0041 };
    uint32_t const ces[9] = { 0x1DCB, 0x1CAD, 0x0000, 0x0020, 0x0020, 0x0000, 0x0008, 0x0008, 0x0000 };

    auto collation = collate_for_tests(
        cps, cps + 2, boost::text::variable_weighting::non_ignorable);

    EXPECT_EQ(collation.size(), 9);
    EXPECT_TRUE(boost::algorithm::equal(collation.begin(), collation.end(), ces, ces + 9))
        << "from:     " << ce_dumper(cps)
        << "expected: " << ce_dumper(ces)
        << "got:      " << ce_dumper(collation);
}

TEST(collation, non_ignorable_111_077)
{
    // FF2B 0061;	
    // (Ôº´) FULLWIDTH LATIN CAPITAL LETTER K	[1DCB 1CAD | 0020 0020 | 0009 0002 |]

    uint32_t cps[2] = { 0xFF2B, 0x0061 };
    uint32_t const ces[9] = { 0x1DCB, 0x1CAD, 0x0000, 0x0020, 0x0020, 0x0000, 0x0009, 0x0002, 0x0000 };

    auto collation = collate_for_tests(
        cps, cps + 2, boost::text::variable_weighting::non_ignorable);

    EXPECT_EQ(collation.size(), 9);
    EXPECT_TRUE(boost::algorithm::equal(collation.begin(), collation.end(), ces, ces + 9))
        << "from:     " << ce_dumper(cps)
        << "expected: " << ce_dumper(ces)
        << "got:      " << ce_dumper(collation);
}

TEST(collation, non_ignorable_111_078)
{
    // FF2B 0041;	
    // (Ôº´) FULLWIDTH LATIN CAPITAL LETTER K	[1DCB 1CAD | 0020 0020 | 0009 0008 |]

    uint32_t cps[2] = { 0xFF2B, 0x0041 };
    uint32_t const ces[9] = { 0x1DCB, 0x1CAD, 0x0000, 0x0020, 0x0020, 0x0000, 0x0009, 0x0008, 0x0000 };

    auto collation = collate_for_tests(
        cps, cps + 2, boost::text::variable_weighting::non_ignorable);

    EXPECT_EQ(collation.size(), 9);
    EXPECT_TRUE(boost::algorithm::equal(collation.begin(), collation.end(), ces, ces + 9))
        << "from:     " << ce_dumper(cps)
        << "expected: " << ce_dumper(ces)
        << "got:      " << ce_dumper(collation);
}

TEST(collation, non_ignorable_111_079)
{
    // 1D40A 0061;	
    // (ùêä) MATHEMATICAL BOLD CAPITAL K	[1DCB 1CAD | 0020 0020 | 000B 0002 |]

    uint32_t cps[2] = { 0x1D40A, 0x0061 };
    uint32_t const ces[9] = { 0x1DCB, 0x1CAD, 0x0000, 0x0020, 0x0020, 0x0000, 0x000B, 0x0002, 0x0000 };

    auto collation = collate_for_tests(
        cps, cps + 2, boost::text::variable_weighting::non_ignorable);

    EXPECT_EQ(collation.size(), 9);
    EXPECT_TRUE(boost::algorithm::equal(collation.begin(), collation.end(), ces, ces + 9))
        << "from:     " << ce_dumper(cps)
        << "expected: " << ce_dumper(ces)
        << "got:      " << ce_dumper(collation);
}

TEST(collation, non_ignorable_111_080)
{
    // 1D43E 0061;	
    // (ùêæ) MATHEMATICAL ITALIC CAPITAL K	[1DCB 1CAD | 0020 0020 | 000B 0002 |]

    uint32_t cps[2] = { 0x1D43E, 0x0061 };
    uint32_t const ces[9] = { 0x1DCB, 0x1CAD, 0x0000, 0x0020, 0x0020, 0x0000, 0x000B, 0x0002, 0x0000 };

    auto collation = collate_for_tests(
        cps, cps + 2, boost::text::variable_weighting::non_ignorable);

    EXPECT_EQ(collation.size(), 9);
    EXPECT_TRUE(boost::algorithm::equal(collation.begin(), collation.end(), ces, ces + 9))
        << "from:     " << ce_dumper(cps)
        << "expected: " << ce_dumper(ces)
        << "got:      " << ce_dumper(collation);
}

TEST(collation, non_ignorable_111_081)
{
    // 1D472 0061;	
    // (ùë≤) MATHEMATICAL BOLD ITALIC CAPITAL K	[1DCB 1CAD | 0020 0020 | 000B 0002 |]

    uint32_t cps[2] = { 0x1D472, 0x0061 };
    uint32_t const ces[9] = { 0x1DCB, 0x1CAD, 0x0000, 0x0020, 0x0020, 0x0000, 0x000B, 0x0002, 0x0000 };

    auto collation = collate_for_tests(
        cps, cps + 2, boost::text::variable_weighting::non_ignorable);

    EXPECT_EQ(collation.size(), 9);
    EXPECT_TRUE(boost::algorithm::equal(collation.begin(), collation.end(), ces, ces + 9))
        << "from:     " << ce_dumper(cps)
        << "expected: " << ce_dumper(ces)
        << "got:      " << ce_dumper(collation);
}

TEST(collation, non_ignorable_111_082)
{
    // 1D4A6 0061;	
    // (ùí¶) MATHEMATICAL SCRIPT CAPITAL K	[1DCB 1CAD | 0020 0020 | 000B 0002 |]

    uint32_t cps[2] = { 0x1D4A6, 0x0061 };
    uint32_t const ces[9] = { 0x1DCB, 0x1CAD, 0x0000, 0x0020, 0x0020, 0x0000, 0x000B, 0x0002, 0x0000 };

    auto collation = collate_for_tests(
        cps, cps + 2, boost::text::variable_weighting::non_ignorable);

    EXPECT_EQ(collation.size(), 9);
    EXPECT_TRUE(boost::algorithm::equal(collation.begin(), collation.end(), ces, ces + 9))
        << "from:     " << ce_dumper(cps)
        << "expected: " << ce_dumper(ces)
        << "got:      " << ce_dumper(collation);
}

TEST(collation, non_ignorable_111_083)
{
    // 1D4DA 0061;	
    // (ùìö) MATHEMATICAL BOLD SCRIPT CAPITAL K	[1DCB 1CAD | 0020 0020 | 000B 0002 |]

    uint32_t cps[2] = { 0x1D4DA, 0x0061 };
    uint32_t const ces[9] = { 0x1DCB, 0x1CAD, 0x0000, 0x0020, 0x0020, 0x0000, 0x000B, 0x0002, 0x0000 };

    auto collation = collate_for_tests(
        cps, cps + 2, boost::text::variable_weighting::non_ignorable);

    EXPECT_EQ(collation.size(), 9);
    EXPECT_TRUE(boost::algorithm::equal(collation.begin(), collation.end(), ces, ces + 9))
        << "from:     " << ce_dumper(cps)
        << "expected: " << ce_dumper(ces)
        << "got:      " << ce_dumper(collation);
}

TEST(collation, non_ignorable_111_084)
{
    // 1D50E 0061;	
    // (ùîé) MATHEMATICAL FRAKTUR CAPITAL K	[1DCB 1CAD | 0020 0020 | 000B 0002 |]

    uint32_t cps[2] = { 0x1D50E, 0x0061 };
    uint32_t const ces[9] = { 0x1DCB, 0x1CAD, 0x0000, 0x0020, 0x0020, 0x0000, 0x000B, 0x0002, 0x0000 };

    auto collation = collate_for_tests(
        cps, cps + 2, boost::text::variable_weighting::non_ignorable);

    EXPECT_EQ(collation.size(), 9);
    EXPECT_TRUE(boost::algorithm::equal(collation.begin(), collation.end(), ces, ces + 9))
        << "from:     " << ce_dumper(cps)
        << "expected: " << ce_dumper(ces)
        << "got:      " << ce_dumper(collation);
}

TEST(collation, non_ignorable_111_085)
{
    // 1D542 0061;	
    // (ùïÇ) MATHEMATICAL DOUBLE-STRUCK CAPITAL K	[1DCB 1CAD | 0020 0020 | 000B 0002 |]

    uint32_t cps[2] = { 0x1D542, 0x0061 };
    uint32_t const ces[9] = { 0x1DCB, 0x1CAD, 0x0000, 0x0020, 0x0020, 0x0000, 0x000B, 0x0002, 0x0000 };

    auto collation = collate_for_tests(
        cps, cps + 2, boost::text::variable_weighting::non_ignorable);

    EXPECT_EQ(collation.size(), 9);
    EXPECT_TRUE(boost::algorithm::equal(collation.begin(), collation.end(), ces, ces + 9))
        << "from:     " << ce_dumper(cps)
        << "expected: " << ce_dumper(ces)
        << "got:      " << ce_dumper(collation);
}

TEST(collation, non_ignorable_111_086)
{
    // 1D576 0061;	
    // (ùï∂) MATHEMATICAL BOLD FRAKTUR CAPITAL K	[1DCB 1CAD | 0020 0020 | 000B 0002 |]

    uint32_t cps[2] = { 0x1D576, 0x0061 };
    uint32_t const ces[9] = { 0x1DCB, 0x1CAD, 0x0000, 0x0020, 0x0020, 0x0000, 0x000B, 0x0002, 0x0000 };

    auto collation = collate_for_tests(
        cps, cps + 2, boost::text::variable_weighting::non_ignorable);

    EXPECT_EQ(collation.size(), 9);
    EXPECT_TRUE(boost::algorithm::equal(collation.begin(), collation.end(), ces, ces + 9))
        << "from:     " << ce_dumper(cps)
        << "expected: " << ce_dumper(ces)
        << "got:      " << ce_dumper(collation);
}

TEST(collation, non_ignorable_111_087)
{
    // 1D5AA 0061;	
    // (ùñ™) MATHEMATICAL SANS-SERIF CAPITAL K	[1DCB 1CAD | 0020 0020 | 000B 0002 |]

    uint32_t cps[2] = { 0x1D5AA, 0x0061 };
    uint32_t const ces[9] = { 0x1DCB, 0x1CAD, 0x0000, 0x0020, 0x0020, 0x0000, 0x000B, 0x0002, 0x0000 };

    auto collation = collate_for_tests(
        cps, cps + 2, boost::text::variable_weighting::non_ignorable);

    EXPECT_EQ(collation.size(), 9);
    EXPECT_TRUE(boost::algorithm::equal(collation.begin(), collation.end(), ces, ces + 9))
        << "from:     " << ce_dumper(cps)
        << "expected: " << ce_dumper(ces)
        << "got:      " << ce_dumper(collation);
}

TEST(collation, non_ignorable_111_088)
{
    // 1D5DE 0061;	
    // (ùóû) MATHEMATICAL SANS-SERIF BOLD CAPITAL K	[1DCB 1CAD | 0020 0020 | 000B 0002 |]

    uint32_t cps[2] = { 0x1D5DE, 0x0061 };
    uint32_t const ces[9] = { 0x1DCB, 0x1CAD, 0x0000, 0x0020, 0x0020, 0x0000, 0x000B, 0x0002, 0x0000 };

    auto collation = collate_for_tests(
        cps, cps + 2, boost::text::variable_weighting::non_ignorable);

    EXPECT_EQ(collation.size(), 9);
    EXPECT_TRUE(boost::algorithm::equal(collation.begin(), collation.end(), ces, ces + 9))
        << "from:     " << ce_dumper(cps)
        << "expected: " << ce_dumper(ces)
        << "got:      " << ce_dumper(collation);
}

TEST(collation, non_ignorable_111_089)
{
    // 1D612 0061;	
    // (ùòí) MATHEMATICAL SANS-SERIF ITALIC CAPITAL K	[1DCB 1CAD | 0020 0020 | 000B 0002 |]

    uint32_t cps[2] = { 0x1D612, 0x0061 };
    uint32_t const ces[9] = { 0x1DCB, 0x1CAD, 0x0000, 0x0020, 0x0020, 0x0000, 0x000B, 0x0002, 0x0000 };

    auto collation = collate_for_tests(
        cps, cps + 2, boost::text::variable_weighting::non_ignorable);

    EXPECT_EQ(collation.size(), 9);
    EXPECT_TRUE(boost::algorithm::equal(collation.begin(), collation.end(), ces, ces + 9))
        << "from:     " << ce_dumper(cps)
        << "expected: " << ce_dumper(ces)
        << "got:      " << ce_dumper(collation);
}

TEST(collation, non_ignorable_111_090)
{
    // 1D646 0061;	
    // (ùôÜ) MATHEMATICAL SANS-SERIF BOLD ITALIC CAPITAL K	[1DCB 1CAD | 0020 0020 | 000B 0002 |]

    uint32_t cps[2] = { 0x1D646, 0x0061 };
    uint32_t const ces[9] = { 0x1DCB, 0x1CAD, 0x0000, 0x0020, 0x0020, 0x0000, 0x000B, 0x0002, 0x0000 };

    auto collation = collate_for_tests(
        cps, cps + 2, boost::text::variable_weighting::non_ignorable);

    EXPECT_EQ(collation.size(), 9);
    EXPECT_TRUE(boost::algorithm::equal(collation.begin(), collation.end(), ces, ces + 9))
        << "from:     " << ce_dumper(cps)
        << "expected: " << ce_dumper(ces)
        << "got:      " << ce_dumper(collation);
}

TEST(collation, non_ignorable_111_091)
{
    // 1D67A 0061;	
    // (ùô∫) MATHEMATICAL MONOSPACE CAPITAL K	[1DCB 1CAD | 0020 0020 | 000B 0002 |]

    uint32_t cps[2] = { 0x1D67A, 0x0061 };
    uint32_t const ces[9] = { 0x1DCB, 0x1CAD, 0x0000, 0x0020, 0x0020, 0x0000, 0x000B, 0x0002, 0x0000 };

    auto collation = collate_for_tests(
        cps, cps + 2, boost::text::variable_weighting::non_ignorable);

    EXPECT_EQ(collation.size(), 9);
    EXPECT_TRUE(boost::algorithm::equal(collation.begin(), collation.end(), ces, ces + 9))
        << "from:     " << ce_dumper(cps)
        << "expected: " << ce_dumper(ces)
        << "got:      " << ce_dumper(collation);
}

TEST(collation, non_ignorable_111_092)
{
    // 1D40A 0041;	
    // (ùêä) MATHEMATICAL BOLD CAPITAL K	[1DCB 1CAD | 0020 0020 | 000B 0008 |]

    uint32_t cps[2] = { 0x1D40A, 0x0041 };
    uint32_t const ces[9] = { 0x1DCB, 0x1CAD, 0x0000, 0x0020, 0x0020, 0x0000, 0x000B, 0x0008, 0x0000 };

    auto collation = collate_for_tests(
        cps, cps + 2, boost::text::variable_weighting::non_ignorable);

    EXPECT_EQ(collation.size(), 9);
    EXPECT_TRUE(boost::algorithm::equal(collation.begin(), collation.end(), ces, ces + 9))
        << "from:     " << ce_dumper(cps)
        << "expected: " << ce_dumper(ces)
        << "got:      " << ce_dumper(collation);
}

TEST(collation, non_ignorable_111_093)
{
    // 1D43E 0041;	
    // (ùêæ) MATHEMATICAL ITALIC CAPITAL K	[1DCB 1CAD | 0020 0020 | 000B 0008 |]

    uint32_t cps[2] = { 0x1D43E, 0x0041 };
    uint32_t const ces[9] = { 0x1DCB, 0x1CAD, 0x0000, 0x0020, 0x0020, 0x0000, 0x000B, 0x0008, 0x0000 };

    auto collation = collate_for_tests(
        cps, cps + 2, boost::text::variable_weighting::non_ignorable);

    EXPECT_EQ(collation.size(), 9);
    EXPECT_TRUE(boost::algorithm::equal(collation.begin(), collation.end(), ces, ces + 9))
        << "from:     " << ce_dumper(cps)
        << "expected: " << ce_dumper(ces)
        << "got:      " << ce_dumper(collation);
}

TEST(collation, non_ignorable_111_094)
{
    // 1D472 0041;	
    // (ùë≤) MATHEMATICAL BOLD ITALIC CAPITAL K	[1DCB 1CAD | 0020 0020 | 000B 0008 |]

    uint32_t cps[2] = { 0x1D472, 0x0041 };
    uint32_t const ces[9] = { 0x1DCB, 0x1CAD, 0x0000, 0x0020, 0x0020, 0x0000, 0x000B, 0x0008, 0x0000 };

    auto collation = collate_for_tests(
        cps, cps + 2, boost::text::variable_weighting::non_ignorable);

    EXPECT_EQ(collation.size(), 9);
    EXPECT_TRUE(boost::algorithm::equal(collation.begin(), collation.end(), ces, ces + 9))
        << "from:     " << ce_dumper(cps)
        << "expected: " << ce_dumper(ces)
        << "got:      " << ce_dumper(collation);
}

TEST(collation, non_ignorable_111_095)
{
    // 1D4A6 0041;	
    // (ùí¶) MATHEMATICAL SCRIPT CAPITAL K	[1DCB 1CAD | 0020 0020 | 000B 0008 |]

    uint32_t cps[2] = { 0x1D4A6, 0x0041 };
    uint32_t const ces[9] = { 0x1DCB, 0x1CAD, 0x0000, 0x0020, 0x0020, 0x0000, 0x000B, 0x0008, 0x0000 };

    auto collation = collate_for_tests(
        cps, cps + 2, boost::text::variable_weighting::non_ignorable);

    EXPECT_EQ(collation.size(), 9);
    EXPECT_TRUE(boost::algorithm::equal(collation.begin(), collation.end(), ces, ces + 9))
        << "from:     " << ce_dumper(cps)
        << "expected: " << ce_dumper(ces)
        << "got:      " << ce_dumper(collation);
}

TEST(collation, non_ignorable_111_096)
{
    // 1D4DA 0041;	
    // (ùìö) MATHEMATICAL BOLD SCRIPT CAPITAL K	[1DCB 1CAD | 0020 0020 | 000B 0008 |]

    uint32_t cps[2] = { 0x1D4DA, 0x0041 };
    uint32_t const ces[9] = { 0x1DCB, 0x1CAD, 0x0000, 0x0020, 0x0020, 0x0000, 0x000B, 0x0008, 0x0000 };

    auto collation = collate_for_tests(
        cps, cps + 2, boost::text::variable_weighting::non_ignorable);

    EXPECT_EQ(collation.size(), 9);
    EXPECT_TRUE(boost::algorithm::equal(collation.begin(), collation.end(), ces, ces + 9))
        << "from:     " << ce_dumper(cps)
        << "expected: " << ce_dumper(ces)
        << "got:      " << ce_dumper(collation);
}

TEST(collation, non_ignorable_111_097)
{
    // 1D50E 0041;	
    // (ùîé) MATHEMATICAL FRAKTUR CAPITAL K	[1DCB 1CAD | 0020 0020 | 000B 0008 |]

    uint32_t cps[2] = { 0x1D50E, 0x0041 };
    uint32_t const ces[9] = { 0x1DCB, 0x1CAD, 0x0000, 0x0020, 0x0020, 0x0000, 0x000B, 0x0008, 0x0000 };

    auto collation = collate_for_tests(
        cps, cps + 2, boost::text::variable_weighting::non_ignorable);

    EXPECT_EQ(collation.size(), 9);
    EXPECT_TRUE(boost::algorithm::equal(collation.begin(), collation.end(), ces, ces + 9))
        << "from:     " << ce_dumper(cps)
        << "expected: " << ce_dumper(ces)
        << "got:      " << ce_dumper(collation);
}

TEST(collation, non_ignorable_111_098)
{
    // 1D542 0041;	
    // (ùïÇ) MATHEMATICAL DOUBLE-STRUCK CAPITAL K	[1DCB 1CAD | 0020 0020 | 000B 0008 |]

    uint32_t cps[2] = { 0x1D542, 0x0041 };
    uint32_t const ces[9] = { 0x1DCB, 0x1CAD, 0x0000, 0x0020, 0x0020, 0x0000, 0x000B, 0x0008, 0x0000 };

    auto collation = collate_for_tests(
        cps, cps + 2, boost::text::variable_weighting::non_ignorable);

    EXPECT_EQ(collation.size(), 9);
    EXPECT_TRUE(boost::algorithm::equal(collation.begin(), collation.end(), ces, ces + 9))
        << "from:     " << ce_dumper(cps)
        << "expected: " << ce_dumper(ces)
        << "got:      " << ce_dumper(collation);
}

TEST(collation, non_ignorable_111_099)
{
    // 1D576 0041;	
    // (ùï∂) MATHEMATICAL BOLD FRAKTUR CAPITAL K	[1DCB 1CAD | 0020 0020 | 000B 0008 |]

    uint32_t cps[2] = { 0x1D576, 0x0041 };
    uint32_t const ces[9] = { 0x1DCB, 0x1CAD, 0x0000, 0x0020, 0x0020, 0x0000, 0x000B, 0x0008, 0x0000 };

    auto collation = collate_for_tests(
        cps, cps + 2, boost::text::variable_weighting::non_ignorable);

    EXPECT_EQ(collation.size(), 9);
    EXPECT_TRUE(boost::algorithm::equal(collation.begin(), collation.end(), ces, ces + 9))
        << "from:     " << ce_dumper(cps)
        << "expected: " << ce_dumper(ces)
        << "got:      " << ce_dumper(collation);
}

TEST(collation, non_ignorable_111_100)
{
    // 1D5AA 0041;	
    // (ùñ™) MATHEMATICAL SANS-SERIF CAPITAL K	[1DCB 1CAD | 0020 0020 | 000B 0008 |]

    uint32_t cps[2] = { 0x1D5AA, 0x0041 };
    uint32_t const ces[9] = { 0x1DCB, 0x1CAD, 0x0000, 0x0020, 0x0020, 0x0000, 0x000B, 0x0008, 0x0000 };

    auto collation = collate_for_tests(
        cps, cps + 2, boost::text::variable_weighting::non_ignorable);

    EXPECT_EQ(collation.size(), 9);
    EXPECT_TRUE(boost::algorithm::equal(collation.begin(), collation.end(), ces, ces + 9))
        << "from:     " << ce_dumper(cps)
        << "expected: " << ce_dumper(ces)
        << "got:      " << ce_dumper(collation);
}

TEST(collation, non_ignorable_111_101)
{
    // 1D5DE 0041;	
    // (ùóû) MATHEMATICAL SANS-SERIF BOLD CAPITAL K	[1DCB 1CAD | 0020 0020 | 000B 0008 |]

    uint32_t cps[2] = { 0x1D5DE, 0x0041 };
    uint32_t const ces[9] = { 0x1DCB, 0x1CAD, 0x0000, 0x0020, 0x0020, 0x0000, 0x000B, 0x0008, 0x0000 };

    auto collation = collate_for_tests(
        cps, cps + 2, boost::text::variable_weighting::non_ignorable);

    EXPECT_EQ(collation.size(), 9);
    EXPECT_TRUE(boost::algorithm::equal(collation.begin(), collation.end(), ces, ces + 9))
        << "from:     " << ce_dumper(cps)
        << "expected: " << ce_dumper(ces)
        << "got:      " << ce_dumper(collation);
}

TEST(collation, non_ignorable_111_102)
{
    // 1D612 0041;	
    // (ùòí) MATHEMATICAL SANS-SERIF ITALIC CAPITAL K	[1DCB 1CAD | 0020 0020 | 000B 0008 |]

    uint32_t cps[2] = { 0x1D612, 0x0041 };
    uint32_t const ces[9] = { 0x1DCB, 0x1CAD, 0x0000, 0x0020, 0x0020, 0x0000, 0x000B, 0x0008, 0x0000 };

    auto collation = collate_for_tests(
        cps, cps + 2, boost::text::variable_weighting::non_ignorable);

    EXPECT_EQ(collation.size(), 9);
    EXPECT_TRUE(boost::algorithm::equal(collation.begin(), collation.end(), ces, ces + 9))
        << "from:     " << ce_dumper(cps)
        << "expected: " << ce_dumper(ces)
        << "got:      " << ce_dumper(collation);
}

TEST(collation, non_ignorable_111_103)
{
    // 1D646 0041;	
    // (ùôÜ) MATHEMATICAL SANS-SERIF BOLD ITALIC CAPITAL K	[1DCB 1CAD | 0020 0020 | 000B 0008 |]

    uint32_t cps[2] = { 0x1D646, 0x0041 };
    uint32_t const ces[9] = { 0x1DCB, 0x1CAD, 0x0000, 0x0020, 0x0020, 0x0000, 0x000B, 0x0008, 0x0000 };

    auto collation = collate_for_tests(
        cps, cps + 2, boost::text::variable_weighting::non_ignorable);

    EXPECT_EQ(collation.size(), 9);
    EXPECT_TRUE(boost::algorithm::equal(collation.begin(), collation.end(), ces, ces + 9))
        << "from:     " << ce_dumper(cps)
        << "expected: " << ce_dumper(ces)
        << "got:      " << ce_dumper(collation);
}

TEST(collation, non_ignorable_111_104)
{
    // 1D67A 0041;	
    // (ùô∫) MATHEMATICAL MONOSPACE CAPITAL K	[1DCB 1CAD | 0020 0020 | 000B 0008 |]

    uint32_t cps[2] = { 0x1D67A, 0x0041 };
    uint32_t const ces[9] = { 0x1DCB, 0x1CAD, 0x0000, 0x0020, 0x0020, 0x0000, 0x000B, 0x0008, 0x0000 };

    auto collation = collate_for_tests(
        cps, cps + 2, boost::text::variable_weighting::non_ignorable);

    EXPECT_EQ(collation.size(), 9);
    EXPECT_TRUE(boost::algorithm::equal(collation.begin(), collation.end(), ces, ces + 9))
        << "from:     " << ce_dumper(cps)
        << "expected: " << ce_dumper(ces)
        << "got:      " << ce_dumper(collation);
}

TEST(collation, non_ignorable_111_105)
{
    // 24C0 0061;	
    // (‚ìÄ) CIRCLED LATIN CAPITAL LETTER K	[1DCB 1CAD | 0020 0020 | 000C 0002 |]

    uint32_t cps[2] = { 0x24C0, 0x0061 };
    uint32_t const ces[9] = { 0x1DCB, 0x1CAD, 0x0000, 0x0020, 0x0020, 0x0000, 0x000C, 0x0002, 0x0000 };

    auto collation = collate_for_tests(
        cps, cps + 2, boost::text::variable_weighting::non_ignorable);

    EXPECT_EQ(collation.size(), 9);
    EXPECT_TRUE(boost::algorithm::equal(collation.begin(), collation.end(), ces, ces + 9))
        << "from:     " << ce_dumper(cps)
        << "expected: " << ce_dumper(ces)
        << "got:      " << ce_dumper(collation);
}

TEST(collation, non_ignorable_111_106)
{
    // 1F15A 0061;	
    // (üÖö) NEGATIVE CIRCLED LATIN CAPITAL LETTER K	[1DCB 1CAD | 0020 0020 | 000C 0002 |]

    uint32_t cps[2] = { 0x1F15A, 0x0061 };
    uint32_t const ces[9] = { 0x1DCB, 0x1CAD, 0x0000, 0x0020, 0x0020, 0x0000, 0x000C, 0x0002, 0x0000 };

    auto collation = collate_for_tests(
        cps, cps + 2, boost::text::variable_weighting::non_ignorable);

    EXPECT_EQ(collation.size(), 9);
    EXPECT_TRUE(boost::algorithm::equal(collation.begin(), collation.end(), ces, ces + 9))
        << "from:     " << ce_dumper(cps)
        << "expected: " << ce_dumper(ces)
        << "got:      " << ce_dumper(collation);
}

TEST(collation, non_ignorable_111_107)
{
    // 24C0 0041;	
    // (‚ìÄ) CIRCLED LATIN CAPITAL LETTER K	[1DCB 1CAD | 0020 0020 | 000C 0008 |]

    uint32_t cps[2] = { 0x24C0, 0x0041 };
    uint32_t const ces[9] = { 0x1DCB, 0x1CAD, 0x0000, 0x0020, 0x0020, 0x0000, 0x000C, 0x0008, 0x0000 };

    auto collation = collate_for_tests(
        cps, cps + 2, boost::text::variable_weighting::non_ignorable);

    EXPECT_EQ(collation.size(), 9);
    EXPECT_TRUE(boost::algorithm::equal(collation.begin(), collation.end(), ces, ces + 9))
        << "from:     " << ce_dumper(cps)
        << "expected: " << ce_dumper(ces)
        << "got:      " << ce_dumper(collation);
}

TEST(collation, non_ignorable_111_108)
{
    // 1F15A 0041;	
    // (üÖö) NEGATIVE CIRCLED LATIN CAPITAL LETTER K	[1DCB 1CAD | 0020 0020 | 000C 0008 |]

    uint32_t cps[2] = { 0x1F15A, 0x0041 };
    uint32_t const ces[9] = { 0x1DCB, 0x1CAD, 0x0000, 0x0020, 0x0020, 0x0000, 0x000C, 0x0008, 0x0000 };

    auto collation = collate_for_tests(
        cps, cps + 2, boost::text::variable_weighting::non_ignorable);

    EXPECT_EQ(collation.size(), 9);
    EXPECT_TRUE(boost::algorithm::equal(collation.begin(), collation.end(), ces, ces + 9))
        << "from:     " << ce_dumper(cps)
        << "expected: " << ce_dumper(ces)
        << "got:      " << ce_dumper(collation);
}

TEST(collation, non_ignorable_111_109)
{
    // 1D4F 0061;	
    // (·µè) MODIFIER LETTER SMALL K	[1DCB 1CAD | 0020 0020 | 0014 0002 |]

    uint32_t cps[2] = { 0x1D4F, 0x0061 };
    uint32_t const ces[9] = { 0x1DCB, 0x1CAD, 0x0000, 0x0020, 0x0020, 0x0000, 0x0014, 0x0002, 0x0000 };

    auto collation = collate_for_tests(
        cps, cps + 2, boost::text::variable_weighting::non_ignorable);

    EXPECT_EQ(collation.size(), 9);
    EXPECT_TRUE(boost::algorithm::equal(collation.begin(), collation.end(), ces, ces + 9))
        << "from:     " << ce_dumper(cps)
        << "expected: " << ce_dumper(ces)
        << "got:      " << ce_dumper(collation);
}

TEST(collation, non_ignorable_111_110)
{
    // 1D4F 0041;	
    // (·µè) MODIFIER LETTER SMALL K	[1DCB 1CAD | 0020 0020 | 0014 0008 |]

    uint32_t cps[2] = { 0x1D4F, 0x0041 };
    uint32_t const ces[9] = { 0x1DCB, 0x1CAD, 0x0000, 0x0020, 0x0020, 0x0000, 0x0014, 0x0008, 0x0000 };

    auto collation = collate_for_tests(
        cps, cps + 2, boost::text::variable_weighting::non_ignorable);

    EXPECT_EQ(collation.size(), 9);
    EXPECT_TRUE(boost::algorithm::equal(collation.begin(), collation.end(), ces, ces + 9))
        << "from:     " << ce_dumper(cps)
        << "expected: " << ce_dumper(ces)
        << "got:      " << ce_dumper(collation);
}

TEST(collation, non_ignorable_111_111)
{
    // 2096 0061;	
    // (‚Çñ) LATIN SUBSCRIPT SMALL LETTER K	[1DCB 1CAD | 0020 0020 | 0015 0002 |]

    uint32_t cps[2] = { 0x2096, 0x0061 };
    uint32_t const ces[9] = { 0x1DCB, 0x1CAD, 0x0000, 0x0020, 0x0020, 0x0000, 0x0015, 0x0002, 0x0000 };

    auto collation = collate_for_tests(
        cps, cps + 2, boost::text::variable_weighting::non_ignorable);

    EXPECT_EQ(collation.size(), 9);
    EXPECT_TRUE(boost::algorithm::equal(collation.begin(), collation.end(), ces, ces + 9))
        << "from:     " << ce_dumper(cps)
        << "expected: " << ce_dumper(ces)
        << "got:      " << ce_dumper(collation);
}

TEST(collation, non_ignorable_111_112)
{
    // 2096 0041;	
    // (‚Çñ) LATIN SUBSCRIPT SMALL LETTER K	[1DCB 1CAD | 0020 0020 | 0015 0008 |]

    uint32_t cps[2] = { 0x2096, 0x0041 };
    uint32_t const ces[9] = { 0x1DCB, 0x1CAD, 0x0000, 0x0020, 0x0020, 0x0000, 0x0015, 0x0008, 0x0000 };

    auto collation = collate_for_tests(
        cps, cps + 2, boost::text::variable_weighting::non_ignorable);

    EXPECT_EQ(collation.size(), 9);
    EXPECT_TRUE(boost::algorithm::equal(collation.begin(), collation.end(), ces, ces + 9))
        << "from:     " << ce_dumper(cps)
        << "expected: " << ce_dumper(ces)
        << "got:      " << ce_dumper(collation);
}

TEST(collation, non_ignorable_111_113)
{
    // 1D37 0061;	
    // (·¥∑) MODIFIER LETTER CAPITAL K	[1DCB 1CAD | 0020 0020 | 001D 0002 |]

    uint32_t cps[2] = { 0x1D37, 0x0061 };
    uint32_t const ces[9] = { 0x1DCB, 0x1CAD, 0x0000, 0x0020, 0x0020, 0x0000, 0x001D, 0x0002, 0x0000 };

    auto collation = collate_for_tests(
        cps, cps + 2, boost::text::variable_weighting::non_ignorable);

    EXPECT_EQ(collation.size(), 9);
    EXPECT_TRUE(boost::algorithm::equal(collation.begin(), collation.end(), ces, ces + 9))
        << "from:     " << ce_dumper(cps)
        << "expected: " << ce_dumper(ces)
        << "got:      " << ce_dumper(collation);
}

TEST(collation, non_ignorable_111_114)
{
    // 1F13A 0061;	
    // (üÑ∫) SQUARED LATIN CAPITAL LETTER K	[1DCB 1CAD | 0020 0020 | 001D 0002 |]

    uint32_t cps[2] = { 0x1F13A, 0x0061 };
    uint32_t const ces[9] = { 0x1DCB, 0x1CAD, 0x0000, 0x0020, 0x0020, 0x0000, 0x001D, 0x0002, 0x0000 };

    auto collation = collate_for_tests(
        cps, cps + 2, boost::text::variable_weighting::non_ignorable);

    EXPECT_EQ(collation.size(), 9);
    EXPECT_TRUE(boost::algorithm::equal(collation.begin(), collation.end(), ces, ces + 9))
        << "from:     " << ce_dumper(cps)
        << "expected: " << ce_dumper(ces)
        << "got:      " << ce_dumper(collation);
}

TEST(collation, non_ignorable_111_115)
{
    // 1F17A 0061;	
    // (üÖ∫) NEGATIVE SQUARED LATIN CAPITAL LETTER K	[1DCB 1CAD | 0020 0020 | 001D 0002 |]

    uint32_t cps[2] = { 0x1F17A, 0x0061 };
    uint32_t const ces[9] = { 0x1DCB, 0x1CAD, 0x0000, 0x0020, 0x0020, 0x0000, 0x001D, 0x0002, 0x0000 };

    auto collation = collate_for_tests(
        cps, cps + 2, boost::text::variable_weighting::non_ignorable);

    EXPECT_EQ(collation.size(), 9);
    EXPECT_TRUE(boost::algorithm::equal(collation.begin(), collation.end(), ces, ces + 9))
        << "from:     " << ce_dumper(cps)
        << "expected: " << ce_dumper(ces)
        << "got:      " << ce_dumper(collation);
}

TEST(collation, non_ignorable_111_116)
{
    // 1D37 0041;	
    // (·¥∑) MODIFIER LETTER CAPITAL K	[1DCB 1CAD | 0020 0020 | 001D 0008 |]

    uint32_t cps[2] = { 0x1D37, 0x0041 };
    uint32_t const ces[9] = { 0x1DCB, 0x1CAD, 0x0000, 0x0020, 0x0020, 0x0000, 0x001D, 0x0008, 0x0000 };

    auto collation = collate_for_tests(
        cps, cps + 2, boost::text::variable_weighting::non_ignorable);

    EXPECT_EQ(collation.size(), 9);
    EXPECT_TRUE(boost::algorithm::equal(collation.begin(), collation.end(), ces, ces + 9))
        << "from:     " << ce_dumper(cps)
        << "expected: " << ce_dumper(ces)
        << "got:      " << ce_dumper(collation);
}

TEST(collation, non_ignorable_111_117)
{
    // 1F13A 0041;	
    // (üÑ∫) SQUARED LATIN CAPITAL LETTER K	[1DCB 1CAD | 0020 0020 | 001D 0008 |]

    uint32_t cps[2] = { 0x1F13A, 0x0041 };
    uint32_t const ces[9] = { 0x1DCB, 0x1CAD, 0x0000, 0x0020, 0x0020, 0x0000, 0x001D, 0x0008, 0x0000 };

    auto collation = collate_for_tests(
        cps, cps + 2, boost::text::variable_weighting::non_ignorable);

    EXPECT_EQ(collation.size(), 9);
    EXPECT_TRUE(boost::algorithm::equal(collation.begin(), collation.end(), ces, ces + 9))
        << "from:     " << ce_dumper(cps)
        << "expected: " << ce_dumper(ces)
        << "got:      " << ce_dumper(collation);
}

TEST(collation, non_ignorable_111_118)
{
    // 1F17A 0041;	
    // (üÖ∫) NEGATIVE SQUARED LATIN CAPITAL LETTER K	[1DCB 1CAD | 0020 0020 | 001D 0008 |]

    uint32_t cps[2] = { 0x1F17A, 0x0041 };
    uint32_t const ces[9] = { 0x1DCB, 0x1CAD, 0x0000, 0x0020, 0x0020, 0x0000, 0x001D, 0x0008, 0x0000 };

    auto collation = collate_for_tests(
        cps, cps + 2, boost::text::variable_weighting::non_ignorable);

    EXPECT_EQ(collation.size(), 9);
    EXPECT_TRUE(boost::algorithm::equal(collation.begin(), collation.end(), ces, ces + 9))
        << "from:     " << ce_dumper(cps)
        << "expected: " << ce_dumper(ces)
        << "got:      " << ce_dumper(collation);
}

TEST(collation, non_ignorable_111_119)
{
    // 1E31 0061;	
    // (·∏±) LATIN SMALL LETTER K WITH ACUTE	[1DCB 1CAD | 0020 0024 0020 | 0002 0002 0002 |]

    uint32_t cps[2] = { 0x1E31, 0x0061 };
    uint32_t const ces[11] = { 0x1DCB, 0x1CAD, 0x0000, 0x0020, 0x0024, 0x0020, 0x0000, 0x0002, 0x0002, 0x0002, 0x0000 };

    auto collation = collate_for_tests(
        cps, cps + 2, boost::text::variable_weighting::non_ignorable);

    EXPECT_EQ(collation.size(), 11);
    EXPECT_TRUE(boost::algorithm::equal(collation.begin(), collation.end(), ces, ces + 11))
        << "from:     " << ce_dumper(cps)
        << "expected: " << ce_dumper(ces)
        << "got:      " << ce_dumper(collation);
}

TEST(collation, non_ignorable_111_120)
{
    // 1E31 0041;	
    // (·∏±) LATIN SMALL LETTER K WITH ACUTE	[1DCB 1CAD | 0020 0024 0020 | 0002 0002 0008 |]

    uint32_t cps[2] = { 0x1E31, 0x0041 };
    uint32_t const ces[11] = { 0x1DCB, 0x1CAD, 0x0000, 0x0020, 0x0024, 0x0020, 0x0000, 0x0002, 0x0002, 0x0008, 0x0000 };

    auto collation = collate_for_tests(
        cps, cps + 2, boost::text::variable_weighting::non_ignorable);

    EXPECT_EQ(collation.size(), 11);
    EXPECT_TRUE(boost::algorithm::equal(collation.begin(), collation.end(), ces, ces + 11))
        << "from:     " << ce_dumper(cps)
        << "expected: " << ce_dumper(ces)
        << "got:      " << ce_dumper(collation);
}

TEST(collation, non_ignorable_111_121)
{
    // 1E30 0061;	
    // (·∏∞) LATIN CAPITAL LETTER K WITH ACUTE	[1DCB 1CAD | 0020 0024 0020 | 0008 0002 0002 |]

    uint32_t cps[2] = { 0x1E30, 0x0061 };
    uint32_t const ces[11] = { 0x1DCB, 0x1CAD, 0x0000, 0x0020, 0x0024, 0x0020, 0x0000, 0x0008, 0x0002, 0x0002, 0x0000 };

    auto collation = collate_for_tests(
        cps, cps + 2, boost::text::variable_weighting::non_ignorable);

    EXPECT_EQ(collation.size(), 11);
    EXPECT_TRUE(boost::algorithm::equal(collation.begin(), collation.end(), ces, ces + 11))
        << "from:     " << ce_dumper(cps)
        << "expected: " << ce_dumper(ces)
        << "got:      " << ce_dumper(collation);
}

TEST(collation, non_ignorable_111_122)
{
    // 1E30 0041;	
    // (·∏∞) LATIN CAPITAL LETTER K WITH ACUTE	[1DCB 1CAD | 0020 0024 0020 | 0008 0002 0008 |]

    uint32_t cps[2] = { 0x1E30, 0x0041 };
    uint32_t const ces[11] = { 0x1DCB, 0x1CAD, 0x0000, 0x0020, 0x0024, 0x0020, 0x0000, 0x0008, 0x0002, 0x0008, 0x0000 };

    auto collation = collate_for_tests(
        cps, cps + 2, boost::text::variable_weighting::non_ignorable);

    EXPECT_EQ(collation.size(), 11);
    EXPECT_TRUE(boost::algorithm::equal(collation.begin(), collation.end(), ces, ces + 11))
        << "from:     " << ce_dumper(cps)
        << "expected: " << ce_dumper(ces)
        << "got:      " << ce_dumper(collation);
}

TEST(collation, non_ignorable_111_123)
{
    // 01E9 0061;	
    // («©) LATIN SMALL LETTER K WITH CARON	[1DCB 1CAD | 0020 0028 0020 | 0002 0002 0002 |]

    uint32_t cps[2] = { 0x01E9, 0x0061 };
    uint32_t const ces[11] = { 0x1DCB, 0x1CAD, 0x0000, 0x0020, 0x0028, 0x0020, 0x0000, 0x0002, 0x0002, 0x0002, 0x0000 };

    auto collation = collate_for_tests(
        cps, cps + 2, boost::text::variable_weighting::non_ignorable);

    EXPECT_EQ(collation.size(), 11);
    EXPECT_TRUE(boost::algorithm::equal(collation.begin(), collation.end(), ces, ces + 11))
        << "from:     " << ce_dumper(cps)
        << "expected: " << ce_dumper(ces)
        << "got:      " << ce_dumper(collation);
}

TEST(collation, non_ignorable_111_124)
{
    // 01E9 0041;	
    // («©) LATIN SMALL LETTER K WITH CARON	[1DCB 1CAD | 0020 0028 0020 | 0002 0002 0008 |]

    uint32_t cps[2] = { 0x01E9, 0x0041 };
    uint32_t const ces[11] = { 0x1DCB, 0x1CAD, 0x0000, 0x0020, 0x0028, 0x0020, 0x0000, 0x0002, 0x0002, 0x0008, 0x0000 };

    auto collation = collate_for_tests(
        cps, cps + 2, boost::text::variable_weighting::non_ignorable);

    EXPECT_EQ(collation.size(), 11);
    EXPECT_TRUE(boost::algorithm::equal(collation.begin(), collation.end(), ces, ces + 11))
        << "from:     " << ce_dumper(cps)
        << "expected: " << ce_dumper(ces)
        << "got:      " << ce_dumper(collation);
}

TEST(collation, non_ignorable_111_125)
{
    // 01E8 0061;	
    // («®) LATIN CAPITAL LETTER K WITH CARON	[1DCB 1CAD | 0020 0028 0020 | 0008 0002 0002 |]

    uint32_t cps[2] = { 0x01E8, 0x0061 };
    uint32_t const ces[11] = { 0x1DCB, 0x1CAD, 0x0000, 0x0020, 0x0028, 0x0020, 0x0000, 0x0008, 0x0002, 0x0002, 0x0000 };

    auto collation = collate_for_tests(
        cps, cps + 2, boost::text::variable_weighting::non_ignorable);

    EXPECT_EQ(collation.size(), 11);
    EXPECT_TRUE(boost::algorithm::equal(collation.begin(), collation.end(), ces, ces + 11))
        << "from:     " << ce_dumper(cps)
        << "expected: " << ce_dumper(ces)
        << "got:      " << ce_dumper(collation);
}

TEST(collation, non_ignorable_111_126)
{
    // 01E8 0041;	
    // («®) LATIN CAPITAL LETTER K WITH CARON	[1DCB 1CAD | 0020 0028 0020 | 0008 0002 0008 |]

    uint32_t cps[2] = { 0x01E8, 0x0041 };
    uint32_t const ces[11] = { 0x1DCB, 0x1CAD, 0x0000, 0x0020, 0x0028, 0x0020, 0x0000, 0x0008, 0x0002, 0x0008, 0x0000 };

    auto collation = collate_for_tests(
        cps, cps + 2, boost::text::variable_weighting::non_ignorable);

    EXPECT_EQ(collation.size(), 11);
    EXPECT_TRUE(boost::algorithm::equal(collation.begin(), collation.end(), ces, ces + 11))
        << "from:     " << ce_dumper(cps)
        << "expected: " << ce_dumper(ces)
        << "got:      " << ce_dumper(collation);
}

TEST(collation, non_ignorable_111_127)
{
    // 0137 0061;	
    // (ƒ∑) LATIN SMALL LETTER K WITH CEDILLA	[1DCB 1CAD | 0020 0030 0020 | 0002 0002 0002 |]

    uint32_t cps[2] = { 0x0137, 0x0061 };
    uint32_t const ces[11] = { 0x1DCB, 0x1CAD, 0x0000, 0x0020, 0x0030, 0x0020, 0x0000, 0x0002, 0x0002, 0x0002, 0x0000 };

    auto collation = collate_for_tests(
        cps, cps + 2, boost::text::variable_weighting::non_ignorable);

    EXPECT_EQ(collation.size(), 11);
    EXPECT_TRUE(boost::algorithm::equal(collation.begin(), collation.end(), ces, ces + 11))
        << "from:     " << ce_dumper(cps)
        << "expected: " << ce_dumper(ces)
        << "got:      " << ce_dumper(collation);
}

TEST(collation, non_ignorable_111_128)
{
    // 0137 0041;	
    // (ƒ∑) LATIN SMALL LETTER K WITH CEDILLA	[1DCB 1CAD | 0020 0030 0020 | 0002 0002 0008 |]

    uint32_t cps[2] = { 0x0137, 0x0041 };
    uint32_t const ces[11] = { 0x1DCB, 0x1CAD, 0x0000, 0x0020, 0x0030, 0x0020, 0x0000, 0x0002, 0x0002, 0x0008, 0x0000 };

    auto collation = collate_for_tests(
        cps, cps + 2, boost::text::variable_weighting::non_ignorable);

    EXPECT_EQ(collation.size(), 11);
    EXPECT_TRUE(boost::algorithm::equal(collation.begin(), collation.end(), ces, ces + 11))
        << "from:     " << ce_dumper(cps)
        << "expected: " << ce_dumper(ces)
        << "got:      " << ce_dumper(collation);
}

TEST(collation, non_ignorable_111_129)
{
    // 0136 0061;	
    // (ƒ∂) LATIN CAPITAL LETTER K WITH CEDILLA	[1DCB 1CAD | 0020 0030 0020 | 0008 0002 0002 |]

    uint32_t cps[2] = { 0x0136, 0x0061 };
    uint32_t const ces[11] = { 0x1DCB, 0x1CAD, 0x0000, 0x0020, 0x0030, 0x0020, 0x0000, 0x0008, 0x0002, 0x0002, 0x0000 };

    auto collation = collate_for_tests(
        cps, cps + 2, boost::text::variable_weighting::non_ignorable);

    EXPECT_EQ(collation.size(), 11);
    EXPECT_TRUE(boost::algorithm::equal(collation.begin(), collation.end(), ces, ces + 11))
        << "from:     " << ce_dumper(cps)
        << "expected: " << ce_dumper(ces)
        << "got:      " << ce_dumper(collation);
}

TEST(collation, non_ignorable_111_130)
{
    // 0136 0041;	
    // (ƒ∂) LATIN CAPITAL LETTER K WITH CEDILLA	[1DCB 1CAD | 0020 0030 0020 | 0008 0002 0008 |]

    uint32_t cps[2] = { 0x0136, 0x0041 };
    uint32_t const ces[11] = { 0x1DCB, 0x1CAD, 0x0000, 0x0020, 0x0030, 0x0020, 0x0000, 0x0008, 0x0002, 0x0008, 0x0000 };

    auto collation = collate_for_tests(
        cps, cps + 2, boost::text::variable_weighting::non_ignorable);

    EXPECT_EQ(collation.size(), 11);
    EXPECT_TRUE(boost::algorithm::equal(collation.begin(), collation.end(), ces, ces + 11))
        << "from:     " << ce_dumper(cps)
        << "expected: " << ce_dumper(ces)
        << "got:      " << ce_dumper(collation);
}

TEST(collation, non_ignorable_111_131)
{
    // A7A3 0061;	
    // (Íû£) LATIN SMALL LETTER K WITH OBLIQUE STROKE	[1DCB 1CAD | 0020 0035 0020 | 0004 0004 0002 |]

    uint32_t cps[2] = { 0xA7A3, 0x0061 };
    uint32_t const ces[11] = { 0x1DCB, 0x1CAD, 0x0000, 0x0020, 0x0035, 0x0020, 0x0000, 0x0004, 0x0004, 0x0002, 0x0000 };

    auto collation = collate_for_tests(
        cps, cps + 2, boost::text::variable_weighting::non_ignorable);

    EXPECT_EQ(collation.size(), 11);
    EXPECT_TRUE(boost::algorithm::equal(collation.begin(), collation.end(), ces, ces + 11))
        << "from:     " << ce_dumper(cps)
        << "expected: " << ce_dumper(ces)
        << "got:      " << ce_dumper(collation);
}

TEST(collation, non_ignorable_111_132)
{
    // A7A3 0041;	
    // (Íû£) LATIN SMALL LETTER K WITH OBLIQUE STROKE	[1DCB 1CAD | 0020 0035 0020 | 0004 0004 0008 |]

    uint32_t cps[2] = { 0xA7A3, 0x0041 };
    uint32_t const ces[11] = { 0x1DCB, 0x1CAD, 0x0000, 0x0020, 0x0035, 0x0020, 0x0000, 0x0004, 0x0004, 0x0008, 0x0000 };

    auto collation = collate_for_tests(
        cps, cps + 2, boost::text::variable_weighting::non_ignorable);

    EXPECT_EQ(collation.size(), 11);
    EXPECT_TRUE(boost::algorithm::equal(collation.begin(), collation.end(), ces, ces + 11))
        << "from:     " << ce_dumper(cps)
        << "expected: " << ce_dumper(ces)
        << "got:      " << ce_dumper(collation);
}

TEST(collation, non_ignorable_111_133)
{
    // A7A2 0061;	
    // (Íû¢) LATIN CAPITAL LETTER K WITH OBLIQUE STROKE	[1DCB 1CAD | 0020 0035 0020 | 000A 0004 0002 |]

    uint32_t cps[2] = { 0xA7A2, 0x0061 };
    uint32_t const ces[11] = { 0x1DCB, 0x1CAD, 0x0000, 0x0020, 0x0035, 0x0020, 0x0000, 0x000A, 0x0004, 0x0002, 0x0000 };

    auto collation = collate_for_tests(
        cps, cps + 2, boost::text::variable_weighting::non_ignorable);

    EXPECT_EQ(collation.size(), 11);
    EXPECT_TRUE(boost::algorithm::equal(collation.begin(), collation.end(), ces, ces + 11))
        << "from:     " << ce_dumper(cps)
        << "expected: " << ce_dumper(ces)
        << "got:      " << ce_dumper(collation);
}

TEST(collation, non_ignorable_111_134)
{
    // A7A2 0041;	
    // (Íû¢) LATIN CAPITAL LETTER K WITH OBLIQUE STROKE	[1DCB 1CAD | 0020 0035 0020 | 000A 0004 0008 |]

    uint32_t cps[2] = { 0xA7A2, 0x0041 };
    uint32_t const ces[11] = { 0x1DCB, 0x1CAD, 0x0000, 0x0020, 0x0035, 0x0020, 0x0000, 0x000A, 0x0004, 0x0008, 0x0000 };

    auto collation = collate_for_tests(
        cps, cps + 2, boost::text::variable_weighting::non_ignorable);

    EXPECT_EQ(collation.size(), 11);
    EXPECT_TRUE(boost::algorithm::equal(collation.begin(), collation.end(), ces, ces + 11))
        << "from:     " << ce_dumper(cps)
        << "expected: " << ce_dumper(ces)
        << "got:      " << ce_dumper(collation);
}

TEST(collation, non_ignorable_111_135)
{
    // 1E33 0061;	
    // (·∏≥) LATIN SMALL LETTER K WITH DOT BELOW	[1DCB 1CAD | 0020 0042 0020 | 0002 0002 0002 |]

    uint32_t cps[2] = { 0x1E33, 0x0061 };
    uint32_t const ces[11] = { 0x1DCB, 0x1CAD, 0x0000, 0x0020, 0x0042, 0x0020, 0x0000, 0x0002, 0x0002, 0x0002, 0x0000 };

    auto collation = collate_for_tests(
        cps, cps + 2, boost::text::variable_weighting::non_ignorable);

    EXPECT_EQ(collation.size(), 11);
    EXPECT_TRUE(boost::algorithm::equal(collation.begin(), collation.end(), ces, ces + 11))
        << "from:     " << ce_dumper(cps)
        << "expected: " << ce_dumper(ces)
        << "got:      " << ce_dumper(collation);
}

TEST(collation, non_ignorable_111_136)
{
    // 1E33 0041;	
    // (·∏≥) LATIN SMALL LETTER K WITH DOT BELOW	[1DCB 1CAD | 0020 0042 0020 | 0002 0002 0008 |]

    uint32_t cps[2] = { 0x1E33, 0x0041 };
    uint32_t const ces[11] = { 0x1DCB, 0x1CAD, 0x0000, 0x0020, 0x0042, 0x0020, 0x0000, 0x0002, 0x0002, 0x0008, 0x0000 };

    auto collation = collate_for_tests(
        cps, cps + 2, boost::text::variable_weighting::non_ignorable);

    EXPECT_EQ(collation.size(), 11);
    EXPECT_TRUE(boost::algorithm::equal(collation.begin(), collation.end(), ces, ces + 11))
        << "from:     " << ce_dumper(cps)
        << "expected: " << ce_dumper(ces)
        << "got:      " << ce_dumper(collation);
}

TEST(collation, non_ignorable_111_137)
{
    // 1E32 0061;	
    // (·∏≤) LATIN CAPITAL LETTER K WITH DOT BELOW	[1DCB 1CAD | 0020 0042 0020 | 0008 0002 0002 |]

    uint32_t cps[2] = { 0x1E32, 0x0061 };
    uint32_t const ces[11] = { 0x1DCB, 0x1CAD, 0x0000, 0x0020, 0x0042, 0x0020, 0x0000, 0x0008, 0x0002, 0x0002, 0x0000 };

    auto collation = collate_for_tests(
        cps, cps + 2, boost::text::variable_weighting::non_ignorable);

    EXPECT_EQ(collation.size(), 11);
    EXPECT_TRUE(boost::algorithm::equal(collation.begin(), collation.end(), ces, ces + 11))
        << "from:     " << ce_dumper(cps)
        << "expected: " << ce_dumper(ces)
        << "got:      " << ce_dumper(collation);
}

TEST(collation, non_ignorable_111_138)
{
    // 1E32 0041;	
    // (·∏≤) LATIN CAPITAL LETTER K WITH DOT BELOW	[1DCB 1CAD | 0020 0042 0020 | 0008 0002 0008 |]

    uint32_t cps[2] = { 0x1E32, 0x0041 };
    uint32_t const ces[11] = { 0x1DCB, 0x1CAD, 0x0000, 0x0020, 0x0042, 0x0020, 0x0000, 0x0008, 0x0002, 0x0008, 0x0000 };

    auto collation = collate_for_tests(
        cps, cps + 2, boost::text::variable_weighting::non_ignorable);

    EXPECT_EQ(collation.size(), 11);
    EXPECT_TRUE(boost::algorithm::equal(collation.begin(), collation.end(), ces, ces + 11))
        << "from:     " << ce_dumper(cps)
        << "expected: " << ce_dumper(ces)
        << "got:      " << ce_dumper(collation);
}

TEST(collation, non_ignorable_111_139)
{
    // 1E35 0061;	
    // (·∏µ) LATIN SMALL LETTER K WITH LINE BELOW	[1DCB 1CAD | 0020 0049 0020 | 0002 0002 0002 |]

    uint32_t cps[2] = { 0x1E35, 0x0061 };
    uint32_t const ces[11] = { 0x1DCB, 0x1CAD, 0x0000, 0x0020, 0x0049, 0x0020, 0x0000, 0x0002, 0x0002, 0x0002, 0x0000 };

    auto collation = collate_for_tests(
        cps, cps + 2, boost::text::variable_weighting::non_ignorable);

    EXPECT_EQ(collation.size(), 11);
    EXPECT_TRUE(boost::algorithm::equal(collation.begin(), collation.end(), ces, ces + 11))
        << "from:     " << ce_dumper(cps)
        << "expected: " << ce_dumper(ces)
        << "got:      " << ce_dumper(collation);
}

TEST(collation, non_ignorable_111_140)
{
    // 1E35 0041;	
    // (·∏µ) LATIN SMALL LETTER K WITH LINE BELOW	[1DCB 1CAD | 0020 0049 0020 | 0002 0002 0008 |]

    uint32_t cps[2] = { 0x1E35, 0x0041 };
    uint32_t const ces[11] = { 0x1DCB, 0x1CAD, 0x0000, 0x0020, 0x0049, 0x0020, 0x0000, 0x0002, 0x0002, 0x0008, 0x0000 };

    auto collation = collate_for_tests(
        cps, cps + 2, boost::text::variable_weighting::non_ignorable);

    EXPECT_EQ(collation.size(), 11);
    EXPECT_TRUE(boost::algorithm::equal(collation.begin(), collation.end(), ces, ces + 11))
        << "from:     " << ce_dumper(cps)
        << "expected: " << ce_dumper(ces)
        << "got:      " << ce_dumper(collation);
}

TEST(collation, non_ignorable_111_141)
{
    // 1E34 0061;	
    // (·∏¥) LATIN CAPITAL LETTER K WITH LINE BELOW	[1DCB 1CAD | 0020 0049 0020 | 0008 0002 0002 |]

    uint32_t cps[2] = { 0x1E34, 0x0061 };
    uint32_t const ces[11] = { 0x1DCB, 0x1CAD, 0x0000, 0x0020, 0x0049, 0x0020, 0x0000, 0x0008, 0x0002, 0x0002, 0x0000 };

    auto collation = collate_for_tests(
        cps, cps + 2, boost::text::variable_weighting::non_ignorable);

    EXPECT_EQ(collation.size(), 11);
    EXPECT_TRUE(boost::algorithm::equal(collation.begin(), collation.end(), ces, ces + 11))
        << "from:     " << ce_dumper(cps)
        << "expected: " << ce_dumper(ces)
        << "got:      " << ce_dumper(collation);
}

TEST(collation, non_ignorable_111_142)
{
    // 1E34 0041;	
    // (·∏¥) LATIN CAPITAL LETTER K WITH LINE BELOW	[1DCB 1CAD | 0020 0049 0020 | 0008 0002 0008 |]

    uint32_t cps[2] = { 0x1E34, 0x0041 };
    uint32_t const ces[11] = { 0x1DCB, 0x1CAD, 0x0000, 0x0020, 0x0049, 0x0020, 0x0000, 0x0008, 0x0002, 0x0008, 0x0000 };

    auto collation = collate_for_tests(
        cps, cps + 2, boost::text::variable_weighting::non_ignorable);

    EXPECT_EQ(collation.size(), 11);
    EXPECT_TRUE(boost::algorithm::equal(collation.begin(), collation.end(), ces, ces + 11))
        << "from:     " << ce_dumper(cps)
        << "expected: " << ce_dumper(ces)
        << "got:      " << ce_dumper(collation);
}

TEST(collation, non_ignorable_111_143)
{
    // 3384 0021;	
    // („éÑ) SQUARE KA	[1DCB 1CAD 0261 | 0020 0020 0020 | 001C 001D 0002 |]

    uint32_t cps[2] = { 0x3384, 0x0021 };
    uint32_t const ces[12] = { 0x1DCB, 0x1CAD, 0x0261, 0x0000, 0x0020, 0x0020, 0x0020, 0x0000, 0x001C, 0x001D, 0x0002, 0x0000 };

    auto collation = collate_for_tests(
        cps, cps + 2, boost::text::variable_weighting::non_ignorable);

    EXPECT_EQ(collation.size(), 12);
    EXPECT_TRUE(boost::algorithm::equal(collation.begin(), collation.end(), ces, ces + 12))
        << "from:     " << ce_dumper(cps)
        << "expected: " << ce_dumper(ces)
        << "got:      " << ce_dumper(collation);
}

TEST(collation, non_ignorable_111_144)
{
    // 3384 003F;	
    // („éÑ) SQUARE KA	[1DCB 1CAD 0267 | 0020 0020 0020 | 001C 001D 0002 |]

    uint32_t cps[2] = { 0x3384, 0x003F };
    uint32_t const ces[12] = { 0x1DCB, 0x1CAD, 0x0267, 0x0000, 0x0020, 0x0020, 0x0020, 0x0000, 0x001C, 0x001D, 0x0002, 0x0000 };

    auto collation = collate_for_tests(
        cps, cps + 2, boost::text::variable_weighting::non_ignorable);

    EXPECT_EQ(collation.size(), 12);
    EXPECT_TRUE(boost::algorithm::equal(collation.begin(), collation.end(), ces, ces + 12))
        << "from:     " << ce_dumper(cps)
        << "expected: " << ce_dumper(ces)
        << "got:      " << ce_dumper(collation);
}

TEST(collation, non_ignorable_111_145)
{
    // 3384 0061;	
    // („éÑ) SQUARE KA	[1DCB 1CAD 1CAD | 0020 0020 0020 | 001C 001D 0002 |]

    uint32_t cps[2] = { 0x3384, 0x0061 };
    uint32_t const ces[12] = { 0x1DCB, 0x1CAD, 0x1CAD, 0x0000, 0x0020, 0x0020, 0x0020, 0x0000, 0x001C, 0x001D, 0x0002, 0x0000 };

    auto collation = collate_for_tests(
        cps, cps + 2, boost::text::variable_weighting::non_ignorable);

    EXPECT_EQ(collation.size(), 12);
    EXPECT_TRUE(boost::algorithm::equal(collation.begin(), collation.end(), ces, ces + 12))
        << "from:     " << ce_dumper(cps)
        << "expected: " << ce_dumper(ces)
        << "got:      " << ce_dumper(collation);
}

TEST(collation, non_ignorable_111_146)
{
    // 3384 0041;	
    // („éÑ) SQUARE KA	[1DCB 1CAD 1CAD | 0020 0020 0020 | 001C 001D 0008 |]

    uint32_t cps[2] = { 0x3384, 0x0041 };
    uint32_t const ces[12] = { 0x1DCB, 0x1CAD, 0x1CAD, 0x0000, 0x0020, 0x0020, 0x0020, 0x0000, 0x001C, 0x001D, 0x0008, 0x0000 };

    auto collation = collate_for_tests(
        cps, cps + 2, boost::text::variable_weighting::non_ignorable);

    EXPECT_EQ(collation.size(), 12);
    EXPECT_TRUE(boost::algorithm::equal(collation.begin(), collation.end(), ces, ces + 12))
        << "from:     " << ce_dumper(cps)
        << "expected: " << ce_dumper(ces)
        << "got:      " << ce_dumper(collation);
}

TEST(collation, non_ignorable_111_147)
{
    // 3384 0062;	
    // („éÑ) SQUARE KA	[1DCB 1CAD 1CC6 | 0020 0020 0020 | 001C 001D 0002 |]

    uint32_t cps[2] = { 0x3384, 0x0062 };
    uint32_t const ces[12] = { 0x1DCB, 0x1CAD, 0x1CC6, 0x0000, 0x0020, 0x0020, 0x0020, 0x0000, 0x001C, 0x001D, 0x0002, 0x0000 };

    auto collation = collate_for_tests(
        cps, cps + 2, boost::text::variable_weighting::non_ignorable);

    EXPECT_EQ(collation.size(), 12);
    EXPECT_TRUE(boost::algorithm::equal(collation.begin(), collation.end(), ces, ces + 12))
        << "from:     " << ce_dumper(cps)
        << "expected: " << ce_dumper(ces)
        << "got:      " << ce_dumper(collation);
}

TEST(collation, non_ignorable_111_148)
{
    // 006B 0062;	
    // (k) LATIN SMALL LETTER K	[1DCB 1CC6 | 0020 0020 | 0002 0002 |]

    uint32_t cps[2] = { 0x006B, 0x0062 };
    uint32_t const ces[9] = { 0x1DCB, 0x1CC6, 0x0000, 0x0020, 0x0020, 0x0000, 0x0002, 0x0002, 0x0000 };

    auto collation = collate_for_tests(
        cps, cps + 2, boost::text::variable_weighting::non_ignorable);

    EXPECT_EQ(collation.size(), 9);
    EXPECT_TRUE(boost::algorithm::equal(collation.begin(), collation.end(), ces, ces + 9))
        << "from:     " << ce_dumper(cps)
        << "expected: " << ce_dumper(ces)
        << "got:      " << ce_dumper(collation);
}

TEST(collation, non_ignorable_111_149)
{
    // FF4B 0062;	
    // (ÔΩã) FULLWIDTH LATIN SMALL LETTER K	[1DCB 1CC6 | 0020 0020 | 0003 0002 |]

    uint32_t cps[2] = { 0xFF4B, 0x0062 };
    uint32_t const ces[9] = { 0x1DCB, 0x1CC6, 0x0000, 0x0020, 0x0020, 0x0000, 0x0003, 0x0002, 0x0000 };

    auto collation = collate_for_tests(
        cps, cps + 2, boost::text::variable_weighting::non_ignorable);

    EXPECT_EQ(collation.size(), 9);
    EXPECT_TRUE(boost::algorithm::equal(collation.begin(), collation.end(), ces, ces + 9))
        << "from:     " << ce_dumper(cps)
        << "expected: " << ce_dumper(ces)
        << "got:      " << ce_dumper(collation);
}

TEST(collation, non_ignorable_111_150)
{
    // 1DDC 0062;	
    // (·∑ú) COMBINING LATIN SMALL LETTER K	[1DCB 1CC6 | 0020 0020 | 0004 0002 |]

    uint32_t cps[2] = { 0x1DDC, 0x0062 };
    uint32_t const ces[9] = { 0x1DCB, 0x1CC6, 0x0000, 0x0020, 0x0020, 0x0000, 0x0004, 0x0002, 0x0000 };

    auto collation = collate_for_tests(
        cps, cps + 2, boost::text::variable_weighting::non_ignorable);

    EXPECT_EQ(collation.size(), 9);
    EXPECT_TRUE(boost::algorithm::equal(collation.begin(), collation.end(), ces, ces + 9))
        << "from:     " << ce_dumper(cps)
        << "expected: " << ce_dumper(ces)
        << "got:      " << ce_dumper(collation);
}

TEST(collation, non_ignorable_111_151)
{
    // 1D424 0062;	
    // (ùê§) MATHEMATICAL BOLD SMALL K	[1DCB 1CC6 | 0020 0020 | 0005 0002 |]

    uint32_t cps[2] = { 0x1D424, 0x0062 };
    uint32_t const ces[9] = { 0x1DCB, 0x1CC6, 0x0000, 0x0020, 0x0020, 0x0000, 0x0005, 0x0002, 0x0000 };

    auto collation = collate_for_tests(
        cps, cps + 2, boost::text::variable_weighting::non_ignorable);

    EXPECT_EQ(collation.size(), 9);
    EXPECT_TRUE(boost::algorithm::equal(collation.begin(), collation.end(), ces, ces + 9))
        << "from:     " << ce_dumper(cps)
        << "expected: " << ce_dumper(ces)
        << "got:      " << ce_dumper(collation);
}

TEST(collation, non_ignorable_111_152)
{
    // 1D458 0062;	
    // (ùëò) MATHEMATICAL ITALIC SMALL K	[1DCB 1CC6 | 0020 0020 | 0005 0002 |]

    uint32_t cps[2] = { 0x1D458, 0x0062 };
    uint32_t const ces[9] = { 0x1DCB, 0x1CC6, 0x0000, 0x0020, 0x0020, 0x0000, 0x0005, 0x0002, 0x0000 };

    auto collation = collate_for_tests(
        cps, cps + 2, boost::text::variable_weighting::non_ignorable);

    EXPECT_EQ(collation.size(), 9);
    EXPECT_TRUE(boost::algorithm::equal(collation.begin(), collation.end(), ces, ces + 9))
        << "from:     " << ce_dumper(cps)
        << "expected: " << ce_dumper(ces)
        << "got:      " << ce_dumper(collation);
}

TEST(collation, non_ignorable_111_153)
{
    // 1D48C 0062;	
    // (ùíå) MATHEMATICAL BOLD ITALIC SMALL K	[1DCB 1CC6 | 0020 0020 | 0005 0002 |]

    uint32_t cps[2] = { 0x1D48C, 0x0062 };
    uint32_t const ces[9] = { 0x1DCB, 0x1CC6, 0x0000, 0x0020, 0x0020, 0x0000, 0x0005, 0x0002, 0x0000 };

    auto collation = collate_for_tests(
        cps, cps + 2, boost::text::variable_weighting::non_ignorable);

    EXPECT_EQ(collation.size(), 9);
    EXPECT_TRUE(boost::algorithm::equal(collation.begin(), collation.end(), ces, ces + 9))
        << "from:     " << ce_dumper(cps)
        << "expected: " << ce_dumper(ces)
        << "got:      " << ce_dumper(collation);
}

TEST(collation, non_ignorable_111_154)
{
    // 1D4C0 0062;	
    // (ùìÄ) MATHEMATICAL SCRIPT SMALL K	[1DCB 1CC6 | 0020 0020 | 0005 0002 |]

    uint32_t cps[2] = { 0x1D4C0, 0x0062 };
    uint32_t const ces[9] = { 0x1DCB, 0x1CC6, 0x0000, 0x0020, 0x0020, 0x0000, 0x0005, 0x0002, 0x0000 };

    auto collation = collate_for_tests(
        cps, cps + 2, boost::text::variable_weighting::non_ignorable);

    EXPECT_EQ(collation.size(), 9);
    EXPECT_TRUE(boost::algorithm::equal(collation.begin(), collation.end(), ces, ces + 9))
        << "from:     " << ce_dumper(cps)
        << "expected: " << ce_dumper(ces)
        << "got:      " << ce_dumper(collation);
}

TEST(collation, non_ignorable_111_155)
{
    // 1D4F4 0062;	
    // (ùì¥) MATHEMATICAL BOLD SCRIPT SMALL K	[1DCB 1CC6 | 0020 0020 | 0005 0002 |]

    uint32_t cps[2] = { 0x1D4F4, 0x0062 };
    uint32_t const ces[9] = { 0x1DCB, 0x1CC6, 0x0000, 0x0020, 0x0020, 0x0000, 0x0005, 0x0002, 0x0000 };

    auto collation = collate_for_tests(
        cps, cps + 2, boost::text::variable_weighting::non_ignorable);

    EXPECT_EQ(collation.size(), 9);
    EXPECT_TRUE(boost::algorithm::equal(collation.begin(), collation.end(), ces, ces + 9))
        << "from:     " << ce_dumper(cps)
        << "expected: " << ce_dumper(ces)
        << "got:      " << ce_dumper(collation);
}

TEST(collation, non_ignorable_111_156)
{
    // 1D528 0062;	
    // (ùî®) MATHEMATICAL FRAKTUR SMALL K	[1DCB 1CC6 | 0020 0020 | 0005 0002 |]

    uint32_t cps[2] = { 0x1D528, 0x0062 };
    uint32_t const ces[9] = { 0x1DCB, 0x1CC6, 0x0000, 0x0020, 0x0020, 0x0000, 0x0005, 0x0002, 0x0000 };

    auto collation = collate_for_tests(
        cps, cps + 2, boost::text::variable_weighting::non_ignorable);

    EXPECT_EQ(collation.size(), 9);
    EXPECT_TRUE(boost::algorithm::equal(collation.begin(), collation.end(), ces, ces + 9))
        << "from:     " << ce_dumper(cps)
        << "expected: " << ce_dumper(ces)
        << "got:      " << ce_dumper(collation);
}

TEST(collation, non_ignorable_111_157)
{
    // 1D55C 0062;	
    // (ùïú) MATHEMATICAL DOUBLE-STRUCK SMALL K	[1DCB 1CC6 | 0020 0020 | 0005 0002 |]

    uint32_t cps[2] = { 0x1D55C, 0x0062 };
    uint32_t const ces[9] = { 0x1DCB, 0x1CC6, 0x0000, 0x0020, 0x0020, 0x0000, 0x0005, 0x0002, 0x0000 };

    auto collation = collate_for_tests(
        cps, cps + 2, boost::text::variable_weighting::non_ignorable);

    EXPECT_EQ(collation.size(), 9);
    EXPECT_TRUE(boost::algorithm::equal(collation.begin(), collation.end(), ces, ces + 9))
        << "from:     " << ce_dumper(cps)
        << "expected: " << ce_dumper(ces)
        << "got:      " << ce_dumper(collation);
}

TEST(collation, non_ignorable_111_158)
{
    // 1D590 0062;	
    // (ùñê) MATHEMATICAL BOLD FRAKTUR SMALL K	[1DCB 1CC6 | 0020 0020 | 0005 0002 |]

    uint32_t cps[2] = { 0x1D590, 0x0062 };
    uint32_t const ces[9] = { 0x1DCB, 0x1CC6, 0x0000, 0x0020, 0x0020, 0x0000, 0x0005, 0x0002, 0x0000 };

    auto collation = collate_for_tests(
        cps, cps + 2, boost::text::variable_weighting::non_ignorable);

    EXPECT_EQ(collation.size(), 9);
    EXPECT_TRUE(boost::algorithm::equal(collation.begin(), collation.end(), ces, ces + 9))
        << "from:     " << ce_dumper(cps)
        << "expected: " << ce_dumper(ces)
        << "got:      " << ce_dumper(collation);
}

TEST(collation, non_ignorable_111_159)
{
    // 1D5C4 0062;	
    // (ùóÑ) MATHEMATICAL SANS-SERIF SMALL K	[1DCB 1CC6 | 0020 0020 | 0005 0002 |]

    uint32_t cps[2] = { 0x1D5C4, 0x0062 };
    uint32_t const ces[9] = { 0x1DCB, 0x1CC6, 0x0000, 0x0020, 0x0020, 0x0000, 0x0005, 0x0002, 0x0000 };

    auto collation = collate_for_tests(
        cps, cps + 2, boost::text::variable_weighting::non_ignorable);

    EXPECT_EQ(collation.size(), 9);
    EXPECT_TRUE(boost::algorithm::equal(collation.begin(), collation.end(), ces, ces + 9))
        << "from:     " << ce_dumper(cps)
        << "expected: " << ce_dumper(ces)
        << "got:      " << ce_dumper(collation);
}

TEST(collation, non_ignorable_111_160)
{
    // 1D5F8 0062;	
    // (ùó∏) MATHEMATICAL SANS-SERIF BOLD SMALL K	[1DCB 1CC6 | 0020 0020 | 0005 0002 |]

    uint32_t cps[2] = { 0x1D5F8, 0x0062 };
    uint32_t const ces[9] = { 0x1DCB, 0x1CC6, 0x0000, 0x0020, 0x0020, 0x0000, 0x0005, 0x0002, 0x0000 };

    auto collation = collate_for_tests(
        cps, cps + 2, boost::text::variable_weighting::non_ignorable);

    EXPECT_EQ(collation.size(), 9);
    EXPECT_TRUE(boost::algorithm::equal(collation.begin(), collation.end(), ces, ces + 9))
        << "from:     " << ce_dumper(cps)
        << "expected: " << ce_dumper(ces)
        << "got:      " << ce_dumper(collation);
}

TEST(collation, non_ignorable_111_161)
{
    // 1D62C 0062;	
    // (ùò¨) MATHEMATICAL SANS-SERIF ITALIC SMALL K	[1DCB 1CC6 | 0020 0020 | 0005 0002 |]

    uint32_t cps[2] = { 0x1D62C, 0x0062 };
    uint32_t const ces[9] = { 0x1DCB, 0x1CC6, 0x0000, 0x0020, 0x0020, 0x0000, 0x0005, 0x0002, 0x0000 };

    auto collation = collate_for_tests(
        cps, cps + 2, boost::text::variable_weighting::non_ignorable);

    EXPECT_EQ(collation.size(), 9);
    EXPECT_TRUE(boost::algorithm::equal(collation.begin(), collation.end(), ces, ces + 9))
        << "from:     " << ce_dumper(cps)
        << "expected: " << ce_dumper(ces)
        << "got:      " << ce_dumper(collation);
}

TEST(collation, non_ignorable_111_162)
{
    // 1D660 0062;	
    // (ùô†) MATHEMATICAL SANS-SERIF BOLD ITALIC SMALL K	[1DCB 1CC6 | 0020 0020 | 0005 0002 |]

    uint32_t cps[2] = { 0x1D660, 0x0062 };
    uint32_t const ces[9] = { 0x1DCB, 0x1CC6, 0x0000, 0x0020, 0x0020, 0x0000, 0x0005, 0x0002, 0x0000 };

    auto collation = collate_for_tests(
        cps, cps + 2, boost::text::variable_weighting::non_ignorable);

    EXPECT_EQ(collation.size(), 9);
    EXPECT_TRUE(boost::algorithm::equal(collation.begin(), collation.end(), ces, ces + 9))
        << "from:     " << ce_dumper(cps)
        << "expected: " << ce_dumper(ces)
        << "got:      " << ce_dumper(collation);
}

TEST(collation, non_ignorable_111_163)
{
    // 1D694 0062;	
    // (ùöî) MATHEMATICAL MONOSPACE SMALL K	[1DCB 1CC6 | 0020 0020 | 0005 0002 |]

    uint32_t cps[2] = { 0x1D694, 0x0062 };
    uint32_t const ces[9] = { 0x1DCB, 0x1CC6, 0x0000, 0x0020, 0x0020, 0x0000, 0x0005, 0x0002, 0x0000 };

    auto collation = collate_for_tests(
        cps, cps + 2, boost::text::variable_weighting::non_ignorable);

    EXPECT_EQ(collation.size(), 9);
    EXPECT_TRUE(boost::algorithm::equal(collation.begin(), collation.end(), ces, ces + 9))
        << "from:     " << ce_dumper(cps)
        << "expected: " << ce_dumper(ces)
        << "got:      " << ce_dumper(collation);
}

TEST(collation, non_ignorable_111_164)
{
    // 24DA 0062;	
    // (‚ìö) CIRCLED LATIN SMALL LETTER K	[1DCB 1CC6 | 0020 0020 | 0006 0002 |]

    uint32_t cps[2] = { 0x24DA, 0x0062 };
    uint32_t const ces[9] = { 0x1DCB, 0x1CC6, 0x0000, 0x0020, 0x0020, 0x0000, 0x0006, 0x0002, 0x0000 };

    auto collation = collate_for_tests(
        cps, cps + 2, boost::text::variable_weighting::non_ignorable);

    EXPECT_EQ(collation.size(), 9);
    EXPECT_TRUE(boost::algorithm::equal(collation.begin(), collation.end(), ces, ces + 9))
        << "from:     " << ce_dumper(cps)
        << "expected: " << ce_dumper(ces)
        << "got:      " << ce_dumper(collation);
}

TEST(collation, non_ignorable_111_165)
{
    // 004B 0062;	
    // (K) LATIN CAPITAL LETTER K	[1DCB 1CC6 | 0020 0020 | 0008 0002 |]

    uint32_t cps[2] = { 0x004B, 0x0062 };
    uint32_t const ces[9] = { 0x1DCB, 0x1CC6, 0x0000, 0x0020, 0x0020, 0x0000, 0x0008, 0x0002, 0x0000 };

    auto collation = collate_for_tests(
        cps, cps + 2, boost::text::variable_weighting::non_ignorable);

    EXPECT_EQ(collation.size(), 9);
    EXPECT_TRUE(boost::algorithm::equal(collation.begin(), collation.end(), ces, ces + 9))
        << "from:     " << ce_dumper(cps)
        << "expected: " << ce_dumper(ces)
        << "got:      " << ce_dumper(collation);
}

TEST(collation, non_ignorable_111_166)
{
    // 212A 0062;	
    // (K) KELVIN SIGN	[1DCB 1CC6 | 0020 0020 | 0008 0002 |]

    uint32_t cps[2] = { 0x212A, 0x0062 };
    uint32_t const ces[9] = { 0x1DCB, 0x1CC6, 0x0000, 0x0020, 0x0020, 0x0000, 0x0008, 0x0002, 0x0000 };

    auto collation = collate_for_tests(
        cps, cps + 2, boost::text::variable_weighting::non_ignorable);

    EXPECT_EQ(collation.size(), 9);
    EXPECT_TRUE(boost::algorithm::equal(collation.begin(), collation.end(), ces, ces + 9))
        << "from:     " << ce_dumper(cps)
        << "expected: " << ce_dumper(ces)
        << "got:      " << ce_dumper(collation);
}

TEST(collation, non_ignorable_111_167)
{
    // FF2B 0062;	
    // (Ôº´) FULLWIDTH LATIN CAPITAL LETTER K	[1DCB 1CC6 | 0020 0020 | 0009 0002 |]

    uint32_t cps[2] = { 0xFF2B, 0x0062 };
    uint32_t const ces[9] = { 0x1DCB, 0x1CC6, 0x0000, 0x0020, 0x0020, 0x0000, 0x0009, 0x0002, 0x0000 };

    auto collation = collate_for_tests(
        cps, cps + 2, boost::text::variable_weighting::non_ignorable);

    EXPECT_EQ(collation.size(), 9);
    EXPECT_TRUE(boost::algorithm::equal(collation.begin(), collation.end(), ces, ces + 9))
        << "from:     " << ce_dumper(cps)
        << "expected: " << ce_dumper(ces)
        << "got:      " << ce_dumper(collation);
}

TEST(collation, non_ignorable_111_168)
{
    // 1D40A 0062;	
    // (ùêä) MATHEMATICAL BOLD CAPITAL K	[1DCB 1CC6 | 0020 0020 | 000B 0002 |]

    uint32_t cps[2] = { 0x1D40A, 0x0062 };
    uint32_t const ces[9] = { 0x1DCB, 0x1CC6, 0x0000, 0x0020, 0x0020, 0x0000, 0x000B, 0x0002, 0x0000 };

    auto collation = collate_for_tests(
        cps, cps + 2, boost::text::variable_weighting::non_ignorable);

    EXPECT_EQ(collation.size(), 9);
    EXPECT_TRUE(boost::algorithm::equal(collation.begin(), collation.end(), ces, ces + 9))
        << "from:     " << ce_dumper(cps)
        << "expected: " << ce_dumper(ces)
        << "got:      " << ce_dumper(collation);
}

TEST(collation, non_ignorable_111_169)
{
    // 1D43E 0062;	
    // (ùêæ) MATHEMATICAL ITALIC CAPITAL K	[1DCB 1CC6 | 0020 0020 | 000B 0002 |]

    uint32_t cps[2] = { 0x1D43E, 0x0062 };
    uint32_t const ces[9] = { 0x1DCB, 0x1CC6, 0x0000, 0x0020, 0x0020, 0x0000, 0x000B, 0x0002, 0x0000 };

    auto collation = collate_for_tests(
        cps, cps + 2, boost::text::variable_weighting::non_ignorable);

    EXPECT_EQ(collation.size(), 9);
    EXPECT_TRUE(boost::algorithm::equal(collation.begin(), collation.end(), ces, ces + 9))
        << "from:     " << ce_dumper(cps)
        << "expected: " << ce_dumper(ces)
        << "got:      " << ce_dumper(collation);
}

TEST(collation, non_ignorable_111_170)
{
    // 1D472 0062;	
    // (ùë≤) MATHEMATICAL BOLD ITALIC CAPITAL K	[1DCB 1CC6 | 0020 0020 | 000B 0002 |]

    uint32_t cps[2] = { 0x1D472, 0x0062 };
    uint32_t const ces[9] = { 0x1DCB, 0x1CC6, 0x0000, 0x0020, 0x0020, 0x0000, 0x000B, 0x0002, 0x0000 };

    auto collation = collate_for_tests(
        cps, cps + 2, boost::text::variable_weighting::non_ignorable);

    EXPECT_EQ(collation.size(), 9);
    EXPECT_TRUE(boost::algorithm::equal(collation.begin(), collation.end(), ces, ces + 9))
        << "from:     " << ce_dumper(cps)
        << "expected: " << ce_dumper(ces)
        << "got:      " << ce_dumper(collation);
}

TEST(collation, non_ignorable_111_171)
{
    // 1D4A6 0062;	
    // (ùí¶) MATHEMATICAL SCRIPT CAPITAL K	[1DCB 1CC6 | 0020 0020 | 000B 0002 |]

    uint32_t cps[2] = { 0x1D4A6, 0x0062 };
    uint32_t const ces[9] = { 0x1DCB, 0x1CC6, 0x0000, 0x0020, 0x0020, 0x0000, 0x000B, 0x0002, 0x0000 };

    auto collation = collate_for_tests(
        cps, cps + 2, boost::text::variable_weighting::non_ignorable);

    EXPECT_EQ(collation.size(), 9);
    EXPECT_TRUE(boost::algorithm::equal(collation.begin(), collation.end(), ces, ces + 9))
        << "from:     " << ce_dumper(cps)
        << "expected: " << ce_dumper(ces)
        << "got:      " << ce_dumper(collation);
}

TEST(collation, non_ignorable_111_172)
{
    // 1D4DA 0062;	
    // (ùìö) MATHEMATICAL BOLD SCRIPT CAPITAL K	[1DCB 1CC6 | 0020 0020 | 000B 0002 |]

    uint32_t cps[2] = { 0x1D4DA, 0x0062 };
    uint32_t const ces[9] = { 0x1DCB, 0x1CC6, 0x0000, 0x0020, 0x0020, 0x0000, 0x000B, 0x0002, 0x0000 };

    auto collation = collate_for_tests(
        cps, cps + 2, boost::text::variable_weighting::non_ignorable);

    EXPECT_EQ(collation.size(), 9);
    EXPECT_TRUE(boost::algorithm::equal(collation.begin(), collation.end(), ces, ces + 9))
        << "from:     " << ce_dumper(cps)
        << "expected: " << ce_dumper(ces)
        << "got:      " << ce_dumper(collation);
}

TEST(collation, non_ignorable_111_173)
{
    // 1D50E 0062;	
    // (ùîé) MATHEMATICAL FRAKTUR CAPITAL K	[1DCB 1CC6 | 0020 0020 | 000B 0002 |]

    uint32_t cps[2] = { 0x1D50E, 0x0062 };
    uint32_t const ces[9] = { 0x1DCB, 0x1CC6, 0x0000, 0x0020, 0x0020, 0x0000, 0x000B, 0x0002, 0x0000 };

    auto collation = collate_for_tests(
        cps, cps + 2, boost::text::variable_weighting::non_ignorable);

    EXPECT_EQ(collation.size(), 9);
    EXPECT_TRUE(boost::algorithm::equal(collation.begin(), collation.end(), ces, ces + 9))
        << "from:     " << ce_dumper(cps)
        << "expected: " << ce_dumper(ces)
        << "got:      " << ce_dumper(collation);
}

TEST(collation, non_ignorable_111_174)
{
    // 1D542 0062;	
    // (ùïÇ) MATHEMATICAL DOUBLE-STRUCK CAPITAL K	[1DCB 1CC6 | 0020 0020 | 000B 0002 |]

    uint32_t cps[2] = { 0x1D542, 0x0062 };
    uint32_t const ces[9] = { 0x1DCB, 0x1CC6, 0x0000, 0x0020, 0x0020, 0x0000, 0x000B, 0x0002, 0x0000 };

    auto collation = collate_for_tests(
        cps, cps + 2, boost::text::variable_weighting::non_ignorable);

    EXPECT_EQ(collation.size(), 9);
    EXPECT_TRUE(boost::algorithm::equal(collation.begin(), collation.end(), ces, ces + 9))
        << "from:     " << ce_dumper(cps)
        << "expected: " << ce_dumper(ces)
        << "got:      " << ce_dumper(collation);
}

TEST(collation, non_ignorable_111_175)
{
    // 1D576 0062;	
    // (ùï∂) MATHEMATICAL BOLD FRAKTUR CAPITAL K	[1DCB 1CC6 | 0020 0020 | 000B 0002 |]

    uint32_t cps[2] = { 0x1D576, 0x0062 };
    uint32_t const ces[9] = { 0x1DCB, 0x1CC6, 0x0000, 0x0020, 0x0020, 0x0000, 0x000B, 0x0002, 0x0000 };

    auto collation = collate_for_tests(
        cps, cps + 2, boost::text::variable_weighting::non_ignorable);

    EXPECT_EQ(collation.size(), 9);
    EXPECT_TRUE(boost::algorithm::equal(collation.begin(), collation.end(), ces, ces + 9))
        << "from:     " << ce_dumper(cps)
        << "expected: " << ce_dumper(ces)
        << "got:      " << ce_dumper(collation);
}

TEST(collation, non_ignorable_111_176)
{
    // 1D5AA 0062;	
    // (ùñ™) MATHEMATICAL SANS-SERIF CAPITAL K	[1DCB 1CC6 | 0020 0020 | 000B 0002 |]

    uint32_t cps[2] = { 0x1D5AA, 0x0062 };
    uint32_t const ces[9] = { 0x1DCB, 0x1CC6, 0x0000, 0x0020, 0x0020, 0x0000, 0x000B, 0x0002, 0x0000 };

    auto collation = collate_for_tests(
        cps, cps + 2, boost::text::variable_weighting::non_ignorable);

    EXPECT_EQ(collation.size(), 9);
    EXPECT_TRUE(boost::algorithm::equal(collation.begin(), collation.end(), ces, ces + 9))
        << "from:     " << ce_dumper(cps)
        << "expected: " << ce_dumper(ces)
        << "got:      " << ce_dumper(collation);
}

TEST(collation, non_ignorable_111_177)
{
    // 1D5DE 0062;	
    // (ùóû) MATHEMATICAL SANS-SERIF BOLD CAPITAL K	[1DCB 1CC6 | 0020 0020 | 000B 0002 |]

    uint32_t cps[2] = { 0x1D5DE, 0x0062 };
    uint32_t const ces[9] = { 0x1DCB, 0x1CC6, 0x0000, 0x0020, 0x0020, 0x0000, 0x000B, 0x0002, 0x0000 };

    auto collation = collate_for_tests(
        cps, cps + 2, boost::text::variable_weighting::non_ignorable);

    EXPECT_EQ(collation.size(), 9);
    EXPECT_TRUE(boost::algorithm::equal(collation.begin(), collation.end(), ces, ces + 9))
        << "from:     " << ce_dumper(cps)
        << "expected: " << ce_dumper(ces)
        << "got:      " << ce_dumper(collation);
}

TEST(collation, non_ignorable_111_178)
{
    // 1D612 0062;	
    // (ùòí) MATHEMATICAL SANS-SERIF ITALIC CAPITAL K	[1DCB 1CC6 | 0020 0020 | 000B 0002 |]

    uint32_t cps[2] = { 0x1D612, 0x0062 };
    uint32_t const ces[9] = { 0x1DCB, 0x1CC6, 0x0000, 0x0020, 0x0020, 0x0000, 0x000B, 0x0002, 0x0000 };

    auto collation = collate_for_tests(
        cps, cps + 2, boost::text::variable_weighting::non_ignorable);

    EXPECT_EQ(collation.size(), 9);
    EXPECT_TRUE(boost::algorithm::equal(collation.begin(), collation.end(), ces, ces + 9))
        << "from:     " << ce_dumper(cps)
        << "expected: " << ce_dumper(ces)
        << "got:      " << ce_dumper(collation);
}

TEST(collation, non_ignorable_111_179)
{
    // 1D646 0062;	
    // (ùôÜ) MATHEMATICAL SANS-SERIF BOLD ITALIC CAPITAL K	[1DCB 1CC6 | 0020 0020 | 000B 0002 |]

    uint32_t cps[2] = { 0x1D646, 0x0062 };
    uint32_t const ces[9] = { 0x1DCB, 0x1CC6, 0x0000, 0x0020, 0x0020, 0x0000, 0x000B, 0x0002, 0x0000 };

    auto collation = collate_for_tests(
        cps, cps + 2, boost::text::variable_weighting::non_ignorable);

    EXPECT_EQ(collation.size(), 9);
    EXPECT_TRUE(boost::algorithm::equal(collation.begin(), collation.end(), ces, ces + 9))
        << "from:     " << ce_dumper(cps)
        << "expected: " << ce_dumper(ces)
        << "got:      " << ce_dumper(collation);
}

TEST(collation, non_ignorable_111_180)
{
    // 1D67A 0062;	
    // (ùô∫) MATHEMATICAL MONOSPACE CAPITAL K	[1DCB 1CC6 | 0020 0020 | 000B 0002 |]

    uint32_t cps[2] = { 0x1D67A, 0x0062 };
    uint32_t const ces[9] = { 0x1DCB, 0x1CC6, 0x0000, 0x0020, 0x0020, 0x0000, 0x000B, 0x0002, 0x0000 };

    auto collation = collate_for_tests(
        cps, cps + 2, boost::text::variable_weighting::non_ignorable);

    EXPECT_EQ(collation.size(), 9);
    EXPECT_TRUE(boost::algorithm::equal(collation.begin(), collation.end(), ces, ces + 9))
        << "from:     " << ce_dumper(cps)
        << "expected: " << ce_dumper(ces)
        << "got:      " << ce_dumper(collation);
}

TEST(collation, non_ignorable_111_181)
{
    // 24C0 0062;	
    // (‚ìÄ) CIRCLED LATIN CAPITAL LETTER K	[1DCB 1CC6 | 0020 0020 | 000C 0002 |]

    uint32_t cps[2] = { 0x24C0, 0x0062 };
    uint32_t const ces[9] = { 0x1DCB, 0x1CC6, 0x0000, 0x0020, 0x0020, 0x0000, 0x000C, 0x0002, 0x0000 };

    auto collation = collate_for_tests(
        cps, cps + 2, boost::text::variable_weighting::non_ignorable);

    EXPECT_EQ(collation.size(), 9);
    EXPECT_TRUE(boost::algorithm::equal(collation.begin(), collation.end(), ces, ces + 9))
        << "from:     " << ce_dumper(cps)
        << "expected: " << ce_dumper(ces)
        << "got:      " << ce_dumper(collation);
}

TEST(collation, non_ignorable_111_182)
{
    // 1F15A 0062;	
    // (üÖö) NEGATIVE CIRCLED LATIN CAPITAL LETTER K	[1DCB 1CC6 | 0020 0020 | 000C 0002 |]

    uint32_t cps[2] = { 0x1F15A, 0x0062 };
    uint32_t const ces[9] = { 0x1DCB, 0x1CC6, 0x0000, 0x0020, 0x0020, 0x0000, 0x000C, 0x0002, 0x0000 };

    auto collation = collate_for_tests(
        cps, cps + 2, boost::text::variable_weighting::non_ignorable);

    EXPECT_EQ(collation.size(), 9);
    EXPECT_TRUE(boost::algorithm::equal(collation.begin(), collation.end(), ces, ces + 9))
        << "from:     " << ce_dumper(cps)
        << "expected: " << ce_dumper(ces)
        << "got:      " << ce_dumper(collation);
}

TEST(collation, non_ignorable_111_183)
{
    // 1D4F 0062;	
    // (·µè) MODIFIER LETTER SMALL K	[1DCB 1CC6 | 0020 0020 | 0014 0002 |]

    uint32_t cps[2] = { 0x1D4F, 0x0062 };
    uint32_t const ces[9] = { 0x1DCB, 0x1CC6, 0x0000, 0x0020, 0x0020, 0x0000, 0x0014, 0x0002, 0x0000 };

    auto collation = collate_for_tests(
        cps, cps + 2, boost::text::variable_weighting::non_ignorable);

    EXPECT_EQ(collation.size(), 9);
    EXPECT_TRUE(boost::algorithm::equal(collation.begin(), collation.end(), ces, ces + 9))
        << "from:     " << ce_dumper(cps)
        << "expected: " << ce_dumper(ces)
        << "got:      " << ce_dumper(collation);
}

TEST(collation, non_ignorable_111_184)
{
    // 2096 0062;	
    // (‚Çñ) LATIN SUBSCRIPT SMALL LETTER K	[1DCB 1CC6 | 0020 0020 | 0015 0002 |]

    uint32_t cps[2] = { 0x2096, 0x0062 };
    uint32_t const ces[9] = { 0x1DCB, 0x1CC6, 0x0000, 0x0020, 0x0020, 0x0000, 0x0015, 0x0002, 0x0000 };

    auto collation = collate_for_tests(
        cps, cps + 2, boost::text::variable_weighting::non_ignorable);

    EXPECT_EQ(collation.size(), 9);
    EXPECT_TRUE(boost::algorithm::equal(collation.begin(), collation.end(), ces, ces + 9))
        << "from:     " << ce_dumper(cps)
        << "expected: " << ce_dumper(ces)
        << "got:      " << ce_dumper(collation);
}

TEST(collation, non_ignorable_111_185)
{
    // 1D37 0062;	
    // (·¥∑) MODIFIER LETTER CAPITAL K	[1DCB 1CC6 | 0020 0020 | 001D 0002 |]

    uint32_t cps[2] = { 0x1D37, 0x0062 };
    uint32_t const ces[9] = { 0x1DCB, 0x1CC6, 0x0000, 0x0020, 0x0020, 0x0000, 0x001D, 0x0002, 0x0000 };

    auto collation = collate_for_tests(
        cps, cps + 2, boost::text::variable_weighting::non_ignorable);

    EXPECT_EQ(collation.size(), 9);
    EXPECT_TRUE(boost::algorithm::equal(collation.begin(), collation.end(), ces, ces + 9))
        << "from:     " << ce_dumper(cps)
        << "expected: " << ce_dumper(ces)
        << "got:      " << ce_dumper(collation);
}

TEST(collation, non_ignorable_111_186)
{
    // 1F13A 0062;	
    // (üÑ∫) SQUARED LATIN CAPITAL LETTER K	[1DCB 1CC6 | 0020 0020 | 001D 0002 |]

    uint32_t cps[2] = { 0x1F13A, 0x0062 };
    uint32_t const ces[9] = { 0x1DCB, 0x1CC6, 0x0000, 0x0020, 0x0020, 0x0000, 0x001D, 0x0002, 0x0000 };

    auto collation = collate_for_tests(
        cps, cps + 2, boost::text::variable_weighting::non_ignorable);

    EXPECT_EQ(collation.size(), 9);
    EXPECT_TRUE(boost::algorithm::equal(collation.begin(), collation.end(), ces, ces + 9))
        << "from:     " << ce_dumper(cps)
        << "expected: " << ce_dumper(ces)
        << "got:      " << ce_dumper(collation);
}

TEST(collation, non_ignorable_111_187)
{
    // 1F17A 0062;	
    // (üÖ∫) NEGATIVE SQUARED LATIN CAPITAL LETTER K	[1DCB 1CC6 | 0020 0020 | 001D 0002 |]

    uint32_t cps[2] = { 0x1F17A, 0x0062 };
    uint32_t const ces[9] = { 0x1DCB, 0x1CC6, 0x0000, 0x0020, 0x0020, 0x0000, 0x001D, 0x0002, 0x0000 };

    auto collation = collate_for_tests(
        cps, cps + 2, boost::text::variable_weighting::non_ignorable);

    EXPECT_EQ(collation.size(), 9);
    EXPECT_TRUE(boost::algorithm::equal(collation.begin(), collation.end(), ces, ces + 9))
        << "from:     " << ce_dumper(cps)
        << "expected: " << ce_dumper(ces)
        << "got:      " << ce_dumper(collation);
}

TEST(collation, non_ignorable_111_188)
{
    // 1E31 0062;	
    // (·∏±) LATIN SMALL LETTER K WITH ACUTE	[1DCB 1CC6 | 0020 0024 0020 | 0002 0002 0002 |]

    uint32_t cps[2] = { 0x1E31, 0x0062 };
    uint32_t const ces[11] = { 0x1DCB, 0x1CC6, 0x0000, 0x0020, 0x0024, 0x0020, 0x0000, 0x0002, 0x0002, 0x0002, 0x0000 };

    auto collation = collate_for_tests(
        cps, cps + 2, boost::text::variable_weighting::non_ignorable);

    EXPECT_EQ(collation.size(), 11);
    EXPECT_TRUE(boost::algorithm::equal(collation.begin(), collation.end(), ces, ces + 11))
        << "from:     " << ce_dumper(cps)
        << "expected: " << ce_dumper(ces)
        << "got:      " << ce_dumper(collation);
}

TEST(collation, non_ignorable_111_189)
{
    // 1E30 0062;	
    // (·∏∞) LATIN CAPITAL LETTER K WITH ACUTE	[1DCB 1CC6 | 0020 0024 0020 | 0008 0002 0002 |]

    uint32_t cps[2] = { 0x1E30, 0x0062 };
    uint32_t const ces[11] = { 0x1DCB, 0x1CC6, 0x0000, 0x0020, 0x0024, 0x0020, 0x0000, 0x0008, 0x0002, 0x0002, 0x0000 };

    auto collation = collate_for_tests(
        cps, cps + 2, boost::text::variable_weighting::non_ignorable);

    EXPECT_EQ(collation.size(), 11);
    EXPECT_TRUE(boost::algorithm::equal(collation.begin(), collation.end(), ces, ces + 11))
        << "from:     " << ce_dumper(cps)
        << "expected: " << ce_dumper(ces)
        << "got:      " << ce_dumper(collation);
}

TEST(collation, non_ignorable_111_190)
{
    // 01E9 0062;	
    // («©) LATIN SMALL LETTER K WITH CARON	[1DCB 1CC6 | 0020 0028 0020 | 0002 0002 0002 |]

    uint32_t cps[2] = { 0x01E9, 0x0062 };
    uint32_t const ces[11] = { 0x1DCB, 0x1CC6, 0x0000, 0x0020, 0x0028, 0x0020, 0x0000, 0x0002, 0x0002, 0x0002, 0x0000 };

    auto collation = collate_for_tests(
        cps, cps + 2, boost::text::variable_weighting::non_ignorable);

    EXPECT_EQ(collation.size(), 11);
    EXPECT_TRUE(boost::algorithm::equal(collation.begin(), collation.end(), ces, ces + 11))
        << "from:     " << ce_dumper(cps)
        << "expected: " << ce_dumper(ces)
        << "got:      " << ce_dumper(collation);
}

TEST(collation, non_ignorable_111_191)
{
    // 01E8 0062;	
    // («®) LATIN CAPITAL LETTER K WITH CARON	[1DCB 1CC6 | 0020 0028 0020 | 0008 0002 0002 |]

    uint32_t cps[2] = { 0x01E8, 0x0062 };
    uint32_t const ces[11] = { 0x1DCB, 0x1CC6, 0x0000, 0x0020, 0x0028, 0x0020, 0x0000, 0x0008, 0x0002, 0x0002, 0x0000 };

    auto collation = collate_for_tests(
        cps, cps + 2, boost::text::variable_weighting::non_ignorable);

    EXPECT_EQ(collation.size(), 11);
    EXPECT_TRUE(boost::algorithm::equal(collation.begin(), collation.end(), ces, ces + 11))
        << "from:     " << ce_dumper(cps)
        << "expected: " << ce_dumper(ces)
        << "got:      " << ce_dumper(collation);
}

TEST(collation, non_ignorable_111_192)
{
    // 0137 0062;	
    // (ƒ∑) LATIN SMALL LETTER K WITH CEDILLA	[1DCB 1CC6 | 0020 0030 0020 | 0002 0002 0002 |]

    uint32_t cps[2] = { 0x0137, 0x0062 };
    uint32_t const ces[11] = { 0x1DCB, 0x1CC6, 0x0000, 0x0020, 0x0030, 0x0020, 0x0000, 0x0002, 0x0002, 0x0002, 0x0000 };

    auto collation = collate_for_tests(
        cps, cps + 2, boost::text::variable_weighting::non_ignorable);

    EXPECT_EQ(collation.size(), 11);
    EXPECT_TRUE(boost::algorithm::equal(collation.begin(), collation.end(), ces, ces + 11))
        << "from:     " << ce_dumper(cps)
        << "expected: " << ce_dumper(ces)
        << "got:      " << ce_dumper(collation);
}

TEST(collation, non_ignorable_111_193)
{
    // 0136 0062;	
    // (ƒ∂) LATIN CAPITAL LETTER K WITH CEDILLA	[1DCB 1CC6 | 0020 0030 0020 | 0008 0002 0002 |]

    uint32_t cps[2] = { 0x0136, 0x0062 };
    uint32_t const ces[11] = { 0x1DCB, 0x1CC6, 0x0000, 0x0020, 0x0030, 0x0020, 0x0000, 0x0008, 0x0002, 0x0002, 0x0000 };

    auto collation = collate_for_tests(
        cps, cps + 2, boost::text::variable_weighting::non_ignorable);

    EXPECT_EQ(collation.size(), 11);
    EXPECT_TRUE(boost::algorithm::equal(collation.begin(), collation.end(), ces, ces + 11))
        << "from:     " << ce_dumper(cps)
        << "expected: " << ce_dumper(ces)
        << "got:      " << ce_dumper(collation);
}

TEST(collation, non_ignorable_111_194)
{
    // A7A3 0062;	
    // (Íû£) LATIN SMALL LETTER K WITH OBLIQUE STROKE	[1DCB 1CC6 | 0020 0035 0020 | 0004 0004 0002 |]

    uint32_t cps[2] = { 0xA7A3, 0x0062 };
    uint32_t const ces[11] = { 0x1DCB, 0x1CC6, 0x0000, 0x0020, 0x0035, 0x0020, 0x0000, 0x0004, 0x0004, 0x0002, 0x0000 };

    auto collation = collate_for_tests(
        cps, cps + 2, boost::text::variable_weighting::non_ignorable);

    EXPECT_EQ(collation.size(), 11);
    EXPECT_TRUE(boost::algorithm::equal(collation.begin(), collation.end(), ces, ces + 11))
        << "from:     " << ce_dumper(cps)
        << "expected: " << ce_dumper(ces)
        << "got:      " << ce_dumper(collation);
}

TEST(collation, non_ignorable_111_195)
{
    // A7A2 0062;	
    // (Íû¢) LATIN CAPITAL LETTER K WITH OBLIQUE STROKE	[1DCB 1CC6 | 0020 0035 0020 | 000A 0004 0002 |]

    uint32_t cps[2] = { 0xA7A2, 0x0062 };
    uint32_t const ces[11] = { 0x1DCB, 0x1CC6, 0x0000, 0x0020, 0x0035, 0x0020, 0x0000, 0x000A, 0x0004, 0x0002, 0x0000 };

    auto collation = collate_for_tests(
        cps, cps + 2, boost::text::variable_weighting::non_ignorable);

    EXPECT_EQ(collation.size(), 11);
    EXPECT_TRUE(boost::algorithm::equal(collation.begin(), collation.end(), ces, ces + 11))
        << "from:     " << ce_dumper(cps)
        << "expected: " << ce_dumper(ces)
        << "got:      " << ce_dumper(collation);
}

TEST(collation, non_ignorable_111_196)
{
    // 1E33 0062;	
    // (·∏≥) LATIN SMALL LETTER K WITH DOT BELOW	[1DCB 1CC6 | 0020 0042 0020 | 0002 0002 0002 |]

    uint32_t cps[2] = { 0x1E33, 0x0062 };
    uint32_t const ces[11] = { 0x1DCB, 0x1CC6, 0x0000, 0x0020, 0x0042, 0x0020, 0x0000, 0x0002, 0x0002, 0x0002, 0x0000 };

    auto collation = collate_for_tests(
        cps, cps + 2, boost::text::variable_weighting::non_ignorable);

    EXPECT_EQ(collation.size(), 11);
    EXPECT_TRUE(boost::algorithm::equal(collation.begin(), collation.end(), ces, ces + 11))
        << "from:     " << ce_dumper(cps)
        << "expected: " << ce_dumper(ces)
        << "got:      " << ce_dumper(collation);
}

TEST(collation, non_ignorable_111_197)
{
    // 1E32 0062;	
    // (·∏≤) LATIN CAPITAL LETTER K WITH DOT BELOW	[1DCB 1CC6 | 0020 0042 0020 | 0008 0002 0002 |]

    uint32_t cps[2] = { 0x1E32, 0x0062 };
    uint32_t const ces[11] = { 0x1DCB, 0x1CC6, 0x0000, 0x0020, 0x0042, 0x0020, 0x0000, 0x0008, 0x0002, 0x0002, 0x0000 };

    auto collation = collate_for_tests(
        cps, cps + 2, boost::text::variable_weighting::non_ignorable);

    EXPECT_EQ(collation.size(), 11);
    EXPECT_TRUE(boost::algorithm::equal(collation.begin(), collation.end(), ces, ces + 11))
        << "from:     " << ce_dumper(cps)
        << "expected: " << ce_dumper(ces)
        << "got:      " << ce_dumper(collation);
}

TEST(collation, non_ignorable_111_198)
{
    // 1E35 0062;	
    // (·∏µ) LATIN SMALL LETTER K WITH LINE BELOW	[1DCB 1CC6 | 0020 0049 0020 | 0002 0002 0002 |]

    uint32_t cps[2] = { 0x1E35, 0x0062 };
    uint32_t const ces[11] = { 0x1DCB, 0x1CC6, 0x0000, 0x0020, 0x0049, 0x0020, 0x0000, 0x0002, 0x0002, 0x0002, 0x0000 };

    auto collation = collate_for_tests(
        cps, cps + 2, boost::text::variable_weighting::non_ignorable);

    EXPECT_EQ(collation.size(), 11);
    EXPECT_TRUE(boost::algorithm::equal(collation.begin(), collation.end(), ces, ces + 11))
        << "from:     " << ce_dumper(cps)
        << "expected: " << ce_dumper(ces)
        << "got:      " << ce_dumper(collation);
}

TEST(collation, non_ignorable_111_199)
{
    // 1E34 0062;	
    // (·∏¥) LATIN CAPITAL LETTER K WITH LINE BELOW	[1DCB 1CC6 | 0020 0049 0020 | 0008 0002 0002 |]

    uint32_t cps[2] = { 0x1E34, 0x0062 };
    uint32_t const ces[11] = { 0x1DCB, 0x1CC6, 0x0000, 0x0020, 0x0049, 0x0020, 0x0000, 0x0008, 0x0002, 0x0002, 0x0000 };

    auto collation = collate_for_tests(
        cps, cps + 2, boost::text::variable_weighting::non_ignorable);

    EXPECT_EQ(collation.size(), 11);
    EXPECT_TRUE(boost::algorithm::equal(collation.begin(), collation.end(), ces, ces + 11))
        << "from:     " << ce_dumper(cps)
        << "expected: " << ce_dumper(ces)
        << "got:      " << ce_dumper(collation);
}

TEST(collation, non_ignorable_111_200)
{
    // 3385 0021;	
    // („éÖ) SQUARE KB	[1DCB 1CC6 0261 | 0020 0020 0020 | 001D 001D 0002 |]

    uint32_t cps[2] = { 0x3385, 0x0021 };
    uint32_t const ces[12] = { 0x1DCB, 0x1CC6, 0x0261, 0x0000, 0x0020, 0x0020, 0x0020, 0x0000, 0x001D, 0x001D, 0x0002, 0x0000 };

    auto collation = collate_for_tests(
        cps, cps + 2, boost::text::variable_weighting::non_ignorable);

    EXPECT_EQ(collation.size(), 12);
    EXPECT_TRUE(boost::algorithm::equal(collation.begin(), collation.end(), ces, ces + 12))
        << "from:     " << ce_dumper(cps)
        << "expected: " << ce_dumper(ces)
        << "got:      " << ce_dumper(collation);
}

TEST(collation, non_ignorable_111_201)
{
    // 3385 003F;	
    // („éÖ) SQUARE KB	[1DCB 1CC6 0267 | 0020 0020 0020 | 001D 001D 0002 |]

    uint32_t cps[2] = { 0x3385, 0x003F };
    uint32_t const ces[12] = { 0x1DCB, 0x1CC6, 0x0267, 0x0000, 0x0020, 0x0020, 0x0020, 0x0000, 0x001D, 0x001D, 0x0002, 0x0000 };

    auto collation = collate_for_tests(
        cps, cps + 2, boost::text::variable_weighting::non_ignorable);

    EXPECT_EQ(collation.size(), 12);
    EXPECT_TRUE(boost::algorithm::equal(collation.begin(), collation.end(), ces, ces + 12))
        << "from:     " << ce_dumper(cps)
        << "expected: " << ce_dumper(ces)
        << "got:      " << ce_dumper(collation);
}

TEST(collation, non_ignorable_111_202)
{
    // 3385 0061;	
    // („éÖ) SQUARE KB	[1DCB 1CC6 1CAD | 0020 0020 0020 | 001D 001D 0002 |]

    uint32_t cps[2] = { 0x3385, 0x0061 };
    uint32_t const ces[12] = { 0x1DCB, 0x1CC6, 0x1CAD, 0x0000, 0x0020, 0x0020, 0x0020, 0x0000, 0x001D, 0x001D, 0x0002, 0x0000 };

    auto collation = collate_for_tests(
        cps, cps + 2, boost::text::variable_weighting::non_ignorable);

    EXPECT_EQ(collation.size(), 12);
    EXPECT_TRUE(boost::algorithm::equal(collation.begin(), collation.end(), ces, ces + 12))
        << "from:     " << ce_dumper(cps)
        << "expected: " << ce_dumper(ces)
        << "got:      " << ce_dumper(collation);
}

TEST(collation, non_ignorable_111_203)
{
    // 3385 0041;	
    // („éÖ) SQUARE KB	[1DCB 1CC6 1CAD | 0020 0020 0020 | 001D 001D 0008 |]

    uint32_t cps[2] = { 0x3385, 0x0041 };
    uint32_t const ces[12] = { 0x1DCB, 0x1CC6, 0x1CAD, 0x0000, 0x0020, 0x0020, 0x0020, 0x0000, 0x001D, 0x001D, 0x0008, 0x0000 };

    auto collation = collate_for_tests(
        cps, cps + 2, boost::text::variable_weighting::non_ignorable);

    EXPECT_EQ(collation.size(), 12);
    EXPECT_TRUE(boost::algorithm::equal(collation.begin(), collation.end(), ces, ces + 12))
        << "from:     " << ce_dumper(cps)
        << "expected: " << ce_dumper(ces)
        << "got:      " << ce_dumper(collation);
}

TEST(collation, non_ignorable_111_204)
{
    // 3385 0062;	
    // („éÖ) SQUARE KB	[1DCB 1CC6 1CC6 | 0020 0020 0020 | 001D 001D 0002 |]

    uint32_t cps[2] = { 0x3385, 0x0062 };
    uint32_t const ces[12] = { 0x1DCB, 0x1CC6, 0x1CC6, 0x0000, 0x0020, 0x0020, 0x0020, 0x0000, 0x001D, 0x001D, 0x0002, 0x0000 };

    auto collation = collate_for_tests(
        cps, cps + 2, boost::text::variable_weighting::non_ignorable);

    EXPECT_EQ(collation.size(), 12);
    EXPECT_TRUE(boost::algorithm::equal(collation.begin(), collation.end(), ces, ces + 12))
        << "from:     " << ce_dumper(cps)
        << "expected: " << ce_dumper(ces)
        << "got:      " << ce_dumper(collation);
}

TEST(collation, non_ignorable_111_205)
{
    // 3389 0021;	
    // („éâ) SQUARE KCAL	[1DCB 1CE0 1CAD 1DDD 0261 | 0020 0020 0020 0020 0020 | 001C 001C 001C 001C 0002 |]

    uint32_t cps[2] = { 0x3389, 0x0021 };
    uint32_t const ces[18] = { 0x1DCB, 0x1CE0, 0x1CAD, 0x1DDD, 0x0261, 0x0000, 0x0020, 0x0020, 0x0020, 0x0020, 0x0020, 0x0000, 0x001C, 0x001C, 0x001C, 0x001C, 0x0002, 0x0000 };

    auto collation = collate_for_tests(
        cps, cps + 2, boost::text::variable_weighting::non_ignorable);

    EXPECT_EQ(collation.size(), 18);
    EXPECT_TRUE(boost::algorithm::equal(collation.begin(), collation.end(), ces, ces + 18))
        << "from:     " << ce_dumper(cps)
        << "expected: " << ce_dumper(ces)
        << "got:      " << ce_dumper(collation);
}

TEST(collation, non_ignorable_111_206)
{
    // 3389 003F;	
    // („éâ) SQUARE KCAL	[1DCB 1CE0 1CAD 1DDD 0267 | 0020 0020 0020 0020 0020 | 001C 001C 001C 001C 0002 |]

    uint32_t cps[2] = { 0x3389, 0x003F };
    uint32_t const ces[18] = { 0x1DCB, 0x1CE0, 0x1CAD, 0x1DDD, 0x0267, 0x0000, 0x0020, 0x0020, 0x0020, 0x0020, 0x0020, 0x0000, 0x001C, 0x001C, 0x001C, 0x001C, 0x0002, 0x0000 };

    auto collation = collate_for_tests(
        cps, cps + 2, boost::text::variable_weighting::non_ignorable);

    EXPECT_EQ(collation.size(), 18);
    EXPECT_TRUE(boost::algorithm::equal(collation.begin(), collation.end(), ces, ces + 18))
        << "from:     " << ce_dumper(cps)
        << "expected: " << ce_dumper(ces)
        << "got:      " << ce_dumper(collation);
}

TEST(collation, non_ignorable_111_207)
{
    // 3389 0061;	
    // („éâ) SQUARE KCAL	[1DCB 1CE0 1CAD 1DDD 1CAD | 0020 0020 0020 0020 0020 | 001C 001C 001C 001C 0002 |]

    uint32_t cps[2] = { 0x3389, 0x0061 };
    uint32_t const ces[18] = { 0x1DCB, 0x1CE0, 0x1CAD, 0x1DDD, 0x1CAD, 0x0000, 0x0020, 0x0020, 0x0020, 0x0020, 0x0020, 0x0000, 0x001C, 0x001C, 0x001C, 0x001C, 0x0002, 0x0000 };

    auto collation = collate_for_tests(
        cps, cps + 2, boost::text::variable_weighting::non_ignorable);

    EXPECT_EQ(collation.size(), 18);
    EXPECT_TRUE(boost::algorithm::equal(collation.begin(), collation.end(), ces, ces + 18))
        << "from:     " << ce_dumper(cps)
        << "expected: " << ce_dumper(ces)
        << "got:      " << ce_dumper(collation);
}

TEST(collation, non_ignorable_111_208)
{
    // 3389 0041;	
    // („éâ) SQUARE KCAL	[1DCB 1CE0 1CAD 1DDD 1CAD | 0020 0020 0020 0020 0020 | 001C 001C 001C 001C 0008 |]

    uint32_t cps[2] = { 0x3389, 0x0041 };
    uint32_t const ces[18] = { 0x1DCB, 0x1CE0, 0x1CAD, 0x1DDD, 0x1CAD, 0x0000, 0x0020, 0x0020, 0x0020, 0x0020, 0x0020, 0x0000, 0x001C, 0x001C, 0x001C, 0x001C, 0x0008, 0x0000 };

    auto collation = collate_for_tests(
        cps, cps + 2, boost::text::variable_weighting::non_ignorable);

    EXPECT_EQ(collation.size(), 18);
    EXPECT_TRUE(boost::algorithm::equal(collation.begin(), collation.end(), ces, ces + 18))
        << "from:     " << ce_dumper(cps)
        << "expected: " << ce_dumper(ces)
        << "got:      " << ce_dumper(collation);
}

TEST(collation, non_ignorable_111_209)
{
    // 3389 0062;	
    // („éâ) SQUARE KCAL	[1DCB 1CE0 1CAD 1DDD 1CC6 | 0020 0020 0020 0020 0020 | 001C 001C 001C 001C 0002 |]

    uint32_t cps[2] = { 0x3389, 0x0062 };
    uint32_t const ces[18] = { 0x1DCB, 0x1CE0, 0x1CAD, 0x1DDD, 0x1CC6, 0x0000, 0x0020, 0x0020, 0x0020, 0x0020, 0x0020, 0x0000, 0x001C, 0x001C, 0x001C, 0x001C, 0x0002, 0x0000 };

    auto collation = collate_for_tests(
        cps, cps + 2, boost::text::variable_weighting::non_ignorable);

    EXPECT_EQ(collation.size(), 18);
    EXPECT_TRUE(boost::algorithm::equal(collation.begin(), collation.end(), ces, ces + 18))
        << "from:     " << ce_dumper(cps)
        << "expected: " << ce_dumper(ces)
        << "got:      " << ce_dumper(collation);
}

TEST(collation, non_ignorable_111_210)
{
    // 338F 0021;	
    // („éè) SQUARE KG	[1DCB 1D5A 0261 | 0020 0020 0020 | 001C 001C 0002 |]

    uint32_t cps[2] = { 0x338F, 0x0021 };
    uint32_t const ces[12] = { 0x1DCB, 0x1D5A, 0x0261, 0x0000, 0x0020, 0x0020, 0x0020, 0x0000, 0x001C, 0x001C, 0x0002, 0x0000 };

    auto collation = collate_for_tests(
        cps, cps + 2, boost::text::variable_weighting::non_ignorable);

    EXPECT_EQ(collation.size(), 12);
    EXPECT_TRUE(boost::algorithm::equal(collation.begin(), collation.end(), ces, ces + 12))
        << "from:     " << ce_dumper(cps)
        << "expected: " << ce_dumper(ces)
        << "got:      " << ce_dumper(collation);
}

TEST(collation, non_ignorable_111_211)
{
    // 338F 003F;	
    // („éè) SQUARE KG	[1DCB 1D5A 0267 | 0020 0020 0020 | 001C 001C 0002 |]

    uint32_t cps[2] = { 0x338F, 0x003F };
    uint32_t const ces[12] = { 0x1DCB, 0x1D5A, 0x0267, 0x0000, 0x0020, 0x0020, 0x0020, 0x0000, 0x001C, 0x001C, 0x0002, 0x0000 };

    auto collation = collate_for_tests(
        cps, cps + 2, boost::text::variable_weighting::non_ignorable);

    EXPECT_EQ(collation.size(), 12);
    EXPECT_TRUE(boost::algorithm::equal(collation.begin(), collation.end(), ces, ces + 12))
        << "from:     " << ce_dumper(cps)
        << "expected: " << ce_dumper(ces)
        << "got:      " << ce_dumper(collation);
}

TEST(collation, non_ignorable_111_212)
{
    // 338F 0061;	
    // („éè) SQUARE KG	[1DCB 1D5A 1CAD | 0020 0020 0020 | 001C 001C 0002 |]

    uint32_t cps[2] = { 0x338F, 0x0061 };
    uint32_t const ces[12] = { 0x1DCB, 0x1D5A, 0x1CAD, 0x0000, 0x0020, 0x0020, 0x0020, 0x0000, 0x001C, 0x001C, 0x0002, 0x0000 };

    auto collation = collate_for_tests(
        cps, cps + 2, boost::text::variable_weighting::non_ignorable);

    EXPECT_EQ(collation.size(), 12);
    EXPECT_TRUE(boost::algorithm::equal(collation.begin(), collation.end(), ces, ces + 12))
        << "from:     " << ce_dumper(cps)
        << "expected: " << ce_dumper(ces)
        << "got:      " << ce_dumper(collation);
}

TEST(collation, non_ignorable_111_213)
{
    // 338F 0041;	
    // („éè) SQUARE KG	[1DCB 1D5A 1CAD | 0020 0020 0020 | 001C 001C 0008 |]

    uint32_t cps[2] = { 0x338F, 0x0041 };
    uint32_t const ces[12] = { 0x1DCB, 0x1D5A, 0x1CAD, 0x0000, 0x0020, 0x0020, 0x0020, 0x0000, 0x001C, 0x001C, 0x0008, 0x0000 };

    auto collation = collate_for_tests(
        cps, cps + 2, boost::text::variable_weighting::non_ignorable);

    EXPECT_EQ(collation.size(), 12);
    EXPECT_TRUE(boost::algorithm::equal(collation.begin(), collation.end(), ces, ces + 12))
        << "from:     " << ce_dumper(cps)
        << "expected: " << ce_dumper(ces)
        << "got:      " << ce_dumper(collation);
}

TEST(collation, non_ignorable_111_214)
{
    // 338F 0062;	
    // („éè) SQUARE KG	[1DCB 1D5A 1CC6 | 0020 0020 0020 | 001C 001C 0002 |]

    uint32_t cps[2] = { 0x338F, 0x0062 };
    uint32_t const ces[12] = { 0x1DCB, 0x1D5A, 0x1CC6, 0x0000, 0x0020, 0x0020, 0x0020, 0x0000, 0x001C, 0x001C, 0x0002, 0x0000 };

    auto collation = collate_for_tests(
        cps, cps + 2, boost::text::variable_weighting::non_ignorable);

    EXPECT_EQ(collation.size(), 12);
    EXPECT_TRUE(boost::algorithm::equal(collation.begin(), collation.end(), ces, ces + 12))
        << "from:     " << ce_dumper(cps)
        << "expected: " << ce_dumper(ces)
        << "got:      " << ce_dumper(collation);
}

TEST(collation, non_ignorable_111_215)
{
    // 3391 0021;	
    // („éë) SQUARE KHZ	[1DCB 1D7E 1F87 0261 | 0020 0020 0020 0020 | 001C 001D 001C 0002 |]

    uint32_t cps[2] = { 0x3391, 0x0021 };
    uint32_t const ces[15] = { 0x1DCB, 0x1D7E, 0x1F87, 0x0261, 0x0000, 0x0020, 0x0020, 0x0020, 0x0020, 0x0000, 0x001C, 0x001D, 0x001C, 0x0002, 0x0000 };

    auto collation = collate_for_tests(
        cps, cps + 2, boost::text::variable_weighting::non_ignorable);

    EXPECT_EQ(collation.size(), 15);
    EXPECT_TRUE(boost::algorithm::equal(collation.begin(), collation.end(), ces, ces + 15))
        << "from:     " << ce_dumper(cps)
        << "expected: " << ce_dumper(ces)
        << "got:      " << ce_dumper(collation);
}

TEST(collation, non_ignorable_111_216)
{
    // 3391 003F;	
    // („éë) SQUARE KHZ	[1DCB 1D7E 1F87 0267 | 0020 0020 0020 0020 | 001C 001D 001C 0002 |]

    uint32_t cps[2] = { 0x3391, 0x003F };
    uint32_t const ces[15] = { 0x1DCB, 0x1D7E, 0x1F87, 0x0267, 0x0000, 0x0020, 0x0020, 0x0020, 0x0020, 0x0000, 0x001C, 0x001D, 0x001C, 0x0002, 0x0000 };

    auto collation = collate_for_tests(
        cps, cps + 2, boost::text::variable_weighting::non_ignorable);

    EXPECT_EQ(collation.size(), 15);
    EXPECT_TRUE(boost::algorithm::equal(collation.begin(), collation.end(), ces, ces + 15))
        << "from:     " << ce_dumper(cps)
        << "expected: " << ce_dumper(ces)
        << "got:      " << ce_dumper(collation);
}

TEST(collation, non_ignorable_111_217)
{
    // 3391 0061;	
    // („éë) SQUARE KHZ	[1DCB 1D7E 1F87 1CAD | 0020 0020 0020 0020 | 001C 001D 001C 0002 |]

    uint32_t cps[2] = { 0x3391, 0x0061 };
    uint32_t const ces[15] = { 0x1DCB, 0x1D7E, 0x1F87, 0x1CAD, 0x0000, 0x0020, 0x0020, 0x0020, 0x0020, 0x0000, 0x001C, 0x001D, 0x001C, 0x0002, 0x0000 };

    auto collation = collate_for_tests(
        cps, cps + 2, boost::text::variable_weighting::non_ignorable);

    EXPECT_EQ(collation.size(), 15);
    EXPECT_TRUE(boost::algorithm::equal(collation.begin(), collation.end(), ces, ces + 15))
        << "from:     " << ce_dumper(cps)
        << "expected: " << ce_dumper(ces)
        << "got:      " << ce_dumper(collation);
}

TEST(collation, non_ignorable_111_218)
{
    // 3391 0041;	
    // („éë) SQUARE KHZ	[1DCB 1D7E 1F87 1CAD | 0020 0020 0020 0020 | 001C 001D 001C 0008 |]

    uint32_t cps[2] = { 0x3391, 0x0041 };
    uint32_t const ces[15] = { 0x1DCB, 0x1D7E, 0x1F87, 0x1CAD, 0x0000, 0x0020, 0x0020, 0x0020, 0x0020, 0x0000, 0x001C, 0x001D, 0x001C, 0x0008, 0x0000 };

    auto collation = collate_for_tests(
        cps, cps + 2, boost::text::variable_weighting::non_ignorable);

    EXPECT_EQ(collation.size(), 15);
    EXPECT_TRUE(boost::algorithm::equal(collation.begin(), collation.end(), ces, ces + 15))
        << "from:     " << ce_dumper(cps)
        << "expected: " << ce_dumper(ces)
        << "got:      " << ce_dumper(collation);
}

TEST(collation, non_ignorable_111_219)
{
    // 3391 0062;	
    // („éë) SQUARE KHZ	[1DCB 1D7E 1F87 1CC6 | 0020 0020 0020 0020 | 001C 001D 001C 0002 |]

    uint32_t cps[2] = { 0x3391, 0x0062 };
    uint32_t const ces[15] = { 0x1DCB, 0x1D7E, 0x1F87, 0x1CC6, 0x0000, 0x0020, 0x0020, 0x0020, 0x0020, 0x0000, 0x001C, 0x001D, 0x001C, 0x0002, 0x0000 };

    auto collation = collate_for_tests(
        cps, cps + 2, boost::text::variable_weighting::non_ignorable);

    EXPECT_EQ(collation.size(), 15);
    EXPECT_TRUE(boost::algorithm::equal(collation.begin(), collation.end(), ces, ces + 15))
        << "from:     " << ce_dumper(cps)
        << "expected: " << ce_dumper(ces)
        << "got:      " << ce_dumper(collation);
}

TEST(collation, non_ignorable_111_220)
{
    // 33CD 0021;	
    // („èç) SQUARE KK	[1DCB 1DCB 0261 | 0020 0020 0020 | 001D 001D 0002 |]

    uint32_t cps[2] = { 0x33CD, 0x0021 };
    uint32_t const ces[12] = { 0x1DCB, 0x1DCB, 0x0261, 0x0000, 0x0020, 0x0020, 0x0020, 0x0000, 0x001D, 0x001D, 0x0002, 0x0000 };

    auto collation = collate_for_tests(
        cps, cps + 2, boost::text::variable_weighting::non_ignorable);

    EXPECT_EQ(collation.size(), 12);
    EXPECT_TRUE(boost::algorithm::equal(collation.begin(), collation.end(), ces, ces + 12))
        << "from:     " << ce_dumper(cps)
        << "expected: " << ce_dumper(ces)
        << "got:      " << ce_dumper(collation);
}

TEST(collation, non_ignorable_111_221)
{
    // 33CD 003F;	
    // („èç) SQUARE KK	[1DCB 1DCB 0267 | 0020 0020 0020 | 001D 001D 0002 |]

    uint32_t cps[2] = { 0x33CD, 0x003F };
    uint32_t const ces[12] = { 0x1DCB, 0x1DCB, 0x0267, 0x0000, 0x0020, 0x0020, 0x0020, 0x0000, 0x001D, 0x001D, 0x0002, 0x0000 };

    auto collation = collate_for_tests(
        cps, cps + 2, boost::text::variable_weighting::non_ignorable);

    EXPECT_EQ(collation.size(), 12);
    EXPECT_TRUE(boost::algorithm::equal(collation.begin(), collation.end(), ces, ces + 12))
        << "from:     " << ce_dumper(cps)
        << "expected: " << ce_dumper(ces)
        << "got:      " << ce_dumper(collation);
}

TEST(collation, non_ignorable_111_222)
{
    // 33CD 0061;	
    // („èç) SQUARE KK	[1DCB 1DCB 1CAD | 0020 0020 0020 | 001D 001D 0002 |]

    uint32_t cps[2] = { 0x33CD, 0x0061 };
    uint32_t const ces[12] = { 0x1DCB, 0x1DCB, 0x1CAD, 0x0000, 0x0020, 0x0020, 0x0020, 0x0000, 0x001D, 0x001D, 0x0002, 0x0000 };

    auto collation = collate_for_tests(
        cps, cps + 2, boost::text::variable_weighting::non_ignorable);

    EXPECT_EQ(collation.size(), 12);
    EXPECT_TRUE(boost::algorithm::equal(collation.begin(), collation.end(), ces, ces + 12))
        << "from:     " << ce_dumper(cps)
        << "expected: " << ce_dumper(ces)
        << "got:      " << ce_dumper(collation);
}

TEST(collation, non_ignorable_111_223)
{
    // 33CD 0041;	
    // („èç) SQUARE KK	[1DCB 1DCB 1CAD | 0020 0020 0020 | 001D 001D 0008 |]

    uint32_t cps[2] = { 0x33CD, 0x0041 };
    uint32_t const ces[12] = { 0x1DCB, 0x1DCB, 0x1CAD, 0x0000, 0x0020, 0x0020, 0x0020, 0x0000, 0x001D, 0x001D, 0x0008, 0x0000 };

    auto collation = collate_for_tests(
        cps, cps + 2, boost::text::variable_weighting::non_ignorable);

    EXPECT_EQ(collation.size(), 12);
    EXPECT_TRUE(boost::algorithm::equal(collation.begin(), collation.end(), ces, ces + 12))
        << "from:     " << ce_dumper(cps)
        << "expected: " << ce_dumper(ces)
        << "got:      " << ce_dumper(collation);
}

TEST(collation, non_ignorable_111_224)
{
    // 33CD 0062;	
    // („èç) SQUARE KK	[1DCB 1DCB 1CC6 | 0020 0020 0020 | 001D 001D 0002 |]

    uint32_t cps[2] = { 0x33CD, 0x0062 };
    uint32_t const ces[12] = { 0x1DCB, 0x1DCB, 0x1CC6, 0x0000, 0x0020, 0x0020, 0x0020, 0x0000, 0x001D, 0x001D, 0x0002, 0x0000 };

    auto collation = collate_for_tests(
        cps, cps + 2, boost::text::variable_weighting::non_ignorable);

    EXPECT_EQ(collation.size(), 12);
    EXPECT_TRUE(boost::algorithm::equal(collation.begin(), collation.end(), ces, ces + 12))
        << "from:     " << ce_dumper(cps)
        << "expected: " << ce_dumper(ces)
        << "got:      " << ce_dumper(collation);
}

TEST(collation, non_ignorable_111_225)
{
    // 3398 0021;	
    // („éò) SQUARE KL	[1DCB 1DDD 0261 | 0020 0020 0020 | 001C 001C 0002 |]

    uint32_t cps[2] = { 0x3398, 0x0021 };
    uint32_t const ces[12] = { 0x1DCB, 0x1DDD, 0x0261, 0x0000, 0x0020, 0x0020, 0x0020, 0x0000, 0x001C, 0x001C, 0x0002, 0x0000 };

    auto collation = collate_for_tests(
        cps, cps + 2, boost::text::variable_weighting::non_ignorable);

    EXPECT_EQ(collation.size(), 12);
    EXPECT_TRUE(boost::algorithm::equal(collation.begin(), collation.end(), ces, ces + 12))
        << "from:     " << ce_dumper(cps)
        << "expected: " << ce_dumper(ces)
        << "got:      " << ce_dumper(collation);
}

TEST(collation, non_ignorable_111_226)
{
    // 3398 003F;	
    // („éò) SQUARE KL	[1DCB 1DDD 0267 | 0020 0020 0020 | 001C 001C 0002 |]

    uint32_t cps[2] = { 0x3398, 0x003F };
    uint32_t const ces[12] = { 0x1DCB, 0x1DDD, 0x0267, 0x0000, 0x0020, 0x0020, 0x0020, 0x0000, 0x001C, 0x001C, 0x0002, 0x0000 };

    auto collation = collate_for_tests(
        cps, cps + 2, boost::text::variable_weighting::non_ignorable);

    EXPECT_EQ(collation.size(), 12);
    EXPECT_TRUE(boost::algorithm::equal(collation.begin(), collation.end(), ces, ces + 12))
        << "from:     " << ce_dumper(cps)
        << "expected: " << ce_dumper(ces)
        << "got:      " << ce_dumper(collation);
}

TEST(collation, non_ignorable_111_227)
{
    // 3398 0061;	
    // („éò) SQUARE KL	[1DCB 1DDD 1CAD | 0020 0020 0020 | 001C 001C 0002 |]

    uint32_t cps[2] = { 0x3398, 0x0061 };
    uint32_t const ces[12] = { 0x1DCB, 0x1DDD, 0x1CAD, 0x0000, 0x0020, 0x0020, 0x0020, 0x0000, 0x001C, 0x001C, 0x0002, 0x0000 };

    auto collation = collate_for_tests(
        cps, cps + 2, boost::text::variable_weighting::non_ignorable);

    EXPECT_EQ(collation.size(), 12);
    EXPECT_TRUE(boost::algorithm::equal(collation.begin(), collation.end(), ces, ces + 12))
        << "from:     " << ce_dumper(cps)
        << "expected: " << ce_dumper(ces)
        << "got:      " << ce_dumper(collation);
}

TEST(collation, non_ignorable_111_228)
{
    // 3398 0041;	
    // („éò) SQUARE KL	[1DCB 1DDD 1CAD | 0020 0020 0020 | 001C 001C 0008 |]

    uint32_t cps[2] = { 0x3398, 0x0041 };
    uint32_t const ces[12] = { 0x1DCB, 0x1DDD, 0x1CAD, 0x0000, 0x0020, 0x0020, 0x0020, 0x0000, 0x001C, 0x001C, 0x0008, 0x0000 };

    auto collation = collate_for_tests(
        cps, cps + 2, boost::text::variable_weighting::non_ignorable);

    EXPECT_EQ(collation.size(), 12);
    EXPECT_TRUE(boost::algorithm::equal(collation.begin(), collation.end(), ces, ces + 12))
        << "from:     " << ce_dumper(cps)
        << "expected: " << ce_dumper(ces)
        << "got:      " << ce_dumper(collation);
}

TEST(collation, non_ignorable_111_229)
{
    // 3398 0062;	
    // („éò) SQUARE KL	[1DCB 1DDD 1CC6 | 0020 0020 0020 | 001C 001C 0002 |]

    uint32_t cps[2] = { 0x3398, 0x0062 };
    uint32_t const ces[12] = { 0x1DCB, 0x1DDD, 0x1CC6, 0x0000, 0x0020, 0x0020, 0x0020, 0x0000, 0x001C, 0x001C, 0x0002, 0x0000 };

    auto collation = collate_for_tests(
        cps, cps + 2, boost::text::variable_weighting::non_ignorable);

    EXPECT_EQ(collation.size(), 12);
    EXPECT_TRUE(boost::algorithm::equal(collation.begin(), collation.end(), ces, ces + 12))
        << "from:     " << ce_dumper(cps)
        << "expected: " << ce_dumper(ces)
        << "got:      " << ce_dumper(collation);
}

TEST(collation, non_ignorable_111_230)
{
    // 339E 0021;	
    // („éû) SQUARE KM	[1DCB 1E10 0261 | 0020 0020 0020 | 001C 001C 0002 |]

    uint32_t cps[2] = { 0x339E, 0x0021 };
    uint32_t const ces[12] = { 0x1DCB, 0x1E10, 0x0261, 0x0000, 0x0020, 0x0020, 0x0020, 0x0000, 0x001C, 0x001C, 0x0002, 0x0000 };

    auto collation = collate_for_tests(
        cps, cps + 2, boost::text::variable_weighting::non_ignorable);

    EXPECT_EQ(collation.size(), 12);
    EXPECT_TRUE(boost::algorithm::equal(collation.begin(), collation.end(), ces, ces + 12))
        << "from:     " << ce_dumper(cps)
        << "expected: " << ce_dumper(ces)
        << "got:      " << ce_dumper(collation);
}

TEST(collation, non_ignorable_111_231)
{
    // 33CE 0021;	
    // („èé) SQUARE KM CAPITAL	[1DCB 1E10 0261 | 0020 0020 0020 | 001D 001D 0002 |]

    uint32_t cps[2] = { 0x33CE, 0x0021 };
    uint32_t const ces[12] = { 0x1DCB, 0x1E10, 0x0261, 0x0000, 0x0020, 0x0020, 0x0020, 0x0000, 0x001D, 0x001D, 0x0002, 0x0000 };

    auto collation = collate_for_tests(
        cps, cps + 2, boost::text::variable_weighting::non_ignorable);

    EXPECT_EQ(collation.size(), 12);
    EXPECT_TRUE(boost::algorithm::equal(collation.begin(), collation.end(), ces, ces + 12))
        << "from:     " << ce_dumper(cps)
        << "expected: " << ce_dumper(ces)
        << "got:      " << ce_dumper(collation);
}

TEST(collation, non_ignorable_111_232)
{
    // 339E 003F;	
    // („éû) SQUARE KM	[1DCB 1E10 0267 | 0020 0020 0020 | 001C 001C 0002 |]

    uint32_t cps[2] = { 0x339E, 0x003F };
    uint32_t const ces[12] = { 0x1DCB, 0x1E10, 0x0267, 0x0000, 0x0020, 0x0020, 0x0020, 0x0000, 0x001C, 0x001C, 0x0002, 0x0000 };

    auto collation = collate_for_tests(
        cps, cps + 2, boost::text::variable_weighting::non_ignorable);

    EXPECT_EQ(collation.size(), 12);
    EXPECT_TRUE(boost::algorithm::equal(collation.begin(), collation.end(), ces, ces + 12))
        << "from:     " << ce_dumper(cps)
        << "expected: " << ce_dumper(ces)
        << "got:      " << ce_dumper(collation);
}

TEST(collation, non_ignorable_111_233)
{
    // 33CE 003F;	
    // („èé) SQUARE KM CAPITAL	[1DCB 1E10 0267 | 0020 0020 0020 | 001D 001D 0002 |]

    uint32_t cps[2] = { 0x33CE, 0x003F };
    uint32_t const ces[12] = { 0x1DCB, 0x1E10, 0x0267, 0x0000, 0x0020, 0x0020, 0x0020, 0x0000, 0x001D, 0x001D, 0x0002, 0x0000 };

    auto collation = collate_for_tests(
        cps, cps + 2, boost::text::variable_weighting::non_ignorable);

    EXPECT_EQ(collation.size(), 12);
    EXPECT_TRUE(boost::algorithm::equal(collation.begin(), collation.end(), ces, ces + 12))
        << "from:     " << ce_dumper(cps)
        << "expected: " << ce_dumper(ces)
        << "got:      " << ce_dumper(collation);
}

TEST(collation, non_ignorable_111_234)
{
    // 33A2 0021;	
    // („é¢) SQUARE KM SQUARED	[1DCB 1E10 1CA5 0261 | 0020 0020 0020 0020 | 001C 001C 001C 0002 |]

    uint32_t cps[2] = { 0x33A2, 0x0021 };
    uint32_t const ces[15] = { 0x1DCB, 0x1E10, 0x1CA5, 0x0261, 0x0000, 0x0020, 0x0020, 0x0020, 0x0020, 0x0000, 0x001C, 0x001C, 0x001C, 0x0002, 0x0000 };

    auto collation = collate_for_tests(
        cps, cps + 2, boost::text::variable_weighting::non_ignorable);

    EXPECT_EQ(collation.size(), 15);
    EXPECT_TRUE(boost::algorithm::equal(collation.begin(), collation.end(), ces, ces + 15))
        << "from:     " << ce_dumper(cps)
        << "expected: " << ce_dumper(ces)
        << "got:      " << ce_dumper(collation);
}

TEST(collation, non_ignorable_111_235)
{
    // 33A2 003F;	
    // („é¢) SQUARE KM SQUARED	[1DCB 1E10 1CA5 0267 | 0020 0020 0020 0020 | 001C 001C 001C 0002 |]

    uint32_t cps[2] = { 0x33A2, 0x003F };
    uint32_t const ces[15] = { 0x1DCB, 0x1E10, 0x1CA5, 0x0267, 0x0000, 0x0020, 0x0020, 0x0020, 0x0020, 0x0000, 0x001C, 0x001C, 0x001C, 0x0002, 0x0000 };

    auto collation = collate_for_tests(
        cps, cps + 2, boost::text::variable_weighting::non_ignorable);

    EXPECT_EQ(collation.size(), 15);
    EXPECT_TRUE(boost::algorithm::equal(collation.begin(), collation.end(), ces, ces + 15))
        << "from:     " << ce_dumper(cps)
        << "expected: " << ce_dumper(ces)
        << "got:      " << ce_dumper(collation);
}

TEST(collation, non_ignorable_111_236)
{
    // 33A2 0061;	
    // („é¢) SQUARE KM SQUARED	[1DCB 1E10 1CA5 1CAD | 0020 0020 0020 0020 | 001C 001C 001C 0002 |]

    uint32_t cps[2] = { 0x33A2, 0x0061 };
    uint32_t const ces[15] = { 0x1DCB, 0x1E10, 0x1CA5, 0x1CAD, 0x0000, 0x0020, 0x0020, 0x0020, 0x0020, 0x0000, 0x001C, 0x001C, 0x001C, 0x0002, 0x0000 };

    auto collation = collate_for_tests(
        cps, cps + 2, boost::text::variable_weighting::non_ignorable);

    EXPECT_EQ(collation.size(), 15);
    EXPECT_TRUE(boost::algorithm::equal(collation.begin(), collation.end(), ces, ces + 15))
        << "from:     " << ce_dumper(cps)
        << "expected: " << ce_dumper(ces)
        << "got:      " << ce_dumper(collation);
}

TEST(collation, non_ignorable_111_237)
{
    // 33A2 0041;	
    // („é¢) SQUARE KM SQUARED	[1DCB 1E10 1CA5 1CAD | 0020 0020 0020 0020 | 001C 001C 001C 0008 |]

    uint32_t cps[2] = { 0x33A2, 0x0041 };
    uint32_t const ces[15] = { 0x1DCB, 0x1E10, 0x1CA5, 0x1CAD, 0x0000, 0x0020, 0x0020, 0x0020, 0x0020, 0x0000, 0x001C, 0x001C, 0x001C, 0x0008, 0x0000 };

    auto collation = collate_for_tests(
        cps, cps + 2, boost::text::variable_weighting::non_ignorable);

    EXPECT_EQ(collation.size(), 15);
    EXPECT_TRUE(boost::algorithm::equal(collation.begin(), collation.end(), ces, ces + 15))
        << "from:     " << ce_dumper(cps)
        << "expected: " << ce_dumper(ces)
        << "got:      " << ce_dumper(collation);
}

TEST(collation, non_ignorable_111_238)
{
    // 33A2 0062;	
    // („é¢) SQUARE KM SQUARED	[1DCB 1E10 1CA5 1CC6 | 0020 0020 0020 0020 | 001C 001C 001C 0002 |]

    uint32_t cps[2] = { 0x33A2, 0x0062 };
    uint32_t const ces[15] = { 0x1DCB, 0x1E10, 0x1CA5, 0x1CC6, 0x0000, 0x0020, 0x0020, 0x0020, 0x0020, 0x0000, 0x001C, 0x001C, 0x001C, 0x0002, 0x0000 };

    auto collation = collate_for_tests(
        cps, cps + 2, boost::text::variable_weighting::non_ignorable);

    EXPECT_EQ(collation.size(), 15);
    EXPECT_TRUE(boost::algorithm::equal(collation.begin(), collation.end(), ces, ces + 15))
        << "from:     " << ce_dumper(cps)
        << "expected: " << ce_dumper(ces)
        << "got:      " << ce_dumper(collation);
}

TEST(collation, non_ignorable_111_239)
{
    // 33A6 0021;	
    // („é¶) SQUARE KM CUBED	[1DCB 1E10 1CA6 0261 | 0020 0020 0020 0020 | 001C 001C 001C 0002 |]

    uint32_t cps[2] = { 0x33A6, 0x0021 };
    uint32_t const ces[15] = { 0x1DCB, 0x1E10, 0x1CA6, 0x0261, 0x0000, 0x0020, 0x0020, 0x0020, 0x0020, 0x0000, 0x001C, 0x001C, 0x001C, 0x0002, 0x0000 };

    auto collation = collate_for_tests(
        cps, cps + 2, boost::text::variable_weighting::non_ignorable);

    EXPECT_EQ(collation.size(), 15);
    EXPECT_TRUE(boost::algorithm::equal(collation.begin(), collation.end(), ces, ces + 15))
        << "from:     " << ce_dumper(cps)
        << "expected: " << ce_dumper(ces)
        << "got:      " << ce_dumper(collation);
}

TEST(collation, non_ignorable_111_240)
{
    // 33A6 003F;	
    // („é¶) SQUARE KM CUBED	[1DCB 1E10 1CA6 0267 | 0020 0020 0020 0020 | 001C 001C 001C 0002 |]

    uint32_t cps[2] = { 0x33A6, 0x003F };
    uint32_t const ces[15] = { 0x1DCB, 0x1E10, 0x1CA6, 0x0267, 0x0000, 0x0020, 0x0020, 0x0020, 0x0020, 0x0000, 0x001C, 0x001C, 0x001C, 0x0002, 0x0000 };

    auto collation = collate_for_tests(
        cps, cps + 2, boost::text::variable_weighting::non_ignorable);

    EXPECT_EQ(collation.size(), 15);
    EXPECT_TRUE(boost::algorithm::equal(collation.begin(), collation.end(), ces, ces + 15))
        << "from:     " << ce_dumper(cps)
        << "expected: " << ce_dumper(ces)
        << "got:      " << ce_dumper(collation);
}

TEST(collation, non_ignorable_111_241)
{
    // 33A6 0061;	
    // („é¶) SQUARE KM CUBED	[1DCB 1E10 1CA6 1CAD | 0020 0020 0020 0020 | 001C 001C 001C 0002 |]

    uint32_t cps[2] = { 0x33A6, 0x0061 };
    uint32_t const ces[15] = { 0x1DCB, 0x1E10, 0x1CA6, 0x1CAD, 0x0000, 0x0020, 0x0020, 0x0020, 0x0020, 0x0000, 0x001C, 0x001C, 0x001C, 0x0002, 0x0000 };

    auto collation = collate_for_tests(
        cps, cps + 2, boost::text::variable_weighting::non_ignorable);

    EXPECT_EQ(collation.size(), 15);
    EXPECT_TRUE(boost::algorithm::equal(collation.begin(), collation.end(), ces, ces + 15))
        << "from:     " << ce_dumper(cps)
        << "expected: " << ce_dumper(ces)
        << "got:      " << ce_dumper(collation);
}

TEST(collation, non_ignorable_111_242)
{
    // 33A6 0041;	
    // („é¶) SQUARE KM CUBED	[1DCB 1E10 1CA6 1CAD | 0020 0020 0020 0020 | 001C 001C 001C 0008 |]

    uint32_t cps[2] = { 0x33A6, 0x0041 };
    uint32_t const ces[15] = { 0x1DCB, 0x1E10, 0x1CA6, 0x1CAD, 0x0000, 0x0020, 0x0020, 0x0020, 0x0020, 0x0000, 0x001C, 0x001C, 0x001C, 0x0008, 0x0000 };

    auto collation = collate_for_tests(
        cps, cps + 2, boost::text::variable_weighting::non_ignorable);

    EXPECT_EQ(collation.size(), 15);
    EXPECT_TRUE(boost::algorithm::equal(collation.begin(), collation.end(), ces, ces + 15))
        << "from:     " << ce_dumper(cps)
        << "expected: " << ce_dumper(ces)
        << "got:      " << ce_dumper(collation);
}

TEST(collation, non_ignorable_111_243)
{
    // 33A6 0062;	
    // („é¶) SQUARE KM CUBED	[1DCB 1E10 1CA6 1CC6 | 0020 0020 0020 0020 | 001C 001C 001C 0002 |]

    uint32_t cps[2] = { 0x33A6, 0x0062 };
    uint32_t const ces[15] = { 0x1DCB, 0x1E10, 0x1CA6, 0x1CC6, 0x0000, 0x0020, 0x0020, 0x0020, 0x0020, 0x0000, 0x001C, 0x001C, 0x001C, 0x0002, 0x0000 };

    auto collation = collate_for_tests(
        cps, cps + 2, boost::text::variable_weighting::non_ignorable);

    EXPECT_EQ(collation.size(), 15);
    EXPECT_TRUE(boost::algorithm::equal(collation.begin(), collation.end(), ces, ces + 15))
        << "from:     " << ce_dumper(cps)
        << "expected: " << ce_dumper(ces)
        << "got:      " << ce_dumper(collation);
}

TEST(collation, non_ignorable_111_244)
{
    // 339E 0061;	
    // („éû) SQUARE KM	[1DCB 1E10 1CAD | 0020 0020 0020 | 001C 001C 0002 |]

    uint32_t cps[2] = { 0x339E, 0x0061 };
    uint32_t const ces[12] = { 0x1DCB, 0x1E10, 0x1CAD, 0x0000, 0x0020, 0x0020, 0x0020, 0x0000, 0x001C, 0x001C, 0x0002, 0x0000 };

    auto collation = collate_for_tests(
        cps, cps + 2, boost::text::variable_weighting::non_ignorable);

    EXPECT_EQ(collation.size(), 12);
    EXPECT_TRUE(boost::algorithm::equal(collation.begin(), collation.end(), ces, ces + 12))
        << "from:     " << ce_dumper(cps)
        << "expected: " << ce_dumper(ces)
        << "got:      " << ce_dumper(collation);
}

TEST(collation, non_ignorable_111_245)
{
    // 339E 0041;	
    // („éû) SQUARE KM	[1DCB 1E10 1CAD | 0020 0020 0020 | 001C 001C 0008 |]

    uint32_t cps[2] = { 0x339E, 0x0041 };
    uint32_t const ces[12] = { 0x1DCB, 0x1E10, 0x1CAD, 0x0000, 0x0020, 0x0020, 0x0020, 0x0000, 0x001C, 0x001C, 0x0008, 0x0000 };

    auto collation = collate_for_tests(
        cps, cps + 2, boost::text::variable_weighting::non_ignorable);

    EXPECT_EQ(collation.size(), 12);
    EXPECT_TRUE(boost::algorithm::equal(collation.begin(), collation.end(), ces, ces + 12))
        << "from:     " << ce_dumper(cps)
        << "expected: " << ce_dumper(ces)
        << "got:      " << ce_dumper(collation);
}

TEST(collation, non_ignorable_111_246)
{
    // 33CE 0061;	
    // („èé) SQUARE KM CAPITAL	[1DCB 1E10 1CAD | 0020 0020 0020 | 001D 001D 0002 |]

    uint32_t cps[2] = { 0x33CE, 0x0061 };
    uint32_t const ces[12] = { 0x1DCB, 0x1E10, 0x1CAD, 0x0000, 0x0020, 0x0020, 0x0020, 0x0000, 0x001D, 0x001D, 0x0002, 0x0000 };

    auto collation = collate_for_tests(
        cps, cps + 2, boost::text::variable_weighting::non_ignorable);

    EXPECT_EQ(collation.size(), 12);
    EXPECT_TRUE(boost::algorithm::equal(collation.begin(), collation.end(), ces, ces + 12))
        << "from:     " << ce_dumper(cps)
        << "expected: " << ce_dumper(ces)
        << "got:      " << ce_dumper(collation);
}

TEST(collation, non_ignorable_111_247)
{
    // 33CE 0041;	
    // („èé) SQUARE KM CAPITAL	[1DCB 1E10 1CAD | 0020 0020 0020 | 001D 001D 0008 |]

    uint32_t cps[2] = { 0x33CE, 0x0041 };
    uint32_t const ces[12] = { 0x1DCB, 0x1E10, 0x1CAD, 0x0000, 0x0020, 0x0020, 0x0020, 0x0000, 0x001D, 0x001D, 0x0008, 0x0000 };

    auto collation = collate_for_tests(
        cps, cps + 2, boost::text::variable_weighting::non_ignorable);

    EXPECT_EQ(collation.size(), 12);
    EXPECT_TRUE(boost::algorithm::equal(collation.begin(), collation.end(), ces, ces + 12))
        << "from:     " << ce_dumper(cps)
        << "expected: " << ce_dumper(ces)
        << "got:      " << ce_dumper(collation);
}

TEST(collation, non_ignorable_111_248)
{
    // 339E 0062;	
    // („éû) SQUARE KM	[1DCB 1E10 1CC6 | 0020 0020 0020 | 001C 001C 0002 |]

    uint32_t cps[2] = { 0x339E, 0x0062 };
    uint32_t const ces[12] = { 0x1DCB, 0x1E10, 0x1CC6, 0x0000, 0x0020, 0x0020, 0x0020, 0x0000, 0x001C, 0x001C, 0x0002, 0x0000 };

    auto collation = collate_for_tests(
        cps, cps + 2, boost::text::variable_weighting::non_ignorable);

    EXPECT_EQ(collation.size(), 12);
    EXPECT_TRUE(boost::algorithm::equal(collation.begin(), collation.end(), ces, ces + 12))
        << "from:     " << ce_dumper(cps)
        << "expected: " << ce_dumper(ces)
        << "got:      " << ce_dumper(collation);
}

TEST(collation, non_ignorable_111_249)
{
    // 33CE 0062;	
    // („èé) SQUARE KM CAPITAL	[1DCB 1E10 1CC6 | 0020 0020 0020 | 001D 001D 0002 |]

    uint32_t cps[2] = { 0x33CE, 0x0062 };
    uint32_t const ces[12] = { 0x1DCB, 0x1E10, 0x1CC6, 0x0000, 0x0020, 0x0020, 0x0020, 0x0000, 0x001D, 0x001D, 0x0002, 0x0000 };

    auto collation = collate_for_tests(
        cps, cps + 2, boost::text::variable_weighting::non_ignorable);

    EXPECT_EQ(collation.size(), 12);
    EXPECT_TRUE(boost::algorithm::equal(collation.begin(), collation.end(), ces, ces + 12))
        << "from:     " << ce_dumper(cps)
        << "expected: " << ce_dumper(ces)
        << "got:      " << ce_dumper(collation);
}

TEST(collation, non_ignorable_111_250)
{
    // 33AA 0021;	
    // („é™) SQUARE KPA	[1DCB 1E72 1CAD 0261 | 0020 0020 0020 0020 | 001C 001D 001C 0002 |]

    uint32_t cps[2] = { 0x33AA, 0x0021 };
    uint32_t const ces[15] = { 0x1DCB, 0x1E72, 0x1CAD, 0x0261, 0x0000, 0x0020, 0x0020, 0x0020, 0x0020, 0x0000, 0x001C, 0x001D, 0x001C, 0x0002, 0x0000 };

    auto collation = collate_for_tests(
        cps, cps + 2, boost::text::variable_weighting::non_ignorable);

    EXPECT_EQ(collation.size(), 15);
    EXPECT_TRUE(boost::algorithm::equal(collation.begin(), collation.end(), ces, ces + 15))
        << "from:     " << ce_dumper(cps)
        << "expected: " << ce_dumper(ces)
        << "got:      " << ce_dumper(collation);
}

TEST(collation, non_ignorable_111_251)
{
    // 33AA 003F;	
    // („é™) SQUARE KPA	[1DCB 1E72 1CAD 0267 | 0020 0020 0020 0020 | 001C 001D 001C 0002 |]

    uint32_t cps[2] = { 0x33AA, 0x003F };
    uint32_t const ces[15] = { 0x1DCB, 0x1E72, 0x1CAD, 0x0267, 0x0000, 0x0020, 0x0020, 0x0020, 0x0020, 0x0000, 0x001C, 0x001D, 0x001C, 0x0002, 0x0000 };

    auto collation = collate_for_tests(
        cps, cps + 2, boost::text::variable_weighting::non_ignorable);

    EXPECT_EQ(collation.size(), 15);
    EXPECT_TRUE(boost::algorithm::equal(collation.begin(), collation.end(), ces, ces + 15))
        << "from:     " << ce_dumper(cps)
        << "expected: " << ce_dumper(ces)
        << "got:      " << ce_dumper(collation);
}

TEST(collation, non_ignorable_111_252)
{
    // 33AA 0061;	
    // („é™) SQUARE KPA	[1DCB 1E72 1CAD 1CAD | 0020 0020 0020 0020 | 001C 001D 001C 0002 |]

    uint32_t cps[2] = { 0x33AA, 0x0061 };
    uint32_t const ces[15] = { 0x1DCB, 0x1E72, 0x1CAD, 0x1CAD, 0x0000, 0x0020, 0x0020, 0x0020, 0x0020, 0x0000, 0x001C, 0x001D, 0x001C, 0x0002, 0x0000 };

    auto collation = collate_for_tests(
        cps, cps + 2, boost::text::variable_weighting::non_ignorable);

    EXPECT_EQ(collation.size(), 15);
    EXPECT_TRUE(boost::algorithm::equal(collation.begin(), collation.end(), ces, ces + 15))
        << "from:     " << ce_dumper(cps)
        << "expected: " << ce_dumper(ces)
        << "got:      " << ce_dumper(collation);
}

TEST(collation, non_ignorable_111_253)
{
    // 33AA 0041;	
    // („é™) SQUARE KPA	[1DCB 1E72 1CAD 1CAD | 0020 0020 0020 0020 | 001C 001D 001C 0008 |]

    uint32_t cps[2] = { 0x33AA, 0x0041 };
    uint32_t const ces[15] = { 0x1DCB, 0x1E72, 0x1CAD, 0x1CAD, 0x0000, 0x0020, 0x0020, 0x0020, 0x0020, 0x0000, 0x001C, 0x001D, 0x001C, 0x0008, 0x0000 };

    auto collation = collate_for_tests(
        cps, cps + 2, boost::text::variable_weighting::non_ignorable);

    EXPECT_EQ(collation.size(), 15);
    EXPECT_TRUE(boost::algorithm::equal(collation.begin(), collation.end(), ces, ces + 15))
        << "from:     " << ce_dumper(cps)
        << "expected: " << ce_dumper(ces)
        << "got:      " << ce_dumper(collation);
}

TEST(collation, non_ignorable_111_254)
{
    // 33AA 0062;	
    // („é™) SQUARE KPA	[1DCB 1E72 1CAD 1CC6 | 0020 0020 0020 0020 | 001C 001D 001C 0002 |]

    uint32_t cps[2] = { 0x33AA, 0x0062 };
    uint32_t const ces[15] = { 0x1DCB, 0x1E72, 0x1CAD, 0x1CC6, 0x0000, 0x0020, 0x0020, 0x0020, 0x0020, 0x0000, 0x001C, 0x001D, 0x001C, 0x0002, 0x0000 };

    auto collation = collate_for_tests(
        cps, cps + 2, boost::text::variable_weighting::non_ignorable);

    EXPECT_EQ(collation.size(), 15);
    EXPECT_TRUE(boost::algorithm::equal(collation.begin(), collation.end(), ces, ces + 15))
        << "from:     " << ce_dumper(cps)
        << "expected: " << ce_dumper(ces)
        << "got:      " << ce_dumper(collation);
}

TEST(collation, non_ignorable_111_255)
{
    // 33CF 0021;	
    // („èè) SQUARE KT	[1DCB 1EFB 0261 | 0020 0020 0020 | 001C 001C 0002 |]

    uint32_t cps[2] = { 0x33CF, 0x0021 };
    uint32_t const ces[12] = { 0x1DCB, 0x1EFB, 0x0261, 0x0000, 0x0020, 0x0020, 0x0020, 0x0000, 0x001C, 0x001C, 0x0002, 0x0000 };

    auto collation = collate_for_tests(
        cps, cps + 2, boost::text::variable_weighting::non_ignorable);

    EXPECT_EQ(collation.size(), 12);
    EXPECT_TRUE(boost::algorithm::equal(collation.begin(), collation.end(), ces, ces + 12))
        << "from:     " << ce_dumper(cps)
        << "expected: " << ce_dumper(ces)
        << "got:      " << ce_dumper(collation);
}

TEST(collation, non_ignorable_111_256)
{
    // 33CF 003F;	
    // („èè) SQUARE KT	[1DCB 1EFB 0267 | 0020 0020 0020 | 001C 001C 0002 |]

    uint32_t cps[2] = { 0x33CF, 0x003F };
    uint32_t const ces[12] = { 0x1DCB, 0x1EFB, 0x0267, 0x0000, 0x0020, 0x0020, 0x0020, 0x0000, 0x001C, 0x001C, 0x0002, 0x0000 };

    auto collation = collate_for_tests(
        cps, cps + 2, boost::text::variable_weighting::non_ignorable);

    EXPECT_EQ(collation.size(), 12);
    EXPECT_TRUE(boost::algorithm::equal(collation.begin(), collation.end(), ces, ces + 12))
        << "from:     " << ce_dumper(cps)
        << "expected: " << ce_dumper(ces)
        << "got:      " << ce_dumper(collation);
}

TEST(collation, non_ignorable_111_257)
{
    // 33CF 0061;	
    // („èè) SQUARE KT	[1DCB 1EFB 1CAD | 0020 0020 0020 | 001C 001C 0002 |]

    uint32_t cps[2] = { 0x33CF, 0x0061 };
    uint32_t const ces[12] = { 0x1DCB, 0x1EFB, 0x1CAD, 0x0000, 0x0020, 0x0020, 0x0020, 0x0000, 0x001C, 0x001C, 0x0002, 0x0000 };

    auto collation = collate_for_tests(
        cps, cps + 2, boost::text::variable_weighting::non_ignorable);

    EXPECT_EQ(collation.size(), 12);
    EXPECT_TRUE(boost::algorithm::equal(collation.begin(), collation.end(), ces, ces + 12))
        << "from:     " << ce_dumper(cps)
        << "expected: " << ce_dumper(ces)
        << "got:      " << ce_dumper(collation);
}

TEST(collation, non_ignorable_111_258)
{
    // 33CF 0041;	
    // („èè) SQUARE KT	[1DCB 1EFB 1CAD | 0020 0020 0020 | 001C 001C 0008 |]

    uint32_t cps[2] = { 0x33CF, 0x0041 };
    uint32_t const ces[12] = { 0x1DCB, 0x1EFB, 0x1CAD, 0x0000, 0x0020, 0x0020, 0x0020, 0x0000, 0x001C, 0x001C, 0x0008, 0x0000 };

    auto collation = collate_for_tests(
        cps, cps + 2, boost::text::variable_weighting::non_ignorable);

    EXPECT_EQ(collation.size(), 12);
    EXPECT_TRUE(boost::algorithm::equal(collation.begin(), collation.end(), ces, ces + 12))
        << "from:     " << ce_dumper(cps)
        << "expected: " << ce_dumper(ces)
        << "got:      " << ce_dumper(collation);
}

TEST(collation, non_ignorable_111_259)
{
    // 33CF 0062;	
    // („èè) SQUARE KT	[1DCB 1EFB 1CC6 | 0020 0020 0020 | 001C 001C 0002 |]

    uint32_t cps[2] = { 0x33CF, 0x0062 };
    uint32_t const ces[12] = { 0x1DCB, 0x1EFB, 0x1CC6, 0x0000, 0x0020, 0x0020, 0x0020, 0x0000, 0x001C, 0x001C, 0x0002, 0x0000 };

    auto collation = collate_for_tests(
        cps, cps + 2, boost::text::variable_weighting::non_ignorable);

    EXPECT_EQ(collation.size(), 12);
    EXPECT_TRUE(boost::algorithm::equal(collation.begin(), collation.end(), ces, ces + 12))
        << "from:     " << ce_dumper(cps)
        << "expected: " << ce_dumper(ces)
        << "got:      " << ce_dumper(collation);
}

TEST(collation, non_ignorable_111_260)
{
    // 33B8 0021;	
    // („é∏) SQUARE KV	[1DCB 1F49 0261 | 0020 0020 0020 | 001C 001D 0002 |]

    uint32_t cps[2] = { 0x33B8, 0x0021 };
    uint32_t const ces[12] = { 0x1DCB, 0x1F49, 0x0261, 0x0000, 0x0020, 0x0020, 0x0020, 0x0000, 0x001C, 0x001D, 0x0002, 0x0000 };

    auto collation = collate_for_tests(
        cps, cps + 2, boost::text::variable_weighting::non_ignorable);

    EXPECT_EQ(collation.size(), 12);
    EXPECT_TRUE(boost::algorithm::equal(collation.begin(), collation.end(), ces, ces + 12))
        << "from:     " << ce_dumper(cps)
        << "expected: " << ce_dumper(ces)
        << "got:      " << ce_dumper(collation);
}

TEST(collation, non_ignorable_111_261)
{
    // 33B8 003F;	
    // („é∏) SQUARE KV	[1DCB 1F49 0267 | 0020 0020 0020 | 001C 001D 0002 |]

    uint32_t cps[2] = { 0x33B8, 0x003F };
    uint32_t const ces[12] = { 0x1DCB, 0x1F49, 0x0267, 0x0000, 0x0020, 0x0020, 0x0020, 0x0000, 0x001C, 0x001D, 0x0002, 0x0000 };

    auto collation = collate_for_tests(
        cps, cps + 2, boost::text::variable_weighting::non_ignorable);

    EXPECT_EQ(collation.size(), 12);
    EXPECT_TRUE(boost::algorithm::equal(collation.begin(), collation.end(), ces, ces + 12))
        << "from:     " << ce_dumper(cps)
        << "expected: " << ce_dumper(ces)
        << "got:      " << ce_dumper(collation);
}

TEST(collation, non_ignorable_111_262)
{
    // 33B8 0061;	
    // („é∏) SQUARE KV	[1DCB 1F49 1CAD | 0020 0020 0020 | 001C 001D 0002 |]

    uint32_t cps[2] = { 0x33B8, 0x0061 };
    uint32_t const ces[12] = { 0x1DCB, 0x1F49, 0x1CAD, 0x0000, 0x0020, 0x0020, 0x0020, 0x0000, 0x001C, 0x001D, 0x0002, 0x0000 };

    auto collation = collate_for_tests(
        cps, cps + 2, boost::text::variable_weighting::non_ignorable);

    EXPECT_EQ(collation.size(), 12);
    EXPECT_TRUE(boost::algorithm::equal(collation.begin(), collation.end(), ces, ces + 12))
        << "from:     " << ce_dumper(cps)
        << "expected: " << ce_dumper(ces)
        << "got:      " << ce_dumper(collation);
}

TEST(collation, non_ignorable_111_263)
{
    // 33B8 0041;	
    // („é∏) SQUARE KV	[1DCB 1F49 1CAD | 0020 0020 0020 | 001C 001D 0008 |]

    uint32_t cps[2] = { 0x33B8, 0x0041 };
    uint32_t const ces[12] = { 0x1DCB, 0x1F49, 0x1CAD, 0x0000, 0x0020, 0x0020, 0x0020, 0x0000, 0x001C, 0x001D, 0x0008, 0x0000 };

    auto collation = collate_for_tests(
        cps, cps + 2, boost::text::variable_weighting::non_ignorable);

    EXPECT_EQ(collation.size(), 12);
    EXPECT_TRUE(boost::algorithm::equal(collation.begin(), collation.end(), ces, ces + 12))
        << "from:     " << ce_dumper(cps)
        << "expected: " << ce_dumper(ces)
        << "got:      " << ce_dumper(collation);
}

TEST(collation, non_ignorable_111_264)
{
    // 33B8 0062;	
    // („é∏) SQUARE KV	[1DCB 1F49 1CC6 | 0020 0020 0020 | 001C 001D 0002 |]

    uint32_t cps[2] = { 0x33B8, 0x0062 };
    uint32_t const ces[12] = { 0x1DCB, 0x1F49, 0x1CC6, 0x0000, 0x0020, 0x0020, 0x0020, 0x0000, 0x001C, 0x001D, 0x0002, 0x0000 };

    auto collation = collate_for_tests(
        cps, cps + 2, boost::text::variable_weighting::non_ignorable);

    EXPECT_EQ(collation.size(), 12);
    EXPECT_TRUE(boost::algorithm::equal(collation.begin(), collation.end(), ces, ces + 12))
        << "from:     " << ce_dumper(cps)
        << "expected: " << ce_dumper(ces)
        << "got:      " << ce_dumper(collation);
}

TEST(collation, non_ignorable_111_265)
{
    // 33BE 0021;	
    // („éæ) SQUARE KW	[1DCB 1F5B 0261 | 0020 0020 0020 | 001C 001D 0002 |]

    uint32_t cps[2] = { 0x33BE, 0x0021 };
    uint32_t const ces[12] = { 0x1DCB, 0x1F5B, 0x0261, 0x0000, 0x0020, 0x0020, 0x0020, 0x0000, 0x001C, 0x001D, 0x0002, 0x0000 };

    auto collation = collate_for_tests(
        cps, cps + 2, boost::text::variable_weighting::non_ignorable);

    EXPECT_EQ(collation.size(), 12);
    EXPECT_TRUE(boost::algorithm::equal(collation.begin(), collation.end(), ces, ces + 12))
        << "from:     " << ce_dumper(cps)
        << "expected: " << ce_dumper(ces)
        << "got:      " << ce_dumper(collation);
}

TEST(collation, non_ignorable_111_266)
{
    // 33BE 003F;	
    // („éæ) SQUARE KW	[1DCB 1F5B 0267 | 0020 0020 0020 | 001C 001D 0002 |]

    uint32_t cps[2] = { 0x33BE, 0x003F };
    uint32_t const ces[12] = { 0x1DCB, 0x1F5B, 0x0267, 0x0000, 0x0020, 0x0020, 0x0020, 0x0000, 0x001C, 0x001D, 0x0002, 0x0000 };

    auto collation = collate_for_tests(
        cps, cps + 2, boost::text::variable_weighting::non_ignorable);

    EXPECT_EQ(collation.size(), 12);
    EXPECT_TRUE(boost::algorithm::equal(collation.begin(), collation.end(), ces, ces + 12))
        << "from:     " << ce_dumper(cps)
        << "expected: " << ce_dumper(ces)
        << "got:      " << ce_dumper(collation);
}

TEST(collation, non_ignorable_111_267)
{
    // 33BE 0061;	
    // („éæ) SQUARE KW	[1DCB 1F5B 1CAD | 0020 0020 0020 | 001C 001D 0002 |]

    uint32_t cps[2] = { 0x33BE, 0x0061 };
    uint32_t const ces[12] = { 0x1DCB, 0x1F5B, 0x1CAD, 0x0000, 0x0020, 0x0020, 0x0020, 0x0000, 0x001C, 0x001D, 0x0002, 0x0000 };

    auto collation = collate_for_tests(
        cps, cps + 2, boost::text::variable_weighting::non_ignorable);

    EXPECT_EQ(collation.size(), 12);
    EXPECT_TRUE(boost::algorithm::equal(collation.begin(), collation.end(), ces, ces + 12))
        << "from:     " << ce_dumper(cps)
        << "expected: " << ce_dumper(ces)
        << "got:      " << ce_dumper(collation);
}

TEST(collation, non_ignorable_111_268)
{
    // 33BE 0041;	
    // („éæ) SQUARE KW	[1DCB 1F5B 1CAD | 0020 0020 0020 | 001C 001D 0008 |]

    uint32_t cps[2] = { 0x33BE, 0x0041 };
    uint32_t const ces[12] = { 0x1DCB, 0x1F5B, 0x1CAD, 0x0000, 0x0020, 0x0020, 0x0020, 0x0000, 0x001C, 0x001D, 0x0008, 0x0000 };

    auto collation = collate_for_tests(
        cps, cps + 2, boost::text::variable_weighting::non_ignorable);

    EXPECT_EQ(collation.size(), 12);
    EXPECT_TRUE(boost::algorithm::equal(collation.begin(), collation.end(), ces, ces + 12))
        << "from:     " << ce_dumper(cps)
        << "expected: " << ce_dumper(ces)
        << "got:      " << ce_dumper(collation);
}

TEST(collation, non_ignorable_111_269)
{
    // 33BE 0062;	
    // („éæ) SQUARE KW	[1DCB 1F5B 1CC6 | 0020 0020 0020 | 001C 001D 0002 |]

    uint32_t cps[2] = { 0x33BE, 0x0062 };
    uint32_t const ces[12] = { 0x1DCB, 0x1F5B, 0x1CC6, 0x0000, 0x0020, 0x0020, 0x0020, 0x0000, 0x001C, 0x001D, 0x0002, 0x0000 };

    auto collation = collate_for_tests(
        cps, cps + 2, boost::text::variable_weighting::non_ignorable);

    EXPECT_EQ(collation.size(), 12);
    EXPECT_TRUE(boost::algorithm::equal(collation.begin(), collation.end(), ces, ces + 12))
        << "from:     " << ce_dumper(cps)
        << "expected: " << ce_dumper(ces)
        << "got:      " << ce_dumper(collation);
}

TEST(collation, non_ignorable_111_270)
{
    // 33C0 0021;	
    // („èÄ) SQUARE K OHM	[1DCB 2047 0261 | 0020 0020 0020 | 001C 001D 0002 |]

    uint32_t cps[2] = { 0x33C0, 0x0021 };
    uint32_t const ces[12] = { 0x1DCB, 0x2047, 0x0261, 0x0000, 0x0020, 0x0020, 0x0020, 0x0000, 0x001C, 0x001D, 0x0002, 0x0000 };

    auto collation = collate_for_tests(
        cps, cps + 2, boost::text::variable_weighting::non_ignorable);

    EXPECT_EQ(collation.size(), 12);
    EXPECT_TRUE(boost::algorithm::equal(collation.begin(), collation.end(), ces, ces + 12))
        << "from:     " << ce_dumper(cps)
        << "expected: " << ce_dumper(ces)
        << "got:      " << ce_dumper(collation);
}

TEST(collation, non_ignorable_111_271)
{
    // 33C0 003F;	
    // („èÄ) SQUARE K OHM	[1DCB 2047 0267 | 0020 0020 0020 | 001C 001D 0002 |]

    uint32_t cps[2] = { 0x33C0, 0x003F };
    uint32_t const ces[12] = { 0x1DCB, 0x2047, 0x0267, 0x0000, 0x0020, 0x0020, 0x0020, 0x0000, 0x001C, 0x001D, 0x0002, 0x0000 };

    auto collation = collate_for_tests(
        cps, cps + 2, boost::text::variable_weighting::non_ignorable);

    EXPECT_EQ(collation.size(), 12);
    EXPECT_TRUE(boost::algorithm::equal(collation.begin(), collation.end(), ces, ces + 12))
        << "from:     " << ce_dumper(cps)
        << "expected: " << ce_dumper(ces)
        << "got:      " << ce_dumper(collation);
}

TEST(collation, non_ignorable_111_272)
{
    // 33C0 0061;	
    // („èÄ) SQUARE K OHM	[1DCB 2047 1CAD | 0020 0020 0020 | 001C 001D 0002 |]

    uint32_t cps[2] = { 0x33C0, 0x0061 };
    uint32_t const ces[12] = { 0x1DCB, 0x2047, 0x1CAD, 0x0000, 0x0020, 0x0020, 0x0020, 0x0000, 0x001C, 0x001D, 0x0002, 0x0000 };

    auto collation = collate_for_tests(
        cps, cps + 2, boost::text::variable_weighting::non_ignorable);

    EXPECT_EQ(collation.size(), 12);
    EXPECT_TRUE(boost::algorithm::equal(collation.begin(), collation.end(), ces, ces + 12))
        << "from:     " << ce_dumper(cps)
        << "expected: " << ce_dumper(ces)
        << "got:      " << ce_dumper(collation);
}

TEST(collation, non_ignorable_111_273)
{
    // 33C0 0041;	
    // („èÄ) SQUARE K OHM	[1DCB 2047 1CAD | 0020 0020 0020 | 001C 001D 0008 |]

    uint32_t cps[2] = { 0x33C0, 0x0041 };
    uint32_t const ces[12] = { 0x1DCB, 0x2047, 0x1CAD, 0x0000, 0x0020, 0x0020, 0x0020, 0x0000, 0x001C, 0x001D, 0x0008, 0x0000 };

    auto collation = collate_for_tests(
        cps, cps + 2, boost::text::variable_weighting::non_ignorable);

    EXPECT_EQ(collation.size(), 12);
    EXPECT_TRUE(boost::algorithm::equal(collation.begin(), collation.end(), ces, ces + 12))
        << "from:     " << ce_dumper(cps)
        << "expected: " << ce_dumper(ces)
        << "got:      " << ce_dumper(collation);
}

TEST(collation, non_ignorable_111_274)
{
    // 33C0 0062;	
    // („èÄ) SQUARE K OHM	[1DCB 2047 1CC6 | 0020 0020 0020 | 001C 001D 0002 |]

    uint32_t cps[2] = { 0x33C0, 0x0062 };
    uint32_t const ces[12] = { 0x1DCB, 0x2047, 0x1CC6, 0x0000, 0x0020, 0x0020, 0x0020, 0x0000, 0x001C, 0x001D, 0x0002, 0x0000 };

    auto collation = collate_for_tests(
        cps, cps + 2, boost::text::variable_weighting::non_ignorable);

    EXPECT_EQ(collation.size(), 12);
    EXPECT_TRUE(boost::algorithm::equal(collation.begin(), collation.end(), ces, ces + 12))
        << "from:     " << ce_dumper(cps)
        << "expected: " << ce_dumper(ces)
        << "got:      " << ce_dumper(collation);
}

TEST(collation, non_ignorable_111_275)
{
    // 1D0B 0021;	
    // (·¥ã) LATIN LETTER SMALL CAPITAL K	[1DCF 0261 | 0020 0020 | 0002 0002 |]

    uint32_t cps[2] = { 0x1D0B, 0x0021 };
    uint32_t const ces[9] = { 0x1DCF, 0x0261, 0x0000, 0x0020, 0x0020, 0x0000, 0x0002, 0x0002, 0x0000 };

    auto collation = collate_for_tests(
        cps, cps + 2, boost::text::variable_weighting::non_ignorable);

    EXPECT_EQ(collation.size(), 9);
    EXPECT_TRUE(boost::algorithm::equal(collation.begin(), collation.end(), ces, ces + 9))
        << "from:     " << ce_dumper(cps)
        << "expected: " << ce_dumper(ces)
        << "got:      " << ce_dumper(collation);
}

TEST(collation, non_ignorable_111_276)
{
    // 1D0B 003F;	
    // (·¥ã) LATIN LETTER SMALL CAPITAL K	[1DCF 0267 | 0020 0020 | 0002 0002 |]

    uint32_t cps[2] = { 0x1D0B, 0x003F };
    uint32_t const ces[9] = { 0x1DCF, 0x0267, 0x0000, 0x0020, 0x0020, 0x0000, 0x0002, 0x0002, 0x0000 };

    auto collation = collate_for_tests(
        cps, cps + 2, boost::text::variable_weighting::non_ignorable);

    EXPECT_EQ(collation.size(), 9);
    EXPECT_TRUE(boost::algorithm::equal(collation.begin(), collation.end(), ces, ces + 9))
        << "from:     " << ce_dumper(cps)
        << "expected: " << ce_dumper(ces)
        << "got:      " << ce_dumper(collation);
}

TEST(collation, non_ignorable_111_277)
{
    // 1D0B 0061;	
    // (·¥ã) LATIN LETTER SMALL CAPITAL K	[1DCF 1CAD | 0020 0020 | 0002 0002 |]

    uint32_t cps[2] = { 0x1D0B, 0x0061 };
    uint32_t const ces[9] = { 0x1DCF, 0x1CAD, 0x0000, 0x0020, 0x0020, 0x0000, 0x0002, 0x0002, 0x0000 };

    auto collation = collate_for_tests(
        cps, cps + 2, boost::text::variable_weighting::non_ignorable);

    EXPECT_EQ(collation.size(), 9);
    EXPECT_TRUE(boost::algorithm::equal(collation.begin(), collation.end(), ces, ces + 9))
        << "from:     " << ce_dumper(cps)
        << "expected: " << ce_dumper(ces)
        << "got:      " << ce_dumper(collation);
}

TEST(collation, non_ignorable_111_278)
{
    // 1D0B 0041;	
    // (·¥ã) LATIN LETTER SMALL CAPITAL K	[1DCF 1CAD | 0020 0020 | 0002 0008 |]

    uint32_t cps[2] = { 0x1D0B, 0x0041 };
    uint32_t const ces[9] = { 0x1DCF, 0x1CAD, 0x0000, 0x0020, 0x0020, 0x0000, 0x0002, 0x0008, 0x0000 };

    auto collation = collate_for_tests(
        cps, cps + 2, boost::text::variable_weighting::non_ignorable);

    EXPECT_EQ(collation.size(), 9);
    EXPECT_TRUE(boost::algorithm::equal(collation.begin(), collation.end(), ces, ces + 9))
        << "from:     " << ce_dumper(cps)
        << "expected: " << ce_dumper(ces)
        << "got:      " << ce_dumper(collation);
}

TEST(collation, non_ignorable_111_279)
{
    // 1D0B 0062;	
    // (·¥ã) LATIN LETTER SMALL CAPITAL K	[1DCF 1CC6 | 0020 0020 | 0002 0002 |]

    uint32_t cps[2] = { 0x1D0B, 0x0062 };
    uint32_t const ces[9] = { 0x1DCF, 0x1CC6, 0x0000, 0x0020, 0x0020, 0x0000, 0x0002, 0x0002, 0x0000 };

    auto collation = collate_for_tests(
        cps, cps + 2, boost::text::variable_weighting::non_ignorable);

    EXPECT_EQ(collation.size(), 9);
    EXPECT_TRUE(boost::algorithm::equal(collation.begin(), collation.end(), ces, ces + 9))
        << "from:     " << ce_dumper(cps)
        << "expected: " << ce_dumper(ces)
        << "got:      " << ce_dumper(collation);
}

TEST(collation, non_ignorable_111_280)
{
    // 1D84 0021;	
    // (·∂Ñ) LATIN SMALL LETTER K WITH PALATAL HOOK	[1DD0 0261 | 0020 0020 | 0002 0002 |]

    uint32_t cps[2] = { 0x1D84, 0x0021 };
    uint32_t const ces[9] = { 0x1DD0, 0x0261, 0x0000, 0x0020, 0x0020, 0x0000, 0x0002, 0x0002, 0x0000 };

    auto collation = collate_for_tests(
        cps, cps + 2, boost::text::variable_weighting::non_ignorable);

    EXPECT_EQ(collation.size(), 9);
    EXPECT_TRUE(boost::algorithm::equal(collation.begin(), collation.end(), ces, ces + 9))
        << "from:     " << ce_dumper(cps)
        << "expected: " << ce_dumper(ces)
        << "got:      " << ce_dumper(collation);
}

TEST(collation, non_ignorable_111_281)
{
    // 1D84 003F;	
    // (·∂Ñ) LATIN SMALL LETTER K WITH PALATAL HOOK	[1DD0 0267 | 0020 0020 | 0002 0002 |]

    uint32_t cps[2] = { 0x1D84, 0x003F };
    uint32_t const ces[9] = { 0x1DD0, 0x0267, 0x0000, 0x0020, 0x0020, 0x0000, 0x0002, 0x0002, 0x0000 };

    auto collation = collate_for_tests(
        cps, cps + 2, boost::text::variable_weighting::non_ignorable);

    EXPECT_EQ(collation.size(), 9);
    EXPECT_TRUE(boost::algorithm::equal(collation.begin(), collation.end(), ces, ces + 9))
        << "from:     " << ce_dumper(cps)
        << "expected: " << ce_dumper(ces)
        << "got:      " << ce_dumper(collation);
}

TEST(collation, non_ignorable_111_282)
{
    // 1D84 0061;	
    // (·∂Ñ) LATIN SMALL LETTER K WITH PALATAL HOOK	[1DD0 1CAD | 0020 0020 | 0002 0002 |]

    uint32_t cps[2] = { 0x1D84, 0x0061 };
    uint32_t const ces[9] = { 0x1DD0, 0x1CAD, 0x0000, 0x0020, 0x0020, 0x0000, 0x0002, 0x0002, 0x0000 };

    auto collation = collate_for_tests(
        cps, cps + 2, boost::text::variable_weighting::non_ignorable);

    EXPECT_EQ(collation.size(), 9);
    EXPECT_TRUE(boost::algorithm::equal(collation.begin(), collation.end(), ces, ces + 9))
        << "from:     " << ce_dumper(cps)
        << "expected: " << ce_dumper(ces)
        << "got:      " << ce_dumper(collation);
}

TEST(collation, non_ignorable_111_283)
{
    // 1D84 0041;	
    // (·∂Ñ) LATIN SMALL LETTER K WITH PALATAL HOOK	[1DD0 1CAD | 0020 0020 | 0002 0008 |]

    uint32_t cps[2] = { 0x1D84, 0x0041 };
    uint32_t const ces[9] = { 0x1DD0, 0x1CAD, 0x0000, 0x0020, 0x0020, 0x0000, 0x0002, 0x0008, 0x0000 };

    auto collation = collate_for_tests(
        cps, cps + 2, boost::text::variable_weighting::non_ignorable);

    EXPECT_EQ(collation.size(), 9);
    EXPECT_TRUE(boost::algorithm::equal(collation.begin(), collation.end(), ces, ces + 9))
        << "from:     " << ce_dumper(cps)
        << "expected: " << ce_dumper(ces)
        << "got:      " << ce_dumper(collation);
}

TEST(collation, non_ignorable_111_284)
{
    // 1D84 0062;	
    // (·∂Ñ) LATIN SMALL LETTER K WITH PALATAL HOOK	[1DD0 1CC6 | 0020 0020 | 0002 0002 |]

    uint32_t cps[2] = { 0x1D84, 0x0062 };
    uint32_t const ces[9] = { 0x1DD0, 0x1CC6, 0x0000, 0x0020, 0x0020, 0x0000, 0x0002, 0x0002, 0x0000 };

    auto collation = collate_for_tests(
        cps, cps + 2, boost::text::variable_weighting::non_ignorable);

    EXPECT_EQ(collation.size(), 9);
    EXPECT_TRUE(boost::algorithm::equal(collation.begin(), collation.end(), ces, ces + 9))
        << "from:     " << ce_dumper(cps)
        << "expected: " << ce_dumper(ces)
        << "got:      " << ce_dumper(collation);
}

TEST(collation, non_ignorable_111_285)
{
    // 0199 0021;	
    // (∆ô) LATIN SMALL LETTER K WITH HOOK	[1DD1 0261 | 0020 0020 | 0002 0002 |]

    uint32_t cps[2] = { 0x0199, 0x0021 };
    uint32_t const ces[9] = { 0x1DD1, 0x0261, 0x0000, 0x0020, 0x0020, 0x0000, 0x0002, 0x0002, 0x0000 };

    auto collation = collate_for_tests(
        cps, cps + 2, boost::text::variable_weighting::non_ignorable);

    EXPECT_EQ(collation.size(), 9);
    EXPECT_TRUE(boost::algorithm::equal(collation.begin(), collation.end(), ces, ces + 9))
        << "from:     " << ce_dumper(cps)
        << "expected: " << ce_dumper(ces)
        << "got:      " << ce_dumper(collation);
}

TEST(collation, non_ignorable_111_286)
{
    // 0198 0021;	
    // (∆ò) LATIN CAPITAL LETTER K WITH HOOK	[1DD1 0261 | 0020 0020 | 0008 0002 |]

    uint32_t cps[2] = { 0x0198, 0x0021 };
    uint32_t const ces[9] = { 0x1DD1, 0x0261, 0x0000, 0x0020, 0x0020, 0x0000, 0x0008, 0x0002, 0x0000 };

    auto collation = collate_for_tests(
        cps, cps + 2, boost::text::variable_weighting::non_ignorable);

    EXPECT_EQ(collation.size(), 9);
    EXPECT_TRUE(boost::algorithm::equal(collation.begin(), collation.end(), ces, ces + 9))
        << "from:     " << ce_dumper(cps)
        << "expected: " << ce_dumper(ces)
        << "got:      " << ce_dumper(collation);
}

TEST(collation, non_ignorable_111_287)
{
    // 0199 003F;	
    // (∆ô) LATIN SMALL LETTER K WITH HOOK	[1DD1 0267 | 0020 0020 | 0002 0002 |]

    uint32_t cps[2] = { 0x0199, 0x003F };
    uint32_t const ces[9] = { 0x1DD1, 0x0267, 0x0000, 0x0020, 0x0020, 0x0000, 0x0002, 0x0002, 0x0000 };

    auto collation = collate_for_tests(
        cps, cps + 2, boost::text::variable_weighting::non_ignorable);

    EXPECT_EQ(collation.size(), 9);
    EXPECT_TRUE(boost::algorithm::equal(collation.begin(), collation.end(), ces, ces + 9))
        << "from:     " << ce_dumper(cps)
        << "expected: " << ce_dumper(ces)
        << "got:      " << ce_dumper(collation);
}

TEST(collation, non_ignorable_111_288)
{
    // 0198 003F;	
    // (∆ò) LATIN CAPITAL LETTER K WITH HOOK	[1DD1 0267 | 0020 0020 | 0008 0002 |]

    uint32_t cps[2] = { 0x0198, 0x003F };
    uint32_t const ces[9] = { 0x1DD1, 0x0267, 0x0000, 0x0020, 0x0020, 0x0000, 0x0008, 0x0002, 0x0000 };

    auto collation = collate_for_tests(
        cps, cps + 2, boost::text::variable_weighting::non_ignorable);

    EXPECT_EQ(collation.size(), 9);
    EXPECT_TRUE(boost::algorithm::equal(collation.begin(), collation.end(), ces, ces + 9))
        << "from:     " << ce_dumper(cps)
        << "expected: " << ce_dumper(ces)
        << "got:      " << ce_dumper(collation);
}

TEST(collation, non_ignorable_111_289)
{
    // 0199 0061;	
    // (∆ô) LATIN SMALL LETTER K WITH HOOK	[1DD1 1CAD | 0020 0020 | 0002 0002 |]

    uint32_t cps[2] = { 0x0199, 0x0061 };
    uint32_t const ces[9] = { 0x1DD1, 0x1CAD, 0x0000, 0x0020, 0x0020, 0x0000, 0x0002, 0x0002, 0x0000 };

    auto collation = collate_for_tests(
        cps, cps + 2, boost::text::variable_weighting::non_ignorable);

    EXPECT_EQ(collation.size(), 9);
    EXPECT_TRUE(boost::algorithm::equal(collation.begin(), collation.end(), ces, ces + 9))
        << "from:     " << ce_dumper(cps)
        << "expected: " << ce_dumper(ces)
        << "got:      " << ce_dumper(collation);
}

TEST(collation, non_ignorable_111_290)
{
    // 0199 0041;	
    // (∆ô) LATIN SMALL LETTER K WITH HOOK	[1DD1 1CAD | 0020 0020 | 0002 0008 |]

    uint32_t cps[2] = { 0x0199, 0x0041 };
    uint32_t const ces[9] = { 0x1DD1, 0x1CAD, 0x0000, 0x0020, 0x0020, 0x0000, 0x0002, 0x0008, 0x0000 };

    auto collation = collate_for_tests(
        cps, cps + 2, boost::text::variable_weighting::non_ignorable);

    EXPECT_EQ(collation.size(), 9);
    EXPECT_TRUE(boost::algorithm::equal(collation.begin(), collation.end(), ces, ces + 9))
        << "from:     " << ce_dumper(cps)
        << "expected: " << ce_dumper(ces)
        << "got:      " << ce_dumper(collation);
}

TEST(collation, non_ignorable_111_291)
{
    // 0198 0061;	
    // (∆ò) LATIN CAPITAL LETTER K WITH HOOK	[1DD1 1CAD | 0020 0020 | 0008 0002 |]

    uint32_t cps[2] = { 0x0198, 0x0061 };
    uint32_t const ces[9] = { 0x1DD1, 0x1CAD, 0x0000, 0x0020, 0x0020, 0x0000, 0x0008, 0x0002, 0x0000 };

    auto collation = collate_for_tests(
        cps, cps + 2, boost::text::variable_weighting::non_ignorable);

    EXPECT_EQ(collation.size(), 9);
    EXPECT_TRUE(boost::algorithm::equal(collation.begin(), collation.end(), ces, ces + 9))
        << "from:     " << ce_dumper(cps)
        << "expected: " << ce_dumper(ces)
        << "got:      " << ce_dumper(collation);
}

TEST(collation, non_ignorable_111_292)
{
    // 0198 0041;	
    // (∆ò) LATIN CAPITAL LETTER K WITH HOOK	[1DD1 1CAD | 0020 0020 | 0008 0008 |]

    uint32_t cps[2] = { 0x0198, 0x0041 };
    uint32_t const ces[9] = { 0x1DD1, 0x1CAD, 0x0000, 0x0020, 0x0020, 0x0000, 0x0008, 0x0008, 0x0000 };

    auto collation = collate_for_tests(
        cps, cps + 2, boost::text::variable_weighting::non_ignorable);

    EXPECT_EQ(collation.size(), 9);
    EXPECT_TRUE(boost::algorithm::equal(collation.begin(), collation.end(), ces, ces + 9))
        << "from:     " << ce_dumper(cps)
        << "expected: " << ce_dumper(ces)
        << "got:      " << ce_dumper(collation);
}

TEST(collation, non_ignorable_111_293)
{
    // 0199 0062;	
    // (∆ô) LATIN SMALL LETTER K WITH HOOK	[1DD1 1CC6 | 0020 0020 | 0002 0002 |]

    uint32_t cps[2] = { 0x0199, 0x0062 };
    uint32_t const ces[9] = { 0x1DD1, 0x1CC6, 0x0000, 0x0020, 0x0020, 0x0000, 0x0002, 0x0002, 0x0000 };

    auto collation = collate_for_tests(
        cps, cps + 2, boost::text::variable_weighting::non_ignorable);

    EXPECT_EQ(collation.size(), 9);
    EXPECT_TRUE(boost::algorithm::equal(collation.begin(), collation.end(), ces, ces + 9))
        << "from:     " << ce_dumper(cps)
        << "expected: " << ce_dumper(ces)
        << "got:      " << ce_dumper(collation);
}

TEST(collation, non_ignorable_111_294)
{
    // 0198 0062;	
    // (∆ò) LATIN CAPITAL LETTER K WITH HOOK	[1DD1 1CC6 | 0020 0020 | 0008 0002 |]

    uint32_t cps[2] = { 0x0198, 0x0062 };
    uint32_t const ces[9] = { 0x1DD1, 0x1CC6, 0x0000, 0x0020, 0x0020, 0x0000, 0x0008, 0x0002, 0x0000 };

    auto collation = collate_for_tests(
        cps, cps + 2, boost::text::variable_weighting::non_ignorable);

    EXPECT_EQ(collation.size(), 9);
    EXPECT_TRUE(boost::algorithm::equal(collation.begin(), collation.end(), ces, ces + 9))
        << "from:     " << ce_dumper(cps)
        << "expected: " << ce_dumper(ces)
        << "got:      " << ce_dumper(collation);
}

TEST(collation, non_ignorable_111_295)
{
    // 2C6A 0021;	
    // (‚±™) LATIN SMALL LETTER K WITH DESCENDER	[1DD5 0261 | 0020 0020 | 0002 0002 |]

    uint32_t cps[2] = { 0x2C6A, 0x0021 };
    uint32_t const ces[9] = { 0x1DD5, 0x0261, 0x0000, 0x0020, 0x0020, 0x0000, 0x0002, 0x0002, 0x0000 };

    auto collation = collate_for_tests(
        cps, cps + 2, boost::text::variable_weighting::non_ignorable);

    EXPECT_EQ(collation.size(), 9);
    EXPECT_TRUE(boost::algorithm::equal(collation.begin(), collation.end(), ces, ces + 9))
        << "from:     " << ce_dumper(cps)
        << "expected: " << ce_dumper(ces)
        << "got:      " << ce_dumper(collation);
}

TEST(collation, non_ignorable_111_296)
{
    // 2C69 0021;	
    // (‚±©) LATIN CAPITAL LETTER K WITH DESCENDER	[1DD5 0261 | 0020 0020 | 0008 0002 |]

    uint32_t cps[2] = { 0x2C69, 0x0021 };
    uint32_t const ces[9] = { 0x1DD5, 0x0261, 0x0000, 0x0020, 0x0020, 0x0000, 0x0008, 0x0002, 0x0000 };

    auto collation = collate_for_tests(
        cps, cps + 2, boost::text::variable_weighting::non_ignorable);

    EXPECT_EQ(collation.size(), 9);
    EXPECT_TRUE(boost::algorithm::equal(collation.begin(), collation.end(), ces, ces + 9))
        << "from:     " << ce_dumper(cps)
        << "expected: " << ce_dumper(ces)
        << "got:      " << ce_dumper(collation);
}

TEST(collation, non_ignorable_111_297)
{
    // 2C6A 003F;	
    // (‚±™) LATIN SMALL LETTER K WITH DESCENDER	[1DD5 0267 | 0020 0020 | 0002 0002 |]

    uint32_t cps[2] = { 0x2C6A, 0x003F };
    uint32_t const ces[9] = { 0x1DD5, 0x0267, 0x0000, 0x0020, 0x0020, 0x0000, 0x0002, 0x0002, 0x0000 };

    auto collation = collate_for_tests(
        cps, cps + 2, boost::text::variable_weighting::non_ignorable);

    EXPECT_EQ(collation.size(), 9);
    EXPECT_TRUE(boost::algorithm::equal(collation.begin(), collation.end(), ces, ces + 9))
        << "from:     " << ce_dumper(cps)
        << "expected: " << ce_dumper(ces)
        << "got:      " << ce_dumper(collation);
}

TEST(collation, non_ignorable_111_298)
{
    // 2C69 003F;	
    // (‚±©) LATIN CAPITAL LETTER K WITH DESCENDER	[1DD5 0267 | 0020 0020 | 0008 0002 |]

    uint32_t cps[2] = { 0x2C69, 0x003F };
    uint32_t const ces[9] = { 0x1DD5, 0x0267, 0x0000, 0x0020, 0x0020, 0x0000, 0x0008, 0x0002, 0x0000 };

    auto collation = collate_for_tests(
        cps, cps + 2, boost::text::variable_weighting::non_ignorable);

    EXPECT_EQ(collation.size(), 9);
    EXPECT_TRUE(boost::algorithm::equal(collation.begin(), collation.end(), ces, ces + 9))
        << "from:     " << ce_dumper(cps)
        << "expected: " << ce_dumper(ces)
        << "got:      " << ce_dumper(collation);
}

TEST(collation, non_ignorable_111_299)
{
    // 2C6A 0061;	
    // (‚±™) LATIN SMALL LETTER K WITH DESCENDER	[1DD5 1CAD | 0020 0020 | 0002 0002 |]

    uint32_t cps[2] = { 0x2C6A, 0x0061 };
    uint32_t const ces[9] = { 0x1DD5, 0x1CAD, 0x0000, 0x0020, 0x0020, 0x0000, 0x0002, 0x0002, 0x0000 };

    auto collation = collate_for_tests(
        cps, cps + 2, boost::text::variable_weighting::non_ignorable);

    EXPECT_EQ(collation.size(), 9);
    EXPECT_TRUE(boost::algorithm::equal(collation.begin(), collation.end(), ces, ces + 9))
        << "from:     " << ce_dumper(cps)
        << "expected: " << ce_dumper(ces)
        << "got:      " << ce_dumper(collation);
}

TEST(collation, non_ignorable_111_300)
{
    // 2C6A 0041;	
    // (‚±™) LATIN SMALL LETTER K WITH DESCENDER	[1DD5 1CAD | 0020 0020 | 0002 0008 |]

    uint32_t cps[2] = { 0x2C6A, 0x0041 };
    uint32_t const ces[9] = { 0x1DD5, 0x1CAD, 0x0000, 0x0020, 0x0020, 0x0000, 0x0002, 0x0008, 0x0000 };

    auto collation = collate_for_tests(
        cps, cps + 2, boost::text::variable_weighting::non_ignorable);

    EXPECT_EQ(collation.size(), 9);
    EXPECT_TRUE(boost::algorithm::equal(collation.begin(), collation.end(), ces, ces + 9))
        << "from:     " << ce_dumper(cps)
        << "expected: " << ce_dumper(ces)
        << "got:      " << ce_dumper(collation);
}

TEST(collation, non_ignorable_111_301)
{
    // 2C69 0061;	
    // (‚±©) LATIN CAPITAL LETTER K WITH DESCENDER	[1DD5 1CAD | 0020 0020 | 0008 0002 |]

    uint32_t cps[2] = { 0x2C69, 0x0061 };
    uint32_t const ces[9] = { 0x1DD5, 0x1CAD, 0x0000, 0x0020, 0x0020, 0x0000, 0x0008, 0x0002, 0x0000 };

    auto collation = collate_for_tests(
        cps, cps + 2, boost::text::variable_weighting::non_ignorable);

    EXPECT_EQ(collation.size(), 9);
    EXPECT_TRUE(boost::algorithm::equal(collation.begin(), collation.end(), ces, ces + 9))
        << "from:     " << ce_dumper(cps)
        << "expected: " << ce_dumper(ces)
        << "got:      " << ce_dumper(collation);
}

TEST(collation, non_ignorable_111_302)
{
    // 2C69 0041;	
    // (‚±©) LATIN CAPITAL LETTER K WITH DESCENDER	[1DD5 1CAD | 0020 0020 | 0008 0008 |]

    uint32_t cps[2] = { 0x2C69, 0x0041 };
    uint32_t const ces[9] = { 0x1DD5, 0x1CAD, 0x0000, 0x0020, 0x0020, 0x0000, 0x0008, 0x0008, 0x0000 };

    auto collation = collate_for_tests(
        cps, cps + 2, boost::text::variable_weighting::non_ignorable);

    EXPECT_EQ(collation.size(), 9);
    EXPECT_TRUE(boost::algorithm::equal(collation.begin(), collation.end(), ces, ces + 9))
        << "from:     " << ce_dumper(cps)
        << "expected: " << ce_dumper(ces)
        << "got:      " << ce_dumper(collation);
}

TEST(collation, non_ignorable_111_303)
{
    // 2C6A 0062;	
    // (‚±™) LATIN SMALL LETTER K WITH DESCENDER	[1DD5 1CC6 | 0020 0020 | 0002 0002 |]

    uint32_t cps[2] = { 0x2C6A, 0x0062 };
    uint32_t const ces[9] = { 0x1DD5, 0x1CC6, 0x0000, 0x0020, 0x0020, 0x0000, 0x0002, 0x0002, 0x0000 };

    auto collation = collate_for_tests(
        cps, cps + 2, boost::text::variable_weighting::non_ignorable);

    EXPECT_EQ(collation.size(), 9);
    EXPECT_TRUE(boost::algorithm::equal(collation.begin(), collation.end(), ces, ces + 9))
        << "from:     " << ce_dumper(cps)
        << "expected: " << ce_dumper(ces)
        << "got:      " << ce_dumper(collation);
}

TEST(collation, non_ignorable_111_304)
{
    // 2C69 0062;	
    // (‚±©) LATIN CAPITAL LETTER K WITH DESCENDER	[1DD5 1CC6 | 0020 0020 | 0008 0002 |]

    uint32_t cps[2] = { 0x2C69, 0x0062 };
    uint32_t const ces[9] = { 0x1DD5, 0x1CC6, 0x0000, 0x0020, 0x0020, 0x0000, 0x0008, 0x0002, 0x0000 };

    auto collation = collate_for_tests(
        cps, cps + 2, boost::text::variable_weighting::non_ignorable);

    EXPECT_EQ(collation.size(), 9);
    EXPECT_TRUE(boost::algorithm::equal(collation.begin(), collation.end(), ces, ces + 9))
        << "from:     " << ce_dumper(cps)
        << "expected: " << ce_dumper(ces)
        << "got:      " << ce_dumper(collation);
}

TEST(collation, non_ignorable_111_305)
{
    // A741 0021;	
    // (ÍùÅ) LATIN SMALL LETTER K WITH STROKE	[1DD6 0261 | 0020 0020 | 0002 0002 |]

    uint32_t cps[2] = { 0xA741, 0x0021 };
    uint32_t const ces[9] = { 0x1DD6, 0x0261, 0x0000, 0x0020, 0x0020, 0x0000, 0x0002, 0x0002, 0x0000 };

    auto collation = collate_for_tests(
        cps, cps + 2, boost::text::variable_weighting::non_ignorable);

    EXPECT_EQ(collation.size(), 9);
    EXPECT_TRUE(boost::algorithm::equal(collation.begin(), collation.end(), ces, ces + 9))
        << "from:     " << ce_dumper(cps)
        << "expected: " << ce_dumper(ces)
        << "got:      " << ce_dumper(collation);
}

TEST(collation, non_ignorable_111_306)
{
    // A740 0021;	
    // (ÍùÄ) LATIN CAPITAL LETTER K WITH STROKE	[1DD6 0261 | 0020 0020 | 0008 0002 |]

    uint32_t cps[2] = { 0xA740, 0x0021 };
    uint32_t const ces[9] = { 0x1DD6, 0x0261, 0x0000, 0x0020, 0x0020, 0x0000, 0x0008, 0x0002, 0x0000 };

    auto collation = collate_for_tests(
        cps, cps + 2, boost::text::variable_weighting::non_ignorable);

    EXPECT_EQ(collation.size(), 9);
    EXPECT_TRUE(boost::algorithm::equal(collation.begin(), collation.end(), ces, ces + 9))
        << "from:     " << ce_dumper(cps)
        << "expected: " << ce_dumper(ces)
        << "got:      " << ce_dumper(collation);
}

TEST(collation, non_ignorable_111_307)
{
    // A741 003F;	
    // (ÍùÅ) LATIN SMALL LETTER K WITH STROKE	[1DD6 0267 | 0020 0020 | 0002 0002 |]

    uint32_t cps[2] = { 0xA741, 0x003F };
    uint32_t const ces[9] = { 0x1DD6, 0x0267, 0x0000, 0x0020, 0x0020, 0x0000, 0x0002, 0x0002, 0x0000 };

    auto collation = collate_for_tests(
        cps, cps + 2, boost::text::variable_weighting::non_ignorable);

    EXPECT_EQ(collation.size(), 9);
    EXPECT_TRUE(boost::algorithm::equal(collation.begin(), collation.end(), ces, ces + 9))
        << "from:     " << ce_dumper(cps)
        << "expected: " << ce_dumper(ces)
        << "got:      " << ce_dumper(collation);
}

TEST(collation, non_ignorable_111_308)
{
    // A740 003F;	
    // (ÍùÄ) LATIN CAPITAL LETTER K WITH STROKE	[1DD6 0267 | 0020 0020 | 0008 0002 |]

    uint32_t cps[2] = { 0xA740, 0x003F };
    uint32_t const ces[9] = { 0x1DD6, 0x0267, 0x0000, 0x0020, 0x0020, 0x0000, 0x0008, 0x0002, 0x0000 };

    auto collation = collate_for_tests(
        cps, cps + 2, boost::text::variable_weighting::non_ignorable);

    EXPECT_EQ(collation.size(), 9);
    EXPECT_TRUE(boost::algorithm::equal(collation.begin(), collation.end(), ces, ces + 9))
        << "from:     " << ce_dumper(cps)
        << "expected: " << ce_dumper(ces)
        << "got:      " << ce_dumper(collation);
}

TEST(collation, non_ignorable_111_309)
{
    // A741 0061;	
    // (ÍùÅ) LATIN SMALL LETTER K WITH STROKE	[1DD6 1CAD | 0020 0020 | 0002 0002 |]

    uint32_t cps[2] = { 0xA741, 0x0061 };
    uint32_t const ces[9] = { 0x1DD6, 0x1CAD, 0x0000, 0x0020, 0x0020, 0x0000, 0x0002, 0x0002, 0x0000 };

    auto collation = collate_for_tests(
        cps, cps + 2, boost::text::variable_weighting::non_ignorable);

    EXPECT_EQ(collation.size(), 9);
    EXPECT_TRUE(boost::algorithm::equal(collation.begin(), collation.end(), ces, ces + 9))
        << "from:     " << ce_dumper(cps)
        << "expected: " << ce_dumper(ces)
        << "got:      " << ce_dumper(collation);
}

TEST(collation, non_ignorable_111_310)
{
    // A741 0041;	
    // (ÍùÅ) LATIN SMALL LETTER K WITH STROKE	[1DD6 1CAD | 0020 0020 | 0002 0008 |]

    uint32_t cps[2] = { 0xA741, 0x0041 };
    uint32_t const ces[9] = { 0x1DD6, 0x1CAD, 0x0000, 0x0020, 0x0020, 0x0000, 0x0002, 0x0008, 0x0000 };

    auto collation = collate_for_tests(
        cps, cps + 2, boost::text::variable_weighting::non_ignorable);

    EXPECT_EQ(collation.size(), 9);
    EXPECT_TRUE(boost::algorithm::equal(collation.begin(), collation.end(), ces, ces + 9))
        << "from:     " << ce_dumper(cps)
        << "expected: " << ce_dumper(ces)
        << "got:      " << ce_dumper(collation);
}

TEST(collation, non_ignorable_111_311)
{
    // A740 0061;	
    // (ÍùÄ) LATIN CAPITAL LETTER K WITH STROKE	[1DD6 1CAD | 0020 0020 | 0008 0002 |]

    uint32_t cps[2] = { 0xA740, 0x0061 };
    uint32_t const ces[9] = { 0x1DD6, 0x1CAD, 0x0000, 0x0020, 0x0020, 0x0000, 0x0008, 0x0002, 0x0000 };

    auto collation = collate_for_tests(
        cps, cps + 2, boost::text::variable_weighting::non_ignorable);

    EXPECT_EQ(collation.size(), 9);
    EXPECT_TRUE(boost::algorithm::equal(collation.begin(), collation.end(), ces, ces + 9))
        << "from:     " << ce_dumper(cps)
        << "expected: " << ce_dumper(ces)
        << "got:      " << ce_dumper(collation);
}

TEST(collation, non_ignorable_111_312)
{
    // A740 0041;	
    // (ÍùÄ) LATIN CAPITAL LETTER K WITH STROKE	[1DD6 1CAD | 0020 0020 | 0008 0008 |]

    uint32_t cps[2] = { 0xA740, 0x0041 };
    uint32_t const ces[9] = { 0x1DD6, 0x1CAD, 0x0000, 0x0020, 0x0020, 0x0000, 0x0008, 0x0008, 0x0000 };

    auto collation = collate_for_tests(
        cps, cps + 2, boost::text::variable_weighting::non_ignorable);

    EXPECT_EQ(collation.size(), 9);
    EXPECT_TRUE(boost::algorithm::equal(collation.begin(), collation.end(), ces, ces + 9))
        << "from:     " << ce_dumper(cps)
        << "expected: " << ce_dumper(ces)
        << "got:      " << ce_dumper(collation);
}

TEST(collation, non_ignorable_111_313)
{
    // A741 0062;	
    // (ÍùÅ) LATIN SMALL LETTER K WITH STROKE	[1DD6 1CC6 | 0020 0020 | 0002 0002 |]

    uint32_t cps[2] = { 0xA741, 0x0062 };
    uint32_t const ces[9] = { 0x1DD6, 0x1CC6, 0x0000, 0x0020, 0x0020, 0x0000, 0x0002, 0x0002, 0x0000 };

    auto collation = collate_for_tests(
        cps, cps + 2, boost::text::variable_weighting::non_ignorable);

    EXPECT_EQ(collation.size(), 9);
    EXPECT_TRUE(boost::algorithm::equal(collation.begin(), collation.end(), ces, ces + 9))
        << "from:     " << ce_dumper(cps)
        << "expected: " << ce_dumper(ces)
        << "got:      " << ce_dumper(collation);
}

TEST(collation, non_ignorable_111_314)
{
    // A740 0062;	
    // (ÍùÄ) LATIN CAPITAL LETTER K WITH STROKE	[1DD6 1CC6 | 0020 0020 | 0008 0002 |]

    uint32_t cps[2] = { 0xA740, 0x0062 };
    uint32_t const ces[9] = { 0x1DD6, 0x1CC6, 0x0000, 0x0020, 0x0020, 0x0000, 0x0008, 0x0002, 0x0000 };

    auto collation = collate_for_tests(
        cps, cps + 2, boost::text::variable_weighting::non_ignorable);

    EXPECT_EQ(collation.size(), 9);
    EXPECT_TRUE(boost::algorithm::equal(collation.begin(), collation.end(), ces, ces + 9))
        << "from:     " << ce_dumper(cps)
        << "expected: " << ce_dumper(ces)
        << "got:      " << ce_dumper(collation);
}

TEST(collation, non_ignorable_111_315)
{
    // A743 0021;	
    // (ÍùÉ) LATIN SMALL LETTER K WITH DIAGONAL STROKE	[1DD7 0261 | 0020 0020 | 0002 0002 |]

    uint32_t cps[2] = { 0xA743, 0x0021 };
    uint32_t const ces[9] = { 0x1DD7, 0x0261, 0x0000, 0x0020, 0x0020, 0x0000, 0x0002, 0x0002, 0x0000 };

    auto collation = collate_for_tests(
        cps, cps + 2, boost::text::variable_weighting::non_ignorable);

    EXPECT_EQ(collation.size(), 9);
    EXPECT_TRUE(boost::algorithm::equal(collation.begin(), collation.end(), ces, ces + 9))
        << "from:     " << ce_dumper(cps)
        << "expected: " << ce_dumper(ces)
        << "got:      " << ce_dumper(collation);
}

TEST(collation, non_ignorable_111_316)
{
    // A742 0021;	
    // (ÍùÇ) LATIN CAPITAL LETTER K WITH DIAGONAL STROKE	[1DD7 0261 | 0020 0020 | 0008 0002 |]

    uint32_t cps[2] = { 0xA742, 0x0021 };
    uint32_t const ces[9] = { 0x1DD7, 0x0261, 0x0000, 0x0020, 0x0020, 0x0000, 0x0008, 0x0002, 0x0000 };

    auto collation = collate_for_tests(
        cps, cps + 2, boost::text::variable_weighting::non_ignorable);

    EXPECT_EQ(collation.size(), 9);
    EXPECT_TRUE(boost::algorithm::equal(collation.begin(), collation.end(), ces, ces + 9))
        << "from:     " << ce_dumper(cps)
        << "expected: " << ce_dumper(ces)
        << "got:      " << ce_dumper(collation);
}

TEST(collation, non_ignorable_111_317)
{
    // A743 003F;	
    // (ÍùÉ) LATIN SMALL LETTER K WITH DIAGONAL STROKE	[1DD7 0267 | 0020 0020 | 0002 0002 |]

    uint32_t cps[2] = { 0xA743, 0x003F };
    uint32_t const ces[9] = { 0x1DD7, 0x0267, 0x0000, 0x0020, 0x0020, 0x0000, 0x0002, 0x0002, 0x0000 };

    auto collation = collate_for_tests(
        cps, cps + 2, boost::text::variable_weighting::non_ignorable);

    EXPECT_EQ(collation.size(), 9);
    EXPECT_TRUE(boost::algorithm::equal(collation.begin(), collation.end(), ces, ces + 9))
        << "from:     " << ce_dumper(cps)
        << "expected: " << ce_dumper(ces)
        << "got:      " << ce_dumper(collation);
}

TEST(collation, non_ignorable_111_318)
{
    // A742 003F;	
    // (ÍùÇ) LATIN CAPITAL LETTER K WITH DIAGONAL STROKE	[1DD7 0267 | 0020 0020 | 0008 0002 |]

    uint32_t cps[2] = { 0xA742, 0x003F };
    uint32_t const ces[9] = { 0x1DD7, 0x0267, 0x0000, 0x0020, 0x0020, 0x0000, 0x0008, 0x0002, 0x0000 };

    auto collation = collate_for_tests(
        cps, cps + 2, boost::text::variable_weighting::non_ignorable);

    EXPECT_EQ(collation.size(), 9);
    EXPECT_TRUE(boost::algorithm::equal(collation.begin(), collation.end(), ces, ces + 9))
        << "from:     " << ce_dumper(cps)
        << "expected: " << ce_dumper(ces)
        << "got:      " << ce_dumper(collation);
}

TEST(collation, non_ignorable_111_319)
{
    // A743 0061;	
    // (ÍùÉ) LATIN SMALL LETTER K WITH DIAGONAL STROKE	[1DD7 1CAD | 0020 0020 | 0002 0002 |]

    uint32_t cps[2] = { 0xA743, 0x0061 };
    uint32_t const ces[9] = { 0x1DD7, 0x1CAD, 0x0000, 0x0020, 0x0020, 0x0000, 0x0002, 0x0002, 0x0000 };

    auto collation = collate_for_tests(
        cps, cps + 2, boost::text::variable_weighting::non_ignorable);

    EXPECT_EQ(collation.size(), 9);
    EXPECT_TRUE(boost::algorithm::equal(collation.begin(), collation.end(), ces, ces + 9))
        << "from:     " << ce_dumper(cps)
        << "expected: " << ce_dumper(ces)
        << "got:      " << ce_dumper(collation);
}

TEST(collation, non_ignorable_111_320)
{
    // A743 0041;	
    // (ÍùÉ) LATIN SMALL LETTER K WITH DIAGONAL STROKE	[1DD7 1CAD | 0020 0020 | 0002 0008 |]

    uint32_t cps[2] = { 0xA743, 0x0041 };
    uint32_t const ces[9] = { 0x1DD7, 0x1CAD, 0x0000, 0x0020, 0x0020, 0x0000, 0x0002, 0x0008, 0x0000 };

    auto collation = collate_for_tests(
        cps, cps + 2, boost::text::variable_weighting::non_ignorable);

    EXPECT_EQ(collation.size(), 9);
    EXPECT_TRUE(boost::algorithm::equal(collation.begin(), collation.end(), ces, ces + 9))
        << "from:     " << ce_dumper(cps)
        << "expected: " << ce_dumper(ces)
        << "got:      " << ce_dumper(collation);
}

TEST(collation, non_ignorable_111_321)
{
    // A742 0061;	
    // (ÍùÇ) LATIN CAPITAL LETTER K WITH DIAGONAL STROKE	[1DD7 1CAD | 0020 0020 | 0008 0002 |]

    uint32_t cps[2] = { 0xA742, 0x0061 };
    uint32_t const ces[9] = { 0x1DD7, 0x1CAD, 0x0000, 0x0020, 0x0020, 0x0000, 0x0008, 0x0002, 0x0000 };

    auto collation = collate_for_tests(
        cps, cps + 2, boost::text::variable_weighting::non_ignorable);

    EXPECT_EQ(collation.size(), 9);
    EXPECT_TRUE(boost::algorithm::equal(collation.begin(), collation.end(), ces, ces + 9))
        << "from:     " << ce_dumper(cps)
        << "expected: " << ce_dumper(ces)
        << "got:      " << ce_dumper(collation);
}

TEST(collation, non_ignorable_111_322)
{
    // A742 0041;	
    // (ÍùÇ) LATIN CAPITAL LETTER K WITH DIAGONAL STROKE	[1DD7 1CAD | 0020 0020 | 0008 0008 |]

    uint32_t cps[2] = { 0xA742, 0x0041 };
    uint32_t const ces[9] = { 0x1DD7, 0x1CAD, 0x0000, 0x0020, 0x0020, 0x0000, 0x0008, 0x0008, 0x0000 };

    auto collation = collate_for_tests(
        cps, cps + 2, boost::text::variable_weighting::non_ignorable);

    EXPECT_EQ(collation.size(), 9);
    EXPECT_TRUE(boost::algorithm::equal(collation.begin(), collation.end(), ces, ces + 9))
        << "from:     " << ce_dumper(cps)
        << "expected: " << ce_dumper(ces)
        << "got:      " << ce_dumper(collation);
}

TEST(collation, non_ignorable_111_323)
{
    // A743 0062;	
    // (ÍùÉ) LATIN SMALL LETTER K WITH DIAGONAL STROKE	[1DD7 1CC6 | 0020 0020 | 0002 0002 |]

    uint32_t cps[2] = { 0xA743, 0x0062 };
    uint32_t const ces[9] = { 0x1DD7, 0x1CC6, 0x0000, 0x0020, 0x0020, 0x0000, 0x0002, 0x0002, 0x0000 };

    auto collation = collate_for_tests(
        cps, cps + 2, boost::text::variable_weighting::non_ignorable);

    EXPECT_EQ(collation.size(), 9);
    EXPECT_TRUE(boost::algorithm::equal(collation.begin(), collation.end(), ces, ces + 9))
        << "from:     " << ce_dumper(cps)
        << "expected: " << ce_dumper(ces)
        << "got:      " << ce_dumper(collation);
}

TEST(collation, non_ignorable_111_324)
{
    // A742 0062;	
    // (ÍùÇ) LATIN CAPITAL LETTER K WITH DIAGONAL STROKE	[1DD7 1CC6 | 0020 0020 | 0008 0002 |]

    uint32_t cps[2] = { 0xA742, 0x0062 };
    uint32_t const ces[9] = { 0x1DD7, 0x1CC6, 0x0000, 0x0020, 0x0020, 0x0000, 0x0008, 0x0002, 0x0000 };

    auto collation = collate_for_tests(
        cps, cps + 2, boost::text::variable_weighting::non_ignorable);

    EXPECT_EQ(collation.size(), 9);
    EXPECT_TRUE(boost::algorithm::equal(collation.begin(), collation.end(), ces, ces + 9))
        << "from:     " << ce_dumper(cps)
        << "expected: " << ce_dumper(ces)
        << "got:      " << ce_dumper(collation);
}

TEST(collation, non_ignorable_111_325)
{
    // A745 0021;	
    // (ÍùÖ) LATIN SMALL LETTER K WITH STROKE AND DIAGONAL STROKE	[1DD8 0261 | 0020 0020 | 0002 0002 |]

    uint32_t cps[2] = { 0xA745, 0x0021 };
    uint32_t const ces[9] = { 0x1DD8, 0x0261, 0x0000, 0x0020, 0x0020, 0x0000, 0x0002, 0x0002, 0x0000 };

    auto collation = collate_for_tests(
        cps, cps + 2, boost::text::variable_weighting::non_ignorable);

    EXPECT_EQ(collation.size(), 9);
    EXPECT_TRUE(boost::algorithm::equal(collation.begin(), collation.end(), ces, ces + 9))
        << "from:     " << ce_dumper(cps)
        << "expected: " << ce_dumper(ces)
        << "got:      " << ce_dumper(collation);
}

TEST(collation, non_ignorable_111_326)
{
    // A744 0021;	
    // (ÍùÑ) LATIN CAPITAL LETTER K WITH STROKE AND DIAGONAL STROKE	[1DD8 0261 | 0020 0020 | 0008 0002 |]

    uint32_t cps[2] = { 0xA744, 0x0021 };
    uint32_t const ces[9] = { 0x1DD8, 0x0261, 0x0000, 0x0020, 0x0020, 0x0000, 0x0008, 0x0002, 0x0000 };

    auto collation = collate_for_tests(
        cps, cps + 2, boost::text::variable_weighting::non_ignorable);

    EXPECT_EQ(collation.size(), 9);
    EXPECT_TRUE(boost::algorithm::equal(collation.begin(), collation.end(), ces, ces + 9))
        << "from:     " << ce_dumper(cps)
        << "expected: " << ce_dumper(ces)
        << "got:      " << ce_dumper(collation);
}

TEST(collation, non_ignorable_111_327)
{
    // A745 003F;	
    // (ÍùÖ) LATIN SMALL LETTER K WITH STROKE AND DIAGONAL STROKE	[1DD8 0267 | 0020 0020 | 0002 0002 |]

    uint32_t cps[2] = { 0xA745, 0x003F };
    uint32_t const ces[9] = { 0x1DD8, 0x0267, 0x0000, 0x0020, 0x0020, 0x0000, 0x0002, 0x0002, 0x0000 };

    auto collation = collate_for_tests(
        cps, cps + 2, boost::text::variable_weighting::non_ignorable);

    EXPECT_EQ(collation.size(), 9);
    EXPECT_TRUE(boost::algorithm::equal(collation.begin(), collation.end(), ces, ces + 9))
        << "from:     " << ce_dumper(cps)
        << "expected: " << ce_dumper(ces)
        << "got:      " << ce_dumper(collation);
}

TEST(collation, non_ignorable_111_328)
{
    // A744 003F;	
    // (ÍùÑ) LATIN CAPITAL LETTER K WITH STROKE AND DIAGONAL STROKE	[1DD8 0267 | 0020 0020 | 0008 0002 |]

    uint32_t cps[2] = { 0xA744, 0x003F };
    uint32_t const ces[9] = { 0x1DD8, 0x0267, 0x0000, 0x0020, 0x0020, 0x0000, 0x0008, 0x0002, 0x0000 };

    auto collation = collate_for_tests(
        cps, cps + 2, boost::text::variable_weighting::non_ignorable);

    EXPECT_EQ(collation.size(), 9);
    EXPECT_TRUE(boost::algorithm::equal(collation.begin(), collation.end(), ces, ces + 9))
        << "from:     " << ce_dumper(cps)
        << "expected: " << ce_dumper(ces)
        << "got:      " << ce_dumper(collation);
}

TEST(collation, non_ignorable_111_329)
{
    // A745 0061;	
    // (ÍùÖ) LATIN SMALL LETTER K WITH STROKE AND DIAGONAL STROKE	[1DD8 1CAD | 0020 0020 | 0002 0002 |]

    uint32_t cps[2] = { 0xA745, 0x0061 };
    uint32_t const ces[9] = { 0x1DD8, 0x1CAD, 0x0000, 0x0020, 0x0020, 0x0000, 0x0002, 0x0002, 0x0000 };

    auto collation = collate_for_tests(
        cps, cps + 2, boost::text::variable_weighting::non_ignorable);

    EXPECT_EQ(collation.size(), 9);
    EXPECT_TRUE(boost::algorithm::equal(collation.begin(), collation.end(), ces, ces + 9))
        << "from:     " << ce_dumper(cps)
        << "expected: " << ce_dumper(ces)
        << "got:      " << ce_dumper(collation);
}

TEST(collation, non_ignorable_111_330)
{
    // A745 0041;	
    // (ÍùÖ) LATIN SMALL LETTER K WITH STROKE AND DIAGONAL STROKE	[1DD8 1CAD | 0020 0020 | 0002 0008 |]

    uint32_t cps[2] = { 0xA745, 0x0041 };
    uint32_t const ces[9] = { 0x1DD8, 0x1CAD, 0x0000, 0x0020, 0x0020, 0x0000, 0x0002, 0x0008, 0x0000 };

    auto collation = collate_for_tests(
        cps, cps + 2, boost::text::variable_weighting::non_ignorable);

    EXPECT_EQ(collation.size(), 9);
    EXPECT_TRUE(boost::algorithm::equal(collation.begin(), collation.end(), ces, ces + 9))
        << "from:     " << ce_dumper(cps)
        << "expected: " << ce_dumper(ces)
        << "got:      " << ce_dumper(collation);
}

TEST(collation, non_ignorable_111_331)
{
    // A744 0061;	
    // (ÍùÑ) LATIN CAPITAL LETTER K WITH STROKE AND DIAGONAL STROKE	[1DD8 1CAD | 0020 0020 | 0008 0002 |]

    uint32_t cps[2] = { 0xA744, 0x0061 };
    uint32_t const ces[9] = { 0x1DD8, 0x1CAD, 0x0000, 0x0020, 0x0020, 0x0000, 0x0008, 0x0002, 0x0000 };

    auto collation = collate_for_tests(
        cps, cps + 2, boost::text::variable_weighting::non_ignorable);

    EXPECT_EQ(collation.size(), 9);
    EXPECT_TRUE(boost::algorithm::equal(collation.begin(), collation.end(), ces, ces + 9))
        << "from:     " << ce_dumper(cps)
        << "expected: " << ce_dumper(ces)
        << "got:      " << ce_dumper(collation);
}

TEST(collation, non_ignorable_111_332)
{
    // A744 0041;	
    // (ÍùÑ) LATIN CAPITAL LETTER K WITH STROKE AND DIAGONAL STROKE	[1DD8 1CAD | 0020 0020 | 0008 0008 |]

    uint32_t cps[2] = { 0xA744, 0x0041 };
    uint32_t const ces[9] = { 0x1DD8, 0x1CAD, 0x0000, 0x0020, 0x0020, 0x0000, 0x0008, 0x0008, 0x0000 };

    auto collation = collate_for_tests(
        cps, cps + 2, boost::text::variable_weighting::non_ignorable);

    EXPECT_EQ(collation.size(), 9);
    EXPECT_TRUE(boost::algorithm::equal(collation.begin(), collation.end(), ces, ces + 9))
        << "from:     " << ce_dumper(cps)
        << "expected: " << ce_dumper(ces)
        << "got:      " << ce_dumper(collation);
}

TEST(collation, non_ignorable_111_333)
{
    // A745 0062;	
    // (ÍùÖ) LATIN SMALL LETTER K WITH STROKE AND DIAGONAL STROKE	[1DD8 1CC6 | 0020 0020 | 0002 0002 |]

    uint32_t cps[2] = { 0xA745, 0x0062 };
    uint32_t const ces[9] = { 0x1DD8, 0x1CC6, 0x0000, 0x0020, 0x0020, 0x0000, 0x0002, 0x0002, 0x0000 };

    auto collation = collate_for_tests(
        cps, cps + 2, boost::text::variable_weighting::non_ignorable);

    EXPECT_EQ(collation.size(), 9);
    EXPECT_TRUE(boost::algorithm::equal(collation.begin(), collation.end(), ces, ces + 9))
        << "from:     " << ce_dumper(cps)
        << "expected: " << ce_dumper(ces)
        << "got:      " << ce_dumper(collation);
}

TEST(collation, non_ignorable_111_334)
{
    // A744 0062;	
    // (ÍùÑ) LATIN CAPITAL LETTER K WITH STROKE AND DIAGONAL STROKE	[1DD8 1CC6 | 0020 0020 | 0008 0002 |]

    uint32_t cps[2] = { 0xA744, 0x0062 };
    uint32_t const ces[9] = { 0x1DD8, 0x1CC6, 0x0000, 0x0020, 0x0020, 0x0000, 0x0008, 0x0002, 0x0000 };

    auto collation = collate_for_tests(
        cps, cps + 2, boost::text::variable_weighting::non_ignorable);

    EXPECT_EQ(collation.size(), 9);
    EXPECT_TRUE(boost::algorithm::equal(collation.begin(), collation.end(), ces, ces + 9))
        << "from:     " << ce_dumper(cps)
        << "expected: " << ce_dumper(ces)
        << "got:      " << ce_dumper(collation);
}

TEST(collation, non_ignorable_111_335)
{
    // 029E 0021;	
    // ( û) LATIN SMALL LETTER TURNED K	[1DD9 0261 | 0020 0020 | 0002 0002 |]

    uint32_t cps[2] = { 0x029E, 0x0021 };
    uint32_t const ces[9] = { 0x1DD9, 0x0261, 0x0000, 0x0020, 0x0020, 0x0000, 0x0002, 0x0002, 0x0000 };

    auto collation = collate_for_tests(
        cps, cps + 2, boost::text::variable_weighting::non_ignorable);

    EXPECT_EQ(collation.size(), 9);
    EXPECT_TRUE(boost::algorithm::equal(collation.begin(), collation.end(), ces, ces + 9))
        << "from:     " << ce_dumper(cps)
        << "expected: " << ce_dumper(ces)
        << "got:      " << ce_dumper(collation);
}

TEST(collation, non_ignorable_111_336)
{
    // A7B0 0021;	
    // (Íû∞) LATIN CAPITAL LETTER TURNED K	[1DD9 0261 | 0020 0020 | 0008 0002 |]

    uint32_t cps[2] = { 0xA7B0, 0x0021 };
    uint32_t const ces[9] = { 0x1DD9, 0x0261, 0x0000, 0x0020, 0x0020, 0x0000, 0x0008, 0x0002, 0x0000 };

    auto collation = collate_for_tests(
        cps, cps + 2, boost::text::variable_weighting::non_ignorable);

    EXPECT_EQ(collation.size(), 9);
    EXPECT_TRUE(boost::algorithm::equal(collation.begin(), collation.end(), ces, ces + 9))
        << "from:     " << ce_dumper(cps)
        << "expected: " << ce_dumper(ces)
        << "got:      " << ce_dumper(collation);
}

TEST(collation, non_ignorable_111_337)
{
    // 029E 003F;	
    // ( û) LATIN SMALL LETTER TURNED K	[1DD9 0267 | 0020 0020 | 0002 0002 |]

    uint32_t cps[2] = { 0x029E, 0x003F };
    uint32_t const ces[9] = { 0x1DD9, 0x0267, 0x0000, 0x0020, 0x0020, 0x0000, 0x0002, 0x0002, 0x0000 };

    auto collation = collate_for_tests(
        cps, cps + 2, boost::text::variable_weighting::non_ignorable);

    EXPECT_EQ(collation.size(), 9);
    EXPECT_TRUE(boost::algorithm::equal(collation.begin(), collation.end(), ces, ces + 9))
        << "from:     " << ce_dumper(cps)
        << "expected: " << ce_dumper(ces)
        << "got:      " << ce_dumper(collation);
}

TEST(collation, non_ignorable_111_338)
{
    // A7B0 003F;	
    // (Íû∞) LATIN CAPITAL LETTER TURNED K	[1DD9 0267 | 0020 0020 | 0008 0002 |]

    uint32_t cps[2] = { 0xA7B0, 0x003F };
    uint32_t const ces[9] = { 0x1DD9, 0x0267, 0x0000, 0x0020, 0x0020, 0x0000, 0x0008, 0x0002, 0x0000 };

    auto collation = collate_for_tests(
        cps, cps + 2, boost::text::variable_weighting::non_ignorable);

    EXPECT_EQ(collation.size(), 9);
    EXPECT_TRUE(boost::algorithm::equal(collation.begin(), collation.end(), ces, ces + 9))
        << "from:     " << ce_dumper(cps)
        << "expected: " << ce_dumper(ces)
        << "got:      " << ce_dumper(collation);
}

TEST(collation, non_ignorable_111_339)
{
    // 029E 0061;	
    // ( û) LATIN SMALL LETTER TURNED K	[1DD9 1CAD | 0020 0020 | 0002 0002 |]

    uint32_t cps[2] = { 0x029E, 0x0061 };
    uint32_t const ces[9] = { 0x1DD9, 0x1CAD, 0x0000, 0x0020, 0x0020, 0x0000, 0x0002, 0x0002, 0x0000 };

    auto collation = collate_for_tests(
        cps, cps + 2, boost::text::variable_weighting::non_ignorable);

    EXPECT_EQ(collation.size(), 9);
    EXPECT_TRUE(boost::algorithm::equal(collation.begin(), collation.end(), ces, ces + 9))
        << "from:     " << ce_dumper(cps)
        << "expected: " << ce_dumper(ces)
        << "got:      " << ce_dumper(collation);
}

TEST(collation, non_ignorable_111_340)
{
    // 029E 0041;	
    // ( û) LATIN SMALL LETTER TURNED K	[1DD9 1CAD | 0020 0020 | 0002 0008 |]

    uint32_t cps[2] = { 0x029E, 0x0041 };
    uint32_t const ces[9] = { 0x1DD9, 0x1CAD, 0x0000, 0x0020, 0x0020, 0x0000, 0x0002, 0x0008, 0x0000 };

    auto collation = collate_for_tests(
        cps, cps + 2, boost::text::variable_weighting::non_ignorable);

    EXPECT_EQ(collation.size(), 9);
    EXPECT_TRUE(boost::algorithm::equal(collation.begin(), collation.end(), ces, ces + 9))
        << "from:     " << ce_dumper(cps)
        << "expected: " << ce_dumper(ces)
        << "got:      " << ce_dumper(collation);
}

TEST(collation, non_ignorable_111_341)
{
    // A7B0 0061;	
    // (Íû∞) LATIN CAPITAL LETTER TURNED K	[1DD9 1CAD | 0020 0020 | 0008 0002 |]

    uint32_t cps[2] = { 0xA7B0, 0x0061 };
    uint32_t const ces[9] = { 0x1DD9, 0x1CAD, 0x0000, 0x0020, 0x0020, 0x0000, 0x0008, 0x0002, 0x0000 };

    auto collation = collate_for_tests(
        cps, cps + 2, boost::text::variable_weighting::non_ignorable);

    EXPECT_EQ(collation.size(), 9);
    EXPECT_TRUE(boost::algorithm::equal(collation.begin(), collation.end(), ces, ces + 9))
        << "from:     " << ce_dumper(cps)
        << "expected: " << ce_dumper(ces)
        << "got:      " << ce_dumper(collation);
}

TEST(collation, non_ignorable_111_342)
{
    // A7B0 0041;	
    // (Íû∞) LATIN CAPITAL LETTER TURNED K	[1DD9 1CAD | 0020 0020 | 0008 0008 |]

    uint32_t cps[2] = { 0xA7B0, 0x0041 };
    uint32_t const ces[9] = { 0x1DD9, 0x1CAD, 0x0000, 0x0020, 0x0020, 0x0000, 0x0008, 0x0008, 0x0000 };

    auto collation = collate_for_tests(
        cps, cps + 2, boost::text::variable_weighting::non_ignorable);

    EXPECT_EQ(collation.size(), 9);
    EXPECT_TRUE(boost::algorithm::equal(collation.begin(), collation.end(), ces, ces + 9))
        << "from:     " << ce_dumper(cps)
        << "expected: " << ce_dumper(ces)
        << "got:      " << ce_dumper(collation);
}

TEST(collation, non_ignorable_111_343)
{
    // 029E 0062;	
    // ( û) LATIN SMALL LETTER TURNED K	[1DD9 1CC6 | 0020 0020 | 0002 0002 |]

    uint32_t cps[2] = { 0x029E, 0x0062 };
    uint32_t const ces[9] = { 0x1DD9, 0x1CC6, 0x0000, 0x0020, 0x0020, 0x0000, 0x0002, 0x0002, 0x0000 };

    auto collation = collate_for_tests(
        cps, cps + 2, boost::text::variable_weighting::non_ignorable);

    EXPECT_EQ(collation.size(), 9);
    EXPECT_TRUE(boost::algorithm::equal(collation.begin(), collation.end(), ces, ces + 9))
        << "from:     " << ce_dumper(cps)
        << "expected: " << ce_dumper(ces)
        << "got:      " << ce_dumper(collation);
}

TEST(collation, non_ignorable_111_344)
{
    // A7B0 0062;	
    // (Íû∞) LATIN CAPITAL LETTER TURNED K	[1DD9 1CC6 | 0020 0020 | 0008 0002 |]

    uint32_t cps[2] = { 0xA7B0, 0x0062 };
    uint32_t const ces[9] = { 0x1DD9, 0x1CC6, 0x0000, 0x0020, 0x0020, 0x0000, 0x0008, 0x0002, 0x0000 };

    auto collation = collate_for_tests(
        cps, cps + 2, boost::text::variable_weighting::non_ignorable);

    EXPECT_EQ(collation.size(), 9);
    EXPECT_TRUE(boost::algorithm::equal(collation.begin(), collation.end(), ces, ces + 9))
        << "from:     " << ce_dumper(cps)
        << "expected: " << ce_dumper(ces)
        << "got:      " << ce_dumper(collation);
}

TEST(collation, non_ignorable_111_345)
{
    // 006C 0301 0334;	
    // (ƒ∫) LATIN SMALL LETTER L, COMBINING ACUTE ACCENT	[1DDD | 0020 004A 0024 | 0002 0002 0002 |]

    uint32_t cps[3] = { 0x006C, 0x0301, 0x0334 };
    uint32_t const ces[10] = { 0x1DDD, 0x0000, 0x0020, 0x004A, 0x0024, 0x0000, 0x0002, 0x0002, 0x0002, 0x0000 };

    auto collation = collate_for_tests(
        cps, cps + 3, boost::text::variable_weighting::non_ignorable);

    EXPECT_EQ(collation.size(), 10);
    EXPECT_TRUE(boost::algorithm::equal(collation.begin(), collation.end(), ces, ces + 10))
        << "from:     " << ce_dumper(cps)
        << "expected: " << ce_dumper(ces)
        << "got:      " << ce_dumper(collation);
}

TEST(collation, non_ignorable_111_346)
{
    // 006C 0334 0301;	
    // (lÃ¥) LATIN SMALL LETTER L, COMBINING TILDE OVERLAY	[1DDD | 0020 004A 0024 | 0002 0002 0002 |]

    uint32_t cps[3] = { 0x006C, 0x0334, 0x0301 };
    uint32_t const ces[10] = { 0x1DDD, 0x0000, 0x0020, 0x004A, 0x0024, 0x0000, 0x0002, 0x0002, 0x0002, 0x0000 };

    auto collation = collate_for_tests(
        cps, cps + 3, boost::text::variable_weighting::non_ignorable);

    EXPECT_EQ(collation.size(), 10);
    EXPECT_TRUE(boost::algorithm::equal(collation.begin(), collation.end(), ces, ces + 10))
        << "from:     " << ce_dumper(cps)
        << "expected: " << ce_dumper(ces)
        << "got:      " << ce_dumper(collation);
}

TEST(collation, non_ignorable_111_347)
{
    // 006C 0334 0341;	
    // (lÃ¥) LATIN SMALL LETTER L, COMBINING TILDE OVERLAY	[1DDD | 0020 004A 0024 | 0002 0002 0002 |]

    uint32_t cps[3] = { 0x006C, 0x0334, 0x0341 };
    uint32_t const ces[10] = { 0x1DDD, 0x0000, 0x0020, 0x004A, 0x0024, 0x0000, 0x0002, 0x0002, 0x0002, 0x0000 };

    auto collation = collate_for_tests(
        cps, cps + 3, boost::text::variable_weighting::non_ignorable);

    EXPECT_EQ(collation.size(), 10);
    EXPECT_TRUE(boost::algorithm::equal(collation.begin(), collation.end(), ces, ces + 10))
        << "from:     " << ce_dumper(cps)
        << "expected: " << ce_dumper(ces)
        << "got:      " << ce_dumper(collation);
}

TEST(collation, non_ignorable_111_348)
{
    // 013A 0334;	
    // (ƒ∫) LATIN SMALL LETTER L WITH ACUTE	[1DDD | 0020 004A 0024 | 0002 0002 0002 |]

    uint32_t cps[2] = { 0x013A, 0x0334 };
    uint32_t const ces[10] = { 0x1DDD, 0x0000, 0x0020, 0x004A, 0x0024, 0x0000, 0x0002, 0x0002, 0x0002, 0x0000 };

    auto collation = collate_for_tests(
        cps, cps + 2, boost::text::variable_weighting::non_ignorable);

    EXPECT_EQ(collation.size(), 10);
    EXPECT_TRUE(boost::algorithm::equal(collation.begin(), collation.end(), ces, ces + 10))
        << "from:     " << ce_dumper(cps)
        << "expected: " << ce_dumper(ces)
        << "got:      " << ce_dumper(collation);
}

TEST(collation, non_ignorable_111_349)
{
    // 004C 0301 0334;	
    // (ƒπ) LATIN CAPITAL LETTER L, COMBINING ACUTE ACCENT	[1DDD | 0020 004A 0024 | 0008 0002 0002 |]

    uint32_t cps[3] = { 0x004C, 0x0301, 0x0334 };
    uint32_t const ces[10] = { 0x1DDD, 0x0000, 0x0020, 0x004A, 0x0024, 0x0000, 0x0008, 0x0002, 0x0002, 0x0000 };

    auto collation = collate_for_tests(
        cps, cps + 3, boost::text::variable_weighting::non_ignorable);

    EXPECT_EQ(collation.size(), 10);
    EXPECT_TRUE(boost::algorithm::equal(collation.begin(), collation.end(), ces, ces + 10))
        << "from:     " << ce_dumper(cps)
        << "expected: " << ce_dumper(ces)
        << "got:      " << ce_dumper(collation);
}

TEST(collation, non_ignorable_111_350)
{
    // 004C 0334 0301;	
    // (LÃ¥) LATIN CAPITAL LETTER L, COMBINING TILDE OVERLAY	[1DDD | 0020 004A 0024 | 0008 0002 0002 |]

    uint32_t cps[3] = { 0x004C, 0x0334, 0x0301 };
    uint32_t const ces[10] = { 0x1DDD, 0x0000, 0x0020, 0x004A, 0x0024, 0x0000, 0x0008, 0x0002, 0x0002, 0x0000 };

    auto collation = collate_for_tests(
        cps, cps + 3, boost::text::variable_weighting::non_ignorable);

    EXPECT_EQ(collation.size(), 10);
    EXPECT_TRUE(boost::algorithm::equal(collation.begin(), collation.end(), ces, ces + 10))
        << "from:     " << ce_dumper(cps)
        << "expected: " << ce_dumper(ces)
        << "got:      " << ce_dumper(collation);
}

TEST(collation, non_ignorable_111_351)
{
    // 004C 0334 0341;	
    // (LÃ¥) LATIN CAPITAL LETTER L, COMBINING TILDE OVERLAY	[1DDD | 0020 004A 0024 | 0008 0002 0002 |]

    uint32_t cps[3] = { 0x004C, 0x0334, 0x0341 };
    uint32_t const ces[10] = { 0x1DDD, 0x0000, 0x0020, 0x004A, 0x0024, 0x0000, 0x0008, 0x0002, 0x0002, 0x0000 };

    auto collation = collate_for_tests(
        cps, cps + 3, boost::text::variable_weighting::non_ignorable);

    EXPECT_EQ(collation.size(), 10);
    EXPECT_TRUE(boost::algorithm::equal(collation.begin(), collation.end(), ces, ces + 10))
        << "from:     " << ce_dumper(cps)
        << "expected: " << ce_dumper(ces)
        << "got:      " << ce_dumper(collation);
}

TEST(collation, non_ignorable_111_352)
{
    // 0139 0334;	
    // (ƒπ) LATIN CAPITAL LETTER L WITH ACUTE	[1DDD | 0020 004A 0024 | 0008 0002 0002 |]

    uint32_t cps[2] = { 0x0139, 0x0334 };
    uint32_t const ces[10] = { 0x1DDD, 0x0000, 0x0020, 0x004A, 0x0024, 0x0000, 0x0008, 0x0002, 0x0002, 0x0000 };

    auto collation = collate_for_tests(
        cps, cps + 2, boost::text::variable_weighting::non_ignorable);

    EXPECT_EQ(collation.size(), 10);
    EXPECT_TRUE(boost::algorithm::equal(collation.begin(), collation.end(), ces, ces + 10))
        << "from:     " << ce_dumper(cps)
        << "expected: " << ce_dumper(ces)
        << "got:      " << ce_dumper(collation);
}

TEST(collation, non_ignorable_111_353)
{
    // 006C 030C 0334;	
    // (ƒæ) LATIN SMALL LETTER L, COMBINING CARON	[1DDD | 0020 004A 0028 | 0002 0002 0002 |]

    uint32_t cps[3] = { 0x006C, 0x030C, 0x0334 };
    uint32_t const ces[10] = { 0x1DDD, 0x0000, 0x0020, 0x004A, 0x0028, 0x0000, 0x0002, 0x0002, 0x0002, 0x0000 };

    auto collation = collate_for_tests(
        cps, cps + 3, boost::text::variable_weighting::non_ignorable);

    EXPECT_EQ(collation.size(), 10);
    EXPECT_TRUE(boost::algorithm::equal(collation.begin(), collation.end(), ces, ces + 10))
        << "from:     " << ce_dumper(cps)
        << "expected: " << ce_dumper(ces)
        << "got:      " << ce_dumper(collation);
}

TEST(collation, non_ignorable_111_354)
{
    // 006C 0334 030C;	
    // (lÃ¥) LATIN SMALL LETTER L, COMBINING TILDE OVERLAY	[1DDD | 0020 004A 0028 | 0002 0002 0002 |]

    uint32_t cps[3] = { 0x006C, 0x0334, 0x030C };
    uint32_t const ces[10] = { 0x1DDD, 0x0000, 0x0020, 0x004A, 0x0028, 0x0000, 0x0002, 0x0002, 0x0002, 0x0000 };

    auto collation = collate_for_tests(
        cps, cps + 3, boost::text::variable_weighting::non_ignorable);

    EXPECT_EQ(collation.size(), 10);
    EXPECT_TRUE(boost::algorithm::equal(collation.begin(), collation.end(), ces, ces + 10))
        << "from:     " << ce_dumper(cps)
        << "expected: " << ce_dumper(ces)
        << "got:      " << ce_dumper(collation);
}

TEST(collation, non_ignorable_111_355)
{
    // 013E 0334;	
    // (ƒæ) LATIN SMALL LETTER L WITH CARON	[1DDD | 0020 004A 0028 | 0002 0002 0002 |]

    uint32_t cps[2] = { 0x013E, 0x0334 };
    uint32_t const ces[10] = { 0x1DDD, 0x0000, 0x0020, 0x004A, 0x0028, 0x0000, 0x0002, 0x0002, 0x0002, 0x0000 };

    auto collation = collate_for_tests(
        cps, cps + 2, boost::text::variable_weighting::non_ignorable);

    EXPECT_EQ(collation.size(), 10);
    EXPECT_TRUE(boost::algorithm::equal(collation.begin(), collation.end(), ces, ces + 10))
        << "from:     " << ce_dumper(cps)
        << "expected: " << ce_dumper(ces)
        << "got:      " << ce_dumper(collation);
}

TEST(collation, non_ignorable_111_356)
{
    // 004C 030C 0334;	
    // (ƒΩ) LATIN CAPITAL LETTER L, COMBINING CARON	[1DDD | 0020 004A 0028 | 0008 0002 0002 |]

    uint32_t cps[3] = { 0x004C, 0x030C, 0x0334 };
    uint32_t const ces[10] = { 0x1DDD, 0x0000, 0x0020, 0x004A, 0x0028, 0x0000, 0x0008, 0x0002, 0x0002, 0x0000 };

    auto collation = collate_for_tests(
        cps, cps + 3, boost::text::variable_weighting::non_ignorable);

    EXPECT_EQ(collation.size(), 10);
    EXPECT_TRUE(boost::algorithm::equal(collation.begin(), collation.end(), ces, ces + 10))
        << "from:     " << ce_dumper(cps)
        << "expected: " << ce_dumper(ces)
        << "got:      " << ce_dumper(collation);
}

TEST(collation, non_ignorable_111_357)
{
    // 004C 0334 030C;	
    // (LÃ¥) LATIN CAPITAL LETTER L, COMBINING TILDE OVERLAY	[1DDD | 0020 004A 0028 | 0008 0002 0002 |]

    uint32_t cps[3] = { 0x004C, 0x0334, 0x030C };
    uint32_t const ces[10] = { 0x1DDD, 0x0000, 0x0020, 0x004A, 0x0028, 0x0000, 0x0008, 0x0002, 0x0002, 0x0000 };

    auto collation = collate_for_tests(
        cps, cps + 3, boost::text::variable_weighting::non_ignorable);

    EXPECT_EQ(collation.size(), 10);
    EXPECT_TRUE(boost::algorithm::equal(collation.begin(), collation.end(), ces, ces + 10))
        << "from:     " << ce_dumper(cps)
        << "expected: " << ce_dumper(ces)
        << "got:      " << ce_dumper(collation);
}

TEST(collation, non_ignorable_111_358)
{
    // 013D 0334;	
    // (ƒΩ) LATIN CAPITAL LETTER L WITH CARON	[1DDD | 0020 004A 0028 | 0008 0002 0002 |]

    uint32_t cps[2] = { 0x013D, 0x0334 };
    uint32_t const ces[10] = { 0x1DDD, 0x0000, 0x0020, 0x004A, 0x0028, 0x0000, 0x0008, 0x0002, 0x0002, 0x0000 };

    auto collation = collate_for_tests(
        cps, cps + 2, boost::text::variable_weighting::non_ignorable);

    EXPECT_EQ(collation.size(), 10);
    EXPECT_TRUE(boost::algorithm::equal(collation.begin(), collation.end(), ces, ces + 10))
        << "from:     " << ce_dumper(cps)
        << "expected: " << ce_dumper(ces)
        << "got:      " << ce_dumper(collation);
}

TEST(collation, non_ignorable_111_359)
{
    // 006C 0327 0334;	
    // (ƒº) LATIN SMALL LETTER L, COMBINING CEDILLA	[1DDD | 0020 004A 0030 | 0002 0002 0002 |]

    uint32_t cps[3] = { 0x006C, 0x0327, 0x0334 };
    uint32_t const ces[10] = { 0x1DDD, 0x0000, 0x0020, 0x004A, 0x0030, 0x0000, 0x0002, 0x0002, 0x0002, 0x0000 };

    auto collation = collate_for_tests(
        cps, cps + 3, boost::text::variable_weighting::non_ignorable);

    EXPECT_EQ(collation.size(), 10);
    EXPECT_TRUE(boost::algorithm::equal(collation.begin(), collation.end(), ces, ces + 10))
        << "from:     " << ce_dumper(cps)
        << "expected: " << ce_dumper(ces)
        << "got:      " << ce_dumper(collation);
}

TEST(collation, non_ignorable_111_360)
{
    // 006C 0334 0327;	
    // (lÃ¥) LATIN SMALL LETTER L, COMBINING TILDE OVERLAY	[1DDD | 0020 004A 0030 | 0002 0002 0002 |]

    uint32_t cps[3] = { 0x006C, 0x0334, 0x0327 };
    uint32_t const ces[10] = { 0x1DDD, 0x0000, 0x0020, 0x004A, 0x0030, 0x0000, 0x0002, 0x0002, 0x0002, 0x0000 };

    auto collation = collate_for_tests(
        cps, cps + 3, boost::text::variable_weighting::non_ignorable);

    EXPECT_EQ(collation.size(), 10);
    EXPECT_TRUE(boost::algorithm::equal(collation.begin(), collation.end(), ces, ces + 10))
        << "from:     " << ce_dumper(cps)
        << "expected: " << ce_dumper(ces)
        << "got:      " << ce_dumper(collation);
}

TEST(collation, non_ignorable_111_361)
{
    // 013C 0334;	
    // (ƒº) LATIN SMALL LETTER L WITH CEDILLA	[1DDD | 0020 004A 0030 | 0002 0002 0002 |]

    uint32_t cps[2] = { 0x013C, 0x0334 };
    uint32_t const ces[10] = { 0x1DDD, 0x0000, 0x0020, 0x004A, 0x0030, 0x0000, 0x0002, 0x0002, 0x0002, 0x0000 };

    auto collation = collate_for_tests(
        cps, cps + 2, boost::text::variable_weighting::non_ignorable);

    EXPECT_EQ(collation.size(), 10);
    EXPECT_TRUE(boost::algorithm::equal(collation.begin(), collation.end(), ces, ces + 10))
        << "from:     " << ce_dumper(cps)
        << "expected: " << ce_dumper(ces)
        << "got:      " << ce_dumper(collation);
}

TEST(collation, non_ignorable_111_362)
{
    // 004C 0327 0334;	
    // (ƒª) LATIN CAPITAL LETTER L, COMBINING CEDILLA	[1DDD | 0020 004A 0030 | 0008 0002 0002 |]

    uint32_t cps[3] = { 0x004C, 0x0327, 0x0334 };
    uint32_t const ces[10] = { 0x1DDD, 0x0000, 0x0020, 0x004A, 0x0030, 0x0000, 0x0008, 0x0002, 0x0002, 0x0000 };

    auto collation = collate_for_tests(
        cps, cps + 3, boost::text::variable_weighting::non_ignorable);

    EXPECT_EQ(collation.size(), 10);
    EXPECT_TRUE(boost::algorithm::equal(collation.begin(), collation.end(), ces, ces + 10))
        << "from:     " << ce_dumper(cps)
        << "expected: " << ce_dumper(ces)
        << "got:      " << ce_dumper(collation);
}

TEST(collation, non_ignorable_111_363)
{
    // 004C 0334 0327;	
    // (LÃ¥) LATIN CAPITAL LETTER L, COMBINING TILDE OVERLAY	[1DDD | 0020 004A 0030 | 0008 0002 0002 |]

    uint32_t cps[3] = { 0x004C, 0x0334, 0x0327 };
    uint32_t const ces[10] = { 0x1DDD, 0x0000, 0x0020, 0x004A, 0x0030, 0x0000, 0x0008, 0x0002, 0x0002, 0x0000 };

    auto collation = collate_for_tests(
        cps, cps + 3, boost::text::variable_weighting::non_ignorable);

    EXPECT_EQ(collation.size(), 10);
    EXPECT_TRUE(boost::algorithm::equal(collation.begin(), collation.end(), ces, ces + 10))
        << "from:     " << ce_dumper(cps)
        << "expected: " << ce_dumper(ces)
        << "got:      " << ce_dumper(collation);
}

TEST(collation, non_ignorable_111_364)
{
    // 013B 0334;	
    // (ƒª) LATIN CAPITAL LETTER L WITH CEDILLA	[1DDD | 0020 004A 0030 | 0008 0002 0002 |]

    uint32_t cps[2] = { 0x013B, 0x0334 };
    uint32_t const ces[10] = { 0x1DDD, 0x0000, 0x0020, 0x004A, 0x0030, 0x0000, 0x0008, 0x0002, 0x0002, 0x0000 };

    auto collation = collate_for_tests(
        cps, cps + 2, boost::text::variable_weighting::non_ignorable);

    EXPECT_EQ(collation.size(), 10);
    EXPECT_TRUE(boost::algorithm::equal(collation.begin(), collation.end(), ces, ces + 10))
        << "from:     " << ce_dumper(cps)
        << "expected: " << ce_dumper(ces)
        << "got:      " << ce_dumper(collation);
}

TEST(collation, non_ignorable_111_365)
{
    // 006C 0323 0334;	
    // (·∏∑) LATIN SMALL LETTER L, COMBINING DOT BELOW	[1DDD | 0020 004A 0042 | 0002 0002 0002 |]

    uint32_t cps[3] = { 0x006C, 0x0323, 0x0334 };
    uint32_t const ces[10] = { 0x1DDD, 0x0000, 0x0020, 0x004A, 0x0042, 0x0000, 0x0002, 0x0002, 0x0002, 0x0000 };

    auto collation = collate_for_tests(
        cps, cps + 3, boost::text::variable_weighting::non_ignorable);

    EXPECT_EQ(collation.size(), 10);
    EXPECT_TRUE(boost::algorithm::equal(collation.begin(), collation.end(), ces, ces + 10))
        << "from:     " << ce_dumper(cps)
        << "expected: " << ce_dumper(ces)
        << "got:      " << ce_dumper(collation);
}

TEST(collation, non_ignorable_111_366)
{
    // 006C 0334 0323;	
    // (lÃ¥) LATIN SMALL LETTER L, COMBINING TILDE OVERLAY	[1DDD | 0020 004A 0042 | 0002 0002 0002 |]

    uint32_t cps[3] = { 0x006C, 0x0334, 0x0323 };
    uint32_t const ces[10] = { 0x1DDD, 0x0000, 0x0020, 0x004A, 0x0042, 0x0000, 0x0002, 0x0002, 0x0002, 0x0000 };

    auto collation = collate_for_tests(
        cps, cps + 3, boost::text::variable_weighting::non_ignorable);

    EXPECT_EQ(collation.size(), 10);
    EXPECT_TRUE(boost::algorithm::equal(collation.begin(), collation.end(), ces, ces + 10))
        << "from:     " << ce_dumper(cps)
        << "expected: " << ce_dumper(ces)
        << "got:      " << ce_dumper(collation);
}

TEST(collation, non_ignorable_111_367)
{
    // 1E37 0334;	
    // (·∏∑) LATIN SMALL LETTER L WITH DOT BELOW	[1DDD | 0020 004A 0042 | 0002 0002 0002 |]

    uint32_t cps[2] = { 0x1E37, 0x0334 };
    uint32_t const ces[10] = { 0x1DDD, 0x0000, 0x0020, 0x004A, 0x0042, 0x0000, 0x0002, 0x0002, 0x0002, 0x0000 };

    auto collation = collate_for_tests(
        cps, cps + 2, boost::text::variable_weighting::non_ignorable);

    EXPECT_EQ(collation.size(), 10);
    EXPECT_TRUE(boost::algorithm::equal(collation.begin(), collation.end(), ces, ces + 10))
        << "from:     " << ce_dumper(cps)
        << "expected: " << ce_dumper(ces)
        << "got:      " << ce_dumper(collation);
}

TEST(collation, non_ignorable_111_368)
{
    // 004C 0323 0334;	
    // (·∏∂) LATIN CAPITAL LETTER L, COMBINING DOT BELOW	[1DDD | 0020 004A 0042 | 0008 0002 0002 |]

    uint32_t cps[3] = { 0x004C, 0x0323, 0x0334 };
    uint32_t const ces[10] = { 0x1DDD, 0x0000, 0x0020, 0x004A, 0x0042, 0x0000, 0x0008, 0x0002, 0x0002, 0x0000 };

    auto collation = collate_for_tests(
        cps, cps + 3, boost::text::variable_weighting::non_ignorable);

    EXPECT_EQ(collation.size(), 10);
    EXPECT_TRUE(boost::algorithm::equal(collation.begin(), collation.end(), ces, ces + 10))
        << "from:     " << ce_dumper(cps)
        << "expected: " << ce_dumper(ces)
        << "got:      " << ce_dumper(collation);
}

TEST(collation, non_ignorable_111_369)
{
    // 004C 0334 0323;	
    // (LÃ¥) LATIN CAPITAL LETTER L, COMBINING TILDE OVERLAY	[1DDD | 0020 004A 0042 | 0008 0002 0002 |]

    uint32_t cps[3] = { 0x004C, 0x0334, 0x0323 };
    uint32_t const ces[10] = { 0x1DDD, 0x0000, 0x0020, 0x004A, 0x0042, 0x0000, 0x0008, 0x0002, 0x0002, 0x0000 };

    auto collation = collate_for_tests(
        cps, cps + 3, boost::text::variable_weighting::non_ignorable);

    EXPECT_EQ(collation.size(), 10);
    EXPECT_TRUE(boost::algorithm::equal(collation.begin(), collation.end(), ces, ces + 10))
        << "from:     " << ce_dumper(cps)
        << "expected: " << ce_dumper(ces)
        << "got:      " << ce_dumper(collation);
}

TEST(collation, non_ignorable_111_370)
{
    // 1E36 0334;	
    // (·∏∂) LATIN CAPITAL LETTER L WITH DOT BELOW	[1DDD | 0020 004A 0042 | 0008 0002 0002 |]

    uint32_t cps[2] = { 0x1E36, 0x0334 };
    uint32_t const ces[10] = { 0x1DDD, 0x0000, 0x0020, 0x004A, 0x0042, 0x0000, 0x0008, 0x0002, 0x0002, 0x0000 };

    auto collation = collate_for_tests(
        cps, cps + 2, boost::text::variable_weighting::non_ignorable);

    EXPECT_EQ(collation.size(), 10);
    EXPECT_TRUE(boost::algorithm::equal(collation.begin(), collation.end(), ces, ces + 10))
        << "from:     " << ce_dumper(cps)
        << "expected: " << ce_dumper(ces)
        << "got:      " << ce_dumper(collation);
}

TEST(collation, non_ignorable_111_371)
{
    // 006C 0304 0323 0334;	
    // (·∏π) LATIN SMALL LETTER L, COMBINING MACRON, COMBINING DOT BELOW	[1DDD | 0020 004A 0042 0032 | 0002 0002 0002 0002 |]

    uint32_t cps[4] = { 0x006C, 0x0304, 0x0323, 0x0334 };
    uint32_t const ces[12] = { 0x1DDD, 0x0000, 0x0020, 0x004A, 0x0042, 0x0032, 0x0000, 0x0002, 0x0002, 0x0002, 0x0002, 0x0000 };

    auto collation = collate_for_tests(
        cps, cps + 4, boost::text::variable_weighting::non_ignorable);

    EXPECT_EQ(collation.size(), 12);
    EXPECT_TRUE(boost::algorithm::equal(collation.begin(), collation.end(), ces, ces + 12))
        << "from:     " << ce_dumper(cps)
        << "expected: " << ce_dumper(ces)
        << "got:      " << ce_dumper(collation);
}

TEST(collation, non_ignorable_111_372)
{
    // 006C 0334 0323 0304;	
    // (·∏∑Ã¥) LATIN SMALL LETTER L, COMBINING TILDE OVERLAY, COMBINING DOT BELOW	[1DDD | 0020 004A 0042 0032 | 0002 0002 0002 0002 |]

    uint32_t cps[4] = { 0x006C, 0x0334, 0x0323, 0x0304 };
    uint32_t const ces[12] = { 0x1DDD, 0x0000, 0x0020, 0x004A, 0x0042, 0x0032, 0x0000, 0x0002, 0x0002, 0x0002, 0x0002, 0x0000 };

    auto collation = collate_for_tests(
        cps, cps + 4, boost::text::variable_weighting::non_ignorable);

    EXPECT_EQ(collation.size(), 12);
    EXPECT_TRUE(boost::algorithm::equal(collation.begin(), collation.end(), ces, ces + 12))
        << "from:     " << ce_dumper(cps)
        << "expected: " << ce_dumper(ces)
        << "got:      " << ce_dumper(collation);
}

TEST(collation, non_ignorable_111_373)
{
    // 1E37 0304 0334;	
    // (·∏π) LATIN SMALL LETTER L WITH DOT BELOW, COMBINING MACRON	[1DDD | 0020 004A 0042 0032 | 0002 0002 0002 0002 |]

    uint32_t cps[3] = { 0x1E37, 0x0304, 0x0334 };
    uint32_t const ces[12] = { 0x1DDD, 0x0000, 0x0020, 0x004A, 0x0042, 0x0032, 0x0000, 0x0002, 0x0002, 0x0002, 0x0002, 0x0000 };

    auto collation = collate_for_tests(
        cps, cps + 3, boost::text::variable_weighting::non_ignorable);

    EXPECT_EQ(collation.size(), 12);
    EXPECT_TRUE(boost::algorithm::equal(collation.begin(), collation.end(), ces, ces + 12))
        << "from:     " << ce_dumper(cps)
        << "expected: " << ce_dumper(ces)
        << "got:      " << ce_dumper(collation);
}

TEST(collation, non_ignorable_111_374)
{
    // 1E37 0334 0304;	
    // (·∏∑Ã¥) LATIN SMALL LETTER L WITH DOT BELOW, COMBINING TILDE OVERLAY	[1DDD | 0020 004A 0042 0032 | 0002 0002 0002 0002 |]

    uint32_t cps[3] = { 0x1E37, 0x0334, 0x0304 };
    uint32_t const ces[12] = { 0x1DDD, 0x0000, 0x0020, 0x004A, 0x0042, 0x0032, 0x0000, 0x0002, 0x0002, 0x0002, 0x0002, 0x0000 };

    auto collation = collate_for_tests(
        cps, cps + 3, boost::text::variable_weighting::non_ignorable);

    EXPECT_EQ(collation.size(), 12);
    EXPECT_TRUE(boost::algorithm::equal(collation.begin(), collation.end(), ces, ces + 12))
        << "from:     " << ce_dumper(cps)
        << "expected: " << ce_dumper(ces)
        << "got:      " << ce_dumper(collation);
}

TEST(collation, non_ignorable_111_375)
{
    // 004C 0304 0323 0334;	
    // (·∏∏) LATIN CAPITAL LETTER L, COMBINING MACRON, COMBINING DOT BELOW	[1DDD | 0020 004A 0042 0032 | 0008 0002 0002 0002 |]

    uint32_t cps[4] = { 0x004C, 0x0304, 0x0323, 0x0334 };
    uint32_t const ces[12] = { 0x1DDD, 0x0000, 0x0020, 0x004A, 0x0042, 0x0032, 0x0000, 0x0008, 0x0002, 0x0002, 0x0002, 0x0000 };

    auto collation = collate_for_tests(
        cps, cps + 4, boost::text::variable_weighting::non_ignorable);

    EXPECT_EQ(collation.size(), 12);
    EXPECT_TRUE(boost::algorithm::equal(collation.begin(), collation.end(), ces, ces + 12))
        << "from:     " << ce_dumper(cps)
        << "expected: " << ce_dumper(ces)
        << "got:      " << ce_dumper(collation);
}

TEST(collation, non_ignorable_111_376)
{
    // 004C 0334 0323 0304;	
    // (·∏∂Ã¥) LATIN CAPITAL LETTER L, COMBINING TILDE OVERLAY, COMBINING DOT BELOW	[1DDD | 0020 004A 0042 0032 | 0008 0002 0002 0002 |]

    uint32_t cps[4] = { 0x004C, 0x0334, 0x0323, 0x0304 };
    uint32_t const ces[12] = { 0x1DDD, 0x0000, 0x0020, 0x004A, 0x0042, 0x0032, 0x0000, 0x0008, 0x0002, 0x0002, 0x0002, 0x0000 };

    auto collation = collate_for_tests(
        cps, cps + 4, boost::text::variable_weighting::non_ignorable);

    EXPECT_EQ(collation.size(), 12);
    EXPECT_TRUE(boost::algorithm::equal(collation.begin(), collation.end(), ces, ces + 12))
        << "from:     " << ce_dumper(cps)
        << "expected: " << ce_dumper(ces)
        << "got:      " << ce_dumper(collation);
}

TEST(collation, non_ignorable_111_377)
{
    // 1E36 0304 0334;	
    // (·∏∏) LATIN CAPITAL LETTER L WITH DOT BELOW, COMBINING MACRON	[1DDD | 0020 004A 0042 0032 | 0008 0002 0002 0002 |]

    uint32_t cps[3] = { 0x1E36, 0x0304, 0x0334 };
    uint32_t const ces[12] = { 0x1DDD, 0x0000, 0x0020, 0x004A, 0x0042, 0x0032, 0x0000, 0x0008, 0x0002, 0x0002, 0x0002, 0x0000 };

    auto collation = collate_for_tests(
        cps, cps + 3, boost::text::variable_weighting::non_ignorable);

    EXPECT_EQ(collation.size(), 12);
    EXPECT_TRUE(boost::algorithm::equal(collation.begin(), collation.end(), ces, ces + 12))
        << "from:     " << ce_dumper(cps)
        << "expected: " << ce_dumper(ces)
        << "got:      " << ce_dumper(collation);
}

TEST(collation, non_ignorable_111_378)
{
    // 1E36 0334 0304;	
    // (·∏∂Ã¥) LATIN CAPITAL LETTER L WITH DOT BELOW, COMBINING TILDE OVERLAY	[1DDD | 0020 004A 0042 0032 | 0008 0002 0002 0002 |]

    uint32_t cps[3] = { 0x1E36, 0x0334, 0x0304 };
    uint32_t const ces[12] = { 0x1DDD, 0x0000, 0x0020, 0x004A, 0x0042, 0x0032, 0x0000, 0x0008, 0x0002, 0x0002, 0x0002, 0x0000 };

    auto collation = collate_for_tests(
        cps, cps + 3, boost::text::variable_weighting::non_ignorable);

    EXPECT_EQ(collation.size(), 12);
    EXPECT_TRUE(boost::algorithm::equal(collation.begin(), collation.end(), ces, ces + 12))
        << "from:     " << ce_dumper(cps)
        << "expected: " << ce_dumper(ces)
        << "got:      " << ce_dumper(collation);
}

TEST(collation, non_ignorable_111_379)
{
    // 006C 032D 0334;	
    // (·∏Ω) LATIN SMALL LETTER L, COMBINING CIRCUMFLEX ACCENT BELOW	[1DDD | 0020 004A 0046 | 0002 0002 0002 |]

    uint32_t cps[3] = { 0x006C, 0x032D, 0x0334 };
    uint32_t const ces[10] = { 0x1DDD, 0x0000, 0x0020, 0x004A, 0x0046, 0x0000, 0x0002, 0x0002, 0x0002, 0x0000 };

    auto collation = collate_for_tests(
        cps, cps + 3, boost::text::variable_weighting::non_ignorable);

    EXPECT_EQ(collation.size(), 10);
    EXPECT_TRUE(boost::algorithm::equal(collation.begin(), collation.end(), ces, ces + 10))
        << "from:     " << ce_dumper(cps)
        << "expected: " << ce_dumper(ces)
        << "got:      " << ce_dumper(collation);
}

TEST(collation, non_ignorable_111_380)
{
    // 006C 0334 032D;	
    // (lÃ¥) LATIN SMALL LETTER L, COMBINING TILDE OVERLAY	[1DDD | 0020 004A 0046 | 0002 0002 0002 |]

    uint32_t cps[3] = { 0x006C, 0x0334, 0x032D };
    uint32_t const ces[10] = { 0x1DDD, 0x0000, 0x0020, 0x004A, 0x0046, 0x0000, 0x0002, 0x0002, 0x0002, 0x0000 };

    auto collation = collate_for_tests(
        cps, cps + 3, boost::text::variable_weighting::non_ignorable);

    EXPECT_EQ(collation.size(), 10);
    EXPECT_TRUE(boost::algorithm::equal(collation.begin(), collation.end(), ces, ces + 10))
        << "from:     " << ce_dumper(cps)
        << "expected: " << ce_dumper(ces)
        << "got:      " << ce_dumper(collation);
}

TEST(collation, non_ignorable_111_381)
{
    // 1E3D 0334;	
    // (·∏Ω) LATIN SMALL LETTER L WITH CIRCUMFLEX BELOW	[1DDD | 0020 004A 0046 | 0002 0002 0002 |]

    uint32_t cps[2] = { 0x1E3D, 0x0334 };
    uint32_t const ces[10] = { 0x1DDD, 0x0000, 0x0020, 0x004A, 0x0046, 0x0000, 0x0002, 0x0002, 0x0002, 0x0000 };

    auto collation = collate_for_tests(
        cps, cps + 2, boost::text::variable_weighting::non_ignorable);

    EXPECT_EQ(collation.size(), 10);
    EXPECT_TRUE(boost::algorithm::equal(collation.begin(), collation.end(), ces, ces + 10))
        << "from:     " << ce_dumper(cps)
        << "expected: " << ce_dumper(ces)
        << "got:      " << ce_dumper(collation);
}

TEST(collation, non_ignorable_111_382)
{
    // 004C 032D 0334;	
    // (·∏º) LATIN CAPITAL LETTER L, COMBINING CIRCUMFLEX ACCENT BELOW	[1DDD | 0020 004A 0046 | 0008 0002 0002 |]

    uint32_t cps[3] = { 0x004C, 0x032D, 0x0334 };
    uint32_t const ces[10] = { 0x1DDD, 0x0000, 0x0020, 0x004A, 0x0046, 0x0000, 0x0008, 0x0002, 0x0002, 0x0000 };

    auto collation = collate_for_tests(
        cps, cps + 3, boost::text::variable_weighting::non_ignorable);

    EXPECT_EQ(collation.size(), 10);
    EXPECT_TRUE(boost::algorithm::equal(collation.begin(), collation.end(), ces, ces + 10))
        << "from:     " << ce_dumper(cps)
        << "expected: " << ce_dumper(ces)
        << "got:      " << ce_dumper(collation);
}

TEST(collation, non_ignorable_111_383)
{
    // 004C 0334 032D;	
    // (LÃ¥) LATIN CAPITAL LETTER L, COMBINING TILDE OVERLAY	[1DDD | 0020 004A 0046 | 0008 0002 0002 |]

    uint32_t cps[3] = { 0x004C, 0x0334, 0x032D };
    uint32_t const ces[10] = { 0x1DDD, 0x0000, 0x0020, 0x004A, 0x0046, 0x0000, 0x0008, 0x0002, 0x0002, 0x0000 };

    auto collation = collate_for_tests(
        cps, cps + 3, boost::text::variable_weighting::non_ignorable);

    EXPECT_EQ(collation.size(), 10);
    EXPECT_TRUE(boost::algorithm::equal(collation.begin(), collation.end(), ces, ces + 10))
        << "from:     " << ce_dumper(cps)
        << "expected: " << ce_dumper(ces)
        << "got:      " << ce_dumper(collation);
}

TEST(collation, non_ignorable_111_384)
{
    // 1E3C 0334;	
    // (·∏º) LATIN CAPITAL LETTER L WITH CIRCUMFLEX BELOW	[1DDD | 0020 004A 0046 | 0008 0002 0002 |]

    uint32_t cps[2] = { 0x1E3C, 0x0334 };
    uint32_t const ces[10] = { 0x1DDD, 0x0000, 0x0020, 0x004A, 0x0046, 0x0000, 0x0008, 0x0002, 0x0002, 0x0000 };

    auto collation = collate_for_tests(
        cps, cps + 2, boost::text::variable_weighting::non_ignorable);

    EXPECT_EQ(collation.size(), 10);
    EXPECT_TRUE(boost::algorithm::equal(collation.begin(), collation.end(), ces, ces + 10))
        << "from:     " << ce_dumper(cps)
        << "expected: " << ce_dumper(ces)
        << "got:      " << ce_dumper(collation);
}

TEST(collation, non_ignorable_111_385)
{
    // 006C 0331 0334;	
    // (·∏ª) LATIN SMALL LETTER L, COMBINING MACRON BELOW	[1DDD | 0020 004A 0049 | 0002 0002 0002 |]

    uint32_t cps[3] = { 0x006C, 0x0331, 0x0334 };
    uint32_t const ces[10] = { 0x1DDD, 0x0000, 0x0020, 0x004A, 0x0049, 0x0000, 0x0002, 0x0002, 0x0002, 0x0000 };

    auto collation = collate_for_tests(
        cps, cps + 3, boost::text::variable_weighting::non_ignorable);

    EXPECT_EQ(collation.size(), 10);
    EXPECT_TRUE(boost::algorithm::equal(collation.begin(), collation.end(), ces, ces + 10))
        << "from:     " << ce_dumper(cps)
        << "expected: " << ce_dumper(ces)
        << "got:      " << ce_dumper(collation);
}

TEST(collation, non_ignorable_111_386)
{
    // 006C 0334 0331;	
    // (lÃ¥) LATIN SMALL LETTER L, COMBINING TILDE OVERLAY	[1DDD | 0020 004A 0049 | 0002 0002 0002 |]

    uint32_t cps[3] = { 0x006C, 0x0334, 0x0331 };
    uint32_t const ces[10] = { 0x1DDD, 0x0000, 0x0020, 0x004A, 0x0049, 0x0000, 0x0002, 0x0002, 0x0002, 0x0000 };

    auto collation = collate_for_tests(
        cps, cps + 3, boost::text::variable_weighting::non_ignorable);

    EXPECT_EQ(collation.size(), 10);
    EXPECT_TRUE(boost::algorithm::equal(collation.begin(), collation.end(), ces, ces + 10))
        << "from:     " << ce_dumper(cps)
        << "expected: " << ce_dumper(ces)
        << "got:      " << ce_dumper(collation);
}

TEST(collation, non_ignorable_111_387)
{
    // 1E3B 0334;	
    // (·∏ª) LATIN SMALL LETTER L WITH LINE BELOW	[1DDD | 0020 004A 0049 | 0002 0002 0002 |]

    uint32_t cps[2] = { 0x1E3B, 0x0334 };
    uint32_t const ces[10] = { 0x1DDD, 0x0000, 0x0020, 0x004A, 0x0049, 0x0000, 0x0002, 0x0002, 0x0002, 0x0000 };

    auto collation = collate_for_tests(
        cps, cps + 2, boost::text::variable_weighting::non_ignorable);

    EXPECT_EQ(collation.size(), 10);
    EXPECT_TRUE(boost::algorithm::equal(collation.begin(), collation.end(), ces, ces + 10))
        << "from:     " << ce_dumper(cps)
        << "expected: " << ce_dumper(ces)
        << "got:      " << ce_dumper(collation);
}

TEST(collation, non_ignorable_111_388)
{
    // 004C 0331 0334;	
    // (·∏∫) LATIN CAPITAL LETTER L, COMBINING MACRON BELOW	[1DDD | 0020 004A 0049 | 0008 0002 0002 |]

    uint32_t cps[3] = { 0x004C, 0x0331, 0x0334 };
    uint32_t const ces[10] = { 0x1DDD, 0x0000, 0x0020, 0x004A, 0x0049, 0x0000, 0x0008, 0x0002, 0x0002, 0x0000 };

    auto collation = collate_for_tests(
        cps, cps + 3, boost::text::variable_weighting::non_ignorable);

    EXPECT_EQ(collation.size(), 10);
    EXPECT_TRUE(boost::algorithm::equal(collation.begin(), collation.end(), ces, ces + 10))
        << "from:     " << ce_dumper(cps)
        << "expected: " << ce_dumper(ces)
        << "got:      " << ce_dumper(collation);
}

TEST(collation, non_ignorable_111_389)
{
    // 004C 0334 0331;	
    // (LÃ¥) LATIN CAPITAL LETTER L, COMBINING TILDE OVERLAY	[1DDD | 0020 004A 0049 | 0008 0002 0002 |]

    uint32_t cps[3] = { 0x004C, 0x0334, 0x0331 };
    uint32_t const ces[10] = { 0x1DDD, 0x0000, 0x0020, 0x004A, 0x0049, 0x0000, 0x0008, 0x0002, 0x0002, 0x0000 };

    auto collation = collate_for_tests(
        cps, cps + 3, boost::text::variable_weighting::non_ignorable);

    EXPECT_EQ(collation.size(), 10);
    EXPECT_TRUE(boost::algorithm::equal(collation.begin(), collation.end(), ces, ces + 10))
        << "from:     " << ce_dumper(cps)
        << "expected: " << ce_dumper(ces)
        << "got:      " << ce_dumper(collation);
}

TEST(collation, non_ignorable_111_390)
{
    // 1E3A 0334;	
    // (·∏∫) LATIN CAPITAL LETTER L WITH LINE BELOW	[1DDD | 0020 004A 0049 | 0008 0002 0002 |]

    uint32_t cps[2] = { 0x1E3A, 0x0334 };
    uint32_t const ces[10] = { 0x1DDD, 0x0000, 0x0020, 0x004A, 0x0049, 0x0000, 0x0008, 0x0002, 0x0002, 0x0000 };

    auto collation = collate_for_tests(
        cps, cps + 2, boost::text::variable_weighting::non_ignorable);

    EXPECT_EQ(collation.size(), 10);
    EXPECT_TRUE(boost::algorithm::equal(collation.begin(), collation.end(), ces, ces + 10))
        << "from:     " << ce_dumper(cps)
        << "expected: " << ce_dumper(ces)
        << "got:      " << ce_dumper(collation);
}

TEST(collation, non_ignorable_111_391)
{
    // 0334 1DDD;	
    // (·∑ù) COMBINING LATIN SMALL LETTER L	[1DDD | 004A 0020 | 0002 0004 |]

    uint32_t cps[2] = { 0x0334, 0x1DDD };
    uint32_t const ces[8] = { 0x1DDD, 0x0000, 0x004A, 0x0020, 0x0000, 0x0002, 0x0004, 0x0000 };

    auto collation = collate_for_tests(
        cps, cps + 2, boost::text::variable_weighting::non_ignorable);

    EXPECT_EQ(collation.size(), 8);
    EXPECT_TRUE(boost::algorithm::equal(collation.begin(), collation.end(), ces, ces + 8))
        << "from:     " << ce_dumper(cps)
        << "expected: " << ce_dumper(ces)
        << "got:      " << ce_dumper(collation);
}

TEST(collation, non_ignorable_111_392)
{
    // 1DDD 0334;	
    // (·∑ù) COMBINING LATIN SMALL LETTER L	[1DDD | 004A 0020 | 0002 0004 |]

    uint32_t cps[2] = { 0x1DDD, 0x0334 };
    uint32_t const ces[8] = { 0x1DDD, 0x0000, 0x004A, 0x0020, 0x0000, 0x0002, 0x0004, 0x0000 };

    auto collation = collate_for_tests(
        cps, cps + 2, boost::text::variable_weighting::non_ignorable);

    EXPECT_EQ(collation.size(), 8);
    EXPECT_TRUE(boost::algorithm::equal(collation.begin(), collation.end(), ces, ces + 8))
        << "from:     " << ce_dumper(cps)
        << "expected: " << ce_dumper(ces)
        << "got:      " << ce_dumper(collation);
}

TEST(collation, non_ignorable_111_393)
{
    // 006C 0021;	
    // (l) LATIN SMALL LETTER L	[1DDD 0261 | 0020 0020 | 0002 0002 |]

    uint32_t cps[2] = { 0x006C, 0x0021 };
    uint32_t const ces[9] = { 0x1DDD, 0x0261, 0x0000, 0x0020, 0x0020, 0x0000, 0x0002, 0x0002, 0x0000 };

    auto collation = collate_for_tests(
        cps, cps + 2, boost::text::variable_weighting::non_ignorable);

    EXPECT_EQ(collation.size(), 9);
    EXPECT_TRUE(boost::algorithm::equal(collation.begin(), collation.end(), ces, ces + 9))
        << "from:     " << ce_dumper(cps)
        << "expected: " << ce_dumper(ces)
        << "got:      " << ce_dumper(collation);
}

TEST(collation, non_ignorable_111_394)
{
    // FF4C 0021;	
    // (ÔΩå) FULLWIDTH LATIN SMALL LETTER L	[1DDD 0261 | 0020 0020 | 0003 0002 |]

    uint32_t cps[2] = { 0xFF4C, 0x0021 };
    uint32_t const ces[9] = { 0x1DDD, 0x0261, 0x0000, 0x0020, 0x0020, 0x0000, 0x0003, 0x0002, 0x0000 };

    auto collation = collate_for_tests(
        cps, cps + 2, boost::text::variable_weighting::non_ignorable);

    EXPECT_EQ(collation.size(), 9);
    EXPECT_TRUE(boost::algorithm::equal(collation.begin(), collation.end(), ces, ces + 9))
        << "from:     " << ce_dumper(cps)
        << "expected: " << ce_dumper(ces)
        << "got:      " << ce_dumper(collation);
}

TEST(collation, non_ignorable_111_395)
{
    // 1DDD 0021;	
    // (·∑ù) COMBINING LATIN SMALL LETTER L	[1DDD 0261 | 0020 0020 | 0004 0002 |]

    uint32_t cps[2] = { 0x1DDD, 0x0021 };
    uint32_t const ces[9] = { 0x1DDD, 0x0261, 0x0000, 0x0020, 0x0020, 0x0000, 0x0004, 0x0002, 0x0000 };

    auto collation = collate_for_tests(
        cps, cps + 2, boost::text::variable_weighting::non_ignorable);

    EXPECT_EQ(collation.size(), 9);
    EXPECT_TRUE(boost::algorithm::equal(collation.begin(), collation.end(), ces, ces + 9))
        << "from:     " << ce_dumper(cps)
        << "expected: " << ce_dumper(ces)
        << "got:      " << ce_dumper(collation);
}

TEST(collation, non_ignorable_111_396)
{
    // 217C 0021;	
    // (‚Öº) SMALL ROMAN NUMERAL FIFTY	[1DDD 0261 | 0020 0020 | 0004 0002 |]

    uint32_t cps[2] = { 0x217C, 0x0021 };
    uint32_t const ces[9] = { 0x1DDD, 0x0261, 0x0000, 0x0020, 0x0020, 0x0000, 0x0004, 0x0002, 0x0000 };

    auto collation = collate_for_tests(
        cps, cps + 2, boost::text::variable_weighting::non_ignorable);

    EXPECT_EQ(collation.size(), 9);
    EXPECT_TRUE(boost::algorithm::equal(collation.begin(), collation.end(), ces, ces + 9))
        << "from:     " << ce_dumper(cps)
        << "expected: " << ce_dumper(ces)
        << "got:      " << ce_dumper(collation);
}

TEST(collation, non_ignorable_111_397)
{
    // 2113 0021;	
    // (‚Ñì) SCRIPT SMALL L	[1DDD 0261 | 0020 0020 | 0005 0002 |]

    uint32_t cps[2] = { 0x2113, 0x0021 };
    uint32_t const ces[9] = { 0x1DDD, 0x0261, 0x0000, 0x0020, 0x0020, 0x0000, 0x0005, 0x0002, 0x0000 };

    auto collation = collate_for_tests(
        cps, cps + 2, boost::text::variable_weighting::non_ignorable);

    EXPECT_EQ(collation.size(), 9);
    EXPECT_TRUE(boost::algorithm::equal(collation.begin(), collation.end(), ces, ces + 9))
        << "from:     " << ce_dumper(cps)
        << "expected: " << ce_dumper(ces)
        << "got:      " << ce_dumper(collation);
}

TEST(collation, non_ignorable_111_398)
{
    // 1D425 0021;	
    // (ùê•) MATHEMATICAL BOLD SMALL L	[1DDD 0261 | 0020 0020 | 0005 0002 |]

    uint32_t cps[2] = { 0x1D425, 0x0021 };
    uint32_t const ces[9] = { 0x1DDD, 0x0261, 0x0000, 0x0020, 0x0020, 0x0000, 0x0005, 0x0002, 0x0000 };

    auto collation = collate_for_tests(
        cps, cps + 2, boost::text::variable_weighting::non_ignorable);

    EXPECT_EQ(collation.size(), 9);
    EXPECT_TRUE(boost::algorithm::equal(collation.begin(), collation.end(), ces, ces + 9))
        << "from:     " << ce_dumper(cps)
        << "expected: " << ce_dumper(ces)
        << "got:      " << ce_dumper(collation);
}

TEST(collation, non_ignorable_111_399)
{
    // 1D459 0021;	
    // (ùëô) MATHEMATICAL ITALIC SMALL L	[1DDD 0261 | 0020 0020 | 0005 0002 |]

    uint32_t cps[2] = { 0x1D459, 0x0021 };
    uint32_t const ces[9] = { 0x1DDD, 0x0261, 0x0000, 0x0020, 0x0020, 0x0000, 0x0005, 0x0002, 0x0000 };

    auto collation = collate_for_tests(
        cps, cps + 2, boost::text::variable_weighting::non_ignorable);

    EXPECT_EQ(collation.size(), 9);
    EXPECT_TRUE(boost::algorithm::equal(collation.begin(), collation.end(), ces, ces + 9))
        << "from:     " << ce_dumper(cps)
        << "expected: " << ce_dumper(ces)
        << "got:      " << ce_dumper(collation);
}

TEST(collation, non_ignorable_111_400)
{
    // 1D48D 0021;	
    // (ùíç) MATHEMATICAL BOLD ITALIC SMALL L	[1DDD 0261 | 0020 0020 | 0005 0002 |]

    uint32_t cps[2] = { 0x1D48D, 0x0021 };
    uint32_t const ces[9] = { 0x1DDD, 0x0261, 0x0000, 0x0020, 0x0020, 0x0000, 0x0005, 0x0002, 0x0000 };

    auto collation = collate_for_tests(
        cps, cps + 2, boost::text::variable_weighting::non_ignorable);

    EXPECT_EQ(collation.size(), 9);
    EXPECT_TRUE(boost::algorithm::equal(collation.begin(), collation.end(), ces, ces + 9))
        << "from:     " << ce_dumper(cps)
        << "expected: " << ce_dumper(ces)
        << "got:      " << ce_dumper(collation);
}

TEST(collation, non_ignorable_111_401)
{
    // 1D4C1 0021;	
    // (ùìÅ) MATHEMATICAL SCRIPT SMALL L	[1DDD 0261 | 0020 0020 | 0005 0002 |]

    uint32_t cps[2] = { 0x1D4C1, 0x0021 };
    uint32_t const ces[9] = { 0x1DDD, 0x0261, 0x0000, 0x0020, 0x0020, 0x0000, 0x0005, 0x0002, 0x0000 };

    auto collation = collate_for_tests(
        cps, cps + 2, boost::text::variable_weighting::non_ignorable);

    EXPECT_EQ(collation.size(), 9);
    EXPECT_TRUE(boost::algorithm::equal(collation.begin(), collation.end(), ces, ces + 9))
        << "from:     " << ce_dumper(cps)
        << "expected: " << ce_dumper(ces)
        << "got:      " << ce_dumper(collation);
}

TEST(collation, non_ignorable_111_402)
{
    // 1D4F5 0021;	
    // (ùìµ) MATHEMATICAL BOLD SCRIPT SMALL L	[1DDD 0261 | 0020 0020 | 0005 0002 |]

    uint32_t cps[2] = { 0x1D4F5, 0x0021 };
    uint32_t const ces[9] = { 0x1DDD, 0x0261, 0x0000, 0x0020, 0x0020, 0x0000, 0x0005, 0x0002, 0x0000 };

    auto collation = collate_for_tests(
        cps, cps + 2, boost::text::variable_weighting::non_ignorable);

    EXPECT_EQ(collation.size(), 9);
    EXPECT_TRUE(boost::algorithm::equal(collation.begin(), collation.end(), ces, ces + 9))
        << "from:     " << ce_dumper(cps)
        << "expected: " << ce_dumper(ces)
        << "got:      " << ce_dumper(collation);
}

TEST(collation, non_ignorable_111_403)
{
    // 1D529 0021;	
    // (ùî©) MATHEMATICAL FRAKTUR SMALL L	[1DDD 0261 | 0020 0020 | 0005 0002 |]

    uint32_t cps[2] = { 0x1D529, 0x0021 };
    uint32_t const ces[9] = { 0x1DDD, 0x0261, 0x0000, 0x0020, 0x0020, 0x0000, 0x0005, 0x0002, 0x0000 };

    auto collation = collate_for_tests(
        cps, cps + 2, boost::text::variable_weighting::non_ignorable);

    EXPECT_EQ(collation.size(), 9);
    EXPECT_TRUE(boost::algorithm::equal(collation.begin(), collation.end(), ces, ces + 9))
        << "from:     " << ce_dumper(cps)
        << "expected: " << ce_dumper(ces)
        << "got:      " << ce_dumper(collation);
}

TEST(collation, non_ignorable_111_404)
{
    // 1D55D 0021;	
    // (ùïù) MATHEMATICAL DOUBLE-STRUCK SMALL L	[1DDD 0261 | 0020 0020 | 0005 0002 |]

    uint32_t cps[2] = { 0x1D55D, 0x0021 };
    uint32_t const ces[9] = { 0x1DDD, 0x0261, 0x0000, 0x0020, 0x0020, 0x0000, 0x0005, 0x0002, 0x0000 };

    auto collation = collate_for_tests(
        cps, cps + 2, boost::text::variable_weighting::non_ignorable);

    EXPECT_EQ(collation.size(), 9);
    EXPECT_TRUE(boost::algorithm::equal(collation.begin(), collation.end(), ces, ces + 9))
        << "from:     " << ce_dumper(cps)
        << "expected: " << ce_dumper(ces)
        << "got:      " << ce_dumper(collation);
}

TEST(collation, non_ignorable_111_405)
{
    // 1D591 0021;	
    // (ùñë) MATHEMATICAL BOLD FRAKTUR SMALL L	[1DDD 0261 | 0020 0020 | 0005 0002 |]

    uint32_t cps[2] = { 0x1D591, 0x0021 };
    uint32_t const ces[9] = { 0x1DDD, 0x0261, 0x0000, 0x0020, 0x0020, 0x0000, 0x0005, 0x0002, 0x0000 };

    auto collation = collate_for_tests(
        cps, cps + 2, boost::text::variable_weighting::non_ignorable);

    EXPECT_EQ(collation.size(), 9);
    EXPECT_TRUE(boost::algorithm::equal(collation.begin(), collation.end(), ces, ces + 9))
        << "from:     " << ce_dumper(cps)
        << "expected: " << ce_dumper(ces)
        << "got:      " << ce_dumper(collation);
}

TEST(collation, non_ignorable_111_406)
{
    // 1D5C5 0021;	
    // (ùóÖ) MATHEMATICAL SANS-SERIF SMALL L	[1DDD 0261 | 0020 0020 | 0005 0002 |]

    uint32_t cps[2] = { 0x1D5C5, 0x0021 };
    uint32_t const ces[9] = { 0x1DDD, 0x0261, 0x0000, 0x0020, 0x0020, 0x0000, 0x0005, 0x0002, 0x0000 };

    auto collation = collate_for_tests(
        cps, cps + 2, boost::text::variable_weighting::non_ignorable);

    EXPECT_EQ(collation.size(), 9);
    EXPECT_TRUE(boost::algorithm::equal(collation.begin(), collation.end(), ces, ces + 9))
        << "from:     " << ce_dumper(cps)
        << "expected: " << ce_dumper(ces)
        << "got:      " << ce_dumper(collation);
}

TEST(collation, non_ignorable_111_407)
{
    // 1D5F9 0021;	
    // (ùóπ) MATHEMATICAL SANS-SERIF BOLD SMALL L	[1DDD 0261 | 0020 0020 | 0005 0002 |]

    uint32_t cps[2] = { 0x1D5F9, 0x0021 };
    uint32_t const ces[9] = { 0x1DDD, 0x0261, 0x0000, 0x0020, 0x0020, 0x0000, 0x0005, 0x0002, 0x0000 };

    auto collation = collate_for_tests(
        cps, cps + 2, boost::text::variable_weighting::non_ignorable);

    EXPECT_EQ(collation.size(), 9);
    EXPECT_TRUE(boost::algorithm::equal(collation.begin(), collation.end(), ces, ces + 9))
        << "from:     " << ce_dumper(cps)
        << "expected: " << ce_dumper(ces)
        << "got:      " << ce_dumper(collation);
}

TEST(collation, non_ignorable_111_408)
{
    // 1D62D 0021;	
    // (ùò≠) MATHEMATICAL SANS-SERIF ITALIC SMALL L	[1DDD 0261 | 0020 0020 | 0005 0002 |]

    uint32_t cps[2] = { 0x1D62D, 0x0021 };
    uint32_t const ces[9] = { 0x1DDD, 0x0261, 0x0000, 0x0020, 0x0020, 0x0000, 0x0005, 0x0002, 0x0000 };

    auto collation = collate_for_tests(
        cps, cps + 2, boost::text::variable_weighting::non_ignorable);

    EXPECT_EQ(collation.size(), 9);
    EXPECT_TRUE(boost::algorithm::equal(collation.begin(), collation.end(), ces, ces + 9))
        << "from:     " << ce_dumper(cps)
        << "expected: " << ce_dumper(ces)
        << "got:      " << ce_dumper(collation);
}

TEST(collation, non_ignorable_111_409)
{
    // 1D661 0021;	
    // (ùô°) MATHEMATICAL SANS-SERIF BOLD ITALIC SMALL L	[1DDD 0261 | 0020 0020 | 0005 0002 |]

    uint32_t cps[2] = { 0x1D661, 0x0021 };
    uint32_t const ces[9] = { 0x1DDD, 0x0261, 0x0000, 0x0020, 0x0020, 0x0000, 0x0005, 0x0002, 0x0000 };

    auto collation = collate_for_tests(
        cps, cps + 2, boost::text::variable_weighting::non_ignorable);

    EXPECT_EQ(collation.size(), 9);
    EXPECT_TRUE(boost::algorithm::equal(collation.begin(), collation.end(), ces, ces + 9))
        << "from:     " << ce_dumper(cps)
        << "expected: " << ce_dumper(ces)
        << "got:      " << ce_dumper(collation);
}

TEST(collation, non_ignorable_111_410)
{
    // 1D695 0021;	
    // (ùöï) MATHEMATICAL MONOSPACE SMALL L	[1DDD 0261 | 0020 0020 | 0005 0002 |]

    uint32_t cps[2] = { 0x1D695, 0x0021 };
    uint32_t const ces[9] = { 0x1DDD, 0x0261, 0x0000, 0x0020, 0x0020, 0x0000, 0x0005, 0x0002, 0x0000 };

    auto collation = collate_for_tests(
        cps, cps + 2, boost::text::variable_weighting::non_ignorable);

    EXPECT_EQ(collation.size(), 9);
    EXPECT_TRUE(boost::algorithm::equal(collation.begin(), collation.end(), ces, ces + 9))
        << "from:     " << ce_dumper(cps)
        << "expected: " << ce_dumper(ces)
        << "got:      " << ce_dumper(collation);
}

TEST(collation, non_ignorable_111_411)
{
    // 24DB 0021;	
    // (‚ìõ) CIRCLED LATIN SMALL LETTER L	[1DDD 0261 | 0020 0020 | 0006 0002 |]

    uint32_t cps[2] = { 0x24DB, 0x0021 };
    uint32_t const ces[9] = { 0x1DDD, 0x0261, 0x0000, 0x0020, 0x0020, 0x0000, 0x0006, 0x0002, 0x0000 };

    auto collation = collate_for_tests(
        cps, cps + 2, boost::text::variable_weighting::non_ignorable);

    EXPECT_EQ(collation.size(), 9);
    EXPECT_TRUE(boost::algorithm::equal(collation.begin(), collation.end(), ces, ces + 9))
        << "from:     " << ce_dumper(cps)
        << "expected: " << ce_dumper(ces)
        << "got:      " << ce_dumper(collation);
}

TEST(collation, non_ignorable_111_412)
{
    // 004C 0021;	
    // (L) LATIN CAPITAL LETTER L	[1DDD 0261 | 0020 0020 | 0008 0002 |]

    uint32_t cps[2] = { 0x004C, 0x0021 };
    uint32_t const ces[9] = { 0x1DDD, 0x0261, 0x0000, 0x0020, 0x0020, 0x0000, 0x0008, 0x0002, 0x0000 };

    auto collation = collate_for_tests(
        cps, cps + 2, boost::text::variable_weighting::non_ignorable);

    EXPECT_EQ(collation.size(), 9);
    EXPECT_TRUE(boost::algorithm::equal(collation.begin(), collation.end(), ces, ces + 9))
        << "from:     " << ce_dumper(cps)
        << "expected: " << ce_dumper(ces)
        << "got:      " << ce_dumper(collation);
}

TEST(collation, non_ignorable_111_413)
{
    // FF2C 0021;	
    // (Ôº¨) FULLWIDTH LATIN CAPITAL LETTER L	[1DDD 0261 | 0020 0020 | 0009 0002 |]

    uint32_t cps[2] = { 0xFF2C, 0x0021 };
    uint32_t const ces[9] = { 0x1DDD, 0x0261, 0x0000, 0x0020, 0x0020, 0x0000, 0x0009, 0x0002, 0x0000 };

    auto collation = collate_for_tests(
        cps, cps + 2, boost::text::variable_weighting::non_ignorable);

    EXPECT_EQ(collation.size(), 9);
    EXPECT_TRUE(boost::algorithm::equal(collation.begin(), collation.end(), ces, ces + 9))
        << "from:     " << ce_dumper(cps)
        << "expected: " << ce_dumper(ces)
        << "got:      " << ce_dumper(collation);
}

TEST(collation, non_ignorable_111_414)
{
    // 216C 0021;	
    // (‚Ö¨) ROMAN NUMERAL FIFTY	[1DDD 0261 | 0020 0020 | 000A 0002 |]

    uint32_t cps[2] = { 0x216C, 0x0021 };
    uint32_t const ces[9] = { 0x1DDD, 0x0261, 0x0000, 0x0020, 0x0020, 0x0000, 0x000A, 0x0002, 0x0000 };

    auto collation = collate_for_tests(
        cps, cps + 2, boost::text::variable_weighting::non_ignorable);

    EXPECT_EQ(collation.size(), 9);
    EXPECT_TRUE(boost::algorithm::equal(collation.begin(), collation.end(), ces, ces + 9))
        << "from:     " << ce_dumper(cps)
        << "expected: " << ce_dumper(ces)
        << "got:      " << ce_dumper(collation);
}

TEST(collation, non_ignorable_111_415)
{
    // 2112 0021;	
    // (‚Ñí) SCRIPT CAPITAL L	[1DDD 0261 | 0020 0020 | 000B 0002 |]

    uint32_t cps[2] = { 0x2112, 0x0021 };
    uint32_t const ces[9] = { 0x1DDD, 0x0261, 0x0000, 0x0020, 0x0020, 0x0000, 0x000B, 0x0002, 0x0000 };

    auto collation = collate_for_tests(
        cps, cps + 2, boost::text::variable_weighting::non_ignorable);

    EXPECT_EQ(collation.size(), 9);
    EXPECT_TRUE(boost::algorithm::equal(collation.begin(), collation.end(), ces, ces + 9))
        << "from:     " << ce_dumper(cps)
        << "expected: " << ce_dumper(ces)
        << "got:      " << ce_dumper(collation);
}

TEST(collation, non_ignorable_111_416)
{
    // 1D40B 0021;	
    // (ùêã) MATHEMATICAL BOLD CAPITAL L	[1DDD 0261 | 0020 0020 | 000B 0002 |]

    uint32_t cps[2] = { 0x1D40B, 0x0021 };
    uint32_t const ces[9] = { 0x1DDD, 0x0261, 0x0000, 0x0020, 0x0020, 0x0000, 0x000B, 0x0002, 0x0000 };

    auto collation = collate_for_tests(
        cps, cps + 2, boost::text::variable_weighting::non_ignorable);

    EXPECT_EQ(collation.size(), 9);
    EXPECT_TRUE(boost::algorithm::equal(collation.begin(), collation.end(), ces, ces + 9))
        << "from:     " << ce_dumper(cps)
        << "expected: " << ce_dumper(ces)
        << "got:      " << ce_dumper(collation);
}

TEST(collation, non_ignorable_111_417)
{
    // 1D43F 0021;	
    // (ùêø) MATHEMATICAL ITALIC CAPITAL L	[1DDD 0261 | 0020 0020 | 000B 0002 |]

    uint32_t cps[2] = { 0x1D43F, 0x0021 };
    uint32_t const ces[9] = { 0x1DDD, 0x0261, 0x0000, 0x0020, 0x0020, 0x0000, 0x000B, 0x0002, 0x0000 };

    auto collation = collate_for_tests(
        cps, cps + 2, boost::text::variable_weighting::non_ignorable);

    EXPECT_EQ(collation.size(), 9);
    EXPECT_TRUE(boost::algorithm::equal(collation.begin(), collation.end(), ces, ces + 9))
        << "from:     " << ce_dumper(cps)
        << "expected: " << ce_dumper(ces)
        << "got:      " << ce_dumper(collation);
}

TEST(collation, non_ignorable_111_418)
{
    // 1D473 0021;	
    // (ùë≥) MATHEMATICAL BOLD ITALIC CAPITAL L	[1DDD 0261 | 0020 0020 | 000B 0002 |]

    uint32_t cps[2] = { 0x1D473, 0x0021 };
    uint32_t const ces[9] = { 0x1DDD, 0x0261, 0x0000, 0x0020, 0x0020, 0x0000, 0x000B, 0x0002, 0x0000 };

    auto collation = collate_for_tests(
        cps, cps + 2, boost::text::variable_weighting::non_ignorable);

    EXPECT_EQ(collation.size(), 9);
    EXPECT_TRUE(boost::algorithm::equal(collation.begin(), collation.end(), ces, ces + 9))
        << "from:     " << ce_dumper(cps)
        << "expected: " << ce_dumper(ces)
        << "got:      " << ce_dumper(collation);
}

TEST(collation, non_ignorable_111_419)
{
    // 1D4DB 0021;	
    // (ùìõ) MATHEMATICAL BOLD SCRIPT CAPITAL L	[1DDD 0261 | 0020 0020 | 000B 0002 |]

    uint32_t cps[2] = { 0x1D4DB, 0x0021 };
    uint32_t const ces[9] = { 0x1DDD, 0x0261, 0x0000, 0x0020, 0x0020, 0x0000, 0x000B, 0x0002, 0x0000 };

    auto collation = collate_for_tests(
        cps, cps + 2, boost::text::variable_weighting::non_ignorable);

    EXPECT_EQ(collation.size(), 9);
    EXPECT_TRUE(boost::algorithm::equal(collation.begin(), collation.end(), ces, ces + 9))
        << "from:     " << ce_dumper(cps)
        << "expected: " << ce_dumper(ces)
        << "got:      " << ce_dumper(collation);
}

TEST(collation, non_ignorable_111_420)
{
    // 1D50F 0021;	
    // (ùîè) MATHEMATICAL FRAKTUR CAPITAL L	[1DDD 0261 | 0020 0020 | 000B 0002 |]

    uint32_t cps[2] = { 0x1D50F, 0x0021 };
    uint32_t const ces[9] = { 0x1DDD, 0x0261, 0x0000, 0x0020, 0x0020, 0x0000, 0x000B, 0x0002, 0x0000 };

    auto collation = collate_for_tests(
        cps, cps + 2, boost::text::variable_weighting::non_ignorable);

    EXPECT_EQ(collation.size(), 9);
    EXPECT_TRUE(boost::algorithm::equal(collation.begin(), collation.end(), ces, ces + 9))
        << "from:     " << ce_dumper(cps)
        << "expected: " << ce_dumper(ces)
        << "got:      " << ce_dumper(collation);
}

TEST(collation, non_ignorable_111_421)
{
    // 1D543 0021;	
    // (ùïÉ) MATHEMATICAL DOUBLE-STRUCK CAPITAL L	[1DDD 0261 | 0020 0020 | 000B 0002 |]

    uint32_t cps[2] = { 0x1D543, 0x0021 };
    uint32_t const ces[9] = { 0x1DDD, 0x0261, 0x0000, 0x0020, 0x0020, 0x0000, 0x000B, 0x0002, 0x0000 };

    auto collation = collate_for_tests(
        cps, cps + 2, boost::text::variable_weighting::non_ignorable);

    EXPECT_EQ(collation.size(), 9);
    EXPECT_TRUE(boost::algorithm::equal(collation.begin(), collation.end(), ces, ces + 9))
        << "from:     " << ce_dumper(cps)
        << "expected: " << ce_dumper(ces)
        << "got:      " << ce_dumper(collation);
}

TEST(collation, non_ignorable_111_422)
{
    // 1D577 0021;	
    // (ùï∑) MATHEMATICAL BOLD FRAKTUR CAPITAL L	[1DDD 0261 | 0020 0020 | 000B 0002 |]

    uint32_t cps[2] = { 0x1D577, 0x0021 };
    uint32_t const ces[9] = { 0x1DDD, 0x0261, 0x0000, 0x0020, 0x0020, 0x0000, 0x000B, 0x0002, 0x0000 };

    auto collation = collate_for_tests(
        cps, cps + 2, boost::text::variable_weighting::non_ignorable);

    EXPECT_EQ(collation.size(), 9);
    EXPECT_TRUE(boost::algorithm::equal(collation.begin(), collation.end(), ces, ces + 9))
        << "from:     " << ce_dumper(cps)
        << "expected: " << ce_dumper(ces)
        << "got:      " << ce_dumper(collation);
}

TEST(collation, non_ignorable_111_423)
{
    // 1D5AB 0021;	
    // (ùñ´) MATHEMATICAL SANS-SERIF CAPITAL L	[1DDD 0261 | 0020 0020 | 000B 0002 |]

    uint32_t cps[2] = { 0x1D5AB, 0x0021 };
    uint32_t const ces[9] = { 0x1DDD, 0x0261, 0x0000, 0x0020, 0x0020, 0x0000, 0x000B, 0x0002, 0x0000 };

    auto collation = collate_for_tests(
        cps, cps + 2, boost::text::variable_weighting::non_ignorable);

    EXPECT_EQ(collation.size(), 9);
    EXPECT_TRUE(boost::algorithm::equal(collation.begin(), collation.end(), ces, ces + 9))
        << "from:     " << ce_dumper(cps)
        << "expected: " << ce_dumper(ces)
        << "got:      " << ce_dumper(collation);
}

TEST(collation, non_ignorable_111_424)
{
    // 1D5DF 0021;	
    // (ùóü) MATHEMATICAL SANS-SERIF BOLD CAPITAL L	[1DDD 0261 | 0020 0020 | 000B 0002 |]

    uint32_t cps[2] = { 0x1D5DF, 0x0021 };
    uint32_t const ces[9] = { 0x1DDD, 0x0261, 0x0000, 0x0020, 0x0020, 0x0000, 0x000B, 0x0002, 0x0000 };

    auto collation = collate_for_tests(
        cps, cps + 2, boost::text::variable_weighting::non_ignorable);

    EXPECT_EQ(collation.size(), 9);
    EXPECT_TRUE(boost::algorithm::equal(collation.begin(), collation.end(), ces, ces + 9))
        << "from:     " << ce_dumper(cps)
        << "expected: " << ce_dumper(ces)
        << "got:      " << ce_dumper(collation);
}

TEST(collation, non_ignorable_111_425)
{
    // 1D613 0021;	
    // (ùòì) MATHEMATICAL SANS-SERIF ITALIC CAPITAL L	[1DDD 0261 | 0020 0020 | 000B 0002 |]

    uint32_t cps[2] = { 0x1D613, 0x0021 };
    uint32_t const ces[9] = { 0x1DDD, 0x0261, 0x0000, 0x0020, 0x0020, 0x0000, 0x000B, 0x0002, 0x0000 };

    auto collation = collate_for_tests(
        cps, cps + 2, boost::text::variable_weighting::non_ignorable);

    EXPECT_EQ(collation.size(), 9);
    EXPECT_TRUE(boost::algorithm::equal(collation.begin(), collation.end(), ces, ces + 9))
        << "from:     " << ce_dumper(cps)
        << "expected: " << ce_dumper(ces)
        << "got:      " << ce_dumper(collation);
}

TEST(collation, non_ignorable_111_426)
{
    // 1D647 0021;	
    // (ùôá) MATHEMATICAL SANS-SERIF BOLD ITALIC CAPITAL L	[1DDD 0261 | 0020 0020 | 000B 0002 |]

    uint32_t cps[2] = { 0x1D647, 0x0021 };
    uint32_t const ces[9] = { 0x1DDD, 0x0261, 0x0000, 0x0020, 0x0020, 0x0000, 0x000B, 0x0002, 0x0000 };

    auto collation = collate_for_tests(
        cps, cps + 2, boost::text::variable_weighting::non_ignorable);

    EXPECT_EQ(collation.size(), 9);
    EXPECT_TRUE(boost::algorithm::equal(collation.begin(), collation.end(), ces, ces + 9))
        << "from:     " << ce_dumper(cps)
        << "expected: " << ce_dumper(ces)
        << "got:      " << ce_dumper(collation);
}

TEST(collation, non_ignorable_111_427)
{
    // 1D67B 0021;	
    // (ùôª) MATHEMATICAL MONOSPACE CAPITAL L	[1DDD 0261 | 0020 0020 | 000B 0002 |]

    uint32_t cps[2] = { 0x1D67B, 0x0021 };
    uint32_t const ces[9] = { 0x1DDD, 0x0261, 0x0000, 0x0020, 0x0020, 0x0000, 0x000B, 0x0002, 0x0000 };

    auto collation = collate_for_tests(
        cps, cps + 2, boost::text::variable_weighting::non_ignorable);

    EXPECT_EQ(collation.size(), 9);
    EXPECT_TRUE(boost::algorithm::equal(collation.begin(), collation.end(), ces, ces + 9))
        << "from:     " << ce_dumper(cps)
        << "expected: " << ce_dumper(ces)
        << "got:      " << ce_dumper(collation);
}

TEST(collation, non_ignorable_111_428)
{
    // 24C1 0021;	
    // (‚ìÅ) CIRCLED LATIN CAPITAL LETTER L	[1DDD 0261 | 0020 0020 | 000C 0002 |]

    uint32_t cps[2] = { 0x24C1, 0x0021 };
    uint32_t const ces[9] = { 0x1DDD, 0x0261, 0x0000, 0x0020, 0x0020, 0x0000, 0x000C, 0x0002, 0x0000 };

    auto collation = collate_for_tests(
        cps, cps + 2, boost::text::variable_weighting::non_ignorable);

    EXPECT_EQ(collation.size(), 9);
    EXPECT_TRUE(boost::algorithm::equal(collation.begin(), collation.end(), ces, ces + 9))
        << "from:     " << ce_dumper(cps)
        << "expected: " << ce_dumper(ces)
        << "got:      " << ce_dumper(collation);
}

TEST(collation, non_ignorable_111_429)
{
    // 1F15B 0021;	
    // (üÖõ) NEGATIVE CIRCLED LATIN CAPITAL LETTER L	[1DDD 0261 | 0020 0020 | 000C 0002 |]

    uint32_t cps[2] = { 0x1F15B, 0x0021 };
    uint32_t const ces[9] = { 0x1DDD, 0x0261, 0x0000, 0x0020, 0x0020, 0x0000, 0x000C, 0x0002, 0x0000 };

    auto collation = collate_for_tests(
        cps, cps + 2, boost::text::variable_weighting::non_ignorable);

    EXPECT_EQ(collation.size(), 9);
    EXPECT_TRUE(boost::algorithm::equal(collation.begin(), collation.end(), ces, ces + 9))
        << "from:     " << ce_dumper(cps)
        << "expected: " << ce_dumper(ces)
        << "got:      " << ce_dumper(collation);
}

TEST(collation, non_ignorable_111_430)
{
    // 02E1 0021;	
    // (À°) MODIFIER LETTER SMALL L	[1DDD 0261 | 0020 0020 | 0014 0002 |]

    uint32_t cps[2] = { 0x02E1, 0x0021 };
    uint32_t const ces[9] = { 0x1DDD, 0x0261, 0x0000, 0x0020, 0x0020, 0x0000, 0x0014, 0x0002, 0x0000 };

    auto collation = collate_for_tests(
        cps, cps + 2, boost::text::variable_weighting::non_ignorable);

    EXPECT_EQ(collation.size(), 9);
    EXPECT_TRUE(boost::algorithm::equal(collation.begin(), collation.end(), ces, ces + 9))
        << "from:     " << ce_dumper(cps)
        << "expected: " << ce_dumper(ces)
        << "got:      " << ce_dumper(collation);
}

TEST(collation, non_ignorable_111_431)
{
    // 2097 0021;	
    // (‚Çó) LATIN SUBSCRIPT SMALL LETTER L	[1DDD 0261 | 0020 0020 | 0015 0002 |]

    uint32_t cps[2] = { 0x2097, 0x0021 };
    uint32_t const ces[9] = { 0x1DDD, 0x0261, 0x0000, 0x0020, 0x0020, 0x0000, 0x0015, 0x0002, 0x0000 };

    auto collation = collate_for_tests(
        cps, cps + 2, boost::text::variable_weighting::non_ignorable);

    EXPECT_EQ(collation.size(), 9);
    EXPECT_TRUE(boost::algorithm::equal(collation.begin(), collation.end(), ces, ces + 9))
        << "from:     " << ce_dumper(cps)
        << "expected: " << ce_dumper(ces)
        << "got:      " << ce_dumper(collation);
}

TEST(collation, non_ignorable_111_432)
{
    // 1D38 0021;	
    // (·¥∏) MODIFIER LETTER CAPITAL L	[1DDD 0261 | 0020 0020 | 001D 0002 |]

    uint32_t cps[2] = { 0x1D38, 0x0021 };
    uint32_t const ces[9] = { 0x1DDD, 0x0261, 0x0000, 0x0020, 0x0020, 0x0000, 0x001D, 0x0002, 0x0000 };

    auto collation = collate_for_tests(
        cps, cps + 2, boost::text::variable_weighting::non_ignorable);

    EXPECT_EQ(collation.size(), 9);
    EXPECT_TRUE(boost::algorithm::equal(collation.begin(), collation.end(), ces, ces + 9))
        << "from:     " << ce_dumper(cps)
        << "expected: " << ce_dumper(ces)
        << "got:      " << ce_dumper(collation);
}

TEST(collation, non_ignorable_111_433)
{
    // 1F13B 0021;	
    // (üÑª) SQUARED LATIN CAPITAL LETTER L	[1DDD 0261 | 0020 0020 | 001D 0002 |]

    uint32_t cps[2] = { 0x1F13B, 0x0021 };
    uint32_t const ces[9] = { 0x1DDD, 0x0261, 0x0000, 0x0020, 0x0020, 0x0000, 0x001D, 0x0002, 0x0000 };

    auto collation = collate_for_tests(
        cps, cps + 2, boost::text::variable_weighting::non_ignorable);

    EXPECT_EQ(collation.size(), 9);
    EXPECT_TRUE(boost::algorithm::equal(collation.begin(), collation.end(), ces, ces + 9))
        << "from:     " << ce_dumper(cps)
        << "expected: " << ce_dumper(ces)
        << "got:      " << ce_dumper(collation);
}

TEST(collation, non_ignorable_111_434)
{
    // 1F17B 0021;	
    // (üÖª) NEGATIVE SQUARED LATIN CAPITAL LETTER L	[1DDD 0261 | 0020 0020 | 001D 0002 |]

    uint32_t cps[2] = { 0x1F17B, 0x0021 };
    uint32_t const ces[9] = { 0x1DDD, 0x0261, 0x0000, 0x0020, 0x0020, 0x0000, 0x001D, 0x0002, 0x0000 };

    auto collation = collate_for_tests(
        cps, cps + 2, boost::text::variable_weighting::non_ignorable);

    EXPECT_EQ(collation.size(), 9);
    EXPECT_TRUE(boost::algorithm::equal(collation.begin(), collation.end(), ces, ces + 9))
        << "from:     " << ce_dumper(cps)
        << "expected: " << ce_dumper(ces)
        << "got:      " << ce_dumper(collation);
}

TEST(collation, non_ignorable_111_435)
{
    // 013A 0021;	
    // (ƒ∫) LATIN SMALL LETTER L WITH ACUTE	[1DDD 0261 | 0020 0024 0020 | 0002 0002 0002 |]

    uint32_t cps[2] = { 0x013A, 0x0021 };
    uint32_t const ces[11] = { 0x1DDD, 0x0261, 0x0000, 0x0020, 0x0024, 0x0020, 0x0000, 0x0002, 0x0002, 0x0002, 0x0000 };

    auto collation = collate_for_tests(
        cps, cps + 2, boost::text::variable_weighting::non_ignorable);

    EXPECT_EQ(collation.size(), 11);
    EXPECT_TRUE(boost::algorithm::equal(collation.begin(), collation.end(), ces, ces + 11))
        << "from:     " << ce_dumper(cps)
        << "expected: " << ce_dumper(ces)
        << "got:      " << ce_dumper(collation);
}

TEST(collation, non_ignorable_111_436)
{
    // 0139 0021;	
    // (ƒπ) LATIN CAPITAL LETTER L WITH ACUTE	[1DDD 0261 | 0020 0024 0020 | 0008 0002 0002 |]

    uint32_t cps[2] = { 0x0139, 0x0021 };
    uint32_t const ces[11] = { 0x1DDD, 0x0261, 0x0000, 0x0020, 0x0024, 0x0020, 0x0000, 0x0008, 0x0002, 0x0002, 0x0000 };

    auto collation = collate_for_tests(
        cps, cps + 2, boost::text::variable_weighting::non_ignorable);

    EXPECT_EQ(collation.size(), 11);
    EXPECT_TRUE(boost::algorithm::equal(collation.begin(), collation.end(), ces, ces + 11))
        << "from:     " << ce_dumper(cps)
        << "expected: " << ce_dumper(ces)
        << "got:      " << ce_dumper(collation);
}

TEST(collation, non_ignorable_111_437)
{
    // 013E 0021;	
    // (ƒæ) LATIN SMALL LETTER L WITH CARON	[1DDD 0261 | 0020 0028 0020 | 0002 0002 0002 |]

    uint32_t cps[2] = { 0x013E, 0x0021 };
    uint32_t const ces[11] = { 0x1DDD, 0x0261, 0x0000, 0x0020, 0x0028, 0x0020, 0x0000, 0x0002, 0x0002, 0x0002, 0x0000 };

    auto collation = collate_for_tests(
        cps, cps + 2, boost::text::variable_weighting::non_ignorable);

    EXPECT_EQ(collation.size(), 11);
    EXPECT_TRUE(boost::algorithm::equal(collation.begin(), collation.end(), ces, ces + 11))
        << "from:     " << ce_dumper(cps)
        << "expected: " << ce_dumper(ces)
        << "got:      " << ce_dumper(collation);
}

TEST(collation, non_ignorable_111_438)
{
    // 013D 0021;	
    // (ƒΩ) LATIN CAPITAL LETTER L WITH CARON	[1DDD 0261 | 0020 0028 0020 | 0008 0002 0002 |]

    uint32_t cps[2] = { 0x013D, 0x0021 };
    uint32_t const ces[11] = { 0x1DDD, 0x0261, 0x0000, 0x0020, 0x0028, 0x0020, 0x0000, 0x0008, 0x0002, 0x0002, 0x0000 };

    auto collation = collate_for_tests(
        cps, cps + 2, boost::text::variable_weighting::non_ignorable);

    EXPECT_EQ(collation.size(), 11);
    EXPECT_TRUE(boost::algorithm::equal(collation.begin(), collation.end(), ces, ces + 11))
        << "from:     " << ce_dumper(cps)
        << "expected: " << ce_dumper(ces)
        << "got:      " << ce_dumper(collation);
}

TEST(collation, non_ignorable_111_439)
{
    // 013C 0021;	
    // (ƒº) LATIN SMALL LETTER L WITH CEDILLA	[1DDD 0261 | 0020 0030 0020 | 0002 0002 0002 |]

    uint32_t cps[2] = { 0x013C, 0x0021 };
    uint32_t const ces[11] = { 0x1DDD, 0x0261, 0x0000, 0x0020, 0x0030, 0x0020, 0x0000, 0x0002, 0x0002, 0x0002, 0x0000 };

    auto collation = collate_for_tests(
        cps, cps + 2, boost::text::variable_weighting::non_ignorable);

    EXPECT_EQ(collation.size(), 11);
    EXPECT_TRUE(boost::algorithm::equal(collation.begin(), collation.end(), ces, ces + 11))
        << "from:     " << ce_dumper(cps)
        << "expected: " << ce_dumper(ces)
        << "got:      " << ce_dumper(collation);
}

TEST(collation, non_ignorable_111_440)
{
    // 013B 0021;	
    // (ƒª) LATIN CAPITAL LETTER L WITH CEDILLA	[1DDD 0261 | 0020 0030 0020 | 0008 0002 0002 |]

    uint32_t cps[2] = { 0x013B, 0x0021 };
    uint32_t const ces[11] = { 0x1DDD, 0x0261, 0x0000, 0x0020, 0x0030, 0x0020, 0x0000, 0x0008, 0x0002, 0x0002, 0x0000 };

    auto collation = collate_for_tests(
        cps, cps + 2, boost::text::variable_weighting::non_ignorable);

    EXPECT_EQ(collation.size(), 11);
    EXPECT_TRUE(boost::algorithm::equal(collation.begin(), collation.end(), ces, ces + 11))
        << "from:     " << ce_dumper(cps)
        << "expected: " << ce_dumper(ces)
        << "got:      " << ce_dumper(collation);
}

TEST(collation, non_ignorable_111_441)
{
    // 0142 0021;	
    // (≈Ç) LATIN SMALL LETTER L WITH STROKE	[1DDD 0261 | 0020 0039 0020 | 0002 0002 0002 |]

    uint32_t cps[2] = { 0x0142, 0x0021 };
    uint32_t const ces[11] = { 0x1DDD, 0x0261, 0x0000, 0x0020, 0x0039, 0x0020, 0x0000, 0x0002, 0x0002, 0x0002, 0x0000 };

    auto collation = collate_for_tests(
        cps, cps + 2, boost::text::variable_weighting::non_ignorable);

    EXPECT_EQ(collation.size(), 11);
    EXPECT_TRUE(boost::algorithm::equal(collation.begin(), collation.end(), ces, ces + 11))
        << "from:     " << ce_dumper(cps)
        << "expected: " << ce_dumper(ces)
        << "got:      " << ce_dumper(collation);
}

TEST(collation, non_ignorable_111_442)
{
    // 0141 0021;	
    // (≈Å) LATIN CAPITAL LETTER L WITH STROKE	[1DDD 0261 | 0020 0039 0020 | 0008 0002 0002 |]

    uint32_t cps[2] = { 0x0141, 0x0021 };
    uint32_t const ces[11] = { 0x1DDD, 0x0261, 0x0000, 0x0020, 0x0039, 0x0020, 0x0000, 0x0008, 0x0002, 0x0002, 0x0000 };

    auto collation = collate_for_tests(
        cps, cps + 2, boost::text::variable_weighting::non_ignorable);

    EXPECT_EQ(collation.size(), 11);
    EXPECT_TRUE(boost::algorithm::equal(collation.begin(), collation.end(), ces, ces + 11))
        << "from:     " << ce_dumper(cps)
        << "expected: " << ce_dumper(ces)
        << "got:      " << ce_dumper(collation);
}

TEST(collation, non_ignorable_111_443)
{
    // 1E37 0021;	
    // (·∏∑) LATIN SMALL LETTER L WITH DOT BELOW	[1DDD 0261 | 0020 0042 0020 | 0002 0002 0002 |]

    uint32_t cps[2] = { 0x1E37, 0x0021 };
    uint32_t const ces[11] = { 0x1DDD, 0x0261, 0x0000, 0x0020, 0x0042, 0x0020, 0x0000, 0x0002, 0x0002, 0x0002, 0x0000 };

    auto collation = collate_for_tests(
        cps, cps + 2, boost::text::variable_weighting::non_ignorable);

    EXPECT_EQ(collation.size(), 11);
    EXPECT_TRUE(boost::algorithm::equal(collation.begin(), collation.end(), ces, ces + 11))
        << "from:     " << ce_dumper(cps)
        << "expected: " << ce_dumper(ces)
        << "got:      " << ce_dumper(collation);
}

TEST(collation, non_ignorable_111_444)
{
    // 1E36 0021;	
    // (·∏∂) LATIN CAPITAL LETTER L WITH DOT BELOW	[1DDD 0261 | 0020 0042 0020 | 0008 0002 0002 |]

    uint32_t cps[2] = { 0x1E36, 0x0021 };
    uint32_t const ces[11] = { 0x1DDD, 0x0261, 0x0000, 0x0020, 0x0042, 0x0020, 0x0000, 0x0008, 0x0002, 0x0002, 0x0000 };

    auto collation = collate_for_tests(
        cps, cps + 2, boost::text::variable_weighting::non_ignorable);

    EXPECT_EQ(collation.size(), 11);
    EXPECT_TRUE(boost::algorithm::equal(collation.begin(), collation.end(), ces, ces + 11))
        << "from:     " << ce_dumper(cps)
        << "expected: " << ce_dumper(ces)
        << "got:      " << ce_dumper(collation);
}

TEST(collation, non_ignorable_111_445)
{
    // 1E39 0021;	
    // (·∏π) LATIN SMALL LETTER L WITH DOT BELOW AND MACRON	[1DDD 0261 | 0020 0042 0032 0020 | 0002 0002 0002 0002 |]

    uint32_t cps[2] = { 0x1E39, 0x0021 };
    uint32_t const ces[13] = { 0x1DDD, 0x0261, 0x0000, 0x0020, 0x0042, 0x0032, 0x0020, 0x0000, 0x0002, 0x0002, 0x0002, 0x0002, 0x0000 };

    auto collation = collate_for_tests(
        cps, cps + 2, boost::text::variable_weighting::non_ignorable);

    EXPECT_EQ(collation.size(), 13);
    EXPECT_TRUE(boost::algorithm::equal(collation.begin(), collation.end(), ces, ces + 13))
        << "from:     " << ce_dumper(cps)
        << "expected: " << ce_dumper(ces)
        << "got:      " << ce_dumper(collation);
}

TEST(collation, non_ignorable_111_446)
{
    // 1E38 0021;	
    // (·∏∏) LATIN CAPITAL LETTER L WITH DOT BELOW AND MACRON	[1DDD 0261 | 0020 0042 0032 0020 | 0008 0002 0002 0002 |]

    uint32_t cps[2] = { 0x1E38, 0x0021 };
    uint32_t const ces[13] = { 0x1DDD, 0x0261, 0x0000, 0x0020, 0x0042, 0x0032, 0x0020, 0x0000, 0x0008, 0x0002, 0x0002, 0x0002, 0x0000 };

    auto collation = collate_for_tests(
        cps, cps + 2, boost::text::variable_weighting::non_ignorable);

    EXPECT_EQ(collation.size(), 13);
    EXPECT_TRUE(boost::algorithm::equal(collation.begin(), collation.end(), ces, ces + 13))
        << "from:     " << ce_dumper(cps)
        << "expected: " << ce_dumper(ces)
        << "got:      " << ce_dumper(collation);
}

TEST(collation, non_ignorable_111_447)
{
    // 1E3D 0021;	
    // (·∏Ω) LATIN SMALL LETTER L WITH CIRCUMFLEX BELOW	[1DDD 0261 | 0020 0046 0020 | 0002 0002 0002 |]

    uint32_t cps[2] = { 0x1E3D, 0x0021 };
    uint32_t const ces[11] = { 0x1DDD, 0x0261, 0x0000, 0x0020, 0x0046, 0x0020, 0x0000, 0x0002, 0x0002, 0x0002, 0x0000 };

    auto collation = collate_for_tests(
        cps, cps + 2, boost::text::variable_weighting::non_ignorable);

    EXPECT_EQ(collation.size(), 11);
    EXPECT_TRUE(boost::algorithm::equal(collation.begin(), collation.end(), ces, ces + 11))
        << "from:     " << ce_dumper(cps)
        << "expected: " << ce_dumper(ces)
        << "got:      " << ce_dumper(collation);
}

TEST(collation, non_ignorable_111_448)
{
    // 1E3C 0021;	
    // (·∏º) LATIN CAPITAL LETTER L WITH CIRCUMFLEX BELOW	[1DDD 0261 | 0020 0046 0020 | 0008 0002 0002 |]

    uint32_t cps[2] = { 0x1E3C, 0x0021 };
    uint32_t const ces[11] = { 0x1DDD, 0x0261, 0x0000, 0x0020, 0x0046, 0x0020, 0x0000, 0x0008, 0x0002, 0x0002, 0x0000 };

    auto collation = collate_for_tests(
        cps, cps + 2, boost::text::variable_weighting::non_ignorable);

    EXPECT_EQ(collation.size(), 11);
    EXPECT_TRUE(boost::algorithm::equal(collation.begin(), collation.end(), ces, ces + 11))
        << "from:     " << ce_dumper(cps)
        << "expected: " << ce_dumper(ces)
        << "got:      " << ce_dumper(collation);
}

TEST(collation, non_ignorable_111_449)
{
    // 1E3B 0021;	
    // (·∏ª) LATIN SMALL LETTER L WITH LINE BELOW	[1DDD 0261 | 0020 0049 0020 | 0002 0002 0002 |]

    uint32_t cps[2] = { 0x1E3B, 0x0021 };
    uint32_t const ces[11] = { 0x1DDD, 0x0261, 0x0000, 0x0020, 0x0049, 0x0020, 0x0000, 0x0002, 0x0002, 0x0002, 0x0000 };

    auto collation = collate_for_tests(
        cps, cps + 2, boost::text::variable_weighting::non_ignorable);

    EXPECT_EQ(collation.size(), 11);
    EXPECT_TRUE(boost::algorithm::equal(collation.begin(), collation.end(), ces, ces + 11))
        << "from:     " << ce_dumper(cps)
        << "expected: " << ce_dumper(ces)
        << "got:      " << ce_dumper(collation);
}

TEST(collation, non_ignorable_111_450)
{
    // 1E3A 0021;	
    // (·∏∫) LATIN CAPITAL LETTER L WITH LINE BELOW	[1DDD 0261 | 0020 0049 0020 | 0008 0002 0002 |]

    uint32_t cps[2] = { 0x1E3A, 0x0021 };
    uint32_t const ces[11] = { 0x1DDD, 0x0261, 0x0000, 0x0020, 0x0049, 0x0020, 0x0000, 0x0008, 0x0002, 0x0002, 0x0000 };

    auto collation = collate_for_tests(
        cps, cps + 2, boost::text::variable_weighting::non_ignorable);

    EXPECT_EQ(collation.size(), 11);
    EXPECT_TRUE(boost::algorithm::equal(collation.begin(), collation.end(), ces, ces + 11))
        << "from:     " << ce_dumper(cps)
        << "expected: " << ce_dumper(ces)
        << "got:      " << ce_dumper(collation);
}

TEST(collation, non_ignorable_111_451)
{
    // 006C 00B7 0021;	
    // (l¬∑) LATIN SMALL LETTER L, MIDDLE DOT	[1DDD 0261 | 0020 0111 0020 | 0002 0002 0002 |]

    uint32_t cps[3] = { 0x006C, 0x00B7, 0x0021 };
    uint32_t const ces[11] = { 0x1DDD, 0x0261, 0x0000, 0x0020, 0x0111, 0x0020, 0x0000, 0x0002, 0x0002, 0x0002, 0x0000 };

    auto collation = collate_for_tests(
        cps, cps + 3, boost::text::variable_weighting::non_ignorable);

    EXPECT_EQ(collation.size(), 11);
    EXPECT_TRUE(boost::algorithm::equal(collation.begin(), collation.end(), ces, ces + 11))
        << "from:     " << ce_dumper(cps)
        << "expected: " << ce_dumper(ces)
        << "got:      " << ce_dumper(collation);
}

TEST(collation, non_ignorable_111_452)
{
    // 006C 0387 0021;	
    // (l¬∑) LATIN SMALL LETTER L, GREEK ANO TELEIA	[1DDD 0261 | 0020 0111 0020 | 0002 0002 0002 |]

    uint32_t cps[3] = { 0x006C, 0x0387, 0x0021 };
    uint32_t const ces[11] = { 0x1DDD, 0x0261, 0x0000, 0x0020, 0x0111, 0x0020, 0x0000, 0x0002, 0x0002, 0x0002, 0x0000 };

    auto collation = collate_for_tests(
        cps, cps + 3, boost::text::variable_weighting::non_ignorable);

    EXPECT_EQ(collation.size(), 11);
    EXPECT_TRUE(boost::algorithm::equal(collation.begin(), collation.end(), ces, ces + 11))
        << "from:     " << ce_dumper(cps)
        << "expected: " << ce_dumper(ces)
        << "got:      " << ce_dumper(collation);
}

TEST(collation, non_ignorable_111_453)
{
    // 0140 0021;	
    // (≈Ä) LATIN SMALL LETTER L WITH MIDDLE DOT	[1DDD 0261 | 0020 0111 0020 | 0002 0002 0002 |]

    uint32_t cps[2] = { 0x0140, 0x0021 };
    uint32_t const ces[11] = { 0x1DDD, 0x0261, 0x0000, 0x0020, 0x0111, 0x0020, 0x0000, 0x0002, 0x0002, 0x0002, 0x0000 };

    auto collation = collate_for_tests(
        cps, cps + 2, boost::text::variable_weighting::non_ignorable);

    EXPECT_EQ(collation.size(), 11);
    EXPECT_TRUE(boost::algorithm::equal(collation.begin(), collation.end(), ces, ces + 11))
        << "from:     " << ce_dumper(cps)
        << "expected: " << ce_dumper(ces)
        << "got:      " << ce_dumper(collation);
}

TEST(collation, non_ignorable_111_454)
{
    // 004C 00B7 0021;	
    // (L¬∑) LATIN CAPITAL LETTER L, MIDDLE DOT	[1DDD 0261 | 0020 0111 0020 | 0008 0002 0002 |]

    uint32_t cps[3] = { 0x004C, 0x00B7, 0x0021 };
    uint32_t const ces[11] = { 0x1DDD, 0x0261, 0x0000, 0x0020, 0x0111, 0x0020, 0x0000, 0x0008, 0x0002, 0x0002, 0x0000 };

    auto collation = collate_for_tests(
        cps, cps + 3, boost::text::variable_weighting::non_ignorable);

    EXPECT_EQ(collation.size(), 11);
    EXPECT_TRUE(boost::algorithm::equal(collation.begin(), collation.end(), ces, ces + 11))
        << "from:     " << ce_dumper(cps)
        << "expected: " << ce_dumper(ces)
        << "got:      " << ce_dumper(collation);
}

TEST(collation, non_ignorable_111_455)
{
    // 004C 0387 0021;	
    // (L¬∑) LATIN CAPITAL LETTER L, GREEK ANO TELEIA	[1DDD 0261 | 0020 0111 0020 | 0008 0002 0002 |]

    uint32_t cps[3] = { 0x004C, 0x0387, 0x0021 };
    uint32_t const ces[11] = { 0x1DDD, 0x0261, 0x0000, 0x0020, 0x0111, 0x0020, 0x0000, 0x0008, 0x0002, 0x0002, 0x0000 };

    auto collation = collate_for_tests(
        cps, cps + 3, boost::text::variable_weighting::non_ignorable);

    EXPECT_EQ(collation.size(), 11);
    EXPECT_TRUE(boost::algorithm::equal(collation.begin(), collation.end(), ces, ces + 11))
        << "from:     " << ce_dumper(cps)
        << "expected: " << ce_dumper(ces)
        << "got:      " << ce_dumper(collation);
}

TEST(collation, non_ignorable_111_456)
{
    // 013F 0021;	
    // (ƒø) LATIN CAPITAL LETTER L WITH MIDDLE DOT	[1DDD 0261 | 0020 0111 0020 | 0008 0002 0002 |]

    uint32_t cps[2] = { 0x013F, 0x0021 };
    uint32_t const ces[11] = { 0x1DDD, 0x0261, 0x0000, 0x0020, 0x0111, 0x0020, 0x0000, 0x0008, 0x0002, 0x0002, 0x0000 };

    auto collation = collate_for_tests(
        cps, cps + 2, boost::text::variable_weighting::non_ignorable);

    EXPECT_EQ(collation.size(), 11);
    EXPECT_TRUE(boost::algorithm::equal(collation.begin(), collation.end(), ces, ces + 11))
        << "from:     " << ce_dumper(cps)
        << "expected: " << ce_dumper(ces)
        << "got:      " << ce_dumper(collation);
}

TEST(collation, non_ignorable_111_457)
{
    // 006C 003F;	
    // (l) LATIN SMALL LETTER L	[1DDD 0267 | 0020 0020 | 0002 0002 |]

    uint32_t cps[2] = { 0x006C, 0x003F };
    uint32_t const ces[9] = { 0x1DDD, 0x0267, 0x0000, 0x0020, 0x0020, 0x0000, 0x0002, 0x0002, 0x0000 };

    auto collation = collate_for_tests(
        cps, cps + 2, boost::text::variable_weighting::non_ignorable);

    EXPECT_EQ(collation.size(), 9);
    EXPECT_TRUE(boost::algorithm::equal(collation.begin(), collation.end(), ces, ces + 9))
        << "from:     " << ce_dumper(cps)
        << "expected: " << ce_dumper(ces)
        << "got:      " << ce_dumper(collation);
}

TEST(collation, non_ignorable_111_458)
{
    // FF4C 003F;	
    // (ÔΩå) FULLWIDTH LATIN SMALL LETTER L	[1DDD 0267 | 0020 0020 | 0003 0002 |]

    uint32_t cps[2] = { 0xFF4C, 0x003F };
    uint32_t const ces[9] = { 0x1DDD, 0x0267, 0x0000, 0x0020, 0x0020, 0x0000, 0x0003, 0x0002, 0x0000 };

    auto collation = collate_for_tests(
        cps, cps + 2, boost::text::variable_weighting::non_ignorable);

    EXPECT_EQ(collation.size(), 9);
    EXPECT_TRUE(boost::algorithm::equal(collation.begin(), collation.end(), ces, ces + 9))
        << "from:     " << ce_dumper(cps)
        << "expected: " << ce_dumper(ces)
        << "got:      " << ce_dumper(collation);
}

TEST(collation, non_ignorable_111_459)
{
    // 1DDD 003F;	
    // (·∑ù) COMBINING LATIN SMALL LETTER L	[1DDD 0267 | 0020 0020 | 0004 0002 |]

    uint32_t cps[2] = { 0x1DDD, 0x003F };
    uint32_t const ces[9] = { 0x1DDD, 0x0267, 0x0000, 0x0020, 0x0020, 0x0000, 0x0004, 0x0002, 0x0000 };

    auto collation = collate_for_tests(
        cps, cps + 2, boost::text::variable_weighting::non_ignorable);

    EXPECT_EQ(collation.size(), 9);
    EXPECT_TRUE(boost::algorithm::equal(collation.begin(), collation.end(), ces, ces + 9))
        << "from:     " << ce_dumper(cps)
        << "expected: " << ce_dumper(ces)
        << "got:      " << ce_dumper(collation);
}

TEST(collation, non_ignorable_111_460)
{
    // 217C 003F;	
    // (‚Öº) SMALL ROMAN NUMERAL FIFTY	[1DDD 0267 | 0020 0020 | 0004 0002 |]

    uint32_t cps[2] = { 0x217C, 0x003F };
    uint32_t const ces[9] = { 0x1DDD, 0x0267, 0x0000, 0x0020, 0x0020, 0x0000, 0x0004, 0x0002, 0x0000 };

    auto collation = collate_for_tests(
        cps, cps + 2, boost::text::variable_weighting::non_ignorable);

    EXPECT_EQ(collation.size(), 9);
    EXPECT_TRUE(boost::algorithm::equal(collation.begin(), collation.end(), ces, ces + 9))
        << "from:     " << ce_dumper(cps)
        << "expected: " << ce_dumper(ces)
        << "got:      " << ce_dumper(collation);
}

TEST(collation, non_ignorable_111_461)
{
    // 2113 003F;	
    // (‚Ñì) SCRIPT SMALL L	[1DDD 0267 | 0020 0020 | 0005 0002 |]

    uint32_t cps[2] = { 0x2113, 0x003F };
    uint32_t const ces[9] = { 0x1DDD, 0x0267, 0x0000, 0x0020, 0x0020, 0x0000, 0x0005, 0x0002, 0x0000 };

    auto collation = collate_for_tests(
        cps, cps + 2, boost::text::variable_weighting::non_ignorable);

    EXPECT_EQ(collation.size(), 9);
    EXPECT_TRUE(boost::algorithm::equal(collation.begin(), collation.end(), ces, ces + 9))
        << "from:     " << ce_dumper(cps)
        << "expected: " << ce_dumper(ces)
        << "got:      " << ce_dumper(collation);
}

TEST(collation, non_ignorable_111_462)
{
    // 1D425 003F;	
    // (ùê•) MATHEMATICAL BOLD SMALL L	[1DDD 0267 | 0020 0020 | 0005 0002 |]

    uint32_t cps[2] = { 0x1D425, 0x003F };
    uint32_t const ces[9] = { 0x1DDD, 0x0267, 0x0000, 0x0020, 0x0020, 0x0000, 0x0005, 0x0002, 0x0000 };

    auto collation = collate_for_tests(
        cps, cps + 2, boost::text::variable_weighting::non_ignorable);

    EXPECT_EQ(collation.size(), 9);
    EXPECT_TRUE(boost::algorithm::equal(collation.begin(), collation.end(), ces, ces + 9))
        << "from:     " << ce_dumper(cps)
        << "expected: " << ce_dumper(ces)
        << "got:      " << ce_dumper(collation);
}

TEST(collation, non_ignorable_111_463)
{
    // 1D459 003F;	
    // (ùëô) MATHEMATICAL ITALIC SMALL L	[1DDD 0267 | 0020 0020 | 0005 0002 |]

    uint32_t cps[2] = { 0x1D459, 0x003F };
    uint32_t const ces[9] = { 0x1DDD, 0x0267, 0x0000, 0x0020, 0x0020, 0x0000, 0x0005, 0x0002, 0x0000 };

    auto collation = collate_for_tests(
        cps, cps + 2, boost::text::variable_weighting::non_ignorable);

    EXPECT_EQ(collation.size(), 9);
    EXPECT_TRUE(boost::algorithm::equal(collation.begin(), collation.end(), ces, ces + 9))
        << "from:     " << ce_dumper(cps)
        << "expected: " << ce_dumper(ces)
        << "got:      " << ce_dumper(collation);
}

TEST(collation, non_ignorable_111_464)
{
    // 1D48D 003F;	
    // (ùíç) MATHEMATICAL BOLD ITALIC SMALL L	[1DDD 0267 | 0020 0020 | 0005 0002 |]

    uint32_t cps[2] = { 0x1D48D, 0x003F };
    uint32_t const ces[9] = { 0x1DDD, 0x0267, 0x0000, 0x0020, 0x0020, 0x0000, 0x0005, 0x0002, 0x0000 };

    auto collation = collate_for_tests(
        cps, cps + 2, boost::text::variable_weighting::non_ignorable);

    EXPECT_EQ(collation.size(), 9);
    EXPECT_TRUE(boost::algorithm::equal(collation.begin(), collation.end(), ces, ces + 9))
        << "from:     " << ce_dumper(cps)
        << "expected: " << ce_dumper(ces)
        << "got:      " << ce_dumper(collation);
}

TEST(collation, non_ignorable_111_465)
{
    // 1D4C1 003F;	
    // (ùìÅ) MATHEMATICAL SCRIPT SMALL L	[1DDD 0267 | 0020 0020 | 0005 0002 |]

    uint32_t cps[2] = { 0x1D4C1, 0x003F };
    uint32_t const ces[9] = { 0x1DDD, 0x0267, 0x0000, 0x0020, 0x0020, 0x0000, 0x0005, 0x0002, 0x0000 };

    auto collation = collate_for_tests(
        cps, cps + 2, boost::text::variable_weighting::non_ignorable);

    EXPECT_EQ(collation.size(), 9);
    EXPECT_TRUE(boost::algorithm::equal(collation.begin(), collation.end(), ces, ces + 9))
        << "from:     " << ce_dumper(cps)
        << "expected: " << ce_dumper(ces)
        << "got:      " << ce_dumper(collation);
}

TEST(collation, non_ignorable_111_466)
{
    // 1D4F5 003F;	
    // (ùìµ) MATHEMATICAL BOLD SCRIPT SMALL L	[1DDD 0267 | 0020 0020 | 0005 0002 |]

    uint32_t cps[2] = { 0x1D4F5, 0x003F };
    uint32_t const ces[9] = { 0x1DDD, 0x0267, 0x0000, 0x0020, 0x0020, 0x0000, 0x0005, 0x0002, 0x0000 };

    auto collation = collate_for_tests(
        cps, cps + 2, boost::text::variable_weighting::non_ignorable);

    EXPECT_EQ(collation.size(), 9);
    EXPECT_TRUE(boost::algorithm::equal(collation.begin(), collation.end(), ces, ces + 9))
        << "from:     " << ce_dumper(cps)
        << "expected: " << ce_dumper(ces)
        << "got:      " << ce_dumper(collation);
}

TEST(collation, non_ignorable_111_467)
{
    // 1D529 003F;	
    // (ùî©) MATHEMATICAL FRAKTUR SMALL L	[1DDD 0267 | 0020 0020 | 0005 0002 |]

    uint32_t cps[2] = { 0x1D529, 0x003F };
    uint32_t const ces[9] = { 0x1DDD, 0x0267, 0x0000, 0x0020, 0x0020, 0x0000, 0x0005, 0x0002, 0x0000 };

    auto collation = collate_for_tests(
        cps, cps + 2, boost::text::variable_weighting::non_ignorable);

    EXPECT_EQ(collation.size(), 9);
    EXPECT_TRUE(boost::algorithm::equal(collation.begin(), collation.end(), ces, ces + 9))
        << "from:     " << ce_dumper(cps)
        << "expected: " << ce_dumper(ces)
        << "got:      " << ce_dumper(collation);
}

TEST(collation, non_ignorable_111_468)
{
    // 1D55D 003F;	
    // (ùïù) MATHEMATICAL DOUBLE-STRUCK SMALL L	[1DDD 0267 | 0020 0020 | 0005 0002 |]

    uint32_t cps[2] = { 0x1D55D, 0x003F };
    uint32_t const ces[9] = { 0x1DDD, 0x0267, 0x0000, 0x0020, 0x0020, 0x0000, 0x0005, 0x0002, 0x0000 };

    auto collation = collate_for_tests(
        cps, cps + 2, boost::text::variable_weighting::non_ignorable);

    EXPECT_EQ(collation.size(), 9);
    EXPECT_TRUE(boost::algorithm::equal(collation.begin(), collation.end(), ces, ces + 9))
        << "from:     " << ce_dumper(cps)
        << "expected: " << ce_dumper(ces)
        << "got:      " << ce_dumper(collation);
}

TEST(collation, non_ignorable_111_469)
{
    // 1D591 003F;	
    // (ùñë) MATHEMATICAL BOLD FRAKTUR SMALL L	[1DDD 0267 | 0020 0020 | 0005 0002 |]

    uint32_t cps[2] = { 0x1D591, 0x003F };
    uint32_t const ces[9] = { 0x1DDD, 0x0267, 0x0000, 0x0020, 0x0020, 0x0000, 0x0005, 0x0002, 0x0000 };

    auto collation = collate_for_tests(
        cps, cps + 2, boost::text::variable_weighting::non_ignorable);

    EXPECT_EQ(collation.size(), 9);
    EXPECT_TRUE(boost::algorithm::equal(collation.begin(), collation.end(), ces, ces + 9))
        << "from:     " << ce_dumper(cps)
        << "expected: " << ce_dumper(ces)
        << "got:      " << ce_dumper(collation);
}

TEST(collation, non_ignorable_111_470)
{
    // 1D5C5 003F;	
    // (ùóÖ) MATHEMATICAL SANS-SERIF SMALL L	[1DDD 0267 | 0020 0020 | 0005 0002 |]

    uint32_t cps[2] = { 0x1D5C5, 0x003F };
    uint32_t const ces[9] = { 0x1DDD, 0x0267, 0x0000, 0x0020, 0x0020, 0x0000, 0x0005, 0x0002, 0x0000 };

    auto collation = collate_for_tests(
        cps, cps + 2, boost::text::variable_weighting::non_ignorable);

    EXPECT_EQ(collation.size(), 9);
    EXPECT_TRUE(boost::algorithm::equal(collation.begin(), collation.end(), ces, ces + 9))
        << "from:     " << ce_dumper(cps)
        << "expected: " << ce_dumper(ces)
        << "got:      " << ce_dumper(collation);
}

TEST(collation, non_ignorable_111_471)
{
    // 1D5F9 003F;	
    // (ùóπ) MATHEMATICAL SANS-SERIF BOLD SMALL L	[1DDD 0267 | 0020 0020 | 0005 0002 |]

    uint32_t cps[2] = { 0x1D5F9, 0x003F };
    uint32_t const ces[9] = { 0x1DDD, 0x0267, 0x0000, 0x0020, 0x0020, 0x0000, 0x0005, 0x0002, 0x0000 };

    auto collation = collate_for_tests(
        cps, cps + 2, boost::text::variable_weighting::non_ignorable);

    EXPECT_EQ(collation.size(), 9);
    EXPECT_TRUE(boost::algorithm::equal(collation.begin(), collation.end(), ces, ces + 9))
        << "from:     " << ce_dumper(cps)
        << "expected: " << ce_dumper(ces)
        << "got:      " << ce_dumper(collation);
}

TEST(collation, non_ignorable_111_472)
{
    // 1D62D 003F;	
    // (ùò≠) MATHEMATICAL SANS-SERIF ITALIC SMALL L	[1DDD 0267 | 0020 0020 | 0005 0002 |]

    uint32_t cps[2] = { 0x1D62D, 0x003F };
    uint32_t const ces[9] = { 0x1DDD, 0x0267, 0x0000, 0x0020, 0x0020, 0x0000, 0x0005, 0x0002, 0x0000 };

    auto collation = collate_for_tests(
        cps, cps + 2, boost::text::variable_weighting::non_ignorable);

    EXPECT_EQ(collation.size(), 9);
    EXPECT_TRUE(boost::algorithm::equal(collation.begin(), collation.end(), ces, ces + 9))
        << "from:     " << ce_dumper(cps)
        << "expected: " << ce_dumper(ces)
        << "got:      " << ce_dumper(collation);
}

TEST(collation, non_ignorable_111_473)
{
    // 1D661 003F;	
    // (ùô°) MATHEMATICAL SANS-SERIF BOLD ITALIC SMALL L	[1DDD 0267 | 0020 0020 | 0005 0002 |]

    uint32_t cps[2] = { 0x1D661, 0x003F };
    uint32_t const ces[9] = { 0x1DDD, 0x0267, 0x0000, 0x0020, 0x0020, 0x0000, 0x0005, 0x0002, 0x0000 };

    auto collation = collate_for_tests(
        cps, cps + 2, boost::text::variable_weighting::non_ignorable);

    EXPECT_EQ(collation.size(), 9);
    EXPECT_TRUE(boost::algorithm::equal(collation.begin(), collation.end(), ces, ces + 9))
        << "from:     " << ce_dumper(cps)
        << "expected: " << ce_dumper(ces)
        << "got:      " << ce_dumper(collation);
}

TEST(collation, non_ignorable_111_474)
{
    // 1D695 003F;	
    // (ùöï) MATHEMATICAL MONOSPACE SMALL L	[1DDD 0267 | 0020 0020 | 0005 0002 |]

    uint32_t cps[2] = { 0x1D695, 0x003F };
    uint32_t const ces[9] = { 0x1DDD, 0x0267, 0x0000, 0x0020, 0x0020, 0x0000, 0x0005, 0x0002, 0x0000 };

    auto collation = collate_for_tests(
        cps, cps + 2, boost::text::variable_weighting::non_ignorable);

    EXPECT_EQ(collation.size(), 9);
    EXPECT_TRUE(boost::algorithm::equal(collation.begin(), collation.end(), ces, ces + 9))
        << "from:     " << ce_dumper(cps)
        << "expected: " << ce_dumper(ces)
        << "got:      " << ce_dumper(collation);
}

TEST(collation, non_ignorable_111_475)
{
    // 24DB 003F;	
    // (‚ìõ) CIRCLED LATIN SMALL LETTER L	[1DDD 0267 | 0020 0020 | 0006 0002 |]

    uint32_t cps[2] = { 0x24DB, 0x003F };
    uint32_t const ces[9] = { 0x1DDD, 0x0267, 0x0000, 0x0020, 0x0020, 0x0000, 0x0006, 0x0002, 0x0000 };

    auto collation = collate_for_tests(
        cps, cps + 2, boost::text::variable_weighting::non_ignorable);

    EXPECT_EQ(collation.size(), 9);
    EXPECT_TRUE(boost::algorithm::equal(collation.begin(), collation.end(), ces, ces + 9))
        << "from:     " << ce_dumper(cps)
        << "expected: " << ce_dumper(ces)
        << "got:      " << ce_dumper(collation);
}

TEST(collation, non_ignorable_111_476)
{
    // 004C 003F;	
    // (L) LATIN CAPITAL LETTER L	[1DDD 0267 | 0020 0020 | 0008 0002 |]

    uint32_t cps[2] = { 0x004C, 0x003F };
    uint32_t const ces[9] = { 0x1DDD, 0x0267, 0x0000, 0x0020, 0x0020, 0x0000, 0x0008, 0x0002, 0x0000 };

    auto collation = collate_for_tests(
        cps, cps + 2, boost::text::variable_weighting::non_ignorable);

    EXPECT_EQ(collation.size(), 9);
    EXPECT_TRUE(boost::algorithm::equal(collation.begin(), collation.end(), ces, ces + 9))
        << "from:     " << ce_dumper(cps)
        << "expected: " << ce_dumper(ces)
        << "got:      " << ce_dumper(collation);
}

TEST(collation, non_ignorable_111_477)
{
    // FF2C 003F;	
    // (Ôº¨) FULLWIDTH LATIN CAPITAL LETTER L	[1DDD 0267 | 0020 0020 | 0009 0002 |]

    uint32_t cps[2] = { 0xFF2C, 0x003F };
    uint32_t const ces[9] = { 0x1DDD, 0x0267, 0x0000, 0x0020, 0x0020, 0x0000, 0x0009, 0x0002, 0x0000 };

    auto collation = collate_for_tests(
        cps, cps + 2, boost::text::variable_weighting::non_ignorable);

    EXPECT_EQ(collation.size(), 9);
    EXPECT_TRUE(boost::algorithm::equal(collation.begin(), collation.end(), ces, ces + 9))
        << "from:     " << ce_dumper(cps)
        << "expected: " << ce_dumper(ces)
        << "got:      " << ce_dumper(collation);
}

TEST(collation, non_ignorable_111_478)
{
    // 216C 003F;	
    // (‚Ö¨) ROMAN NUMERAL FIFTY	[1DDD 0267 | 0020 0020 | 000A 0002 |]

    uint32_t cps[2] = { 0x216C, 0x003F };
    uint32_t const ces[9] = { 0x1DDD, 0x0267, 0x0000, 0x0020, 0x0020, 0x0000, 0x000A, 0x0002, 0x0000 };

    auto collation = collate_for_tests(
        cps, cps + 2, boost::text::variable_weighting::non_ignorable);

    EXPECT_EQ(collation.size(), 9);
    EXPECT_TRUE(boost::algorithm::equal(collation.begin(), collation.end(), ces, ces + 9))
        << "from:     " << ce_dumper(cps)
        << "expected: " << ce_dumper(ces)
        << "got:      " << ce_dumper(collation);
}

TEST(collation, non_ignorable_111_479)
{
    // 2112 003F;	
    // (‚Ñí) SCRIPT CAPITAL L	[1DDD 0267 | 0020 0020 | 000B 0002 |]

    uint32_t cps[2] = { 0x2112, 0x003F };
    uint32_t const ces[9] = { 0x1DDD, 0x0267, 0x0000, 0x0020, 0x0020, 0x0000, 0x000B, 0x0002, 0x0000 };

    auto collation = collate_for_tests(
        cps, cps + 2, boost::text::variable_weighting::non_ignorable);

    EXPECT_EQ(collation.size(), 9);
    EXPECT_TRUE(boost::algorithm::equal(collation.begin(), collation.end(), ces, ces + 9))
        << "from:     " << ce_dumper(cps)
        << "expected: " << ce_dumper(ces)
        << "got:      " << ce_dumper(collation);
}

TEST(collation, non_ignorable_111_480)
{
    // 1D40B 003F;	
    // (ùêã) MATHEMATICAL BOLD CAPITAL L	[1DDD 0267 | 0020 0020 | 000B 0002 |]

    uint32_t cps[2] = { 0x1D40B, 0x003F };
    uint32_t const ces[9] = { 0x1DDD, 0x0267, 0x0000, 0x0020, 0x0020, 0x0000, 0x000B, 0x0002, 0x0000 };

    auto collation = collate_for_tests(
        cps, cps + 2, boost::text::variable_weighting::non_ignorable);

    EXPECT_EQ(collation.size(), 9);
    EXPECT_TRUE(boost::algorithm::equal(collation.begin(), collation.end(), ces, ces + 9))
        << "from:     " << ce_dumper(cps)
        << "expected: " << ce_dumper(ces)
        << "got:      " << ce_dumper(collation);
}

TEST(collation, non_ignorable_111_481)
{
    // 1D43F 003F;	
    // (ùêø) MATHEMATICAL ITALIC CAPITAL L	[1DDD 0267 | 0020 0020 | 000B 0002 |]

    uint32_t cps[2] = { 0x1D43F, 0x003F };
    uint32_t const ces[9] = { 0x1DDD, 0x0267, 0x0000, 0x0020, 0x0020, 0x0000, 0x000B, 0x0002, 0x0000 };

    auto collation = collate_for_tests(
        cps, cps + 2, boost::text::variable_weighting::non_ignorable);

    EXPECT_EQ(collation.size(), 9);
    EXPECT_TRUE(boost::algorithm::equal(collation.begin(), collation.end(), ces, ces + 9))
        << "from:     " << ce_dumper(cps)
        << "expected: " << ce_dumper(ces)
        << "got:      " << ce_dumper(collation);
}

TEST(collation, non_ignorable_111_482)
{
    // 1D473 003F;	
    // (ùë≥) MATHEMATICAL BOLD ITALIC CAPITAL L	[1DDD 0267 | 0020 0020 | 000B 0002 |]

    uint32_t cps[2] = { 0x1D473, 0x003F };
    uint32_t const ces[9] = { 0x1DDD, 0x0267, 0x0000, 0x0020, 0x0020, 0x0000, 0x000B, 0x0002, 0x0000 };

    auto collation = collate_for_tests(
        cps, cps + 2, boost::text::variable_weighting::non_ignorable);

    EXPECT_EQ(collation.size(), 9);
    EXPECT_TRUE(boost::algorithm::equal(collation.begin(), collation.end(), ces, ces + 9))
        << "from:     " << ce_dumper(cps)
        << "expected: " << ce_dumper(ces)
        << "got:      " << ce_dumper(collation);
}

TEST(collation, non_ignorable_111_483)
{
    // 1D4DB 003F;	
    // (ùìõ) MATHEMATICAL BOLD SCRIPT CAPITAL L	[1DDD 0267 | 0020 0020 | 000B 0002 |]

    uint32_t cps[2] = { 0x1D4DB, 0x003F };
    uint32_t const ces[9] = { 0x1DDD, 0x0267, 0x0000, 0x0020, 0x0020, 0x0000, 0x000B, 0x0002, 0x0000 };

    auto collation = collate_for_tests(
        cps, cps + 2, boost::text::variable_weighting::non_ignorable);

    EXPECT_EQ(collation.size(), 9);
    EXPECT_TRUE(boost::algorithm::equal(collation.begin(), collation.end(), ces, ces + 9))
        << "from:     " << ce_dumper(cps)
        << "expected: " << ce_dumper(ces)
        << "got:      " << ce_dumper(collation);
}

TEST(collation, non_ignorable_111_484)
{
    // 1D50F 003F;	
    // (ùîè) MATHEMATICAL FRAKTUR CAPITAL L	[1DDD 0267 | 0020 0020 | 000B 0002 |]

    uint32_t cps[2] = { 0x1D50F, 0x003F };
    uint32_t const ces[9] = { 0x1DDD, 0x0267, 0x0000, 0x0020, 0x0020, 0x0000, 0x000B, 0x0002, 0x0000 };

    auto collation = collate_for_tests(
        cps, cps + 2, boost::text::variable_weighting::non_ignorable);

    EXPECT_EQ(collation.size(), 9);
    EXPECT_TRUE(boost::algorithm::equal(collation.begin(), collation.end(), ces, ces + 9))
        << "from:     " << ce_dumper(cps)
        << "expected: " << ce_dumper(ces)
        << "got:      " << ce_dumper(collation);
}

TEST(collation, non_ignorable_111_485)
{
    // 1D543 003F;	
    // (ùïÉ) MATHEMATICAL DOUBLE-STRUCK CAPITAL L	[1DDD 0267 | 0020 0020 | 000B 0002 |]

    uint32_t cps[2] = { 0x1D543, 0x003F };
    uint32_t const ces[9] = { 0x1DDD, 0x0267, 0x0000, 0x0020, 0x0020, 0x0000, 0x000B, 0x0002, 0x0000 };

    auto collation = collate_for_tests(
        cps, cps + 2, boost::text::variable_weighting::non_ignorable);

    EXPECT_EQ(collation.size(), 9);
    EXPECT_TRUE(boost::algorithm::equal(collation.begin(), collation.end(), ces, ces + 9))
        << "from:     " << ce_dumper(cps)
        << "expected: " << ce_dumper(ces)
        << "got:      " << ce_dumper(collation);
}

TEST(collation, non_ignorable_111_486)
{
    // 1D577 003F;	
    // (ùï∑) MATHEMATICAL BOLD FRAKTUR CAPITAL L	[1DDD 0267 | 0020 0020 | 000B 0002 |]

    uint32_t cps[2] = { 0x1D577, 0x003F };
    uint32_t const ces[9] = { 0x1DDD, 0x0267, 0x0000, 0x0020, 0x0020, 0x0000, 0x000B, 0x0002, 0x0000 };

    auto collation = collate_for_tests(
        cps, cps + 2, boost::text::variable_weighting::non_ignorable);

    EXPECT_EQ(collation.size(), 9);
    EXPECT_TRUE(boost::algorithm::equal(collation.begin(), collation.end(), ces, ces + 9))
        << "from:     " << ce_dumper(cps)
        << "expected: " << ce_dumper(ces)
        << "got:      " << ce_dumper(collation);
}

TEST(collation, non_ignorable_111_487)
{
    // 1D5AB 003F;	
    // (ùñ´) MATHEMATICAL SANS-SERIF CAPITAL L	[1DDD 0267 | 0020 0020 | 000B 0002 |]

    uint32_t cps[2] = { 0x1D5AB, 0x003F };
    uint32_t const ces[9] = { 0x1DDD, 0x0267, 0x0000, 0x0020, 0x0020, 0x0000, 0x000B, 0x0002, 0x0000 };

    auto collation = collate_for_tests(
        cps, cps + 2, boost::text::variable_weighting::non_ignorable);

    EXPECT_EQ(collation.size(), 9);
    EXPECT_TRUE(boost::algorithm::equal(collation.begin(), collation.end(), ces, ces + 9))
        << "from:     " << ce_dumper(cps)
        << "expected: " << ce_dumper(ces)
        << "got:      " << ce_dumper(collation);
}

TEST(collation, non_ignorable_111_488)
{
    // 1D5DF 003F;	
    // (ùóü) MATHEMATICAL SANS-SERIF BOLD CAPITAL L	[1DDD 0267 | 0020 0020 | 000B 0002 |]

    uint32_t cps[2] = { 0x1D5DF, 0x003F };
    uint32_t const ces[9] = { 0x1DDD, 0x0267, 0x0000, 0x0020, 0x0020, 0x0000, 0x000B, 0x0002, 0x0000 };

    auto collation = collate_for_tests(
        cps, cps + 2, boost::text::variable_weighting::non_ignorable);

    EXPECT_EQ(collation.size(), 9);
    EXPECT_TRUE(boost::algorithm::equal(collation.begin(), collation.end(), ces, ces + 9))
        << "from:     " << ce_dumper(cps)
        << "expected: " << ce_dumper(ces)
        << "got:      " << ce_dumper(collation);
}

TEST(collation, non_ignorable_111_489)
{
    // 1D613 003F;	
    // (ùòì) MATHEMATICAL SANS-SERIF ITALIC CAPITAL L	[1DDD 0267 | 0020 0020 | 000B 0002 |]

    uint32_t cps[2] = { 0x1D613, 0x003F };
    uint32_t const ces[9] = { 0x1DDD, 0x0267, 0x0000, 0x0020, 0x0020, 0x0000, 0x000B, 0x0002, 0x0000 };

    auto collation = collate_for_tests(
        cps, cps + 2, boost::text::variable_weighting::non_ignorable);

    EXPECT_EQ(collation.size(), 9);
    EXPECT_TRUE(boost::algorithm::equal(collation.begin(), collation.end(), ces, ces + 9))
        << "from:     " << ce_dumper(cps)
        << "expected: " << ce_dumper(ces)
        << "got:      " << ce_dumper(collation);
}

TEST(collation, non_ignorable_111_490)
{
    // 1D647 003F;	
    // (ùôá) MATHEMATICAL SANS-SERIF BOLD ITALIC CAPITAL L	[1DDD 0267 | 0020 0020 | 000B 0002 |]

    uint32_t cps[2] = { 0x1D647, 0x003F };
    uint32_t const ces[9] = { 0x1DDD, 0x0267, 0x0000, 0x0020, 0x0020, 0x0000, 0x000B, 0x0002, 0x0000 };

    auto collation = collate_for_tests(
        cps, cps + 2, boost::text::variable_weighting::non_ignorable);

    EXPECT_EQ(collation.size(), 9);
    EXPECT_TRUE(boost::algorithm::equal(collation.begin(), collation.end(), ces, ces + 9))
        << "from:     " << ce_dumper(cps)
        << "expected: " << ce_dumper(ces)
        << "got:      " << ce_dumper(collation);
}

TEST(collation, non_ignorable_111_491)
{
    // 1D67B 003F;	
    // (ùôª) MATHEMATICAL MONOSPACE CAPITAL L	[1DDD 0267 | 0020 0020 | 000B 0002 |]

    uint32_t cps[2] = { 0x1D67B, 0x003F };
    uint32_t const ces[9] = { 0x1DDD, 0x0267, 0x0000, 0x0020, 0x0020, 0x0000, 0x000B, 0x0002, 0x0000 };

    auto collation = collate_for_tests(
        cps, cps + 2, boost::text::variable_weighting::non_ignorable);

    EXPECT_EQ(collation.size(), 9);
    EXPECT_TRUE(boost::algorithm::equal(collation.begin(), collation.end(), ces, ces + 9))
        << "from:     " << ce_dumper(cps)
        << "expected: " << ce_dumper(ces)
        << "got:      " << ce_dumper(collation);
}

TEST(collation, non_ignorable_111_492)
{
    // 24C1 003F;	
    // (‚ìÅ) CIRCLED LATIN CAPITAL LETTER L	[1DDD 0267 | 0020 0020 | 000C 0002 |]

    uint32_t cps[2] = { 0x24C1, 0x003F };
    uint32_t const ces[9] = { 0x1DDD, 0x0267, 0x0000, 0x0020, 0x0020, 0x0000, 0x000C, 0x0002, 0x0000 };

    auto collation = collate_for_tests(
        cps, cps + 2, boost::text::variable_weighting::non_ignorable);

    EXPECT_EQ(collation.size(), 9);
    EXPECT_TRUE(boost::algorithm::equal(collation.begin(), collation.end(), ces, ces + 9))
        << "from:     " << ce_dumper(cps)
        << "expected: " << ce_dumper(ces)
        << "got:      " << ce_dumper(collation);
}

TEST(collation, non_ignorable_111_493)
{
    // 1F15B 003F;	
    // (üÖõ) NEGATIVE CIRCLED LATIN CAPITAL LETTER L	[1DDD 0267 | 0020 0020 | 000C 0002 |]

    uint32_t cps[2] = { 0x1F15B, 0x003F };
    uint32_t const ces[9] = { 0x1DDD, 0x0267, 0x0000, 0x0020, 0x0020, 0x0000, 0x000C, 0x0002, 0x0000 };

    auto collation = collate_for_tests(
        cps, cps + 2, boost::text::variable_weighting::non_ignorable);

    EXPECT_EQ(collation.size(), 9);
    EXPECT_TRUE(boost::algorithm::equal(collation.begin(), collation.end(), ces, ces + 9))
        << "from:     " << ce_dumper(cps)
        << "expected: " << ce_dumper(ces)
        << "got:      " << ce_dumper(collation);
}

TEST(collation, non_ignorable_111_494)
{
    // 02E1 003F;	
    // (À°) MODIFIER LETTER SMALL L	[1DDD 0267 | 0020 0020 | 0014 0002 |]

    uint32_t cps[2] = { 0x02E1, 0x003F };
    uint32_t const ces[9] = { 0x1DDD, 0x0267, 0x0000, 0x0020, 0x0020, 0x0000, 0x0014, 0x0002, 0x0000 };

    auto collation = collate_for_tests(
        cps, cps + 2, boost::text::variable_weighting::non_ignorable);

    EXPECT_EQ(collation.size(), 9);
    EXPECT_TRUE(boost::algorithm::equal(collation.begin(), collation.end(), ces, ces + 9))
        << "from:     " << ce_dumper(cps)
        << "expected: " << ce_dumper(ces)
        << "got:      " << ce_dumper(collation);
}

TEST(collation, non_ignorable_111_495)
{
    // 2097 003F;	
    // (‚Çó) LATIN SUBSCRIPT SMALL LETTER L	[1DDD 0267 | 0020 0020 | 0015 0002 |]

    uint32_t cps[2] = { 0x2097, 0x003F };
    uint32_t const ces[9] = { 0x1DDD, 0x0267, 0x0000, 0x0020, 0x0020, 0x0000, 0x0015, 0x0002, 0x0000 };

    auto collation = collate_for_tests(
        cps, cps + 2, boost::text::variable_weighting::non_ignorable);

    EXPECT_EQ(collation.size(), 9);
    EXPECT_TRUE(boost::algorithm::equal(collation.begin(), collation.end(), ces, ces + 9))
        << "from:     " << ce_dumper(cps)
        << "expected: " << ce_dumper(ces)
        << "got:      " << ce_dumper(collation);
}

TEST(collation, non_ignorable_111_496)
{
    // 1D38 003F;	
    // (·¥∏) MODIFIER LETTER CAPITAL L	[1DDD 0267 | 0020 0020 | 001D 0002 |]

    uint32_t cps[2] = { 0x1D38, 0x003F };
    uint32_t const ces[9] = { 0x1DDD, 0x0267, 0x0000, 0x0020, 0x0020, 0x0000, 0x001D, 0x0002, 0x0000 };

    auto collation = collate_for_tests(
        cps, cps + 2, boost::text::variable_weighting::non_ignorable);

    EXPECT_EQ(collation.size(), 9);
    EXPECT_TRUE(boost::algorithm::equal(collation.begin(), collation.end(), ces, ces + 9))
        << "from:     " << ce_dumper(cps)
        << "expected: " << ce_dumper(ces)
        << "got:      " << ce_dumper(collation);
}

TEST(collation, non_ignorable_111_497)
{
    // 1F13B 003F;	
    // (üÑª) SQUARED LATIN CAPITAL LETTER L	[1DDD 0267 | 0020 0020 | 001D 0002 |]

    uint32_t cps[2] = { 0x1F13B, 0x003F };
    uint32_t const ces[9] = { 0x1DDD, 0x0267, 0x0000, 0x0020, 0x0020, 0x0000, 0x001D, 0x0002, 0x0000 };

    auto collation = collate_for_tests(
        cps, cps + 2, boost::text::variable_weighting::non_ignorable);

    EXPECT_EQ(collation.size(), 9);
    EXPECT_TRUE(boost::algorithm::equal(collation.begin(), collation.end(), ces, ces + 9))
        << "from:     " << ce_dumper(cps)
        << "expected: " << ce_dumper(ces)
        << "got:      " << ce_dumper(collation);
}

TEST(collation, non_ignorable_111_498)
{
    // 1F17B 003F;	
    // (üÖª) NEGATIVE SQUARED LATIN CAPITAL LETTER L	[1DDD 0267 | 0020 0020 | 001D 0002 |]

    uint32_t cps[2] = { 0x1F17B, 0x003F };
    uint32_t const ces[9] = { 0x1DDD, 0x0267, 0x0000, 0x0020, 0x0020, 0x0000, 0x001D, 0x0002, 0x0000 };

    auto collation = collate_for_tests(
        cps, cps + 2, boost::text::variable_weighting::non_ignorable);

    EXPECT_EQ(collation.size(), 9);
    EXPECT_TRUE(boost::algorithm::equal(collation.begin(), collation.end(), ces, ces + 9))
        << "from:     " << ce_dumper(cps)
        << "expected: " << ce_dumper(ces)
        << "got:      " << ce_dumper(collation);
}

TEST(collation, non_ignorable_111_499)
{
    // 013A 003F;	
    // (ƒ∫) LATIN SMALL LETTER L WITH ACUTE	[1DDD 0267 | 0020 0024 0020 | 0002 0002 0002 |]

    uint32_t cps[2] = { 0x013A, 0x003F };
    uint32_t const ces[11] = { 0x1DDD, 0x0267, 0x0000, 0x0020, 0x0024, 0x0020, 0x0000, 0x0002, 0x0002, 0x0002, 0x0000 };

    auto collation = collate_for_tests(
        cps, cps + 2, boost::text::variable_weighting::non_ignorable);

    EXPECT_EQ(collation.size(), 11);
    EXPECT_TRUE(boost::algorithm::equal(collation.begin(), collation.end(), ces, ces + 11))
        << "from:     " << ce_dumper(cps)
        << "expected: " << ce_dumper(ces)
        << "got:      " << ce_dumper(collation);
}

