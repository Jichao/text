// Warning! This file is autogenerated.
#include "collation_tests.hpp"

#include <boost/algorithm/cxx14/equal.hpp>

#include <gtest/gtest.h>



TEST(collation, verbatim_131_000)
{
    uint32_t const cps[2] = { 0x03CA, 0x0334 };

    // 03CA 0334;	
    // (ϊ) GREEK SMALL LETTER IOTA WITH DIALYTIKA	[202C | 0020 004A 002B | 0002 0002 0002 |]
    uint32_t const ces_non_ignorable[10] = { 0x202C, 0x0000, 0x0020, 0x004A, 0x002B, 0x0000, 0x0002, 0x0002, 0x0002, 0x0000 };

    auto const non_ignorable = collate_for_tests(
        cps, cps + 2, boost::text::variable_weighting::non_ignorable);

    EXPECT_EQ(non_ignorable.size(), 10);
    EXPECT_TRUE(boost::algorithm::equal(non_ignorable.begin(), non_ignorable.end(), ces_non_ignorable, ces_non_ignorable + 10))
        << "from:     " << ce_dumper(cps)
        << "expected: " << ce_dumper(ces_non_ignorable)
        << "got:      " << ce_dumper(non_ignorable);

    // 03CA 0334;	
    // (ϊ) GREEK SMALL LETTER IOTA WITH DIALYTIKA	[202C | 0020 004A 002B | 0002 0002 0002 | FFFF FFFF FFFF |]
    uint32_t const ces_shifted[14] = { 0x202C, 0x0000, 0x0020, 0x004A, 0x002B, 0x0000, 0x0002, 0x0002, 0x0002, 0x0000, 0xFFFF, 0xFFFF, 0xFFFF, 0x0000 };

    auto const shifted = collate_for_tests(
        cps, cps + 2, boost::text::variable_weighting::shifted);

    EXPECT_EQ(shifted.size(), 14);
    EXPECT_TRUE(boost::algorithm::equal(shifted.begin(), shifted.end(), ces_shifted, ces_shifted + 14))
        << "from:     " << ce_dumper(cps)
        << "expected: " << ce_dumper(ces_shifted)
        << "got:      " << ce_dumper(shifted);
}

TEST(collation, verbatim_131_001)
{
    uint32_t const cps[3] = { 0x1FBE, 0x0334, 0x0308 };

    // 1FBE 0334 0308;	
    // (ι̴) GREEK PROSGEGRAMMENI, COMBINING TILDE OVERLAY	[202C | 0020 004A 002B | 0002 0002 0002 |]
    uint32_t const ces_non_ignorable[10] = { 0x202C, 0x0000, 0x0020, 0x004A, 0x002B, 0x0000, 0x0002, 0x0002, 0x0002, 0x0000 };

    auto const non_ignorable = collate_for_tests(
        cps, cps + 3, boost::text::variable_weighting::non_ignorable);

    EXPECT_EQ(non_ignorable.size(), 10);
    EXPECT_TRUE(boost::algorithm::equal(non_ignorable.begin(), non_ignorable.end(), ces_non_ignorable, ces_non_ignorable + 10))
        << "from:     " << ce_dumper(cps)
        << "expected: " << ce_dumper(ces_non_ignorable)
        << "got:      " << ce_dumper(non_ignorable);

    // 1FBE 0334 0308;	
    // (ι̴) GREEK PROSGEGRAMMENI, COMBINING TILDE OVERLAY	[202C | 0020 004A 002B | 0002 0002 0002 | FFFF FFFF FFFF |]
    uint32_t const ces_shifted[14] = { 0x202C, 0x0000, 0x0020, 0x004A, 0x002B, 0x0000, 0x0002, 0x0002, 0x0002, 0x0000, 0xFFFF, 0xFFFF, 0xFFFF, 0x0000 };

    auto const shifted = collate_for_tests(
        cps, cps + 3, boost::text::variable_weighting::shifted);

    EXPECT_EQ(shifted.size(), 14);
    EXPECT_TRUE(boost::algorithm::equal(shifted.begin(), shifted.end(), ces_shifted, ces_shifted + 14))
        << "from:     " << ce_dumper(cps)
        << "expected: " << ce_dumper(ces_shifted)
        << "got:      " << ce_dumper(shifted);
}

TEST(collation, verbatim_131_002)
{
    uint32_t const cps[3] = { 0x0399, 0x0308, 0x0334 };

    // 0399 0308 0334;	
    // (Ϊ) GREEK CAPITAL LETTER IOTA, COMBINING DIAERESIS	[202C | 0020 004A 002B | 0008 0002 0002 |]
    uint32_t const ces_non_ignorable[10] = { 0x202C, 0x0000, 0x0020, 0x004A, 0x002B, 0x0000, 0x0008, 0x0002, 0x0002, 0x0000 };

    auto const non_ignorable = collate_for_tests(
        cps, cps + 3, boost::text::variable_weighting::non_ignorable);

    EXPECT_EQ(non_ignorable.size(), 10);
    EXPECT_TRUE(boost::algorithm::equal(non_ignorable.begin(), non_ignorable.end(), ces_non_ignorable, ces_non_ignorable + 10))
        << "from:     " << ce_dumper(cps)
        << "expected: " << ce_dumper(ces_non_ignorable)
        << "got:      " << ce_dumper(non_ignorable);

    // 0399 0308 0334;	
    // (Ϊ) GREEK CAPITAL LETTER IOTA, COMBINING DIAERESIS	[202C | 0020 004A 002B | 0008 0002 0002 | FFFF FFFF FFFF |]
    uint32_t const ces_shifted[14] = { 0x202C, 0x0000, 0x0020, 0x004A, 0x002B, 0x0000, 0x0008, 0x0002, 0x0002, 0x0000, 0xFFFF, 0xFFFF, 0xFFFF, 0x0000 };

    auto const shifted = collate_for_tests(
        cps, cps + 3, boost::text::variable_weighting::shifted);

    EXPECT_EQ(shifted.size(), 14);
    EXPECT_TRUE(boost::algorithm::equal(shifted.begin(), shifted.end(), ces_shifted, ces_shifted + 14))
        << "from:     " << ce_dumper(cps)
        << "expected: " << ce_dumper(ces_shifted)
        << "got:      " << ce_dumper(shifted);
}

TEST(collation, verbatim_131_003)
{
    uint32_t const cps[3] = { 0x0399, 0x0334, 0x0308 };

    // 0399 0334 0308;	
    // (Ι̴) GREEK CAPITAL LETTER IOTA, COMBINING TILDE OVERLAY	[202C | 0020 004A 002B | 0008 0002 0002 |]
    uint32_t const ces_non_ignorable[10] = { 0x202C, 0x0000, 0x0020, 0x004A, 0x002B, 0x0000, 0x0008, 0x0002, 0x0002, 0x0000 };

    auto const non_ignorable = collate_for_tests(
        cps, cps + 3, boost::text::variable_weighting::non_ignorable);

    EXPECT_EQ(non_ignorable.size(), 10);
    EXPECT_TRUE(boost::algorithm::equal(non_ignorable.begin(), non_ignorable.end(), ces_non_ignorable, ces_non_ignorable + 10))
        << "from:     " << ce_dumper(cps)
        << "expected: " << ce_dumper(ces_non_ignorable)
        << "got:      " << ce_dumper(non_ignorable);

    // 0399 0334 0308;	
    // (Ι̴) GREEK CAPITAL LETTER IOTA, COMBINING TILDE OVERLAY	[202C | 0020 004A 002B | 0008 0002 0002 | FFFF FFFF FFFF |]
    uint32_t const ces_shifted[14] = { 0x202C, 0x0000, 0x0020, 0x004A, 0x002B, 0x0000, 0x0008, 0x0002, 0x0002, 0x0000, 0xFFFF, 0xFFFF, 0xFFFF, 0x0000 };

    auto const shifted = collate_for_tests(
        cps, cps + 3, boost::text::variable_weighting::shifted);

    EXPECT_EQ(shifted.size(), 14);
    EXPECT_TRUE(boost::algorithm::equal(shifted.begin(), shifted.end(), ces_shifted, ces_shifted + 14))
        << "from:     " << ce_dumper(cps)
        << "expected: " << ce_dumper(ces_shifted)
        << "got:      " << ce_dumper(shifted);
}

TEST(collation, verbatim_131_004)
{
    uint32_t const cps[2] = { 0x03AA, 0x0334 };

    // 03AA 0334;	
    // (Ϊ) GREEK CAPITAL LETTER IOTA WITH DIALYTIKA	[202C | 0020 004A 002B | 0008 0002 0002 |]
    uint32_t const ces_non_ignorable[10] = { 0x202C, 0x0000, 0x0020, 0x004A, 0x002B, 0x0000, 0x0008, 0x0002, 0x0002, 0x0000 };

    auto const non_ignorable = collate_for_tests(
        cps, cps + 2, boost::text::variable_weighting::non_ignorable);

    EXPECT_EQ(non_ignorable.size(), 10);
    EXPECT_TRUE(boost::algorithm::equal(non_ignorable.begin(), non_ignorable.end(), ces_non_ignorable, ces_non_ignorable + 10))
        << "from:     " << ce_dumper(cps)
        << "expected: " << ce_dumper(ces_non_ignorable)
        << "got:      " << ce_dumper(non_ignorable);

    // 03AA 0334;	
    // (Ϊ) GREEK CAPITAL LETTER IOTA WITH DIALYTIKA	[202C | 0020 004A 002B | 0008 0002 0002 | FFFF FFFF FFFF |]
    uint32_t const ces_shifted[14] = { 0x202C, 0x0000, 0x0020, 0x004A, 0x002B, 0x0000, 0x0008, 0x0002, 0x0002, 0x0000, 0xFFFF, 0xFFFF, 0xFFFF, 0x0000 };

    auto const shifted = collate_for_tests(
        cps, cps + 2, boost::text::variable_weighting::shifted);

    EXPECT_EQ(shifted.size(), 14);
    EXPECT_TRUE(boost::algorithm::equal(shifted.begin(), shifted.end(), ces_shifted, ces_shifted + 14))
        << "from:     " << ce_dumper(cps)
        << "expected: " << ce_dumper(ces_shifted)
        << "got:      " << ce_dumper(shifted);
}

TEST(collation, verbatim_131_005)
{
    uint32_t const cps[2] = { 0x0390, 0x0334 };

    // 0390 0334;	
    // (ΐ) GREEK SMALL LETTER IOTA WITH DIALYTIKA AND TONOS	[202C | 0020 004A 002B 0024 | 0002 0002 0002 0002 |]
    uint32_t const ces_non_ignorable[12] = { 0x202C, 0x0000, 0x0020, 0x004A, 0x002B, 0x0024, 0x0000, 0x0002, 0x0002, 0x0002, 0x0002, 0x0000 };

    auto const non_ignorable = collate_for_tests(
        cps, cps + 2, boost::text::variable_weighting::non_ignorable);

    EXPECT_EQ(non_ignorable.size(), 12);
    EXPECT_TRUE(boost::algorithm::equal(non_ignorable.begin(), non_ignorable.end(), ces_non_ignorable, ces_non_ignorable + 12))
        << "from:     " << ce_dumper(cps)
        << "expected: " << ce_dumper(ces_non_ignorable)
        << "got:      " << ce_dumper(non_ignorable);

    // 0390 0334;	
    // (ΐ) GREEK SMALL LETTER IOTA WITH DIALYTIKA AND TONOS	[202C | 0020 004A 002B 0024 | 0002 0002 0002 0002 | FFFF FFFF FFFF FFFF |]
    uint32_t const ces_shifted[17] = { 0x202C, 0x0000, 0x0020, 0x004A, 0x002B, 0x0024, 0x0000, 0x0002, 0x0002, 0x0002, 0x0002, 0x0000, 0xFFFF, 0xFFFF, 0xFFFF, 0xFFFF, 0x0000 };

    auto const shifted = collate_for_tests(
        cps, cps + 2, boost::text::variable_weighting::shifted);

    EXPECT_EQ(shifted.size(), 17);
    EXPECT_TRUE(boost::algorithm::equal(shifted.begin(), shifted.end(), ces_shifted, ces_shifted + 17))
        << "from:     " << ce_dumper(cps)
        << "expected: " << ce_dumper(ces_shifted)
        << "got:      " << ce_dumper(shifted);
}

TEST(collation, verbatim_131_006)
{
    uint32_t const cps[4] = { 0x03B9, 0x0308, 0x0334, 0x0301 };

    // 03B9 0308 0334 0301;	
    // (ϊ̴) GREEK SMALL LETTER IOTA, COMBINING DIAERESIS, COMBINING TILDE OVERLAY	[202C | 0020 004A 002B 0024 | 0002 0002 0002 0002 |]
    uint32_t const ces_non_ignorable[12] = { 0x202C, 0x0000, 0x0020, 0x004A, 0x002B, 0x0024, 0x0000, 0x0002, 0x0002, 0x0002, 0x0002, 0x0000 };

    auto const non_ignorable = collate_for_tests(
        cps, cps + 4, boost::text::variable_weighting::non_ignorable);

    EXPECT_EQ(non_ignorable.size(), 12);
    EXPECT_TRUE(boost::algorithm::equal(non_ignorable.begin(), non_ignorable.end(), ces_non_ignorable, ces_non_ignorable + 12))
        << "from:     " << ce_dumper(cps)
        << "expected: " << ce_dumper(ces_non_ignorable)
        << "got:      " << ce_dumper(non_ignorable);

    // 03B9 0308 0334 0301;	
    // (ϊ̴) GREEK SMALL LETTER IOTA, COMBINING DIAERESIS, COMBINING TILDE OVERLAY	[202C | 0020 004A 002B 0024 | 0002 0002 0002 0002 | FFFF FFFF FFFF FFFF |]
    uint32_t const ces_shifted[17] = { 0x202C, 0x0000, 0x0020, 0x004A, 0x002B, 0x0024, 0x0000, 0x0002, 0x0002, 0x0002, 0x0002, 0x0000, 0xFFFF, 0xFFFF, 0xFFFF, 0xFFFF, 0x0000 };

    auto const shifted = collate_for_tests(
        cps, cps + 4, boost::text::variable_weighting::shifted);

    EXPECT_EQ(shifted.size(), 17);
    EXPECT_TRUE(boost::algorithm::equal(shifted.begin(), shifted.end(), ces_shifted, ces_shifted + 17))
        << "from:     " << ce_dumper(cps)
        << "expected: " << ce_dumper(ces_shifted)
        << "got:      " << ce_dumper(shifted);
}

TEST(collation, verbatim_131_007)
{
    uint32_t const cps[4] = { 0x03B9, 0x0308, 0x0334, 0x0341 };

    // 03B9 0308 0334 0341;	
    // (ϊ̴) GREEK SMALL LETTER IOTA, COMBINING DIAERESIS, COMBINING TILDE OVERLAY	[202C | 0020 004A 002B 0024 | 0002 0002 0002 0002 |]
    uint32_t const ces_non_ignorable[12] = { 0x202C, 0x0000, 0x0020, 0x004A, 0x002B, 0x0024, 0x0000, 0x0002, 0x0002, 0x0002, 0x0002, 0x0000 };

    auto const non_ignorable = collate_for_tests(
        cps, cps + 4, boost::text::variable_weighting::non_ignorable);

    EXPECT_EQ(non_ignorable.size(), 12);
    EXPECT_TRUE(boost::algorithm::equal(non_ignorable.begin(), non_ignorable.end(), ces_non_ignorable, ces_non_ignorable + 12))
        << "from:     " << ce_dumper(cps)
        << "expected: " << ce_dumper(ces_non_ignorable)
        << "got:      " << ce_dumper(non_ignorable);

    // 03B9 0308 0334 0341;	
    // (ϊ̴) GREEK SMALL LETTER IOTA, COMBINING DIAERESIS, COMBINING TILDE OVERLAY	[202C | 0020 004A 002B 0024 | 0002 0002 0002 0002 | FFFF FFFF FFFF FFFF |]
    uint32_t const ces_shifted[17] = { 0x202C, 0x0000, 0x0020, 0x004A, 0x002B, 0x0024, 0x0000, 0x0002, 0x0002, 0x0002, 0x0002, 0x0000, 0xFFFF, 0xFFFF, 0xFFFF, 0xFFFF, 0x0000 };

    auto const shifted = collate_for_tests(
        cps, cps + 4, boost::text::variable_weighting::shifted);

    EXPECT_EQ(shifted.size(), 17);
    EXPECT_TRUE(boost::algorithm::equal(shifted.begin(), shifted.end(), ces_shifted, ces_shifted + 17))
        << "from:     " << ce_dumper(cps)
        << "expected: " << ce_dumper(ces_shifted)
        << "got:      " << ce_dumper(shifted);
}

TEST(collation, verbatim_131_008)
{
    uint32_t const cps[2] = { 0x1FD3, 0x0334 };

    // 1FD3 0334;	
    // (ΐ) GREEK SMALL LETTER IOTA WITH DIALYTIKA AND OXIA	[202C | 0020 004A 002B 0024 | 0002 0002 0002 0002 |]
    uint32_t const ces_non_ignorable[12] = { 0x202C, 0x0000, 0x0020, 0x004A, 0x002B, 0x0024, 0x0000, 0x0002, 0x0002, 0x0002, 0x0002, 0x0000 };

    auto const non_ignorable = collate_for_tests(
        cps, cps + 2, boost::text::variable_weighting::non_ignorable);

    EXPECT_EQ(non_ignorable.size(), 12);
    EXPECT_TRUE(boost::algorithm::equal(non_ignorable.begin(), non_ignorable.end(), ces_non_ignorable, ces_non_ignorable + 12))
        << "from:     " << ce_dumper(cps)
        << "expected: " << ce_dumper(ces_non_ignorable)
        << "got:      " << ce_dumper(non_ignorable);

    // 1FD3 0334;	
    // (ΐ) GREEK SMALL LETTER IOTA WITH DIALYTIKA AND OXIA	[202C | 0020 004A 002B 0024 | 0002 0002 0002 0002 | FFFF FFFF FFFF FFFF |]
    uint32_t const ces_shifted[17] = { 0x202C, 0x0000, 0x0020, 0x004A, 0x002B, 0x0024, 0x0000, 0x0002, 0x0002, 0x0002, 0x0002, 0x0000, 0xFFFF, 0xFFFF, 0xFFFF, 0xFFFF, 0x0000 };

    auto const shifted = collate_for_tests(
        cps, cps + 2, boost::text::variable_weighting::shifted);

    EXPECT_EQ(shifted.size(), 17);
    EXPECT_TRUE(boost::algorithm::equal(shifted.begin(), shifted.end(), ces_shifted, ces_shifted + 17))
        << "from:     " << ce_dumper(cps)
        << "expected: " << ce_dumper(ces_shifted)
        << "got:      " << ce_dumper(shifted);
}

TEST(collation, verbatim_131_009)
{
    uint32_t const cps[4] = { 0x03B9, 0x0308, 0x0334, 0x0300 };

    // 03B9 0308 0334 0300;	
    // (ϊ̴) GREEK SMALL LETTER IOTA, COMBINING DIAERESIS, COMBINING TILDE OVERLAY	[202C | 0020 004A 002B 0025 | 0002 0002 0002 0002 |]
    uint32_t const ces_non_ignorable[12] = { 0x202C, 0x0000, 0x0020, 0x004A, 0x002B, 0x0025, 0x0000, 0x0002, 0x0002, 0x0002, 0x0002, 0x0000 };

    auto const non_ignorable = collate_for_tests(
        cps, cps + 4, boost::text::variable_weighting::non_ignorable);

    EXPECT_EQ(non_ignorable.size(), 12);
    EXPECT_TRUE(boost::algorithm::equal(non_ignorable.begin(), non_ignorable.end(), ces_non_ignorable, ces_non_ignorable + 12))
        << "from:     " << ce_dumper(cps)
        << "expected: " << ce_dumper(ces_non_ignorable)
        << "got:      " << ce_dumper(non_ignorable);

    // 03B9 0308 0334 0300;	
    // (ϊ̴) GREEK SMALL LETTER IOTA, COMBINING DIAERESIS, COMBINING TILDE OVERLAY	[202C | 0020 004A 002B 0025 | 0002 0002 0002 0002 | FFFF FFFF FFFF FFFF |]
    uint32_t const ces_shifted[17] = { 0x202C, 0x0000, 0x0020, 0x004A, 0x002B, 0x0025, 0x0000, 0x0002, 0x0002, 0x0002, 0x0002, 0x0000, 0xFFFF, 0xFFFF, 0xFFFF, 0xFFFF, 0x0000 };

    auto const shifted = collate_for_tests(
        cps, cps + 4, boost::text::variable_weighting::shifted);

    EXPECT_EQ(shifted.size(), 17);
    EXPECT_TRUE(boost::algorithm::equal(shifted.begin(), shifted.end(), ces_shifted, ces_shifted + 17))
        << "from:     " << ce_dumper(cps)
        << "expected: " << ce_dumper(ces_shifted)
        << "got:      " << ce_dumper(shifted);
}

TEST(collation, verbatim_131_010)
{
    uint32_t const cps[4] = { 0x1FBE, 0x0308, 0x0300, 0x0334 };

    // 1FBE 0308 0300 0334;	
    // (ῒ) GREEK PROSGEGRAMMENI, COMBINING DIAERESIS, COMBINING GRAVE ACCENT	[202C | 0020 004A 002B 0025 | 0002 0002 0002 0002 |]
    uint32_t const ces_non_ignorable[12] = { 0x202C, 0x0000, 0x0020, 0x004A, 0x002B, 0x0025, 0x0000, 0x0002, 0x0002, 0x0002, 0x0002, 0x0000 };

    auto const non_ignorable = collate_for_tests(
        cps, cps + 4, boost::text::variable_weighting::non_ignorable);

    EXPECT_EQ(non_ignorable.size(), 12);
    EXPECT_TRUE(boost::algorithm::equal(non_ignorable.begin(), non_ignorable.end(), ces_non_ignorable, ces_non_ignorable + 12))
        << "from:     " << ce_dumper(cps)
        << "expected: " << ce_dumper(ces_non_ignorable)
        << "got:      " << ce_dumper(non_ignorable);

    // 1FBE 0308 0300 0334;	
    // (ῒ) GREEK PROSGEGRAMMENI, COMBINING DIAERESIS, COMBINING GRAVE ACCENT	[202C | 0020 004A 002B 0025 | 0002 0002 0002 0002 | FFFF FFFF FFFF FFFF |]
    uint32_t const ces_shifted[17] = { 0x202C, 0x0000, 0x0020, 0x004A, 0x002B, 0x0025, 0x0000, 0x0002, 0x0002, 0x0002, 0x0002, 0x0000, 0xFFFF, 0xFFFF, 0xFFFF, 0xFFFF, 0x0000 };

    auto const shifted = collate_for_tests(
        cps, cps + 4, boost::text::variable_weighting::shifted);

    EXPECT_EQ(shifted.size(), 17);
    EXPECT_TRUE(boost::algorithm::equal(shifted.begin(), shifted.end(), ces_shifted, ces_shifted + 17))
        << "from:     " << ce_dumper(cps)
        << "expected: " << ce_dumper(ces_shifted)
        << "got:      " << ce_dumper(shifted);
}

TEST(collation, verbatim_131_011)
{
    uint32_t const cps[4] = { 0x1FBE, 0x0308, 0x0340, 0x0334 };

    // 1FBE 0308 0340 0334;	
    // (ῒ) GREEK PROSGEGRAMMENI, COMBINING DIAERESIS, COMBINING GRAVE TONE MARK	[202C | 0020 004A 002B 0025 | 0002 0002 0002 0002 |]
    uint32_t const ces_non_ignorable[12] = { 0x202C, 0x0000, 0x0020, 0x004A, 0x002B, 0x0025, 0x0000, 0x0002, 0x0002, 0x0002, 0x0002, 0x0000 };

    auto const non_ignorable = collate_for_tests(
        cps, cps + 4, boost::text::variable_weighting::non_ignorable);

    EXPECT_EQ(non_ignorable.size(), 12);
    EXPECT_TRUE(boost::algorithm::equal(non_ignorable.begin(), non_ignorable.end(), ces_non_ignorable, ces_non_ignorable + 12))
        << "from:     " << ce_dumper(cps)
        << "expected: " << ce_dumper(ces_non_ignorable)
        << "got:      " << ce_dumper(non_ignorable);

    // 1FBE 0308 0340 0334;	
    // (ῒ) GREEK PROSGEGRAMMENI, COMBINING DIAERESIS, COMBINING GRAVE TONE MARK	[202C | 0020 004A 002B 0025 | 0002 0002 0002 0002 | FFFF FFFF FFFF FFFF |]
    uint32_t const ces_shifted[17] = { 0x202C, 0x0000, 0x0020, 0x004A, 0x002B, 0x0025, 0x0000, 0x0002, 0x0002, 0x0002, 0x0002, 0x0000, 0xFFFF, 0xFFFF, 0xFFFF, 0xFFFF, 0x0000 };

    auto const shifted = collate_for_tests(
        cps, cps + 4, boost::text::variable_weighting::shifted);

    EXPECT_EQ(shifted.size(), 17);
    EXPECT_TRUE(boost::algorithm::equal(shifted.begin(), shifted.end(), ces_shifted, ces_shifted + 17))
        << "from:     " << ce_dumper(cps)
        << "expected: " << ce_dumper(ces_shifted)
        << "got:      " << ce_dumper(shifted);
}

TEST(collation, verbatim_131_012)
{
    uint32_t const cps[2] = { 0x1FD2, 0x0334 };

    // 1FD2 0334;	
    // (ῒ) GREEK SMALL LETTER IOTA WITH DIALYTIKA AND VARIA	[202C | 0020 004A 002B 0025 | 0002 0002 0002 0002 |]
    uint32_t const ces_non_ignorable[12] = { 0x202C, 0x0000, 0x0020, 0x004A, 0x002B, 0x0025, 0x0000, 0x0002, 0x0002, 0x0002, 0x0002, 0x0000 };

    auto const non_ignorable = collate_for_tests(
        cps, cps + 2, boost::text::variable_weighting::non_ignorable);

    EXPECT_EQ(non_ignorable.size(), 12);
    EXPECT_TRUE(boost::algorithm::equal(non_ignorable.begin(), non_ignorable.end(), ces_non_ignorable, ces_non_ignorable + 12))
        << "from:     " << ce_dumper(cps)
        << "expected: " << ce_dumper(ces_non_ignorable)
        << "got:      " << ce_dumper(non_ignorable);

    // 1FD2 0334;	
    // (ῒ) GREEK SMALL LETTER IOTA WITH DIALYTIKA AND VARIA	[202C | 0020 004A 002B 0025 | 0002 0002 0002 0002 | FFFF FFFF FFFF FFFF |]
    uint32_t const ces_shifted[17] = { 0x202C, 0x0000, 0x0020, 0x004A, 0x002B, 0x0025, 0x0000, 0x0002, 0x0002, 0x0002, 0x0002, 0x0000, 0xFFFF, 0xFFFF, 0xFFFF, 0xFFFF, 0x0000 };

    auto const shifted = collate_for_tests(
        cps, cps + 2, boost::text::variable_weighting::shifted);

    EXPECT_EQ(shifted.size(), 17);
    EXPECT_TRUE(boost::algorithm::equal(shifted.begin(), shifted.end(), ces_shifted, ces_shifted + 17))
        << "from:     " << ce_dumper(cps)
        << "expected: " << ce_dumper(ces_shifted)
        << "got:      " << ce_dumper(shifted);
}

TEST(collation, verbatim_131_013)
{
    uint32_t const cps[4] = { 0x03B9, 0x0308, 0x0334, 0x0342 };

    // 03B9 0308 0334 0342;	
    // (ϊ̴) GREEK SMALL LETTER IOTA, COMBINING DIAERESIS, COMBINING TILDE OVERLAY	[202C | 0020 004A 002B 002A | 0002 0002 0002 0002 |]
    uint32_t const ces_non_ignorable[12] = { 0x202C, 0x0000, 0x0020, 0x004A, 0x002B, 0x002A, 0x0000, 0x0002, 0x0002, 0x0002, 0x0002, 0x0000 };

    auto const non_ignorable = collate_for_tests(
        cps, cps + 4, boost::text::variable_weighting::non_ignorable);

    EXPECT_EQ(non_ignorable.size(), 12);
    EXPECT_TRUE(boost::algorithm::equal(non_ignorable.begin(), non_ignorable.end(), ces_non_ignorable, ces_non_ignorable + 12))
        << "from:     " << ce_dumper(cps)
        << "expected: " << ce_dumper(ces_non_ignorable)
        << "got:      " << ce_dumper(non_ignorable);

    // 03B9 0308 0334 0342;	
    // (ϊ̴) GREEK SMALL LETTER IOTA, COMBINING DIAERESIS, COMBINING TILDE OVERLAY	[202C | 0020 004A 002B 002A | 0002 0002 0002 0002 | FFFF FFFF FFFF FFFF |]
    uint32_t const ces_shifted[17] = { 0x202C, 0x0000, 0x0020, 0x004A, 0x002B, 0x002A, 0x0000, 0x0002, 0x0002, 0x0002, 0x0002, 0x0000, 0xFFFF, 0xFFFF, 0xFFFF, 0xFFFF, 0x0000 };

    auto const shifted = collate_for_tests(
        cps, cps + 4, boost::text::variable_weighting::shifted);

    EXPECT_EQ(shifted.size(), 17);
    EXPECT_TRUE(boost::algorithm::equal(shifted.begin(), shifted.end(), ces_shifted, ces_shifted + 17))
        << "from:     " << ce_dumper(cps)
        << "expected: " << ce_dumper(ces_shifted)
        << "got:      " << ce_dumper(shifted);
}

TEST(collation, verbatim_131_014)
{
    uint32_t const cps[3] = { 0x03CA, 0x0342, 0x0334 };

    // 03CA 0342 0334;	
    // (ῗ) GREEK SMALL LETTER IOTA WITH DIALYTIKA, COMBINING GREEK PERISPOMENI	[202C | 0020 004A 002B 002A | 0002 0002 0002 0002 |]
    uint32_t const ces_non_ignorable[12] = { 0x202C, 0x0000, 0x0020, 0x004A, 0x002B, 0x002A, 0x0000, 0x0002, 0x0002, 0x0002, 0x0002, 0x0000 };

    auto const non_ignorable = collate_for_tests(
        cps, cps + 3, boost::text::variable_weighting::non_ignorable);

    EXPECT_EQ(non_ignorable.size(), 12);
    EXPECT_TRUE(boost::algorithm::equal(non_ignorable.begin(), non_ignorable.end(), ces_non_ignorable, ces_non_ignorable + 12))
        << "from:     " << ce_dumper(cps)
        << "expected: " << ce_dumper(ces_non_ignorable)
        << "got:      " << ce_dumper(non_ignorable);

    // 03CA 0342 0334;	
    // (ῗ) GREEK SMALL LETTER IOTA WITH DIALYTIKA, COMBINING GREEK PERISPOMENI	[202C | 0020 004A 002B 002A | 0002 0002 0002 0002 | FFFF FFFF FFFF FFFF |]
    uint32_t const ces_shifted[17] = { 0x202C, 0x0000, 0x0020, 0x004A, 0x002B, 0x002A, 0x0000, 0x0002, 0x0002, 0x0002, 0x0002, 0x0000, 0xFFFF, 0xFFFF, 0xFFFF, 0xFFFF, 0x0000 };

    auto const shifted = collate_for_tests(
        cps, cps + 3, boost::text::variable_weighting::shifted);

    EXPECT_EQ(shifted.size(), 17);
    EXPECT_TRUE(boost::algorithm::equal(shifted.begin(), shifted.end(), ces_shifted, ces_shifted + 17))
        << "from:     " << ce_dumper(cps)
        << "expected: " << ce_dumper(ces_shifted)
        << "got:      " << ce_dumper(shifted);
}

TEST(collation, verbatim_131_015)
{
    uint32_t const cps[4] = { 0x1FBE, 0x0308, 0x0334, 0x0342 };

    // 1FBE 0308 0334 0342;	
    // (ϊ̴) GREEK PROSGEGRAMMENI, COMBINING DIAERESIS, COMBINING TILDE OVERLAY	[202C | 0020 004A 002B 002A | 0002 0002 0002 0002 |]
    uint32_t const ces_non_ignorable[12] = { 0x202C, 0x0000, 0x0020, 0x004A, 0x002B, 0x002A, 0x0000, 0x0002, 0x0002, 0x0002, 0x0002, 0x0000 };

    auto const non_ignorable = collate_for_tests(
        cps, cps + 4, boost::text::variable_weighting::non_ignorable);

    EXPECT_EQ(non_ignorable.size(), 12);
    EXPECT_TRUE(boost::algorithm::equal(non_ignorable.begin(), non_ignorable.end(), ces_non_ignorable, ces_non_ignorable + 12))
        << "from:     " << ce_dumper(cps)
        << "expected: " << ce_dumper(ces_non_ignorable)
        << "got:      " << ce_dumper(non_ignorable);

    // 1FBE 0308 0334 0342;	
    // (ϊ̴) GREEK PROSGEGRAMMENI, COMBINING DIAERESIS, COMBINING TILDE OVERLAY	[202C | 0020 004A 002B 002A | 0002 0002 0002 0002 | FFFF FFFF FFFF FFFF |]
    uint32_t const ces_shifted[17] = { 0x202C, 0x0000, 0x0020, 0x004A, 0x002B, 0x002A, 0x0000, 0x0002, 0x0002, 0x0002, 0x0002, 0x0000, 0xFFFF, 0xFFFF, 0xFFFF, 0xFFFF, 0x0000 };

    auto const shifted = collate_for_tests(
        cps, cps + 4, boost::text::variable_weighting::shifted);

    EXPECT_EQ(shifted.size(), 17);
    EXPECT_TRUE(boost::algorithm::equal(shifted.begin(), shifted.end(), ces_shifted, ces_shifted + 17))
        << "from:     " << ce_dumper(cps)
        << "expected: " << ce_dumper(ces_shifted)
        << "got:      " << ce_dumper(shifted);
}

TEST(collation, verbatim_131_016)
{
    uint32_t const cps[4] = { 0x1FBE, 0x0308, 0x0342, 0x0334 };

    // 1FBE 0308 0342 0334;	
    // (ῗ) GREEK PROSGEGRAMMENI, COMBINING DIAERESIS, COMBINING GREEK PERISPOMENI	[202C | 0020 004A 002B 002A | 0002 0002 0002 0002 |]
    uint32_t const ces_non_ignorable[12] = { 0x202C, 0x0000, 0x0020, 0x004A, 0x002B, 0x002A, 0x0000, 0x0002, 0x0002, 0x0002, 0x0002, 0x0000 };

    auto const non_ignorable = collate_for_tests(
        cps, cps + 4, boost::text::variable_weighting::non_ignorable);

    EXPECT_EQ(non_ignorable.size(), 12);
    EXPECT_TRUE(boost::algorithm::equal(non_ignorable.begin(), non_ignorable.end(), ces_non_ignorable, ces_non_ignorable + 12))
        << "from:     " << ce_dumper(cps)
        << "expected: " << ce_dumper(ces_non_ignorable)
        << "got:      " << ce_dumper(non_ignorable);

    // 1FBE 0308 0342 0334;	
    // (ῗ) GREEK PROSGEGRAMMENI, COMBINING DIAERESIS, COMBINING GREEK PERISPOMENI	[202C | 0020 004A 002B 002A | 0002 0002 0002 0002 | FFFF FFFF FFFF FFFF |]
    uint32_t const ces_shifted[17] = { 0x202C, 0x0000, 0x0020, 0x004A, 0x002B, 0x002A, 0x0000, 0x0002, 0x0002, 0x0002, 0x0002, 0x0000, 0xFFFF, 0xFFFF, 0xFFFF, 0xFFFF, 0x0000 };

    auto const shifted = collate_for_tests(
        cps, cps + 4, boost::text::variable_weighting::shifted);

    EXPECT_EQ(shifted.size(), 17);
    EXPECT_TRUE(boost::algorithm::equal(shifted.begin(), shifted.end(), ces_shifted, ces_shifted + 17))
        << "from:     " << ce_dumper(cps)
        << "expected: " << ce_dumper(ces_shifted)
        << "got:      " << ce_dumper(shifted);
}

TEST(collation, verbatim_131_017)
{
    uint32_t const cps[3] = { 0x03B9, 0x0304, 0x0334 };

    // 03B9 0304 0334;	
    // (ῑ) GREEK SMALL LETTER IOTA, COMBINING MACRON	[202C | 0020 004A 0032 | 0002 0002 0002 |]
    uint32_t const ces_non_ignorable[10] = { 0x202C, 0x0000, 0x0020, 0x004A, 0x0032, 0x0000, 0x0002, 0x0002, 0x0002, 0x0000 };

    auto const non_ignorable = collate_for_tests(
        cps, cps + 3, boost::text::variable_weighting::non_ignorable);

    EXPECT_EQ(non_ignorable.size(), 10);
    EXPECT_TRUE(boost::algorithm::equal(non_ignorable.begin(), non_ignorable.end(), ces_non_ignorable, ces_non_ignorable + 10))
        << "from:     " << ce_dumper(cps)
        << "expected: " << ce_dumper(ces_non_ignorable)
        << "got:      " << ce_dumper(non_ignorable);

    // 03B9 0304 0334;	
    // (ῑ) GREEK SMALL LETTER IOTA, COMBINING MACRON	[202C | 0020 004A 0032 | 0002 0002 0002 | FFFF FFFF FFFF |]
    uint32_t const ces_shifted[14] = { 0x202C, 0x0000, 0x0020, 0x004A, 0x0032, 0x0000, 0x0002, 0x0002, 0x0002, 0x0000, 0xFFFF, 0xFFFF, 0xFFFF, 0x0000 };

    auto const shifted = collate_for_tests(
        cps, cps + 3, boost::text::variable_weighting::shifted);

    EXPECT_EQ(shifted.size(), 14);
    EXPECT_TRUE(boost::algorithm::equal(shifted.begin(), shifted.end(), ces_shifted, ces_shifted + 14))
        << "from:     " << ce_dumper(cps)
        << "expected: " << ce_dumper(ces_shifted)
        << "got:      " << ce_dumper(shifted);
}

TEST(collation, verbatim_131_018)
{
    uint32_t const cps[3] = { 0x03B9, 0x0334, 0x0304 };

    // 03B9 0334 0304;	
    // (ι̴) GREEK SMALL LETTER IOTA, COMBINING TILDE OVERLAY	[202C | 0020 004A 0032 | 0002 0002 0002 |]
    uint32_t const ces_non_ignorable[10] = { 0x202C, 0x0000, 0x0020, 0x004A, 0x0032, 0x0000, 0x0002, 0x0002, 0x0002, 0x0000 };

    auto const non_ignorable = collate_for_tests(
        cps, cps + 3, boost::text::variable_weighting::non_ignorable);

    EXPECT_EQ(non_ignorable.size(), 10);
    EXPECT_TRUE(boost::algorithm::equal(non_ignorable.begin(), non_ignorable.end(), ces_non_ignorable, ces_non_ignorable + 10))
        << "from:     " << ce_dumper(cps)
        << "expected: " << ce_dumper(ces_non_ignorable)
        << "got:      " << ce_dumper(non_ignorable);

    // 03B9 0334 0304;	
    // (ι̴) GREEK SMALL LETTER IOTA, COMBINING TILDE OVERLAY	[202C | 0020 004A 0032 | 0002 0002 0002 | FFFF FFFF FFFF |]
    uint32_t const ces_shifted[14] = { 0x202C, 0x0000, 0x0020, 0x004A, 0x0032, 0x0000, 0x0002, 0x0002, 0x0002, 0x0000, 0xFFFF, 0xFFFF, 0xFFFF, 0x0000 };

    auto const shifted = collate_for_tests(
        cps, cps + 3, boost::text::variable_weighting::shifted);

    EXPECT_EQ(shifted.size(), 14);
    EXPECT_TRUE(boost::algorithm::equal(shifted.begin(), shifted.end(), ces_shifted, ces_shifted + 14))
        << "from:     " << ce_dumper(cps)
        << "expected: " << ce_dumper(ces_shifted)
        << "got:      " << ce_dumper(shifted);
}

TEST(collation, verbatim_131_019)
{
    uint32_t const cps[3] = { 0x1FBE, 0x0334, 0x0304 };

    // 1FBE 0334 0304;	
    // (ι̴) GREEK PROSGEGRAMMENI, COMBINING TILDE OVERLAY	[202C | 0020 004A 0032 | 0002 0002 0002 |]
    uint32_t const ces_non_ignorable[10] = { 0x202C, 0x0000, 0x0020, 0x004A, 0x0032, 0x0000, 0x0002, 0x0002, 0x0002, 0x0000 };

    auto const non_ignorable = collate_for_tests(
        cps, cps + 3, boost::text::variable_weighting::non_ignorable);

    EXPECT_EQ(non_ignorable.size(), 10);
    EXPECT_TRUE(boost::algorithm::equal(non_ignorable.begin(), non_ignorable.end(), ces_non_ignorable, ces_non_ignorable + 10))
        << "from:     " << ce_dumper(cps)
        << "expected: " << ce_dumper(ces_non_ignorable)
        << "got:      " << ce_dumper(non_ignorable);

    // 1FBE 0334 0304;	
    // (ι̴) GREEK PROSGEGRAMMENI, COMBINING TILDE OVERLAY	[202C | 0020 004A 0032 | 0002 0002 0002 | FFFF FFFF FFFF |]
    uint32_t const ces_shifted[14] = { 0x202C, 0x0000, 0x0020, 0x004A, 0x0032, 0x0000, 0x0002, 0x0002, 0x0002, 0x0000, 0xFFFF, 0xFFFF, 0xFFFF, 0x0000 };

    auto const shifted = collate_for_tests(
        cps, cps + 3, boost::text::variable_weighting::shifted);

    EXPECT_EQ(shifted.size(), 14);
    EXPECT_TRUE(boost::algorithm::equal(shifted.begin(), shifted.end(), ces_shifted, ces_shifted + 14))
        << "from:     " << ce_dumper(cps)
        << "expected: " << ce_dumper(ces_shifted)
        << "got:      " << ce_dumper(shifted);
}

TEST(collation, verbatim_131_020)
{
    uint32_t const cps[2] = { 0x1FD1, 0x0334 };

    // 1FD1 0334;	
    // (ῑ) GREEK SMALL LETTER IOTA WITH MACRON	[202C | 0020 004A 0032 | 0002 0002 0002 |]
    uint32_t const ces_non_ignorable[10] = { 0x202C, 0x0000, 0x0020, 0x004A, 0x0032, 0x0000, 0x0002, 0x0002, 0x0002, 0x0000 };

    auto const non_ignorable = collate_for_tests(
        cps, cps + 2, boost::text::variable_weighting::non_ignorable);

    EXPECT_EQ(non_ignorable.size(), 10);
    EXPECT_TRUE(boost::algorithm::equal(non_ignorable.begin(), non_ignorable.end(), ces_non_ignorable, ces_non_ignorable + 10))
        << "from:     " << ce_dumper(cps)
        << "expected: " << ce_dumper(ces_non_ignorable)
        << "got:      " << ce_dumper(non_ignorable);

    // 1FD1 0334;	
    // (ῑ) GREEK SMALL LETTER IOTA WITH MACRON	[202C | 0020 004A 0032 | 0002 0002 0002 | FFFF FFFF FFFF |]
    uint32_t const ces_shifted[14] = { 0x202C, 0x0000, 0x0020, 0x004A, 0x0032, 0x0000, 0x0002, 0x0002, 0x0002, 0x0000, 0xFFFF, 0xFFFF, 0xFFFF, 0x0000 };

    auto const shifted = collate_for_tests(
        cps, cps + 2, boost::text::variable_weighting::shifted);

    EXPECT_EQ(shifted.size(), 14);
    EXPECT_TRUE(boost::algorithm::equal(shifted.begin(), shifted.end(), ces_shifted, ces_shifted + 14))
        << "from:     " << ce_dumper(cps)
        << "expected: " << ce_dumper(ces_shifted)
        << "got:      " << ce_dumper(shifted);
}

TEST(collation, verbatim_131_021)
{
    uint32_t const cps[3] = { 0x0399, 0x0304, 0x0334 };

    // 0399 0304 0334;	
    // (Ῑ) GREEK CAPITAL LETTER IOTA, COMBINING MACRON	[202C | 0020 004A 0032 | 0008 0002 0002 |]
    uint32_t const ces_non_ignorable[10] = { 0x202C, 0x0000, 0x0020, 0x004A, 0x0032, 0x0000, 0x0008, 0x0002, 0x0002, 0x0000 };

    auto const non_ignorable = collate_for_tests(
        cps, cps + 3, boost::text::variable_weighting::non_ignorable);

    EXPECT_EQ(non_ignorable.size(), 10);
    EXPECT_TRUE(boost::algorithm::equal(non_ignorable.begin(), non_ignorable.end(), ces_non_ignorable, ces_non_ignorable + 10))
        << "from:     " << ce_dumper(cps)
        << "expected: " << ce_dumper(ces_non_ignorable)
        << "got:      " << ce_dumper(non_ignorable);

    // 0399 0304 0334;	
    // (Ῑ) GREEK CAPITAL LETTER IOTA, COMBINING MACRON	[202C | 0020 004A 0032 | 0008 0002 0002 | FFFF FFFF FFFF |]
    uint32_t const ces_shifted[14] = { 0x202C, 0x0000, 0x0020, 0x004A, 0x0032, 0x0000, 0x0008, 0x0002, 0x0002, 0x0000, 0xFFFF, 0xFFFF, 0xFFFF, 0x0000 };

    auto const shifted = collate_for_tests(
        cps, cps + 3, boost::text::variable_weighting::shifted);

    EXPECT_EQ(shifted.size(), 14);
    EXPECT_TRUE(boost::algorithm::equal(shifted.begin(), shifted.end(), ces_shifted, ces_shifted + 14))
        << "from:     " << ce_dumper(cps)
        << "expected: " << ce_dumper(ces_shifted)
        << "got:      " << ce_dumper(shifted);
}

TEST(collation, verbatim_131_022)
{
    uint32_t const cps[3] = { 0x0399, 0x0334, 0x0304 };

    // 0399 0334 0304;	
    // (Ι̴) GREEK CAPITAL LETTER IOTA, COMBINING TILDE OVERLAY	[202C | 0020 004A 0032 | 0008 0002 0002 |]
    uint32_t const ces_non_ignorable[10] = { 0x202C, 0x0000, 0x0020, 0x004A, 0x0032, 0x0000, 0x0008, 0x0002, 0x0002, 0x0000 };

    auto const non_ignorable = collate_for_tests(
        cps, cps + 3, boost::text::variable_weighting::non_ignorable);

    EXPECT_EQ(non_ignorable.size(), 10);
    EXPECT_TRUE(boost::algorithm::equal(non_ignorable.begin(), non_ignorable.end(), ces_non_ignorable, ces_non_ignorable + 10))
        << "from:     " << ce_dumper(cps)
        << "expected: " << ce_dumper(ces_non_ignorable)
        << "got:      " << ce_dumper(non_ignorable);

    // 0399 0334 0304;	
    // (Ι̴) GREEK CAPITAL LETTER IOTA, COMBINING TILDE OVERLAY	[202C | 0020 004A 0032 | 0008 0002 0002 | FFFF FFFF FFFF |]
    uint32_t const ces_shifted[14] = { 0x202C, 0x0000, 0x0020, 0x004A, 0x0032, 0x0000, 0x0008, 0x0002, 0x0002, 0x0000, 0xFFFF, 0xFFFF, 0xFFFF, 0x0000 };

    auto const shifted = collate_for_tests(
        cps, cps + 3, boost::text::variable_weighting::shifted);

    EXPECT_EQ(shifted.size(), 14);
    EXPECT_TRUE(boost::algorithm::equal(shifted.begin(), shifted.end(), ces_shifted, ces_shifted + 14))
        << "from:     " << ce_dumper(cps)
        << "expected: " << ce_dumper(ces_shifted)
        << "got:      " << ce_dumper(shifted);
}

TEST(collation, verbatim_131_023)
{
    uint32_t const cps[2] = { 0x1FD9, 0x0334 };

    // 1FD9 0334;	
    // (Ῑ) GREEK CAPITAL LETTER IOTA WITH MACRON	[202C | 0020 004A 0032 | 0008 0002 0002 |]
    uint32_t const ces_non_ignorable[10] = { 0x202C, 0x0000, 0x0020, 0x004A, 0x0032, 0x0000, 0x0008, 0x0002, 0x0002, 0x0000 };

    auto const non_ignorable = collate_for_tests(
        cps, cps + 2, boost::text::variable_weighting::non_ignorable);

    EXPECT_EQ(non_ignorable.size(), 10);
    EXPECT_TRUE(boost::algorithm::equal(non_ignorable.begin(), non_ignorable.end(), ces_non_ignorable, ces_non_ignorable + 10))
        << "from:     " << ce_dumper(cps)
        << "expected: " << ce_dumper(ces_non_ignorable)
        << "got:      " << ce_dumper(non_ignorable);

    // 1FD9 0334;	
    // (Ῑ) GREEK CAPITAL LETTER IOTA WITH MACRON	[202C | 0020 004A 0032 | 0008 0002 0002 | FFFF FFFF FFFF |]
    uint32_t const ces_shifted[14] = { 0x202C, 0x0000, 0x0020, 0x004A, 0x0032, 0x0000, 0x0008, 0x0002, 0x0002, 0x0000, 0xFFFF, 0xFFFF, 0xFFFF, 0x0000 };

    auto const shifted = collate_for_tests(
        cps, cps + 2, boost::text::variable_weighting::shifted);

    EXPECT_EQ(shifted.size(), 14);
    EXPECT_TRUE(boost::algorithm::equal(shifted.begin(), shifted.end(), ces_shifted, ces_shifted + 14))
        << "from:     " << ce_dumper(cps)
        << "expected: " << ce_dumper(ces_shifted)
        << "got:      " << ce_dumper(shifted);
}

TEST(collation, verbatim_131_024)
{
    uint32_t const cps[2] = { 0x03B9, 0x0021 };

    // 03B9 0021;	
    // (ι) GREEK SMALL LETTER IOTA	[202C 0261 | 0020 0020 | 0002 0002 |]
    uint32_t const ces_non_ignorable[9] = { 0x202C, 0x0261, 0x0000, 0x0020, 0x0020, 0x0000, 0x0002, 0x0002, 0x0000 };

    auto const non_ignorable = collate_for_tests(
        cps, cps + 2, boost::text::variable_weighting::non_ignorable);

    EXPECT_EQ(non_ignorable.size(), 9);
    EXPECT_TRUE(boost::algorithm::equal(non_ignorable.begin(), non_ignorable.end(), ces_non_ignorable, ces_non_ignorable + 9))
        << "from:     " << ce_dumper(cps)
        << "expected: " << ce_dumper(ces_non_ignorable)
        << "got:      " << ce_dumper(non_ignorable);

    // 03B9 0021;	
    // (ι) GREEK SMALL LETTER IOTA	[202C | 0020 | 0002 | FFFF 0261 |]
    uint32_t const ces_shifted[9] = { 0x202C, 0x0000, 0x0020, 0x0000, 0x0002, 0x0000, 0xFFFF, 0x0261, 0x0000 };

    auto const shifted = collate_for_tests(
        cps, cps + 2, boost::text::variable_weighting::shifted);

    EXPECT_EQ(shifted.size(), 9);
    EXPECT_TRUE(boost::algorithm::equal(shifted.begin(), shifted.end(), ces_shifted, ces_shifted + 9))
        << "from:     " << ce_dumper(cps)
        << "expected: " << ce_dumper(ces_shifted)
        << "got:      " << ce_dumper(shifted);
}

TEST(collation, verbatim_131_025)
{
    uint32_t const cps[2] = { 0x1FBE, 0x0021 };

    // 1FBE 0021;	
    // (ι) GREEK PROSGEGRAMMENI	[202C 0261 | 0020 0020 | 0002 0002 |]
    uint32_t const ces_non_ignorable[9] = { 0x202C, 0x0261, 0x0000, 0x0020, 0x0020, 0x0000, 0x0002, 0x0002, 0x0000 };

    auto const non_ignorable = collate_for_tests(
        cps, cps + 2, boost::text::variable_weighting::non_ignorable);

    EXPECT_EQ(non_ignorable.size(), 9);
    EXPECT_TRUE(boost::algorithm::equal(non_ignorable.begin(), non_ignorable.end(), ces_non_ignorable, ces_non_ignorable + 9))
        << "from:     " << ce_dumper(cps)
        << "expected: " << ce_dumper(ces_non_ignorable)
        << "got:      " << ce_dumper(non_ignorable);

    // 1FBE 0021;	
    // (ι) GREEK PROSGEGRAMMENI	[202C | 0020 | 0002 | FFFF 0261 |]
    uint32_t const ces_shifted[9] = { 0x202C, 0x0000, 0x0020, 0x0000, 0x0002, 0x0000, 0xFFFF, 0x0261, 0x0000 };

    auto const shifted = collate_for_tests(
        cps, cps + 2, boost::text::variable_weighting::shifted);

    EXPECT_EQ(shifted.size(), 9);
    EXPECT_TRUE(boost::algorithm::equal(shifted.begin(), shifted.end(), ces_shifted, ces_shifted + 9))
        << "from:     " << ce_dumper(cps)
        << "expected: " << ce_dumper(ces_shifted)
        << "got:      " << ce_dumper(shifted);
}

TEST(collation, verbatim_131_026)
{
    uint32_t const cps[2] = { 0x037A, 0x0021 };

    // 037A 0021;	
    // (ͺ) GREEK YPOGEGRAMMENI	[202C 0261 | 0020 0020 | 0004 0002 |]
    uint32_t const ces_non_ignorable[9] = { 0x202C, 0x0261, 0x0000, 0x0020, 0x0020, 0x0000, 0x0004, 0x0002, 0x0000 };

    auto const non_ignorable = collate_for_tests(
        cps, cps + 2, boost::text::variable_weighting::non_ignorable);

    EXPECT_EQ(non_ignorable.size(), 9);
    EXPECT_TRUE(boost::algorithm::equal(non_ignorable.begin(), non_ignorable.end(), ces_non_ignorable, ces_non_ignorable + 9))
        << "from:     " << ce_dumper(cps)
        << "expected: " << ce_dumper(ces_non_ignorable)
        << "got:      " << ce_dumper(non_ignorable);

    // 037A 0021;	
    // (ͺ) GREEK YPOGEGRAMMENI	[202C | 0020 | 0004 | FFFF 0261 |]
    uint32_t const ces_shifted[9] = { 0x202C, 0x0000, 0x0020, 0x0000, 0x0004, 0x0000, 0xFFFF, 0x0261, 0x0000 };

    auto const shifted = collate_for_tests(
        cps, cps + 2, boost::text::variable_weighting::shifted);

    EXPECT_EQ(shifted.size(), 9);
    EXPECT_TRUE(boost::algorithm::equal(shifted.begin(), shifted.end(), ces_shifted, ces_shifted + 9))
        << "from:     " << ce_dumper(cps)
        << "expected: " << ce_dumper(ces_shifted)
        << "got:      " << ce_dumper(shifted);
}

TEST(collation, verbatim_131_027)
{
    uint32_t const cps[2] = { 0x1D6CA, 0x0021 };

    // 1D6CA 0021;	
    // (𝛊) MATHEMATICAL BOLD SMALL IOTA	[202C 0261 | 0020 0020 | 0005 0002 |]
    uint32_t const ces_non_ignorable[9] = { 0x202C, 0x0261, 0x0000, 0x0020, 0x0020, 0x0000, 0x0005, 0x0002, 0x0000 };

    auto const non_ignorable = collate_for_tests(
        cps, cps + 2, boost::text::variable_weighting::non_ignorable);

    EXPECT_EQ(non_ignorable.size(), 9);
    EXPECT_TRUE(boost::algorithm::equal(non_ignorable.begin(), non_ignorable.end(), ces_non_ignorable, ces_non_ignorable + 9))
        << "from:     " << ce_dumper(cps)
        << "expected: " << ce_dumper(ces_non_ignorable)
        << "got:      " << ce_dumper(non_ignorable);

    // 1D6CA 0021;	
    // (𝛊) MATHEMATICAL BOLD SMALL IOTA	[202C | 0020 | 0005 | FFFF 0261 |]
    uint32_t const ces_shifted[9] = { 0x202C, 0x0000, 0x0020, 0x0000, 0x0005, 0x0000, 0xFFFF, 0x0261, 0x0000 };

    auto const shifted = collate_for_tests(
        cps, cps + 2, boost::text::variable_weighting::shifted);

    EXPECT_EQ(shifted.size(), 9);
    EXPECT_TRUE(boost::algorithm::equal(shifted.begin(), shifted.end(), ces_shifted, ces_shifted + 9))
        << "from:     " << ce_dumper(cps)
        << "expected: " << ce_dumper(ces_shifted)
        << "got:      " << ce_dumper(shifted);
}

TEST(collation, verbatim_131_028)
{
    uint32_t const cps[2] = { 0x1D704, 0x0021 };

    // 1D704 0021;	
    // (𝜄) MATHEMATICAL ITALIC SMALL IOTA	[202C 0261 | 0020 0020 | 0005 0002 |]
    uint32_t const ces_non_ignorable[9] = { 0x202C, 0x0261, 0x0000, 0x0020, 0x0020, 0x0000, 0x0005, 0x0002, 0x0000 };

    auto const non_ignorable = collate_for_tests(
        cps, cps + 2, boost::text::variable_weighting::non_ignorable);

    EXPECT_EQ(non_ignorable.size(), 9);
    EXPECT_TRUE(boost::algorithm::equal(non_ignorable.begin(), non_ignorable.end(), ces_non_ignorable, ces_non_ignorable + 9))
        << "from:     " << ce_dumper(cps)
        << "expected: " << ce_dumper(ces_non_ignorable)
        << "got:      " << ce_dumper(non_ignorable);

    // 1D704 0021;	
    // (𝜄) MATHEMATICAL ITALIC SMALL IOTA	[202C | 0020 | 0005 | FFFF 0261 |]
    uint32_t const ces_shifted[9] = { 0x202C, 0x0000, 0x0020, 0x0000, 0x0005, 0x0000, 0xFFFF, 0x0261, 0x0000 };

    auto const shifted = collate_for_tests(
        cps, cps + 2, boost::text::variable_weighting::shifted);

    EXPECT_EQ(shifted.size(), 9);
    EXPECT_TRUE(boost::algorithm::equal(shifted.begin(), shifted.end(), ces_shifted, ces_shifted + 9))
        << "from:     " << ce_dumper(cps)
        << "expected: " << ce_dumper(ces_shifted)
        << "got:      " << ce_dumper(shifted);
}

TEST(collation, verbatim_131_029)
{
    uint32_t const cps[2] = { 0x1D73E, 0x0021 };

    // 1D73E 0021;	
    // (𝜾) MATHEMATICAL BOLD ITALIC SMALL IOTA	[202C 0261 | 0020 0020 | 0005 0002 |]
    uint32_t const ces_non_ignorable[9] = { 0x202C, 0x0261, 0x0000, 0x0020, 0x0020, 0x0000, 0x0005, 0x0002, 0x0000 };

    auto const non_ignorable = collate_for_tests(
        cps, cps + 2, boost::text::variable_weighting::non_ignorable);

    EXPECT_EQ(non_ignorable.size(), 9);
    EXPECT_TRUE(boost::algorithm::equal(non_ignorable.begin(), non_ignorable.end(), ces_non_ignorable, ces_non_ignorable + 9))
        << "from:     " << ce_dumper(cps)
        << "expected: " << ce_dumper(ces_non_ignorable)
        << "got:      " << ce_dumper(non_ignorable);

    // 1D73E 0021;	
    // (𝜾) MATHEMATICAL BOLD ITALIC SMALL IOTA	[202C | 0020 | 0005 | FFFF 0261 |]
    uint32_t const ces_shifted[9] = { 0x202C, 0x0000, 0x0020, 0x0000, 0x0005, 0x0000, 0xFFFF, 0x0261, 0x0000 };

    auto const shifted = collate_for_tests(
        cps, cps + 2, boost::text::variable_weighting::shifted);

    EXPECT_EQ(shifted.size(), 9);
    EXPECT_TRUE(boost::algorithm::equal(shifted.begin(), shifted.end(), ces_shifted, ces_shifted + 9))
        << "from:     " << ce_dumper(cps)
        << "expected: " << ce_dumper(ces_shifted)
        << "got:      " << ce_dumper(shifted);
}

TEST(collation, verbatim_131_030)
{
    uint32_t const cps[2] = { 0x1D778, 0x0021 };

    // 1D778 0021;	
    // (𝝸) MATHEMATICAL SANS-SERIF BOLD SMALL IOTA	[202C 0261 | 0020 0020 | 0005 0002 |]
    uint32_t const ces_non_ignorable[9] = { 0x202C, 0x0261, 0x0000, 0x0020, 0x0020, 0x0000, 0x0005, 0x0002, 0x0000 };

    auto const non_ignorable = collate_for_tests(
        cps, cps + 2, boost::text::variable_weighting::non_ignorable);

    EXPECT_EQ(non_ignorable.size(), 9);
    EXPECT_TRUE(boost::algorithm::equal(non_ignorable.begin(), non_ignorable.end(), ces_non_ignorable, ces_non_ignorable + 9))
        << "from:     " << ce_dumper(cps)
        << "expected: " << ce_dumper(ces_non_ignorable)
        << "got:      " << ce_dumper(non_ignorable);

    // 1D778 0021;	
    // (𝝸) MATHEMATICAL SANS-SERIF BOLD SMALL IOTA	[202C | 0020 | 0005 | FFFF 0261 |]
    uint32_t const ces_shifted[9] = { 0x202C, 0x0000, 0x0020, 0x0000, 0x0005, 0x0000, 0xFFFF, 0x0261, 0x0000 };

    auto const shifted = collate_for_tests(
        cps, cps + 2, boost::text::variable_weighting::shifted);

    EXPECT_EQ(shifted.size(), 9);
    EXPECT_TRUE(boost::algorithm::equal(shifted.begin(), shifted.end(), ces_shifted, ces_shifted + 9))
        << "from:     " << ce_dumper(cps)
        << "expected: " << ce_dumper(ces_shifted)
        << "got:      " << ce_dumper(shifted);
}

TEST(collation, verbatim_131_031)
{
    uint32_t const cps[2] = { 0x1D7B2, 0x0021 };

    // 1D7B2 0021;	
    // (𝞲) MATHEMATICAL SANS-SERIF BOLD ITALIC SMALL IOTA	[202C 0261 | 0020 0020 | 0005 0002 |]
    uint32_t const ces_non_ignorable[9] = { 0x202C, 0x0261, 0x0000, 0x0020, 0x0020, 0x0000, 0x0005, 0x0002, 0x0000 };

    auto const non_ignorable = collate_for_tests(
        cps, cps + 2, boost::text::variable_weighting::non_ignorable);

    EXPECT_EQ(non_ignorable.size(), 9);
    EXPECT_TRUE(boost::algorithm::equal(non_ignorable.begin(), non_ignorable.end(), ces_non_ignorable, ces_non_ignorable + 9))
        << "from:     " << ce_dumper(cps)
        << "expected: " << ce_dumper(ces_non_ignorable)
        << "got:      " << ce_dumper(non_ignorable);

    // 1D7B2 0021;	
    // (𝞲) MATHEMATICAL SANS-SERIF BOLD ITALIC SMALL IOTA	[202C | 0020 | 0005 | FFFF 0261 |]
    uint32_t const ces_shifted[9] = { 0x202C, 0x0000, 0x0020, 0x0000, 0x0005, 0x0000, 0xFFFF, 0x0261, 0x0000 };

    auto const shifted = collate_for_tests(
        cps, cps + 2, boost::text::variable_weighting::shifted);

    EXPECT_EQ(shifted.size(), 9);
    EXPECT_TRUE(boost::algorithm::equal(shifted.begin(), shifted.end(), ces_shifted, ces_shifted + 9))
        << "from:     " << ce_dumper(cps)
        << "expected: " << ce_dumper(ces_shifted)
        << "got:      " << ce_dumper(shifted);
}

TEST(collation, verbatim_131_032)
{
    uint32_t const cps[2] = { 0x0399, 0x0021 };

    // 0399 0021;	
    // (Ι) GREEK CAPITAL LETTER IOTA	[202C 0261 | 0020 0020 | 0008 0002 |]
    uint32_t const ces_non_ignorable[9] = { 0x202C, 0x0261, 0x0000, 0x0020, 0x0020, 0x0000, 0x0008, 0x0002, 0x0000 };

    auto const non_ignorable = collate_for_tests(
        cps, cps + 2, boost::text::variable_weighting::non_ignorable);

    EXPECT_EQ(non_ignorable.size(), 9);
    EXPECT_TRUE(boost::algorithm::equal(non_ignorable.begin(), non_ignorable.end(), ces_non_ignorable, ces_non_ignorable + 9))
        << "from:     " << ce_dumper(cps)
        << "expected: " << ce_dumper(ces_non_ignorable)
        << "got:      " << ce_dumper(non_ignorable);

    // 0399 0021;	
    // (Ι) GREEK CAPITAL LETTER IOTA	[202C | 0020 | 0008 | FFFF 0261 |]
    uint32_t const ces_shifted[9] = { 0x202C, 0x0000, 0x0020, 0x0000, 0x0008, 0x0000, 0xFFFF, 0x0261, 0x0000 };

    auto const shifted = collate_for_tests(
        cps, cps + 2, boost::text::variable_weighting::shifted);

    EXPECT_EQ(shifted.size(), 9);
    EXPECT_TRUE(boost::algorithm::equal(shifted.begin(), shifted.end(), ces_shifted, ces_shifted + 9))
        << "from:     " << ce_dumper(cps)
        << "expected: " << ce_dumper(ces_shifted)
        << "got:      " << ce_dumper(shifted);
}

TEST(collation, verbatim_131_033)
{
    uint32_t const cps[2] = { 0x1D6B0, 0x0021 };

    // 1D6B0 0021;	
    // (𝚰) MATHEMATICAL BOLD CAPITAL IOTA	[202C 0261 | 0020 0020 | 000B 0002 |]
    uint32_t const ces_non_ignorable[9] = { 0x202C, 0x0261, 0x0000, 0x0020, 0x0020, 0x0000, 0x000B, 0x0002, 0x0000 };

    auto const non_ignorable = collate_for_tests(
        cps, cps + 2, boost::text::variable_weighting::non_ignorable);

    EXPECT_EQ(non_ignorable.size(), 9);
    EXPECT_TRUE(boost::algorithm::equal(non_ignorable.begin(), non_ignorable.end(), ces_non_ignorable, ces_non_ignorable + 9))
        << "from:     " << ce_dumper(cps)
        << "expected: " << ce_dumper(ces_non_ignorable)
        << "got:      " << ce_dumper(non_ignorable);

    // 1D6B0 0021;	
    // (𝚰) MATHEMATICAL BOLD CAPITAL IOTA	[202C | 0020 | 000B | FFFF 0261 |]
    uint32_t const ces_shifted[9] = { 0x202C, 0x0000, 0x0020, 0x0000, 0x000B, 0x0000, 0xFFFF, 0x0261, 0x0000 };

    auto const shifted = collate_for_tests(
        cps, cps + 2, boost::text::variable_weighting::shifted);

    EXPECT_EQ(shifted.size(), 9);
    EXPECT_TRUE(boost::algorithm::equal(shifted.begin(), shifted.end(), ces_shifted, ces_shifted + 9))
        << "from:     " << ce_dumper(cps)
        << "expected: " << ce_dumper(ces_shifted)
        << "got:      " << ce_dumper(shifted);
}

TEST(collation, verbatim_131_034)
{
    uint32_t const cps[2] = { 0x1D6EA, 0x0021 };

    // 1D6EA 0021;	
    // (𝛪) MATHEMATICAL ITALIC CAPITAL IOTA	[202C 0261 | 0020 0020 | 000B 0002 |]
    uint32_t const ces_non_ignorable[9] = { 0x202C, 0x0261, 0x0000, 0x0020, 0x0020, 0x0000, 0x000B, 0x0002, 0x0000 };

    auto const non_ignorable = collate_for_tests(
        cps, cps + 2, boost::text::variable_weighting::non_ignorable);

    EXPECT_EQ(non_ignorable.size(), 9);
    EXPECT_TRUE(boost::algorithm::equal(non_ignorable.begin(), non_ignorable.end(), ces_non_ignorable, ces_non_ignorable + 9))
        << "from:     " << ce_dumper(cps)
        << "expected: " << ce_dumper(ces_non_ignorable)
        << "got:      " << ce_dumper(non_ignorable);

    // 1D6EA 0021;	
    // (𝛪) MATHEMATICAL ITALIC CAPITAL IOTA	[202C | 0020 | 000B | FFFF 0261 |]
    uint32_t const ces_shifted[9] = { 0x202C, 0x0000, 0x0020, 0x0000, 0x000B, 0x0000, 0xFFFF, 0x0261, 0x0000 };

    auto const shifted = collate_for_tests(
        cps, cps + 2, boost::text::variable_weighting::shifted);

    EXPECT_EQ(shifted.size(), 9);
    EXPECT_TRUE(boost::algorithm::equal(shifted.begin(), shifted.end(), ces_shifted, ces_shifted + 9))
        << "from:     " << ce_dumper(cps)
        << "expected: " << ce_dumper(ces_shifted)
        << "got:      " << ce_dumper(shifted);
}

TEST(collation, verbatim_131_035)
{
    uint32_t const cps[2] = { 0x1D724, 0x0021 };

    // 1D724 0021;	
    // (𝜤) MATHEMATICAL BOLD ITALIC CAPITAL IOTA	[202C 0261 | 0020 0020 | 000B 0002 |]
    uint32_t const ces_non_ignorable[9] = { 0x202C, 0x0261, 0x0000, 0x0020, 0x0020, 0x0000, 0x000B, 0x0002, 0x0000 };

    auto const non_ignorable = collate_for_tests(
        cps, cps + 2, boost::text::variable_weighting::non_ignorable);

    EXPECT_EQ(non_ignorable.size(), 9);
    EXPECT_TRUE(boost::algorithm::equal(non_ignorable.begin(), non_ignorable.end(), ces_non_ignorable, ces_non_ignorable + 9))
        << "from:     " << ce_dumper(cps)
        << "expected: " << ce_dumper(ces_non_ignorable)
        << "got:      " << ce_dumper(non_ignorable);

    // 1D724 0021;	
    // (𝜤) MATHEMATICAL BOLD ITALIC CAPITAL IOTA	[202C | 0020 | 000B | FFFF 0261 |]
    uint32_t const ces_shifted[9] = { 0x202C, 0x0000, 0x0020, 0x0000, 0x000B, 0x0000, 0xFFFF, 0x0261, 0x0000 };

    auto const shifted = collate_for_tests(
        cps, cps + 2, boost::text::variable_weighting::shifted);

    EXPECT_EQ(shifted.size(), 9);
    EXPECT_TRUE(boost::algorithm::equal(shifted.begin(), shifted.end(), ces_shifted, ces_shifted + 9))
        << "from:     " << ce_dumper(cps)
        << "expected: " << ce_dumper(ces_shifted)
        << "got:      " << ce_dumper(shifted);
}

TEST(collation, verbatim_131_036)
{
    uint32_t const cps[2] = { 0x1D75E, 0x0021 };

    // 1D75E 0021;	
    // (𝝞) MATHEMATICAL SANS-SERIF BOLD CAPITAL IOTA	[202C 0261 | 0020 0020 | 000B 0002 |]
    uint32_t const ces_non_ignorable[9] = { 0x202C, 0x0261, 0x0000, 0x0020, 0x0020, 0x0000, 0x000B, 0x0002, 0x0000 };

    auto const non_ignorable = collate_for_tests(
        cps, cps + 2, boost::text::variable_weighting::non_ignorable);

    EXPECT_EQ(non_ignorable.size(), 9);
    EXPECT_TRUE(boost::algorithm::equal(non_ignorable.begin(), non_ignorable.end(), ces_non_ignorable, ces_non_ignorable + 9))
        << "from:     " << ce_dumper(cps)
        << "expected: " << ce_dumper(ces_non_ignorable)
        << "got:      " << ce_dumper(non_ignorable);

    // 1D75E 0021;	
    // (𝝞) MATHEMATICAL SANS-SERIF BOLD CAPITAL IOTA	[202C | 0020 | 000B | FFFF 0261 |]
    uint32_t const ces_shifted[9] = { 0x202C, 0x0000, 0x0020, 0x0000, 0x000B, 0x0000, 0xFFFF, 0x0261, 0x0000 };

    auto const shifted = collate_for_tests(
        cps, cps + 2, boost::text::variable_weighting::shifted);

    EXPECT_EQ(shifted.size(), 9);
    EXPECT_TRUE(boost::algorithm::equal(shifted.begin(), shifted.end(), ces_shifted, ces_shifted + 9))
        << "from:     " << ce_dumper(cps)
        << "expected: " << ce_dumper(ces_shifted)
        << "got:      " << ce_dumper(shifted);
}

TEST(collation, verbatim_131_037)
{
    uint32_t const cps[2] = { 0x1D798, 0x0021 };

    // 1D798 0021;	
    // (𝞘) MATHEMATICAL SANS-SERIF BOLD ITALIC CAPITAL IOTA	[202C 0261 | 0020 0020 | 000B 0002 |]
    uint32_t const ces_non_ignorable[9] = { 0x202C, 0x0261, 0x0000, 0x0020, 0x0020, 0x0000, 0x000B, 0x0002, 0x0000 };

    auto const non_ignorable = collate_for_tests(
        cps, cps + 2, boost::text::variable_weighting::non_ignorable);

    EXPECT_EQ(non_ignorable.size(), 9);
    EXPECT_TRUE(boost::algorithm::equal(non_ignorable.begin(), non_ignorable.end(), ces_non_ignorable, ces_non_ignorable + 9))
        << "from:     " << ce_dumper(cps)
        << "expected: " << ce_dumper(ces_non_ignorable)
        << "got:      " << ce_dumper(non_ignorable);

    // 1D798 0021;	
    // (𝞘) MATHEMATICAL SANS-SERIF BOLD ITALIC CAPITAL IOTA	[202C | 0020 | 000B | FFFF 0261 |]
    uint32_t const ces_shifted[9] = { 0x202C, 0x0000, 0x0020, 0x0000, 0x000B, 0x0000, 0xFFFF, 0x0261, 0x0000 };

    auto const shifted = collate_for_tests(
        cps, cps + 2, boost::text::variable_weighting::shifted);

    EXPECT_EQ(shifted.size(), 9);
    EXPECT_TRUE(boost::algorithm::equal(shifted.begin(), shifted.end(), ces_shifted, ces_shifted + 9))
        << "from:     " << ce_dumper(cps)
        << "expected: " << ce_dumper(ces_shifted)
        << "got:      " << ce_dumper(shifted);
}

TEST(collation, verbatim_131_038)
{
    uint32_t const cps[2] = { 0x1F30, 0x0021 };

    // 1F30 0021;	
    // (ἰ) GREEK SMALL LETTER IOTA WITH PSILI	[202C 0261 | 0020 0022 0020 | 0002 0002 0002 |]
    uint32_t const ces_non_ignorable[11] = { 0x202C, 0x0261, 0x0000, 0x0020, 0x0022, 0x0020, 0x0000, 0x0002, 0x0002, 0x0002, 0x0000 };

    auto const non_ignorable = collate_for_tests(
        cps, cps + 2, boost::text::variable_weighting::non_ignorable);

    EXPECT_EQ(non_ignorable.size(), 11);
    EXPECT_TRUE(boost::algorithm::equal(non_ignorable.begin(), non_ignorable.end(), ces_non_ignorable, ces_non_ignorable + 11))
        << "from:     " << ce_dumper(cps)
        << "expected: " << ce_dumper(ces_non_ignorable)
        << "got:      " << ce_dumper(non_ignorable);

    // 1F30 0021;	
    // (ἰ) GREEK SMALL LETTER IOTA WITH PSILI	[202C | 0020 0022 | 0002 0002 | FFFF FFFF 0261 |]
    uint32_t const ces_shifted[12] = { 0x202C, 0x0000, 0x0020, 0x0022, 0x0000, 0x0002, 0x0002, 0x0000, 0xFFFF, 0xFFFF, 0x0261, 0x0000 };

    auto const shifted = collate_for_tests(
        cps, cps + 2, boost::text::variable_weighting::shifted);

    EXPECT_EQ(shifted.size(), 12);
    EXPECT_TRUE(boost::algorithm::equal(shifted.begin(), shifted.end(), ces_shifted, ces_shifted + 12))
        << "from:     " << ce_dumper(cps)
        << "expected: " << ce_dumper(ces_shifted)
        << "got:      " << ce_dumper(shifted);
}

TEST(collation, verbatim_131_039)
{
    uint32_t const cps[2] = { 0x1F38, 0x0021 };

    // 1F38 0021;	
    // (Ἰ) GREEK CAPITAL LETTER IOTA WITH PSILI	[202C 0261 | 0020 0022 0020 | 0008 0002 0002 |]
    uint32_t const ces_non_ignorable[11] = { 0x202C, 0x0261, 0x0000, 0x0020, 0x0022, 0x0020, 0x0000, 0x0008, 0x0002, 0x0002, 0x0000 };

    auto const non_ignorable = collate_for_tests(
        cps, cps + 2, boost::text::variable_weighting::non_ignorable);

    EXPECT_EQ(non_ignorable.size(), 11);
    EXPECT_TRUE(boost::algorithm::equal(non_ignorable.begin(), non_ignorable.end(), ces_non_ignorable, ces_non_ignorable + 11))
        << "from:     " << ce_dumper(cps)
        << "expected: " << ce_dumper(ces_non_ignorable)
        << "got:      " << ce_dumper(non_ignorable);

    // 1F38 0021;	
    // (Ἰ) GREEK CAPITAL LETTER IOTA WITH PSILI	[202C | 0020 0022 | 0008 0002 | FFFF FFFF 0261 |]
    uint32_t const ces_shifted[12] = { 0x202C, 0x0000, 0x0020, 0x0022, 0x0000, 0x0008, 0x0002, 0x0000, 0xFFFF, 0xFFFF, 0x0261, 0x0000 };

    auto const shifted = collate_for_tests(
        cps, cps + 2, boost::text::variable_weighting::shifted);

    EXPECT_EQ(shifted.size(), 12);
    EXPECT_TRUE(boost::algorithm::equal(shifted.begin(), shifted.end(), ces_shifted, ces_shifted + 12))
        << "from:     " << ce_dumper(cps)
        << "expected: " << ce_dumper(ces_shifted)
        << "got:      " << ce_dumper(shifted);
}

TEST(collation, verbatim_131_040)
{
    uint32_t const cps[2] = { 0x1F34, 0x0021 };

    // 1F34 0021;	
    // (ἴ) GREEK SMALL LETTER IOTA WITH PSILI AND OXIA	[202C 0261 | 0020 0022 0024 0020 | 0002 0002 0002 0002 |]
    uint32_t const ces_non_ignorable[13] = { 0x202C, 0x0261, 0x0000, 0x0020, 0x0022, 0x0024, 0x0020, 0x0000, 0x0002, 0x0002, 0x0002, 0x0002, 0x0000 };

    auto const non_ignorable = collate_for_tests(
        cps, cps + 2, boost::text::variable_weighting::non_ignorable);

    EXPECT_EQ(non_ignorable.size(), 13);
    EXPECT_TRUE(boost::algorithm::equal(non_ignorable.begin(), non_ignorable.end(), ces_non_ignorable, ces_non_ignorable + 13))
        << "from:     " << ce_dumper(cps)
        << "expected: " << ce_dumper(ces_non_ignorable)
        << "got:      " << ce_dumper(non_ignorable);

    // 1F34 0021;	
    // (ἴ) GREEK SMALL LETTER IOTA WITH PSILI AND OXIA	[202C | 0020 0022 0024 | 0002 0002 0002 | FFFF FFFF FFFF 0261 |]
    uint32_t const ces_shifted[15] = { 0x202C, 0x0000, 0x0020, 0x0022, 0x0024, 0x0000, 0x0002, 0x0002, 0x0002, 0x0000, 0xFFFF, 0xFFFF, 0xFFFF, 0x0261, 0x0000 };

    auto const shifted = collate_for_tests(
        cps, cps + 2, boost::text::variable_weighting::shifted);

    EXPECT_EQ(shifted.size(), 15);
    EXPECT_TRUE(boost::algorithm::equal(shifted.begin(), shifted.end(), ces_shifted, ces_shifted + 15))
        << "from:     " << ce_dumper(cps)
        << "expected: " << ce_dumper(ces_shifted)
        << "got:      " << ce_dumper(shifted);
}

TEST(collation, verbatim_131_041)
{
    uint32_t const cps[2] = { 0x1F3C, 0x0021 };

    // 1F3C 0021;	
    // (Ἴ) GREEK CAPITAL LETTER IOTA WITH PSILI AND OXIA	[202C 0261 | 0020 0022 0024 0020 | 0008 0002 0002 0002 |]
    uint32_t const ces_non_ignorable[13] = { 0x202C, 0x0261, 0x0000, 0x0020, 0x0022, 0x0024, 0x0020, 0x0000, 0x0008, 0x0002, 0x0002, 0x0002, 0x0000 };

    auto const non_ignorable = collate_for_tests(
        cps, cps + 2, boost::text::variable_weighting::non_ignorable);

    EXPECT_EQ(non_ignorable.size(), 13);
    EXPECT_TRUE(boost::algorithm::equal(non_ignorable.begin(), non_ignorable.end(), ces_non_ignorable, ces_non_ignorable + 13))
        << "from:     " << ce_dumper(cps)
        << "expected: " << ce_dumper(ces_non_ignorable)
        << "got:      " << ce_dumper(non_ignorable);

    // 1F3C 0021;	
    // (Ἴ) GREEK CAPITAL LETTER IOTA WITH PSILI AND OXIA	[202C | 0020 0022 0024 | 0008 0002 0002 | FFFF FFFF FFFF 0261 |]
    uint32_t const ces_shifted[15] = { 0x202C, 0x0000, 0x0020, 0x0022, 0x0024, 0x0000, 0x0008, 0x0002, 0x0002, 0x0000, 0xFFFF, 0xFFFF, 0xFFFF, 0x0261, 0x0000 };

    auto const shifted = collate_for_tests(
        cps, cps + 2, boost::text::variable_weighting::shifted);

    EXPECT_EQ(shifted.size(), 15);
    EXPECT_TRUE(boost::algorithm::equal(shifted.begin(), shifted.end(), ces_shifted, ces_shifted + 15))
        << "from:     " << ce_dumper(cps)
        << "expected: " << ce_dumper(ces_shifted)
        << "got:      " << ce_dumper(shifted);
}

TEST(collation, verbatim_131_042)
{
    uint32_t const cps[2] = { 0x1F32, 0x0021 };

    // 1F32 0021;	
    // (ἲ) GREEK SMALL LETTER IOTA WITH PSILI AND VARIA	[202C 0261 | 0020 0022 0025 0020 | 0002 0002 0002 0002 |]
    uint32_t const ces_non_ignorable[13] = { 0x202C, 0x0261, 0x0000, 0x0020, 0x0022, 0x0025, 0x0020, 0x0000, 0x0002, 0x0002, 0x0002, 0x0002, 0x0000 };

    auto const non_ignorable = collate_for_tests(
        cps, cps + 2, boost::text::variable_weighting::non_ignorable);

    EXPECT_EQ(non_ignorable.size(), 13);
    EXPECT_TRUE(boost::algorithm::equal(non_ignorable.begin(), non_ignorable.end(), ces_non_ignorable, ces_non_ignorable + 13))
        << "from:     " << ce_dumper(cps)
        << "expected: " << ce_dumper(ces_non_ignorable)
        << "got:      " << ce_dumper(non_ignorable);

    // 1F32 0021;	
    // (ἲ) GREEK SMALL LETTER IOTA WITH PSILI AND VARIA	[202C | 0020 0022 0025 | 0002 0002 0002 | FFFF FFFF FFFF 0261 |]
    uint32_t const ces_shifted[15] = { 0x202C, 0x0000, 0x0020, 0x0022, 0x0025, 0x0000, 0x0002, 0x0002, 0x0002, 0x0000, 0xFFFF, 0xFFFF, 0xFFFF, 0x0261, 0x0000 };

    auto const shifted = collate_for_tests(
        cps, cps + 2, boost::text::variable_weighting::shifted);

    EXPECT_EQ(shifted.size(), 15);
    EXPECT_TRUE(boost::algorithm::equal(shifted.begin(), shifted.end(), ces_shifted, ces_shifted + 15))
        << "from:     " << ce_dumper(cps)
        << "expected: " << ce_dumper(ces_shifted)
        << "got:      " << ce_dumper(shifted);
}

TEST(collation, verbatim_131_043)
{
    uint32_t const cps[2] = { 0x1F3A, 0x0021 };

    // 1F3A 0021;	
    // (Ἲ) GREEK CAPITAL LETTER IOTA WITH PSILI AND VARIA	[202C 0261 | 0020 0022 0025 0020 | 0008 0002 0002 0002 |]
    uint32_t const ces_non_ignorable[13] = { 0x202C, 0x0261, 0x0000, 0x0020, 0x0022, 0x0025, 0x0020, 0x0000, 0x0008, 0x0002, 0x0002, 0x0002, 0x0000 };

    auto const non_ignorable = collate_for_tests(
        cps, cps + 2, boost::text::variable_weighting::non_ignorable);

    EXPECT_EQ(non_ignorable.size(), 13);
    EXPECT_TRUE(boost::algorithm::equal(non_ignorable.begin(), non_ignorable.end(), ces_non_ignorable, ces_non_ignorable + 13))
        << "from:     " << ce_dumper(cps)
        << "expected: " << ce_dumper(ces_non_ignorable)
        << "got:      " << ce_dumper(non_ignorable);

    // 1F3A 0021;	
    // (Ἲ) GREEK CAPITAL LETTER IOTA WITH PSILI AND VARIA	[202C | 0020 0022 0025 | 0008 0002 0002 | FFFF FFFF FFFF 0261 |]
    uint32_t const ces_shifted[15] = { 0x202C, 0x0000, 0x0020, 0x0022, 0x0025, 0x0000, 0x0008, 0x0002, 0x0002, 0x0000, 0xFFFF, 0xFFFF, 0xFFFF, 0x0261, 0x0000 };

    auto const shifted = collate_for_tests(
        cps, cps + 2, boost::text::variable_weighting::shifted);

    EXPECT_EQ(shifted.size(), 15);
    EXPECT_TRUE(boost::algorithm::equal(shifted.begin(), shifted.end(), ces_shifted, ces_shifted + 15))
        << "from:     " << ce_dumper(cps)
        << "expected: " << ce_dumper(ces_shifted)
        << "got:      " << ce_dumper(shifted);
}

TEST(collation, verbatim_131_044)
{
    uint32_t const cps[2] = { 0x1F36, 0x0021 };

    // 1F36 0021;	
    // (ἶ) GREEK SMALL LETTER IOTA WITH PSILI AND PERISPOMENI	[202C 0261 | 0020 0022 002A 0020 | 0002 0002 0002 0002 |]
    uint32_t const ces_non_ignorable[13] = { 0x202C, 0x0261, 0x0000, 0x0020, 0x0022, 0x002A, 0x0020, 0x0000, 0x0002, 0x0002, 0x0002, 0x0002, 0x0000 };

    auto const non_ignorable = collate_for_tests(
        cps, cps + 2, boost::text::variable_weighting::non_ignorable);

    EXPECT_EQ(non_ignorable.size(), 13);
    EXPECT_TRUE(boost::algorithm::equal(non_ignorable.begin(), non_ignorable.end(), ces_non_ignorable, ces_non_ignorable + 13))
        << "from:     " << ce_dumper(cps)
        << "expected: " << ce_dumper(ces_non_ignorable)
        << "got:      " << ce_dumper(non_ignorable);

    // 1F36 0021;	
    // (ἶ) GREEK SMALL LETTER IOTA WITH PSILI AND PERISPOMENI	[202C | 0020 0022 002A | 0002 0002 0002 | FFFF FFFF FFFF 0261 |]
    uint32_t const ces_shifted[15] = { 0x202C, 0x0000, 0x0020, 0x0022, 0x002A, 0x0000, 0x0002, 0x0002, 0x0002, 0x0000, 0xFFFF, 0xFFFF, 0xFFFF, 0x0261, 0x0000 };

    auto const shifted = collate_for_tests(
        cps, cps + 2, boost::text::variable_weighting::shifted);

    EXPECT_EQ(shifted.size(), 15);
    EXPECT_TRUE(boost::algorithm::equal(shifted.begin(), shifted.end(), ces_shifted, ces_shifted + 15))
        << "from:     " << ce_dumper(cps)
        << "expected: " << ce_dumper(ces_shifted)
        << "got:      " << ce_dumper(shifted);
}

TEST(collation, verbatim_131_045)
{
    uint32_t const cps[2] = { 0x1F3E, 0x0021 };

    // 1F3E 0021;	
    // (Ἶ) GREEK CAPITAL LETTER IOTA WITH PSILI AND PERISPOMENI	[202C 0261 | 0020 0022 002A 0020 | 0008 0002 0002 0002 |]
    uint32_t const ces_non_ignorable[13] = { 0x202C, 0x0261, 0x0000, 0x0020, 0x0022, 0x002A, 0x0020, 0x0000, 0x0008, 0x0002, 0x0002, 0x0002, 0x0000 };

    auto const non_ignorable = collate_for_tests(
        cps, cps + 2, boost::text::variable_weighting::non_ignorable);

    EXPECT_EQ(non_ignorable.size(), 13);
    EXPECT_TRUE(boost::algorithm::equal(non_ignorable.begin(), non_ignorable.end(), ces_non_ignorable, ces_non_ignorable + 13))
        << "from:     " << ce_dumper(cps)
        << "expected: " << ce_dumper(ces_non_ignorable)
        << "got:      " << ce_dumper(non_ignorable);

    // 1F3E 0021;	
    // (Ἶ) GREEK CAPITAL LETTER IOTA WITH PSILI AND PERISPOMENI	[202C | 0020 0022 002A | 0008 0002 0002 | FFFF FFFF FFFF 0261 |]
    uint32_t const ces_shifted[15] = { 0x202C, 0x0000, 0x0020, 0x0022, 0x002A, 0x0000, 0x0008, 0x0002, 0x0002, 0x0000, 0xFFFF, 0xFFFF, 0xFFFF, 0x0261, 0x0000 };

    auto const shifted = collate_for_tests(
        cps, cps + 2, boost::text::variable_weighting::shifted);

    EXPECT_EQ(shifted.size(), 15);
    EXPECT_TRUE(boost::algorithm::equal(shifted.begin(), shifted.end(), ces_shifted, ces_shifted + 15))
        << "from:     " << ce_dumper(cps)
        << "expected: " << ce_dumper(ces_shifted)
        << "got:      " << ce_dumper(shifted);
}

TEST(collation, verbatim_131_046)
{
    uint32_t const cps[2] = { 0x1F31, 0x0021 };

    // 1F31 0021;	
    // (ἱ) GREEK SMALL LETTER IOTA WITH DASIA	[202C 0261 | 0020 0023 0020 | 0002 0002 0002 |]
    uint32_t const ces_non_ignorable[11] = { 0x202C, 0x0261, 0x0000, 0x0020, 0x0023, 0x0020, 0x0000, 0x0002, 0x0002, 0x0002, 0x0000 };

    auto const non_ignorable = collate_for_tests(
        cps, cps + 2, boost::text::variable_weighting::non_ignorable);

    EXPECT_EQ(non_ignorable.size(), 11);
    EXPECT_TRUE(boost::algorithm::equal(non_ignorable.begin(), non_ignorable.end(), ces_non_ignorable, ces_non_ignorable + 11))
        << "from:     " << ce_dumper(cps)
        << "expected: " << ce_dumper(ces_non_ignorable)
        << "got:      " << ce_dumper(non_ignorable);

    // 1F31 0021;	
    // (ἱ) GREEK SMALL LETTER IOTA WITH DASIA	[202C | 0020 0023 | 0002 0002 | FFFF FFFF 0261 |]
    uint32_t const ces_shifted[12] = { 0x202C, 0x0000, 0x0020, 0x0023, 0x0000, 0x0002, 0x0002, 0x0000, 0xFFFF, 0xFFFF, 0x0261, 0x0000 };

    auto const shifted = collate_for_tests(
        cps, cps + 2, boost::text::variable_weighting::shifted);

    EXPECT_EQ(shifted.size(), 12);
    EXPECT_TRUE(boost::algorithm::equal(shifted.begin(), shifted.end(), ces_shifted, ces_shifted + 12))
        << "from:     " << ce_dumper(cps)
        << "expected: " << ce_dumper(ces_shifted)
        << "got:      " << ce_dumper(shifted);
}

TEST(collation, verbatim_131_047)
{
    uint32_t const cps[2] = { 0x1F39, 0x0021 };

    // 1F39 0021;	
    // (Ἱ) GREEK CAPITAL LETTER IOTA WITH DASIA	[202C 0261 | 0020 0023 0020 | 0008 0002 0002 |]
    uint32_t const ces_non_ignorable[11] = { 0x202C, 0x0261, 0x0000, 0x0020, 0x0023, 0x0020, 0x0000, 0x0008, 0x0002, 0x0002, 0x0000 };

    auto const non_ignorable = collate_for_tests(
        cps, cps + 2, boost::text::variable_weighting::non_ignorable);

    EXPECT_EQ(non_ignorable.size(), 11);
    EXPECT_TRUE(boost::algorithm::equal(non_ignorable.begin(), non_ignorable.end(), ces_non_ignorable, ces_non_ignorable + 11))
        << "from:     " << ce_dumper(cps)
        << "expected: " << ce_dumper(ces_non_ignorable)
        << "got:      " << ce_dumper(non_ignorable);

    // 1F39 0021;	
    // (Ἱ) GREEK CAPITAL LETTER IOTA WITH DASIA	[202C | 0020 0023 | 0008 0002 | FFFF FFFF 0261 |]
    uint32_t const ces_shifted[12] = { 0x202C, 0x0000, 0x0020, 0x0023, 0x0000, 0x0008, 0x0002, 0x0000, 0xFFFF, 0xFFFF, 0x0261, 0x0000 };

    auto const shifted = collate_for_tests(
        cps, cps + 2, boost::text::variable_weighting::shifted);

    EXPECT_EQ(shifted.size(), 12);
    EXPECT_TRUE(boost::algorithm::equal(shifted.begin(), shifted.end(), ces_shifted, ces_shifted + 12))
        << "from:     " << ce_dumper(cps)
        << "expected: " << ce_dumper(ces_shifted)
        << "got:      " << ce_dumper(shifted);
}

TEST(collation, verbatim_131_048)
{
    uint32_t const cps[2] = { 0x1F35, 0x0021 };

    // 1F35 0021;	
    // (ἵ) GREEK SMALL LETTER IOTA WITH DASIA AND OXIA	[202C 0261 | 0020 0023 0024 0020 | 0002 0002 0002 0002 |]
    uint32_t const ces_non_ignorable[13] = { 0x202C, 0x0261, 0x0000, 0x0020, 0x0023, 0x0024, 0x0020, 0x0000, 0x0002, 0x0002, 0x0002, 0x0002, 0x0000 };

    auto const non_ignorable = collate_for_tests(
        cps, cps + 2, boost::text::variable_weighting::non_ignorable);

    EXPECT_EQ(non_ignorable.size(), 13);
    EXPECT_TRUE(boost::algorithm::equal(non_ignorable.begin(), non_ignorable.end(), ces_non_ignorable, ces_non_ignorable + 13))
        << "from:     " << ce_dumper(cps)
        << "expected: " << ce_dumper(ces_non_ignorable)
        << "got:      " << ce_dumper(non_ignorable);

    // 1F35 0021;	
    // (ἵ) GREEK SMALL LETTER IOTA WITH DASIA AND OXIA	[202C | 0020 0023 0024 | 0002 0002 0002 | FFFF FFFF FFFF 0261 |]
    uint32_t const ces_shifted[15] = { 0x202C, 0x0000, 0x0020, 0x0023, 0x0024, 0x0000, 0x0002, 0x0002, 0x0002, 0x0000, 0xFFFF, 0xFFFF, 0xFFFF, 0x0261, 0x0000 };

    auto const shifted = collate_for_tests(
        cps, cps + 2, boost::text::variable_weighting::shifted);

    EXPECT_EQ(shifted.size(), 15);
    EXPECT_TRUE(boost::algorithm::equal(shifted.begin(), shifted.end(), ces_shifted, ces_shifted + 15))
        << "from:     " << ce_dumper(cps)
        << "expected: " << ce_dumper(ces_shifted)
        << "got:      " << ce_dumper(shifted);
}

TEST(collation, verbatim_131_049)
{
    uint32_t const cps[2] = { 0x1F3D, 0x0021 };

    // 1F3D 0021;	
    // (Ἵ) GREEK CAPITAL LETTER IOTA WITH DASIA AND OXIA	[202C 0261 | 0020 0023 0024 0020 | 0008 0002 0002 0002 |]
    uint32_t const ces_non_ignorable[13] = { 0x202C, 0x0261, 0x0000, 0x0020, 0x0023, 0x0024, 0x0020, 0x0000, 0x0008, 0x0002, 0x0002, 0x0002, 0x0000 };

    auto const non_ignorable = collate_for_tests(
        cps, cps + 2, boost::text::variable_weighting::non_ignorable);

    EXPECT_EQ(non_ignorable.size(), 13);
    EXPECT_TRUE(boost::algorithm::equal(non_ignorable.begin(), non_ignorable.end(), ces_non_ignorable, ces_non_ignorable + 13))
        << "from:     " << ce_dumper(cps)
        << "expected: " << ce_dumper(ces_non_ignorable)
        << "got:      " << ce_dumper(non_ignorable);

    // 1F3D 0021;	
    // (Ἵ) GREEK CAPITAL LETTER IOTA WITH DASIA AND OXIA	[202C | 0020 0023 0024 | 0008 0002 0002 | FFFF FFFF FFFF 0261 |]
    uint32_t const ces_shifted[15] = { 0x202C, 0x0000, 0x0020, 0x0023, 0x0024, 0x0000, 0x0008, 0x0002, 0x0002, 0x0000, 0xFFFF, 0xFFFF, 0xFFFF, 0x0261, 0x0000 };

    auto const shifted = collate_for_tests(
        cps, cps + 2, boost::text::variable_weighting::shifted);

    EXPECT_EQ(shifted.size(), 15);
    EXPECT_TRUE(boost::algorithm::equal(shifted.begin(), shifted.end(), ces_shifted, ces_shifted + 15))
        << "from:     " << ce_dumper(cps)
        << "expected: " << ce_dumper(ces_shifted)
        << "got:      " << ce_dumper(shifted);
}

TEST(collation, verbatim_131_050)
{
    uint32_t const cps[2] = { 0x1F33, 0x0021 };

    // 1F33 0021;	
    // (ἳ) GREEK SMALL LETTER IOTA WITH DASIA AND VARIA	[202C 0261 | 0020 0023 0025 0020 | 0002 0002 0002 0002 |]
    uint32_t const ces_non_ignorable[13] = { 0x202C, 0x0261, 0x0000, 0x0020, 0x0023, 0x0025, 0x0020, 0x0000, 0x0002, 0x0002, 0x0002, 0x0002, 0x0000 };

    auto const non_ignorable = collate_for_tests(
        cps, cps + 2, boost::text::variable_weighting::non_ignorable);

    EXPECT_EQ(non_ignorable.size(), 13);
    EXPECT_TRUE(boost::algorithm::equal(non_ignorable.begin(), non_ignorable.end(), ces_non_ignorable, ces_non_ignorable + 13))
        << "from:     " << ce_dumper(cps)
        << "expected: " << ce_dumper(ces_non_ignorable)
        << "got:      " << ce_dumper(non_ignorable);

    // 1F33 0021;	
    // (ἳ) GREEK SMALL LETTER IOTA WITH DASIA AND VARIA	[202C | 0020 0023 0025 | 0002 0002 0002 | FFFF FFFF FFFF 0261 |]
    uint32_t const ces_shifted[15] = { 0x202C, 0x0000, 0x0020, 0x0023, 0x0025, 0x0000, 0x0002, 0x0002, 0x0002, 0x0000, 0xFFFF, 0xFFFF, 0xFFFF, 0x0261, 0x0000 };

    auto const shifted = collate_for_tests(
        cps, cps + 2, boost::text::variable_weighting::shifted);

    EXPECT_EQ(shifted.size(), 15);
    EXPECT_TRUE(boost::algorithm::equal(shifted.begin(), shifted.end(), ces_shifted, ces_shifted + 15))
        << "from:     " << ce_dumper(cps)
        << "expected: " << ce_dumper(ces_shifted)
        << "got:      " << ce_dumper(shifted);
}

TEST(collation, verbatim_131_051)
{
    uint32_t const cps[2] = { 0x1F3B, 0x0021 };

    // 1F3B 0021;	
    // (Ἳ) GREEK CAPITAL LETTER IOTA WITH DASIA AND VARIA	[202C 0261 | 0020 0023 0025 0020 | 0008 0002 0002 0002 |]
    uint32_t const ces_non_ignorable[13] = { 0x202C, 0x0261, 0x0000, 0x0020, 0x0023, 0x0025, 0x0020, 0x0000, 0x0008, 0x0002, 0x0002, 0x0002, 0x0000 };

    auto const non_ignorable = collate_for_tests(
        cps, cps + 2, boost::text::variable_weighting::non_ignorable);

    EXPECT_EQ(non_ignorable.size(), 13);
    EXPECT_TRUE(boost::algorithm::equal(non_ignorable.begin(), non_ignorable.end(), ces_non_ignorable, ces_non_ignorable + 13))
        << "from:     " << ce_dumper(cps)
        << "expected: " << ce_dumper(ces_non_ignorable)
        << "got:      " << ce_dumper(non_ignorable);

    // 1F3B 0021;	
    // (Ἳ) GREEK CAPITAL LETTER IOTA WITH DASIA AND VARIA	[202C | 0020 0023 0025 | 0008 0002 0002 | FFFF FFFF FFFF 0261 |]
    uint32_t const ces_shifted[15] = { 0x202C, 0x0000, 0x0020, 0x0023, 0x0025, 0x0000, 0x0008, 0x0002, 0x0002, 0x0000, 0xFFFF, 0xFFFF, 0xFFFF, 0x0261, 0x0000 };

    auto const shifted = collate_for_tests(
        cps, cps + 2, boost::text::variable_weighting::shifted);

    EXPECT_EQ(shifted.size(), 15);
    EXPECT_TRUE(boost::algorithm::equal(shifted.begin(), shifted.end(), ces_shifted, ces_shifted + 15))
        << "from:     " << ce_dumper(cps)
        << "expected: " << ce_dumper(ces_shifted)
        << "got:      " << ce_dumper(shifted);
}

TEST(collation, verbatim_131_052)
{
    uint32_t const cps[2] = { 0x1F37, 0x0021 };

    // 1F37 0021;	
    // (ἷ) GREEK SMALL LETTER IOTA WITH DASIA AND PERISPOMENI	[202C 0261 | 0020 0023 002A 0020 | 0002 0002 0002 0002 |]
    uint32_t const ces_non_ignorable[13] = { 0x202C, 0x0261, 0x0000, 0x0020, 0x0023, 0x002A, 0x0020, 0x0000, 0x0002, 0x0002, 0x0002, 0x0002, 0x0000 };

    auto const non_ignorable = collate_for_tests(
        cps, cps + 2, boost::text::variable_weighting::non_ignorable);

    EXPECT_EQ(non_ignorable.size(), 13);
    EXPECT_TRUE(boost::algorithm::equal(non_ignorable.begin(), non_ignorable.end(), ces_non_ignorable, ces_non_ignorable + 13))
        << "from:     " << ce_dumper(cps)
        << "expected: " << ce_dumper(ces_non_ignorable)
        << "got:      " << ce_dumper(non_ignorable);

    // 1F37 0021;	
    // (ἷ) GREEK SMALL LETTER IOTA WITH DASIA AND PERISPOMENI	[202C | 0020 0023 002A | 0002 0002 0002 | FFFF FFFF FFFF 0261 |]
    uint32_t const ces_shifted[15] = { 0x202C, 0x0000, 0x0020, 0x0023, 0x002A, 0x0000, 0x0002, 0x0002, 0x0002, 0x0000, 0xFFFF, 0xFFFF, 0xFFFF, 0x0261, 0x0000 };

    auto const shifted = collate_for_tests(
        cps, cps + 2, boost::text::variable_weighting::shifted);

    EXPECT_EQ(shifted.size(), 15);
    EXPECT_TRUE(boost::algorithm::equal(shifted.begin(), shifted.end(), ces_shifted, ces_shifted + 15))
        << "from:     " << ce_dumper(cps)
        << "expected: " << ce_dumper(ces_shifted)
        << "got:      " << ce_dumper(shifted);
}

TEST(collation, verbatim_131_053)
{
    uint32_t const cps[2] = { 0x1F3F, 0x0021 };

    // 1F3F 0021;	
    // (Ἷ) GREEK CAPITAL LETTER IOTA WITH DASIA AND PERISPOMENI	[202C 0261 | 0020 0023 002A 0020 | 0008 0002 0002 0002 |]
    uint32_t const ces_non_ignorable[13] = { 0x202C, 0x0261, 0x0000, 0x0020, 0x0023, 0x002A, 0x0020, 0x0000, 0x0008, 0x0002, 0x0002, 0x0002, 0x0000 };

    auto const non_ignorable = collate_for_tests(
        cps, cps + 2, boost::text::variable_weighting::non_ignorable);

    EXPECT_EQ(non_ignorable.size(), 13);
    EXPECT_TRUE(boost::algorithm::equal(non_ignorable.begin(), non_ignorable.end(), ces_non_ignorable, ces_non_ignorable + 13))
        << "from:     " << ce_dumper(cps)
        << "expected: " << ce_dumper(ces_non_ignorable)
        << "got:      " << ce_dumper(non_ignorable);

    // 1F3F 0021;	
    // (Ἷ) GREEK CAPITAL LETTER IOTA WITH DASIA AND PERISPOMENI	[202C | 0020 0023 002A | 0008 0002 0002 | FFFF FFFF FFFF 0261 |]
    uint32_t const ces_shifted[15] = { 0x202C, 0x0000, 0x0020, 0x0023, 0x002A, 0x0000, 0x0008, 0x0002, 0x0002, 0x0000, 0xFFFF, 0xFFFF, 0xFFFF, 0x0261, 0x0000 };

    auto const shifted = collate_for_tests(
        cps, cps + 2, boost::text::variable_weighting::shifted);

    EXPECT_EQ(shifted.size(), 15);
    EXPECT_TRUE(boost::algorithm::equal(shifted.begin(), shifted.end(), ces_shifted, ces_shifted + 15))
        << "from:     " << ce_dumper(cps)
        << "expected: " << ce_dumper(ces_shifted)
        << "got:      " << ce_dumper(shifted);
}

TEST(collation, verbatim_131_054)
{
    uint32_t const cps[2] = { 0x03AF, 0x0021 };

    // 03AF 0021;	
    // (ί) GREEK SMALL LETTER IOTA WITH TONOS	[202C 0261 | 0020 0024 0020 | 0002 0002 0002 |]
    uint32_t const ces_non_ignorable[11] = { 0x202C, 0x0261, 0x0000, 0x0020, 0x0024, 0x0020, 0x0000, 0x0002, 0x0002, 0x0002, 0x0000 };

    auto const non_ignorable = collate_for_tests(
        cps, cps + 2, boost::text::variable_weighting::non_ignorable);

    EXPECT_EQ(non_ignorable.size(), 11);
    EXPECT_TRUE(boost::algorithm::equal(non_ignorable.begin(), non_ignorable.end(), ces_non_ignorable, ces_non_ignorable + 11))
        << "from:     " << ce_dumper(cps)
        << "expected: " << ce_dumper(ces_non_ignorable)
        << "got:      " << ce_dumper(non_ignorable);

    // 03AF 0021;	
    // (ί) GREEK SMALL LETTER IOTA WITH TONOS	[202C | 0020 0024 | 0002 0002 | FFFF FFFF 0261 |]
    uint32_t const ces_shifted[12] = { 0x202C, 0x0000, 0x0020, 0x0024, 0x0000, 0x0002, 0x0002, 0x0000, 0xFFFF, 0xFFFF, 0x0261, 0x0000 };

    auto const shifted = collate_for_tests(
        cps, cps + 2, boost::text::variable_weighting::shifted);

    EXPECT_EQ(shifted.size(), 12);
    EXPECT_TRUE(boost::algorithm::equal(shifted.begin(), shifted.end(), ces_shifted, ces_shifted + 12))
        << "from:     " << ce_dumper(cps)
        << "expected: " << ce_dumper(ces_shifted)
        << "got:      " << ce_dumper(shifted);
}

TEST(collation, verbatim_131_055)
{
    uint32_t const cps[2] = { 0x1F77, 0x0021 };

    // 1F77 0021;	
    // (ί) GREEK SMALL LETTER IOTA WITH OXIA	[202C 0261 | 0020 0024 0020 | 0002 0002 0002 |]
    uint32_t const ces_non_ignorable[11] = { 0x202C, 0x0261, 0x0000, 0x0020, 0x0024, 0x0020, 0x0000, 0x0002, 0x0002, 0x0002, 0x0000 };

    auto const non_ignorable = collate_for_tests(
        cps, cps + 2, boost::text::variable_weighting::non_ignorable);

    EXPECT_EQ(non_ignorable.size(), 11);
    EXPECT_TRUE(boost::algorithm::equal(non_ignorable.begin(), non_ignorable.end(), ces_non_ignorable, ces_non_ignorable + 11))
        << "from:     " << ce_dumper(cps)
        << "expected: " << ce_dumper(ces_non_ignorable)
        << "got:      " << ce_dumper(non_ignorable);

    // 1F77 0021;	
    // (ί) GREEK SMALL LETTER IOTA WITH OXIA	[202C | 0020 0024 | 0002 0002 | FFFF FFFF 0261 |]
    uint32_t const ces_shifted[12] = { 0x202C, 0x0000, 0x0020, 0x0024, 0x0000, 0x0002, 0x0002, 0x0000, 0xFFFF, 0xFFFF, 0x0261, 0x0000 };

    auto const shifted = collate_for_tests(
        cps, cps + 2, boost::text::variable_weighting::shifted);

    EXPECT_EQ(shifted.size(), 12);
    EXPECT_TRUE(boost::algorithm::equal(shifted.begin(), shifted.end(), ces_shifted, ces_shifted + 12))
        << "from:     " << ce_dumper(cps)
        << "expected: " << ce_dumper(ces_shifted)
        << "got:      " << ce_dumper(shifted);
}

TEST(collation, verbatim_131_056)
{
    uint32_t const cps[2] = { 0x038A, 0x0021 };

    // 038A 0021;	
    // (Ί) GREEK CAPITAL LETTER IOTA WITH TONOS	[202C 0261 | 0020 0024 0020 | 0008 0002 0002 |]
    uint32_t const ces_non_ignorable[11] = { 0x202C, 0x0261, 0x0000, 0x0020, 0x0024, 0x0020, 0x0000, 0x0008, 0x0002, 0x0002, 0x0000 };

    auto const non_ignorable = collate_for_tests(
        cps, cps + 2, boost::text::variable_weighting::non_ignorable);

    EXPECT_EQ(non_ignorable.size(), 11);
    EXPECT_TRUE(boost::algorithm::equal(non_ignorable.begin(), non_ignorable.end(), ces_non_ignorable, ces_non_ignorable + 11))
        << "from:     " << ce_dumper(cps)
        << "expected: " << ce_dumper(ces_non_ignorable)
        << "got:      " << ce_dumper(non_ignorable);

    // 038A 0021;	
    // (Ί) GREEK CAPITAL LETTER IOTA WITH TONOS	[202C | 0020 0024 | 0008 0002 | FFFF FFFF 0261 |]
    uint32_t const ces_shifted[12] = { 0x202C, 0x0000, 0x0020, 0x0024, 0x0000, 0x0008, 0x0002, 0x0000, 0xFFFF, 0xFFFF, 0x0261, 0x0000 };

    auto const shifted = collate_for_tests(
        cps, cps + 2, boost::text::variable_weighting::shifted);

    EXPECT_EQ(shifted.size(), 12);
    EXPECT_TRUE(boost::algorithm::equal(shifted.begin(), shifted.end(), ces_shifted, ces_shifted + 12))
        << "from:     " << ce_dumper(cps)
        << "expected: " << ce_dumper(ces_shifted)
        << "got:      " << ce_dumper(shifted);
}

TEST(collation, verbatim_131_057)
{
    uint32_t const cps[2] = { 0x1FDB, 0x0021 };

    // 1FDB 0021;	
    // (Ί) GREEK CAPITAL LETTER IOTA WITH OXIA	[202C 0261 | 0020 0024 0020 | 0008 0002 0002 |]
    uint32_t const ces_non_ignorable[11] = { 0x202C, 0x0261, 0x0000, 0x0020, 0x0024, 0x0020, 0x0000, 0x0008, 0x0002, 0x0002, 0x0000 };

    auto const non_ignorable = collate_for_tests(
        cps, cps + 2, boost::text::variable_weighting::non_ignorable);

    EXPECT_EQ(non_ignorable.size(), 11);
    EXPECT_TRUE(boost::algorithm::equal(non_ignorable.begin(), non_ignorable.end(), ces_non_ignorable, ces_non_ignorable + 11))
        << "from:     " << ce_dumper(cps)
        << "expected: " << ce_dumper(ces_non_ignorable)
        << "got:      " << ce_dumper(non_ignorable);

    // 1FDB 0021;	
    // (Ί) GREEK CAPITAL LETTER IOTA WITH OXIA	[202C | 0020 0024 | 0008 0002 | FFFF FFFF 0261 |]
    uint32_t const ces_shifted[12] = { 0x202C, 0x0000, 0x0020, 0x0024, 0x0000, 0x0008, 0x0002, 0x0000, 0xFFFF, 0xFFFF, 0x0261, 0x0000 };

    auto const shifted = collate_for_tests(
        cps, cps + 2, boost::text::variable_weighting::shifted);

    EXPECT_EQ(shifted.size(), 12);
    EXPECT_TRUE(boost::algorithm::equal(shifted.begin(), shifted.end(), ces_shifted, ces_shifted + 12))
        << "from:     " << ce_dumper(cps)
        << "expected: " << ce_dumper(ces_shifted)
        << "got:      " << ce_dumper(shifted);
}

TEST(collation, verbatim_131_058)
{
    uint32_t const cps[2] = { 0x1F76, 0x0021 };

    // 1F76 0021;	
    // (ὶ) GREEK SMALL LETTER IOTA WITH VARIA	[202C 0261 | 0020 0025 0020 | 0002 0002 0002 |]
    uint32_t const ces_non_ignorable[11] = { 0x202C, 0x0261, 0x0000, 0x0020, 0x0025, 0x0020, 0x0000, 0x0002, 0x0002, 0x0002, 0x0000 };

    auto const non_ignorable = collate_for_tests(
        cps, cps + 2, boost::text::variable_weighting::non_ignorable);

    EXPECT_EQ(non_ignorable.size(), 11);
    EXPECT_TRUE(boost::algorithm::equal(non_ignorable.begin(), non_ignorable.end(), ces_non_ignorable, ces_non_ignorable + 11))
        << "from:     " << ce_dumper(cps)
        << "expected: " << ce_dumper(ces_non_ignorable)
        << "got:      " << ce_dumper(non_ignorable);

    // 1F76 0021;	
    // (ὶ) GREEK SMALL LETTER IOTA WITH VARIA	[202C | 0020 0025 | 0002 0002 | FFFF FFFF 0261 |]
    uint32_t const ces_shifted[12] = { 0x202C, 0x0000, 0x0020, 0x0025, 0x0000, 0x0002, 0x0002, 0x0000, 0xFFFF, 0xFFFF, 0x0261, 0x0000 };

    auto const shifted = collate_for_tests(
        cps, cps + 2, boost::text::variable_weighting::shifted);

    EXPECT_EQ(shifted.size(), 12);
    EXPECT_TRUE(boost::algorithm::equal(shifted.begin(), shifted.end(), ces_shifted, ces_shifted + 12))
        << "from:     " << ce_dumper(cps)
        << "expected: " << ce_dumper(ces_shifted)
        << "got:      " << ce_dumper(shifted);
}

TEST(collation, verbatim_131_059)
{
    uint32_t const cps[2] = { 0x1FDA, 0x0021 };

    // 1FDA 0021;	
    // (Ὶ) GREEK CAPITAL LETTER IOTA WITH VARIA	[202C 0261 | 0020 0025 0020 | 0008 0002 0002 |]
    uint32_t const ces_non_ignorable[11] = { 0x202C, 0x0261, 0x0000, 0x0020, 0x0025, 0x0020, 0x0000, 0x0008, 0x0002, 0x0002, 0x0000 };

    auto const non_ignorable = collate_for_tests(
        cps, cps + 2, boost::text::variable_weighting::non_ignorable);

    EXPECT_EQ(non_ignorable.size(), 11);
    EXPECT_TRUE(boost::algorithm::equal(non_ignorable.begin(), non_ignorable.end(), ces_non_ignorable, ces_non_ignorable + 11))
        << "from:     " << ce_dumper(cps)
        << "expected: " << ce_dumper(ces_non_ignorable)
        << "got:      " << ce_dumper(non_ignorable);

    // 1FDA 0021;	
    // (Ὶ) GREEK CAPITAL LETTER IOTA WITH VARIA	[202C | 0020 0025 | 0008 0002 | FFFF FFFF 0261 |]
    uint32_t const ces_shifted[12] = { 0x202C, 0x0000, 0x0020, 0x0025, 0x0000, 0x0008, 0x0002, 0x0000, 0xFFFF, 0xFFFF, 0x0261, 0x0000 };

    auto const shifted = collate_for_tests(
        cps, cps + 2, boost::text::variable_weighting::shifted);

    EXPECT_EQ(shifted.size(), 12);
    EXPECT_TRUE(boost::algorithm::equal(shifted.begin(), shifted.end(), ces_shifted, ces_shifted + 12))
        << "from:     " << ce_dumper(cps)
        << "expected: " << ce_dumper(ces_shifted)
        << "got:      " << ce_dumper(shifted);
}

TEST(collation, verbatim_131_060)
{
    uint32_t const cps[2] = { 0x1FD0, 0x0021 };

    // 1FD0 0021;	
    // (ῐ) GREEK SMALL LETTER IOTA WITH VRACHY	[202C 0261 | 0020 0026 0020 | 0002 0002 0002 |]
    uint32_t const ces_non_ignorable[11] = { 0x202C, 0x0261, 0x0000, 0x0020, 0x0026, 0x0020, 0x0000, 0x0002, 0x0002, 0x0002, 0x0000 };

    auto const non_ignorable = collate_for_tests(
        cps, cps + 2, boost::text::variable_weighting::non_ignorable);

    EXPECT_EQ(non_ignorable.size(), 11);
    EXPECT_TRUE(boost::algorithm::equal(non_ignorable.begin(), non_ignorable.end(), ces_non_ignorable, ces_non_ignorable + 11))
        << "from:     " << ce_dumper(cps)
        << "expected: " << ce_dumper(ces_non_ignorable)
        << "got:      " << ce_dumper(non_ignorable);

    // 1FD0 0021;	
    // (ῐ) GREEK SMALL LETTER IOTA WITH VRACHY	[202C | 0020 0026 | 0002 0002 | FFFF FFFF 0261 |]
    uint32_t const ces_shifted[12] = { 0x202C, 0x0000, 0x0020, 0x0026, 0x0000, 0x0002, 0x0002, 0x0000, 0xFFFF, 0xFFFF, 0x0261, 0x0000 };

    auto const shifted = collate_for_tests(
        cps, cps + 2, boost::text::variable_weighting::shifted);

    EXPECT_EQ(shifted.size(), 12);
    EXPECT_TRUE(boost::algorithm::equal(shifted.begin(), shifted.end(), ces_shifted, ces_shifted + 12))
        << "from:     " << ce_dumper(cps)
        << "expected: " << ce_dumper(ces_shifted)
        << "got:      " << ce_dumper(shifted);
}

TEST(collation, verbatim_131_061)
{
    uint32_t const cps[2] = { 0x1FD8, 0x0021 };

    // 1FD8 0021;	
    // (Ῐ) GREEK CAPITAL LETTER IOTA WITH VRACHY	[202C 0261 | 0020 0026 0020 | 0008 0002 0002 |]
    uint32_t const ces_non_ignorable[11] = { 0x202C, 0x0261, 0x0000, 0x0020, 0x0026, 0x0020, 0x0000, 0x0008, 0x0002, 0x0002, 0x0000 };

    auto const non_ignorable = collate_for_tests(
        cps, cps + 2, boost::text::variable_weighting::non_ignorable);

    EXPECT_EQ(non_ignorable.size(), 11);
    EXPECT_TRUE(boost::algorithm::equal(non_ignorable.begin(), non_ignorable.end(), ces_non_ignorable, ces_non_ignorable + 11))
        << "from:     " << ce_dumper(cps)
        << "expected: " << ce_dumper(ces_non_ignorable)
        << "got:      " << ce_dumper(non_ignorable);

    // 1FD8 0021;	
    // (Ῐ) GREEK CAPITAL LETTER IOTA WITH VRACHY	[202C | 0020 0026 | 0008 0002 | FFFF FFFF 0261 |]
    uint32_t const ces_shifted[12] = { 0x202C, 0x0000, 0x0020, 0x0026, 0x0000, 0x0008, 0x0002, 0x0000, 0xFFFF, 0xFFFF, 0x0261, 0x0000 };

    auto const shifted = collate_for_tests(
        cps, cps + 2, boost::text::variable_weighting::shifted);

    EXPECT_EQ(shifted.size(), 12);
    EXPECT_TRUE(boost::algorithm::equal(shifted.begin(), shifted.end(), ces_shifted, ces_shifted + 12))
        << "from:     " << ce_dumper(cps)
        << "expected: " << ce_dumper(ces_shifted)
        << "got:      " << ce_dumper(shifted);
}

TEST(collation, verbatim_131_062)
{
    uint32_t const cps[2] = { 0x1FD6, 0x0021 };

    // 1FD6 0021;	
    // (ῖ) GREEK SMALL LETTER IOTA WITH PERISPOMENI	[202C 0261 | 0020 002A 0020 | 0002 0002 0002 |]
    uint32_t const ces_non_ignorable[11] = { 0x202C, 0x0261, 0x0000, 0x0020, 0x002A, 0x0020, 0x0000, 0x0002, 0x0002, 0x0002, 0x0000 };

    auto const non_ignorable = collate_for_tests(
        cps, cps + 2, boost::text::variable_weighting::non_ignorable);

    EXPECT_EQ(non_ignorable.size(), 11);
    EXPECT_TRUE(boost::algorithm::equal(non_ignorable.begin(), non_ignorable.end(), ces_non_ignorable, ces_non_ignorable + 11))
        << "from:     " << ce_dumper(cps)
        << "expected: " << ce_dumper(ces_non_ignorable)
        << "got:      " << ce_dumper(non_ignorable);

    // 1FD6 0021;	
    // (ῖ) GREEK SMALL LETTER IOTA WITH PERISPOMENI	[202C | 0020 002A | 0002 0002 | FFFF FFFF 0261 |]
    uint32_t const ces_shifted[12] = { 0x202C, 0x0000, 0x0020, 0x002A, 0x0000, 0x0002, 0x0002, 0x0000, 0xFFFF, 0xFFFF, 0x0261, 0x0000 };

    auto const shifted = collate_for_tests(
        cps, cps + 2, boost::text::variable_weighting::shifted);

    EXPECT_EQ(shifted.size(), 12);
    EXPECT_TRUE(boost::algorithm::equal(shifted.begin(), shifted.end(), ces_shifted, ces_shifted + 12))
        << "from:     " << ce_dumper(cps)
        << "expected: " << ce_dumper(ces_shifted)
        << "got:      " << ce_dumper(shifted);
}

TEST(collation, verbatim_131_063)
{
    uint32_t const cps[2] = { 0x03CA, 0x0021 };

    // 03CA 0021;	
    // (ϊ) GREEK SMALL LETTER IOTA WITH DIALYTIKA	[202C 0261 | 0020 002B 0020 | 0002 0002 0002 |]
    uint32_t const ces_non_ignorable[11] = { 0x202C, 0x0261, 0x0000, 0x0020, 0x002B, 0x0020, 0x0000, 0x0002, 0x0002, 0x0002, 0x0000 };

    auto const non_ignorable = collate_for_tests(
        cps, cps + 2, boost::text::variable_weighting::non_ignorable);

    EXPECT_EQ(non_ignorable.size(), 11);
    EXPECT_TRUE(boost::algorithm::equal(non_ignorable.begin(), non_ignorable.end(), ces_non_ignorable, ces_non_ignorable + 11))
        << "from:     " << ce_dumper(cps)
        << "expected: " << ce_dumper(ces_non_ignorable)
        << "got:      " << ce_dumper(non_ignorable);

    // 03CA 0021;	
    // (ϊ) GREEK SMALL LETTER IOTA WITH DIALYTIKA	[202C | 0020 002B | 0002 0002 | FFFF FFFF 0261 |]
    uint32_t const ces_shifted[12] = { 0x202C, 0x0000, 0x0020, 0x002B, 0x0000, 0x0002, 0x0002, 0x0000, 0xFFFF, 0xFFFF, 0x0261, 0x0000 };

    auto const shifted = collate_for_tests(
        cps, cps + 2, boost::text::variable_weighting::shifted);

    EXPECT_EQ(shifted.size(), 12);
    EXPECT_TRUE(boost::algorithm::equal(shifted.begin(), shifted.end(), ces_shifted, ces_shifted + 12))
        << "from:     " << ce_dumper(cps)
        << "expected: " << ce_dumper(ces_shifted)
        << "got:      " << ce_dumper(shifted);
}

TEST(collation, verbatim_131_064)
{
    uint32_t const cps[2] = { 0x03AA, 0x0021 };

    // 03AA 0021;	
    // (Ϊ) GREEK CAPITAL LETTER IOTA WITH DIALYTIKA	[202C 0261 | 0020 002B 0020 | 0008 0002 0002 |]
    uint32_t const ces_non_ignorable[11] = { 0x202C, 0x0261, 0x0000, 0x0020, 0x002B, 0x0020, 0x0000, 0x0008, 0x0002, 0x0002, 0x0000 };

    auto const non_ignorable = collate_for_tests(
        cps, cps + 2, boost::text::variable_weighting::non_ignorable);

    EXPECT_EQ(non_ignorable.size(), 11);
    EXPECT_TRUE(boost::algorithm::equal(non_ignorable.begin(), non_ignorable.end(), ces_non_ignorable, ces_non_ignorable + 11))
        << "from:     " << ce_dumper(cps)
        << "expected: " << ce_dumper(ces_non_ignorable)
        << "got:      " << ce_dumper(non_ignorable);

    // 03AA 0021;	
    // (Ϊ) GREEK CAPITAL LETTER IOTA WITH DIALYTIKA	[202C | 0020 002B | 0008 0002 | FFFF FFFF 0261 |]
    uint32_t const ces_shifted[12] = { 0x202C, 0x0000, 0x0020, 0x002B, 0x0000, 0x0008, 0x0002, 0x0000, 0xFFFF, 0xFFFF, 0x0261, 0x0000 };

    auto const shifted = collate_for_tests(
        cps, cps + 2, boost::text::variable_weighting::shifted);

    EXPECT_EQ(shifted.size(), 12);
    EXPECT_TRUE(boost::algorithm::equal(shifted.begin(), shifted.end(), ces_shifted, ces_shifted + 12))
        << "from:     " << ce_dumper(cps)
        << "expected: " << ce_dumper(ces_shifted)
        << "got:      " << ce_dumper(shifted);
}

TEST(collation, verbatim_131_065)
{
    uint32_t const cps[2] = { 0x0390, 0x0021 };

    // 0390 0021;	
    // (ΐ) GREEK SMALL LETTER IOTA WITH DIALYTIKA AND TONOS	[202C 0261 | 0020 002B 0024 0020 | 0002 0002 0002 0002 |]
    uint32_t const ces_non_ignorable[13] = { 0x202C, 0x0261, 0x0000, 0x0020, 0x002B, 0x0024, 0x0020, 0x0000, 0x0002, 0x0002, 0x0002, 0x0002, 0x0000 };

    auto const non_ignorable = collate_for_tests(
        cps, cps + 2, boost::text::variable_weighting::non_ignorable);

    EXPECT_EQ(non_ignorable.size(), 13);
    EXPECT_TRUE(boost::algorithm::equal(non_ignorable.begin(), non_ignorable.end(), ces_non_ignorable, ces_non_ignorable + 13))
        << "from:     " << ce_dumper(cps)
        << "expected: " << ce_dumper(ces_non_ignorable)
        << "got:      " << ce_dumper(non_ignorable);

    // 0390 0021;	
    // (ΐ) GREEK SMALL LETTER IOTA WITH DIALYTIKA AND TONOS	[202C | 0020 002B 0024 | 0002 0002 0002 | FFFF FFFF FFFF 0261 |]
    uint32_t const ces_shifted[15] = { 0x202C, 0x0000, 0x0020, 0x002B, 0x0024, 0x0000, 0x0002, 0x0002, 0x0002, 0x0000, 0xFFFF, 0xFFFF, 0xFFFF, 0x0261, 0x0000 };

    auto const shifted = collate_for_tests(
        cps, cps + 2, boost::text::variable_weighting::shifted);

    EXPECT_EQ(shifted.size(), 15);
    EXPECT_TRUE(boost::algorithm::equal(shifted.begin(), shifted.end(), ces_shifted, ces_shifted + 15))
        << "from:     " << ce_dumper(cps)
        << "expected: " << ce_dumper(ces_shifted)
        << "got:      " << ce_dumper(shifted);
}

TEST(collation, verbatim_131_066)
{
    uint32_t const cps[2] = { 0x1FD3, 0x0021 };

    // 1FD3 0021;	
    // (ΐ) GREEK SMALL LETTER IOTA WITH DIALYTIKA AND OXIA	[202C 0261 | 0020 002B 0024 0020 | 0002 0002 0002 0002 |]
    uint32_t const ces_non_ignorable[13] = { 0x202C, 0x0261, 0x0000, 0x0020, 0x002B, 0x0024, 0x0020, 0x0000, 0x0002, 0x0002, 0x0002, 0x0002, 0x0000 };

    auto const non_ignorable = collate_for_tests(
        cps, cps + 2, boost::text::variable_weighting::non_ignorable);

    EXPECT_EQ(non_ignorable.size(), 13);
    EXPECT_TRUE(boost::algorithm::equal(non_ignorable.begin(), non_ignorable.end(), ces_non_ignorable, ces_non_ignorable + 13))
        << "from:     " << ce_dumper(cps)
        << "expected: " << ce_dumper(ces_non_ignorable)
        << "got:      " << ce_dumper(non_ignorable);

    // 1FD3 0021;	
    // (ΐ) GREEK SMALL LETTER IOTA WITH DIALYTIKA AND OXIA	[202C | 0020 002B 0024 | 0002 0002 0002 | FFFF FFFF FFFF 0261 |]
    uint32_t const ces_shifted[15] = { 0x202C, 0x0000, 0x0020, 0x002B, 0x0024, 0x0000, 0x0002, 0x0002, 0x0002, 0x0000, 0xFFFF, 0xFFFF, 0xFFFF, 0x0261, 0x0000 };

    auto const shifted = collate_for_tests(
        cps, cps + 2, boost::text::variable_weighting::shifted);

    EXPECT_EQ(shifted.size(), 15);
    EXPECT_TRUE(boost::algorithm::equal(shifted.begin(), shifted.end(), ces_shifted, ces_shifted + 15))
        << "from:     " << ce_dumper(cps)
        << "expected: " << ce_dumper(ces_shifted)
        << "got:      " << ce_dumper(shifted);
}

TEST(collation, verbatim_131_067)
{
    uint32_t const cps[2] = { 0x1FD2, 0x0021 };

    // 1FD2 0021;	
    // (ῒ) GREEK SMALL LETTER IOTA WITH DIALYTIKA AND VARIA	[202C 0261 | 0020 002B 0025 0020 | 0002 0002 0002 0002 |]
    uint32_t const ces_non_ignorable[13] = { 0x202C, 0x0261, 0x0000, 0x0020, 0x002B, 0x0025, 0x0020, 0x0000, 0x0002, 0x0002, 0x0002, 0x0002, 0x0000 };

    auto const non_ignorable = collate_for_tests(
        cps, cps + 2, boost::text::variable_weighting::non_ignorable);

    EXPECT_EQ(non_ignorable.size(), 13);
    EXPECT_TRUE(boost::algorithm::equal(non_ignorable.begin(), non_ignorable.end(), ces_non_ignorable, ces_non_ignorable + 13))
        << "from:     " << ce_dumper(cps)
        << "expected: " << ce_dumper(ces_non_ignorable)
        << "got:      " << ce_dumper(non_ignorable);

    // 1FD2 0021;	
    // (ῒ) GREEK SMALL LETTER IOTA WITH DIALYTIKA AND VARIA	[202C | 0020 002B 0025 | 0002 0002 0002 | FFFF FFFF FFFF 0261 |]
    uint32_t const ces_shifted[15] = { 0x202C, 0x0000, 0x0020, 0x002B, 0x0025, 0x0000, 0x0002, 0x0002, 0x0002, 0x0000, 0xFFFF, 0xFFFF, 0xFFFF, 0x0261, 0x0000 };

    auto const shifted = collate_for_tests(
        cps, cps + 2, boost::text::variable_weighting::shifted);

    EXPECT_EQ(shifted.size(), 15);
    EXPECT_TRUE(boost::algorithm::equal(shifted.begin(), shifted.end(), ces_shifted, ces_shifted + 15))
        << "from:     " << ce_dumper(cps)
        << "expected: " << ce_dumper(ces_shifted)
        << "got:      " << ce_dumper(shifted);
}

TEST(collation, verbatim_131_068)
{
    uint32_t const cps[2] = { 0x1FD7, 0x0021 };

    // 1FD7 0021;	
    // (ῗ) GREEK SMALL LETTER IOTA WITH DIALYTIKA AND PERISPOMENI	[202C 0261 | 0020 002B 002A 0020 | 0002 0002 0002 0002 |]
    uint32_t const ces_non_ignorable[13] = { 0x202C, 0x0261, 0x0000, 0x0020, 0x002B, 0x002A, 0x0020, 0x0000, 0x0002, 0x0002, 0x0002, 0x0002, 0x0000 };

    auto const non_ignorable = collate_for_tests(
        cps, cps + 2, boost::text::variable_weighting::non_ignorable);

    EXPECT_EQ(non_ignorable.size(), 13);
    EXPECT_TRUE(boost::algorithm::equal(non_ignorable.begin(), non_ignorable.end(), ces_non_ignorable, ces_non_ignorable + 13))
        << "from:     " << ce_dumper(cps)
        << "expected: " << ce_dumper(ces_non_ignorable)
        << "got:      " << ce_dumper(non_ignorable);

    // 1FD7 0021;	
    // (ῗ) GREEK SMALL LETTER IOTA WITH DIALYTIKA AND PERISPOMENI	[202C | 0020 002B 002A | 0002 0002 0002 | FFFF FFFF FFFF 0261 |]
    uint32_t const ces_shifted[15] = { 0x202C, 0x0000, 0x0020, 0x002B, 0x002A, 0x0000, 0x0002, 0x0002, 0x0002, 0x0000, 0xFFFF, 0xFFFF, 0xFFFF, 0x0261, 0x0000 };

    auto const shifted = collate_for_tests(
        cps, cps + 2, boost::text::variable_weighting::shifted);

    EXPECT_EQ(shifted.size(), 15);
    EXPECT_TRUE(boost::algorithm::equal(shifted.begin(), shifted.end(), ces_shifted, ces_shifted + 15))
        << "from:     " << ce_dumper(cps)
        << "expected: " << ce_dumper(ces_shifted)
        << "got:      " << ce_dumper(shifted);
}

TEST(collation, verbatim_131_069)
{
    uint32_t const cps[2] = { 0x1FD1, 0x0021 };

    // 1FD1 0021;	
    // (ῑ) GREEK SMALL LETTER IOTA WITH MACRON	[202C 0261 | 0020 0032 0020 | 0002 0002 0002 |]
    uint32_t const ces_non_ignorable[11] = { 0x202C, 0x0261, 0x0000, 0x0020, 0x0032, 0x0020, 0x0000, 0x0002, 0x0002, 0x0002, 0x0000 };

    auto const non_ignorable = collate_for_tests(
        cps, cps + 2, boost::text::variable_weighting::non_ignorable);

    EXPECT_EQ(non_ignorable.size(), 11);
    EXPECT_TRUE(boost::algorithm::equal(non_ignorable.begin(), non_ignorable.end(), ces_non_ignorable, ces_non_ignorable + 11))
        << "from:     " << ce_dumper(cps)
        << "expected: " << ce_dumper(ces_non_ignorable)
        << "got:      " << ce_dumper(non_ignorable);

    // 1FD1 0021;	
    // (ῑ) GREEK SMALL LETTER IOTA WITH MACRON	[202C | 0020 0032 | 0002 0002 | FFFF FFFF 0261 |]
    uint32_t const ces_shifted[12] = { 0x202C, 0x0000, 0x0020, 0x0032, 0x0000, 0x0002, 0x0002, 0x0000, 0xFFFF, 0xFFFF, 0x0261, 0x0000 };

    auto const shifted = collate_for_tests(
        cps, cps + 2, boost::text::variable_weighting::shifted);

    EXPECT_EQ(shifted.size(), 12);
    EXPECT_TRUE(boost::algorithm::equal(shifted.begin(), shifted.end(), ces_shifted, ces_shifted + 12))
        << "from:     " << ce_dumper(cps)
        << "expected: " << ce_dumper(ces_shifted)
        << "got:      " << ce_dumper(shifted);
}

TEST(collation, verbatim_131_070)
{
    uint32_t const cps[2] = { 0x1FD9, 0x0021 };

    // 1FD9 0021;	
    // (Ῑ) GREEK CAPITAL LETTER IOTA WITH MACRON	[202C 0261 | 0020 0032 0020 | 0008 0002 0002 |]
    uint32_t const ces_non_ignorable[11] = { 0x202C, 0x0261, 0x0000, 0x0020, 0x0032, 0x0020, 0x0000, 0x0008, 0x0002, 0x0002, 0x0000 };

    auto const non_ignorable = collate_for_tests(
        cps, cps + 2, boost::text::variable_weighting::non_ignorable);

    EXPECT_EQ(non_ignorable.size(), 11);
    EXPECT_TRUE(boost::algorithm::equal(non_ignorable.begin(), non_ignorable.end(), ces_non_ignorable, ces_non_ignorable + 11))
        << "from:     " << ce_dumper(cps)
        << "expected: " << ce_dumper(ces_non_ignorable)
        << "got:      " << ce_dumper(non_ignorable);

    // 1FD9 0021;	
    // (Ῑ) GREEK CAPITAL LETTER IOTA WITH MACRON	[202C | 0020 0032 | 0008 0002 | FFFF FFFF 0261 |]
    uint32_t const ces_shifted[12] = { 0x202C, 0x0000, 0x0020, 0x0032, 0x0000, 0x0008, 0x0002, 0x0000, 0xFFFF, 0xFFFF, 0x0261, 0x0000 };

    auto const shifted = collate_for_tests(
        cps, cps + 2, boost::text::variable_weighting::shifted);

    EXPECT_EQ(shifted.size(), 12);
    EXPECT_TRUE(boost::algorithm::equal(shifted.begin(), shifted.end(), ces_shifted, ces_shifted + 12))
        << "from:     " << ce_dumper(cps)
        << "expected: " << ce_dumper(ces_shifted)
        << "got:      " << ce_dumper(shifted);
}

TEST(collation, verbatim_131_071)
{
    uint32_t const cps[2] = { 0x03B9, 0x003F };

    // 03B9 003F;	
    // (ι) GREEK SMALL LETTER IOTA	[202C 0267 | 0020 0020 | 0002 0002 |]
    uint32_t const ces_non_ignorable[9] = { 0x202C, 0x0267, 0x0000, 0x0020, 0x0020, 0x0000, 0x0002, 0x0002, 0x0000 };

    auto const non_ignorable = collate_for_tests(
        cps, cps + 2, boost::text::variable_weighting::non_ignorable);

    EXPECT_EQ(non_ignorable.size(), 9);
    EXPECT_TRUE(boost::algorithm::equal(non_ignorable.begin(), non_ignorable.end(), ces_non_ignorable, ces_non_ignorable + 9))
        << "from:     " << ce_dumper(cps)
        << "expected: " << ce_dumper(ces_non_ignorable)
        << "got:      " << ce_dumper(non_ignorable);

    // 03B9 003F;	
    // (ι) GREEK SMALL LETTER IOTA	[202C | 0020 | 0002 | FFFF 0267 |]
    uint32_t const ces_shifted[9] = { 0x202C, 0x0000, 0x0020, 0x0000, 0x0002, 0x0000, 0xFFFF, 0x0267, 0x0000 };

    auto const shifted = collate_for_tests(
        cps, cps + 2, boost::text::variable_weighting::shifted);

    EXPECT_EQ(shifted.size(), 9);
    EXPECT_TRUE(boost::algorithm::equal(shifted.begin(), shifted.end(), ces_shifted, ces_shifted + 9))
        << "from:     " << ce_dumper(cps)
        << "expected: " << ce_dumper(ces_shifted)
        << "got:      " << ce_dumper(shifted);
}

TEST(collation, verbatim_131_072)
{
    uint32_t const cps[2] = { 0x1FBE, 0x003F };

    // 1FBE 003F;	
    // (ι) GREEK PROSGEGRAMMENI	[202C 0267 | 0020 0020 | 0002 0002 |]
    uint32_t const ces_non_ignorable[9] = { 0x202C, 0x0267, 0x0000, 0x0020, 0x0020, 0x0000, 0x0002, 0x0002, 0x0000 };

    auto const non_ignorable = collate_for_tests(
        cps, cps + 2, boost::text::variable_weighting::non_ignorable);

    EXPECT_EQ(non_ignorable.size(), 9);
    EXPECT_TRUE(boost::algorithm::equal(non_ignorable.begin(), non_ignorable.end(), ces_non_ignorable, ces_non_ignorable + 9))
        << "from:     " << ce_dumper(cps)
        << "expected: " << ce_dumper(ces_non_ignorable)
        << "got:      " << ce_dumper(non_ignorable);

    // 1FBE 003F;	
    // (ι) GREEK PROSGEGRAMMENI	[202C | 0020 | 0002 | FFFF 0267 |]
    uint32_t const ces_shifted[9] = { 0x202C, 0x0000, 0x0020, 0x0000, 0x0002, 0x0000, 0xFFFF, 0x0267, 0x0000 };

    auto const shifted = collate_for_tests(
        cps, cps + 2, boost::text::variable_weighting::shifted);

    EXPECT_EQ(shifted.size(), 9);
    EXPECT_TRUE(boost::algorithm::equal(shifted.begin(), shifted.end(), ces_shifted, ces_shifted + 9))
        << "from:     " << ce_dumper(cps)
        << "expected: " << ce_dumper(ces_shifted)
        << "got:      " << ce_dumper(shifted);
}

TEST(collation, verbatim_131_073)
{
    uint32_t const cps[2] = { 0x037A, 0x003F };

    // 037A 003F;	
    // (ͺ) GREEK YPOGEGRAMMENI	[202C 0267 | 0020 0020 | 0004 0002 |]
    uint32_t const ces_non_ignorable[9] = { 0x202C, 0x0267, 0x0000, 0x0020, 0x0020, 0x0000, 0x0004, 0x0002, 0x0000 };

    auto const non_ignorable = collate_for_tests(
        cps, cps + 2, boost::text::variable_weighting::non_ignorable);

    EXPECT_EQ(non_ignorable.size(), 9);
    EXPECT_TRUE(boost::algorithm::equal(non_ignorable.begin(), non_ignorable.end(), ces_non_ignorable, ces_non_ignorable + 9))
        << "from:     " << ce_dumper(cps)
        << "expected: " << ce_dumper(ces_non_ignorable)
        << "got:      " << ce_dumper(non_ignorable);

    // 037A 003F;	
    // (ͺ) GREEK YPOGEGRAMMENI	[202C | 0020 | 0004 | FFFF 0267 |]
    uint32_t const ces_shifted[9] = { 0x202C, 0x0000, 0x0020, 0x0000, 0x0004, 0x0000, 0xFFFF, 0x0267, 0x0000 };

    auto const shifted = collate_for_tests(
        cps, cps + 2, boost::text::variable_weighting::shifted);

    EXPECT_EQ(shifted.size(), 9);
    EXPECT_TRUE(boost::algorithm::equal(shifted.begin(), shifted.end(), ces_shifted, ces_shifted + 9))
        << "from:     " << ce_dumper(cps)
        << "expected: " << ce_dumper(ces_shifted)
        << "got:      " << ce_dumper(shifted);
}

TEST(collation, verbatim_131_074)
{
    uint32_t const cps[2] = { 0x1D6CA, 0x003F };

    // 1D6CA 003F;	
    // (𝛊) MATHEMATICAL BOLD SMALL IOTA	[202C 0267 | 0020 0020 | 0005 0002 |]
    uint32_t const ces_non_ignorable[9] = { 0x202C, 0x0267, 0x0000, 0x0020, 0x0020, 0x0000, 0x0005, 0x0002, 0x0000 };

    auto const non_ignorable = collate_for_tests(
        cps, cps + 2, boost::text::variable_weighting::non_ignorable);

    EXPECT_EQ(non_ignorable.size(), 9);
    EXPECT_TRUE(boost::algorithm::equal(non_ignorable.begin(), non_ignorable.end(), ces_non_ignorable, ces_non_ignorable + 9))
        << "from:     " << ce_dumper(cps)
        << "expected: " << ce_dumper(ces_non_ignorable)
        << "got:      " << ce_dumper(non_ignorable);

    // 1D6CA 003F;	
    // (𝛊) MATHEMATICAL BOLD SMALL IOTA	[202C | 0020 | 0005 | FFFF 0267 |]
    uint32_t const ces_shifted[9] = { 0x202C, 0x0000, 0x0020, 0x0000, 0x0005, 0x0000, 0xFFFF, 0x0267, 0x0000 };

    auto const shifted = collate_for_tests(
        cps, cps + 2, boost::text::variable_weighting::shifted);

    EXPECT_EQ(shifted.size(), 9);
    EXPECT_TRUE(boost::algorithm::equal(shifted.begin(), shifted.end(), ces_shifted, ces_shifted + 9))
        << "from:     " << ce_dumper(cps)
        << "expected: " << ce_dumper(ces_shifted)
        << "got:      " << ce_dumper(shifted);
}

TEST(collation, verbatim_131_075)
{
    uint32_t const cps[2] = { 0x1D704, 0x003F };

    // 1D704 003F;	
    // (𝜄) MATHEMATICAL ITALIC SMALL IOTA	[202C 0267 | 0020 0020 | 0005 0002 |]
    uint32_t const ces_non_ignorable[9] = { 0x202C, 0x0267, 0x0000, 0x0020, 0x0020, 0x0000, 0x0005, 0x0002, 0x0000 };

    auto const non_ignorable = collate_for_tests(
        cps, cps + 2, boost::text::variable_weighting::non_ignorable);

    EXPECT_EQ(non_ignorable.size(), 9);
    EXPECT_TRUE(boost::algorithm::equal(non_ignorable.begin(), non_ignorable.end(), ces_non_ignorable, ces_non_ignorable + 9))
        << "from:     " << ce_dumper(cps)
        << "expected: " << ce_dumper(ces_non_ignorable)
        << "got:      " << ce_dumper(non_ignorable);

    // 1D704 003F;	
    // (𝜄) MATHEMATICAL ITALIC SMALL IOTA	[202C | 0020 | 0005 | FFFF 0267 |]
    uint32_t const ces_shifted[9] = { 0x202C, 0x0000, 0x0020, 0x0000, 0x0005, 0x0000, 0xFFFF, 0x0267, 0x0000 };

    auto const shifted = collate_for_tests(
        cps, cps + 2, boost::text::variable_weighting::shifted);

    EXPECT_EQ(shifted.size(), 9);
    EXPECT_TRUE(boost::algorithm::equal(shifted.begin(), shifted.end(), ces_shifted, ces_shifted + 9))
        << "from:     " << ce_dumper(cps)
        << "expected: " << ce_dumper(ces_shifted)
        << "got:      " << ce_dumper(shifted);
}

TEST(collation, verbatim_131_076)
{
    uint32_t const cps[2] = { 0x1D73E, 0x003F };

    // 1D73E 003F;	
    // (𝜾) MATHEMATICAL BOLD ITALIC SMALL IOTA	[202C 0267 | 0020 0020 | 0005 0002 |]
    uint32_t const ces_non_ignorable[9] = { 0x202C, 0x0267, 0x0000, 0x0020, 0x0020, 0x0000, 0x0005, 0x0002, 0x0000 };

    auto const non_ignorable = collate_for_tests(
        cps, cps + 2, boost::text::variable_weighting::non_ignorable);

    EXPECT_EQ(non_ignorable.size(), 9);
    EXPECT_TRUE(boost::algorithm::equal(non_ignorable.begin(), non_ignorable.end(), ces_non_ignorable, ces_non_ignorable + 9))
        << "from:     " << ce_dumper(cps)
        << "expected: " << ce_dumper(ces_non_ignorable)
        << "got:      " << ce_dumper(non_ignorable);

    // 1D73E 003F;	
    // (𝜾) MATHEMATICAL BOLD ITALIC SMALL IOTA	[202C | 0020 | 0005 | FFFF 0267 |]
    uint32_t const ces_shifted[9] = { 0x202C, 0x0000, 0x0020, 0x0000, 0x0005, 0x0000, 0xFFFF, 0x0267, 0x0000 };

    auto const shifted = collate_for_tests(
        cps, cps + 2, boost::text::variable_weighting::shifted);

    EXPECT_EQ(shifted.size(), 9);
    EXPECT_TRUE(boost::algorithm::equal(shifted.begin(), shifted.end(), ces_shifted, ces_shifted + 9))
        << "from:     " << ce_dumper(cps)
        << "expected: " << ce_dumper(ces_shifted)
        << "got:      " << ce_dumper(shifted);
}

TEST(collation, verbatim_131_077)
{
    uint32_t const cps[2] = { 0x1D778, 0x003F };

    // 1D778 003F;	
    // (𝝸) MATHEMATICAL SANS-SERIF BOLD SMALL IOTA	[202C 0267 | 0020 0020 | 0005 0002 |]
    uint32_t const ces_non_ignorable[9] = { 0x202C, 0x0267, 0x0000, 0x0020, 0x0020, 0x0000, 0x0005, 0x0002, 0x0000 };

    auto const non_ignorable = collate_for_tests(
        cps, cps + 2, boost::text::variable_weighting::non_ignorable);

    EXPECT_EQ(non_ignorable.size(), 9);
    EXPECT_TRUE(boost::algorithm::equal(non_ignorable.begin(), non_ignorable.end(), ces_non_ignorable, ces_non_ignorable + 9))
        << "from:     " << ce_dumper(cps)
        << "expected: " << ce_dumper(ces_non_ignorable)
        << "got:      " << ce_dumper(non_ignorable);

    // 1D778 003F;	
    // (𝝸) MATHEMATICAL SANS-SERIF BOLD SMALL IOTA	[202C | 0020 | 0005 | FFFF 0267 |]
    uint32_t const ces_shifted[9] = { 0x202C, 0x0000, 0x0020, 0x0000, 0x0005, 0x0000, 0xFFFF, 0x0267, 0x0000 };

    auto const shifted = collate_for_tests(
        cps, cps + 2, boost::text::variable_weighting::shifted);

    EXPECT_EQ(shifted.size(), 9);
    EXPECT_TRUE(boost::algorithm::equal(shifted.begin(), shifted.end(), ces_shifted, ces_shifted + 9))
        << "from:     " << ce_dumper(cps)
        << "expected: " << ce_dumper(ces_shifted)
        << "got:      " << ce_dumper(shifted);
}

TEST(collation, verbatim_131_078)
{
    uint32_t const cps[2] = { 0x1D7B2, 0x003F };

    // 1D7B2 003F;	
    // (𝞲) MATHEMATICAL SANS-SERIF BOLD ITALIC SMALL IOTA	[202C 0267 | 0020 0020 | 0005 0002 |]
    uint32_t const ces_non_ignorable[9] = { 0x202C, 0x0267, 0x0000, 0x0020, 0x0020, 0x0000, 0x0005, 0x0002, 0x0000 };

    auto const non_ignorable = collate_for_tests(
        cps, cps + 2, boost::text::variable_weighting::non_ignorable);

    EXPECT_EQ(non_ignorable.size(), 9);
    EXPECT_TRUE(boost::algorithm::equal(non_ignorable.begin(), non_ignorable.end(), ces_non_ignorable, ces_non_ignorable + 9))
        << "from:     " << ce_dumper(cps)
        << "expected: " << ce_dumper(ces_non_ignorable)
        << "got:      " << ce_dumper(non_ignorable);

    // 1D7B2 003F;	
    // (𝞲) MATHEMATICAL SANS-SERIF BOLD ITALIC SMALL IOTA	[202C | 0020 | 0005 | FFFF 0267 |]
    uint32_t const ces_shifted[9] = { 0x202C, 0x0000, 0x0020, 0x0000, 0x0005, 0x0000, 0xFFFF, 0x0267, 0x0000 };

    auto const shifted = collate_for_tests(
        cps, cps + 2, boost::text::variable_weighting::shifted);

    EXPECT_EQ(shifted.size(), 9);
    EXPECT_TRUE(boost::algorithm::equal(shifted.begin(), shifted.end(), ces_shifted, ces_shifted + 9))
        << "from:     " << ce_dumper(cps)
        << "expected: " << ce_dumper(ces_shifted)
        << "got:      " << ce_dumper(shifted);
}

TEST(collation, verbatim_131_079)
{
    uint32_t const cps[2] = { 0x0399, 0x003F };

    // 0399 003F;	
    // (Ι) GREEK CAPITAL LETTER IOTA	[202C 0267 | 0020 0020 | 0008 0002 |]
    uint32_t const ces_non_ignorable[9] = { 0x202C, 0x0267, 0x0000, 0x0020, 0x0020, 0x0000, 0x0008, 0x0002, 0x0000 };

    auto const non_ignorable = collate_for_tests(
        cps, cps + 2, boost::text::variable_weighting::non_ignorable);

    EXPECT_EQ(non_ignorable.size(), 9);
    EXPECT_TRUE(boost::algorithm::equal(non_ignorable.begin(), non_ignorable.end(), ces_non_ignorable, ces_non_ignorable + 9))
        << "from:     " << ce_dumper(cps)
        << "expected: " << ce_dumper(ces_non_ignorable)
        << "got:      " << ce_dumper(non_ignorable);

    // 0399 003F;	
    // (Ι) GREEK CAPITAL LETTER IOTA	[202C | 0020 | 0008 | FFFF 0267 |]
    uint32_t const ces_shifted[9] = { 0x202C, 0x0000, 0x0020, 0x0000, 0x0008, 0x0000, 0xFFFF, 0x0267, 0x0000 };

    auto const shifted = collate_for_tests(
        cps, cps + 2, boost::text::variable_weighting::shifted);

    EXPECT_EQ(shifted.size(), 9);
    EXPECT_TRUE(boost::algorithm::equal(shifted.begin(), shifted.end(), ces_shifted, ces_shifted + 9))
        << "from:     " << ce_dumper(cps)
        << "expected: " << ce_dumper(ces_shifted)
        << "got:      " << ce_dumper(shifted);
}

TEST(collation, verbatim_131_080)
{
    uint32_t const cps[2] = { 0x1D6B0, 0x003F };

    // 1D6B0 003F;	
    // (𝚰) MATHEMATICAL BOLD CAPITAL IOTA	[202C 0267 | 0020 0020 | 000B 0002 |]
    uint32_t const ces_non_ignorable[9] = { 0x202C, 0x0267, 0x0000, 0x0020, 0x0020, 0x0000, 0x000B, 0x0002, 0x0000 };

    auto const non_ignorable = collate_for_tests(
        cps, cps + 2, boost::text::variable_weighting::non_ignorable);

    EXPECT_EQ(non_ignorable.size(), 9);
    EXPECT_TRUE(boost::algorithm::equal(non_ignorable.begin(), non_ignorable.end(), ces_non_ignorable, ces_non_ignorable + 9))
        << "from:     " << ce_dumper(cps)
        << "expected: " << ce_dumper(ces_non_ignorable)
        << "got:      " << ce_dumper(non_ignorable);

    // 1D6B0 003F;	
    // (𝚰) MATHEMATICAL BOLD CAPITAL IOTA	[202C | 0020 | 000B | FFFF 0267 |]
    uint32_t const ces_shifted[9] = { 0x202C, 0x0000, 0x0020, 0x0000, 0x000B, 0x0000, 0xFFFF, 0x0267, 0x0000 };

    auto const shifted = collate_for_tests(
        cps, cps + 2, boost::text::variable_weighting::shifted);

    EXPECT_EQ(shifted.size(), 9);
    EXPECT_TRUE(boost::algorithm::equal(shifted.begin(), shifted.end(), ces_shifted, ces_shifted + 9))
        << "from:     " << ce_dumper(cps)
        << "expected: " << ce_dumper(ces_shifted)
        << "got:      " << ce_dumper(shifted);
}

TEST(collation, verbatim_131_081)
{
    uint32_t const cps[2] = { 0x1D6EA, 0x003F };

    // 1D6EA 003F;	
    // (𝛪) MATHEMATICAL ITALIC CAPITAL IOTA	[202C 0267 | 0020 0020 | 000B 0002 |]
    uint32_t const ces_non_ignorable[9] = { 0x202C, 0x0267, 0x0000, 0x0020, 0x0020, 0x0000, 0x000B, 0x0002, 0x0000 };

    auto const non_ignorable = collate_for_tests(
        cps, cps + 2, boost::text::variable_weighting::non_ignorable);

    EXPECT_EQ(non_ignorable.size(), 9);
    EXPECT_TRUE(boost::algorithm::equal(non_ignorable.begin(), non_ignorable.end(), ces_non_ignorable, ces_non_ignorable + 9))
        << "from:     " << ce_dumper(cps)
        << "expected: " << ce_dumper(ces_non_ignorable)
        << "got:      " << ce_dumper(non_ignorable);

    // 1D6EA 003F;	
    // (𝛪) MATHEMATICAL ITALIC CAPITAL IOTA	[202C | 0020 | 000B | FFFF 0267 |]
    uint32_t const ces_shifted[9] = { 0x202C, 0x0000, 0x0020, 0x0000, 0x000B, 0x0000, 0xFFFF, 0x0267, 0x0000 };

    auto const shifted = collate_for_tests(
        cps, cps + 2, boost::text::variable_weighting::shifted);

    EXPECT_EQ(shifted.size(), 9);
    EXPECT_TRUE(boost::algorithm::equal(shifted.begin(), shifted.end(), ces_shifted, ces_shifted + 9))
        << "from:     " << ce_dumper(cps)
        << "expected: " << ce_dumper(ces_shifted)
        << "got:      " << ce_dumper(shifted);
}

TEST(collation, verbatim_131_082)
{
    uint32_t const cps[2] = { 0x1D724, 0x003F };

    // 1D724 003F;	
    // (𝜤) MATHEMATICAL BOLD ITALIC CAPITAL IOTA	[202C 0267 | 0020 0020 | 000B 0002 |]
    uint32_t const ces_non_ignorable[9] = { 0x202C, 0x0267, 0x0000, 0x0020, 0x0020, 0x0000, 0x000B, 0x0002, 0x0000 };

    auto const non_ignorable = collate_for_tests(
        cps, cps + 2, boost::text::variable_weighting::non_ignorable);

    EXPECT_EQ(non_ignorable.size(), 9);
    EXPECT_TRUE(boost::algorithm::equal(non_ignorable.begin(), non_ignorable.end(), ces_non_ignorable, ces_non_ignorable + 9))
        << "from:     " << ce_dumper(cps)
        << "expected: " << ce_dumper(ces_non_ignorable)
        << "got:      " << ce_dumper(non_ignorable);

    // 1D724 003F;	
    // (𝜤) MATHEMATICAL BOLD ITALIC CAPITAL IOTA	[202C | 0020 | 000B | FFFF 0267 |]
    uint32_t const ces_shifted[9] = { 0x202C, 0x0000, 0x0020, 0x0000, 0x000B, 0x0000, 0xFFFF, 0x0267, 0x0000 };

    auto const shifted = collate_for_tests(
        cps, cps + 2, boost::text::variable_weighting::shifted);

    EXPECT_EQ(shifted.size(), 9);
    EXPECT_TRUE(boost::algorithm::equal(shifted.begin(), shifted.end(), ces_shifted, ces_shifted + 9))
        << "from:     " << ce_dumper(cps)
        << "expected: " << ce_dumper(ces_shifted)
        << "got:      " << ce_dumper(shifted);
}

TEST(collation, verbatim_131_083)
{
    uint32_t const cps[2] = { 0x1D75E, 0x003F };

    // 1D75E 003F;	
    // (𝝞) MATHEMATICAL SANS-SERIF BOLD CAPITAL IOTA	[202C 0267 | 0020 0020 | 000B 0002 |]
    uint32_t const ces_non_ignorable[9] = { 0x202C, 0x0267, 0x0000, 0x0020, 0x0020, 0x0000, 0x000B, 0x0002, 0x0000 };

    auto const non_ignorable = collate_for_tests(
        cps, cps + 2, boost::text::variable_weighting::non_ignorable);

    EXPECT_EQ(non_ignorable.size(), 9);
    EXPECT_TRUE(boost::algorithm::equal(non_ignorable.begin(), non_ignorable.end(), ces_non_ignorable, ces_non_ignorable + 9))
        << "from:     " << ce_dumper(cps)
        << "expected: " << ce_dumper(ces_non_ignorable)
        << "got:      " << ce_dumper(non_ignorable);

    // 1D75E 003F;	
    // (𝝞) MATHEMATICAL SANS-SERIF BOLD CAPITAL IOTA	[202C | 0020 | 000B | FFFF 0267 |]
    uint32_t const ces_shifted[9] = { 0x202C, 0x0000, 0x0020, 0x0000, 0x000B, 0x0000, 0xFFFF, 0x0267, 0x0000 };

    auto const shifted = collate_for_tests(
        cps, cps + 2, boost::text::variable_weighting::shifted);

    EXPECT_EQ(shifted.size(), 9);
    EXPECT_TRUE(boost::algorithm::equal(shifted.begin(), shifted.end(), ces_shifted, ces_shifted + 9))
        << "from:     " << ce_dumper(cps)
        << "expected: " << ce_dumper(ces_shifted)
        << "got:      " << ce_dumper(shifted);
}

TEST(collation, verbatim_131_084)
{
    uint32_t const cps[2] = { 0x1D798, 0x003F };

    // 1D798 003F;	
    // (𝞘) MATHEMATICAL SANS-SERIF BOLD ITALIC CAPITAL IOTA	[202C 0267 | 0020 0020 | 000B 0002 |]
    uint32_t const ces_non_ignorable[9] = { 0x202C, 0x0267, 0x0000, 0x0020, 0x0020, 0x0000, 0x000B, 0x0002, 0x0000 };

    auto const non_ignorable = collate_for_tests(
        cps, cps + 2, boost::text::variable_weighting::non_ignorable);

    EXPECT_EQ(non_ignorable.size(), 9);
    EXPECT_TRUE(boost::algorithm::equal(non_ignorable.begin(), non_ignorable.end(), ces_non_ignorable, ces_non_ignorable + 9))
        << "from:     " << ce_dumper(cps)
        << "expected: " << ce_dumper(ces_non_ignorable)
        << "got:      " << ce_dumper(non_ignorable);

    // 1D798 003F;	
    // (𝞘) MATHEMATICAL SANS-SERIF BOLD ITALIC CAPITAL IOTA	[202C | 0020 | 000B | FFFF 0267 |]
    uint32_t const ces_shifted[9] = { 0x202C, 0x0000, 0x0020, 0x0000, 0x000B, 0x0000, 0xFFFF, 0x0267, 0x0000 };

    auto const shifted = collate_for_tests(
        cps, cps + 2, boost::text::variable_weighting::shifted);

    EXPECT_EQ(shifted.size(), 9);
    EXPECT_TRUE(boost::algorithm::equal(shifted.begin(), shifted.end(), ces_shifted, ces_shifted + 9))
        << "from:     " << ce_dumper(cps)
        << "expected: " << ce_dumper(ces_shifted)
        << "got:      " << ce_dumper(shifted);
}

TEST(collation, verbatim_131_085)
{
    uint32_t const cps[2] = { 0x1F30, 0x003F };

    // 1F30 003F;	
    // (ἰ) GREEK SMALL LETTER IOTA WITH PSILI	[202C 0267 | 0020 0022 0020 | 0002 0002 0002 |]
    uint32_t const ces_non_ignorable[11] = { 0x202C, 0x0267, 0x0000, 0x0020, 0x0022, 0x0020, 0x0000, 0x0002, 0x0002, 0x0002, 0x0000 };

    auto const non_ignorable = collate_for_tests(
        cps, cps + 2, boost::text::variable_weighting::non_ignorable);

    EXPECT_EQ(non_ignorable.size(), 11);
    EXPECT_TRUE(boost::algorithm::equal(non_ignorable.begin(), non_ignorable.end(), ces_non_ignorable, ces_non_ignorable + 11))
        << "from:     " << ce_dumper(cps)
        << "expected: " << ce_dumper(ces_non_ignorable)
        << "got:      " << ce_dumper(non_ignorable);

    // 1F30 003F;	
    // (ἰ) GREEK SMALL LETTER IOTA WITH PSILI	[202C | 0020 0022 | 0002 0002 | FFFF FFFF 0267 |]
    uint32_t const ces_shifted[12] = { 0x202C, 0x0000, 0x0020, 0x0022, 0x0000, 0x0002, 0x0002, 0x0000, 0xFFFF, 0xFFFF, 0x0267, 0x0000 };

    auto const shifted = collate_for_tests(
        cps, cps + 2, boost::text::variable_weighting::shifted);

    EXPECT_EQ(shifted.size(), 12);
    EXPECT_TRUE(boost::algorithm::equal(shifted.begin(), shifted.end(), ces_shifted, ces_shifted + 12))
        << "from:     " << ce_dumper(cps)
        << "expected: " << ce_dumper(ces_shifted)
        << "got:      " << ce_dumper(shifted);
}

TEST(collation, verbatim_131_086)
{
    uint32_t const cps[2] = { 0x1F38, 0x003F };

    // 1F38 003F;	
    // (Ἰ) GREEK CAPITAL LETTER IOTA WITH PSILI	[202C 0267 | 0020 0022 0020 | 0008 0002 0002 |]
    uint32_t const ces_non_ignorable[11] = { 0x202C, 0x0267, 0x0000, 0x0020, 0x0022, 0x0020, 0x0000, 0x0008, 0x0002, 0x0002, 0x0000 };

    auto const non_ignorable = collate_for_tests(
        cps, cps + 2, boost::text::variable_weighting::non_ignorable);

    EXPECT_EQ(non_ignorable.size(), 11);
    EXPECT_TRUE(boost::algorithm::equal(non_ignorable.begin(), non_ignorable.end(), ces_non_ignorable, ces_non_ignorable + 11))
        << "from:     " << ce_dumper(cps)
        << "expected: " << ce_dumper(ces_non_ignorable)
        << "got:      " << ce_dumper(non_ignorable);

    // 1F38 003F;	
    // (Ἰ) GREEK CAPITAL LETTER IOTA WITH PSILI	[202C | 0020 0022 | 0008 0002 | FFFF FFFF 0267 |]
    uint32_t const ces_shifted[12] = { 0x202C, 0x0000, 0x0020, 0x0022, 0x0000, 0x0008, 0x0002, 0x0000, 0xFFFF, 0xFFFF, 0x0267, 0x0000 };

    auto const shifted = collate_for_tests(
        cps, cps + 2, boost::text::variable_weighting::shifted);

    EXPECT_EQ(shifted.size(), 12);
    EXPECT_TRUE(boost::algorithm::equal(shifted.begin(), shifted.end(), ces_shifted, ces_shifted + 12))
        << "from:     " << ce_dumper(cps)
        << "expected: " << ce_dumper(ces_shifted)
        << "got:      " << ce_dumper(shifted);
}

TEST(collation, verbatim_131_087)
{
    uint32_t const cps[2] = { 0x1F34, 0x003F };

    // 1F34 003F;	
    // (ἴ) GREEK SMALL LETTER IOTA WITH PSILI AND OXIA	[202C 0267 | 0020 0022 0024 0020 | 0002 0002 0002 0002 |]
    uint32_t const ces_non_ignorable[13] = { 0x202C, 0x0267, 0x0000, 0x0020, 0x0022, 0x0024, 0x0020, 0x0000, 0x0002, 0x0002, 0x0002, 0x0002, 0x0000 };

    auto const non_ignorable = collate_for_tests(
        cps, cps + 2, boost::text::variable_weighting::non_ignorable);

    EXPECT_EQ(non_ignorable.size(), 13);
    EXPECT_TRUE(boost::algorithm::equal(non_ignorable.begin(), non_ignorable.end(), ces_non_ignorable, ces_non_ignorable + 13))
        << "from:     " << ce_dumper(cps)
        << "expected: " << ce_dumper(ces_non_ignorable)
        << "got:      " << ce_dumper(non_ignorable);

    // 1F34 003F;	
    // (ἴ) GREEK SMALL LETTER IOTA WITH PSILI AND OXIA	[202C | 0020 0022 0024 | 0002 0002 0002 | FFFF FFFF FFFF 0267 |]
    uint32_t const ces_shifted[15] = { 0x202C, 0x0000, 0x0020, 0x0022, 0x0024, 0x0000, 0x0002, 0x0002, 0x0002, 0x0000, 0xFFFF, 0xFFFF, 0xFFFF, 0x0267, 0x0000 };

    auto const shifted = collate_for_tests(
        cps, cps + 2, boost::text::variable_weighting::shifted);

    EXPECT_EQ(shifted.size(), 15);
    EXPECT_TRUE(boost::algorithm::equal(shifted.begin(), shifted.end(), ces_shifted, ces_shifted + 15))
        << "from:     " << ce_dumper(cps)
        << "expected: " << ce_dumper(ces_shifted)
        << "got:      " << ce_dumper(shifted);
}

TEST(collation, verbatim_131_088)
{
    uint32_t const cps[2] = { 0x1F3C, 0x003F };

    // 1F3C 003F;	
    // (Ἴ) GREEK CAPITAL LETTER IOTA WITH PSILI AND OXIA	[202C 0267 | 0020 0022 0024 0020 | 0008 0002 0002 0002 |]
    uint32_t const ces_non_ignorable[13] = { 0x202C, 0x0267, 0x0000, 0x0020, 0x0022, 0x0024, 0x0020, 0x0000, 0x0008, 0x0002, 0x0002, 0x0002, 0x0000 };

    auto const non_ignorable = collate_for_tests(
        cps, cps + 2, boost::text::variable_weighting::non_ignorable);

    EXPECT_EQ(non_ignorable.size(), 13);
    EXPECT_TRUE(boost::algorithm::equal(non_ignorable.begin(), non_ignorable.end(), ces_non_ignorable, ces_non_ignorable + 13))
        << "from:     " << ce_dumper(cps)
        << "expected: " << ce_dumper(ces_non_ignorable)
        << "got:      " << ce_dumper(non_ignorable);

    // 1F3C 003F;	
    // (Ἴ) GREEK CAPITAL LETTER IOTA WITH PSILI AND OXIA	[202C | 0020 0022 0024 | 0008 0002 0002 | FFFF FFFF FFFF 0267 |]
    uint32_t const ces_shifted[15] = { 0x202C, 0x0000, 0x0020, 0x0022, 0x0024, 0x0000, 0x0008, 0x0002, 0x0002, 0x0000, 0xFFFF, 0xFFFF, 0xFFFF, 0x0267, 0x0000 };

    auto const shifted = collate_for_tests(
        cps, cps + 2, boost::text::variable_weighting::shifted);

    EXPECT_EQ(shifted.size(), 15);
    EXPECT_TRUE(boost::algorithm::equal(shifted.begin(), shifted.end(), ces_shifted, ces_shifted + 15))
        << "from:     " << ce_dumper(cps)
        << "expected: " << ce_dumper(ces_shifted)
        << "got:      " << ce_dumper(shifted);
}

TEST(collation, verbatim_131_089)
{
    uint32_t const cps[2] = { 0x1F32, 0x003F };

    // 1F32 003F;	
    // (ἲ) GREEK SMALL LETTER IOTA WITH PSILI AND VARIA	[202C 0267 | 0020 0022 0025 0020 | 0002 0002 0002 0002 |]
    uint32_t const ces_non_ignorable[13] = { 0x202C, 0x0267, 0x0000, 0x0020, 0x0022, 0x0025, 0x0020, 0x0000, 0x0002, 0x0002, 0x0002, 0x0002, 0x0000 };

    auto const non_ignorable = collate_for_tests(
        cps, cps + 2, boost::text::variable_weighting::non_ignorable);

    EXPECT_EQ(non_ignorable.size(), 13);
    EXPECT_TRUE(boost::algorithm::equal(non_ignorable.begin(), non_ignorable.end(), ces_non_ignorable, ces_non_ignorable + 13))
        << "from:     " << ce_dumper(cps)
        << "expected: " << ce_dumper(ces_non_ignorable)
        << "got:      " << ce_dumper(non_ignorable);

    // 1F32 003F;	
    // (ἲ) GREEK SMALL LETTER IOTA WITH PSILI AND VARIA	[202C | 0020 0022 0025 | 0002 0002 0002 | FFFF FFFF FFFF 0267 |]
    uint32_t const ces_shifted[15] = { 0x202C, 0x0000, 0x0020, 0x0022, 0x0025, 0x0000, 0x0002, 0x0002, 0x0002, 0x0000, 0xFFFF, 0xFFFF, 0xFFFF, 0x0267, 0x0000 };

    auto const shifted = collate_for_tests(
        cps, cps + 2, boost::text::variable_weighting::shifted);

    EXPECT_EQ(shifted.size(), 15);
    EXPECT_TRUE(boost::algorithm::equal(shifted.begin(), shifted.end(), ces_shifted, ces_shifted + 15))
        << "from:     " << ce_dumper(cps)
        << "expected: " << ce_dumper(ces_shifted)
        << "got:      " << ce_dumper(shifted);
}

TEST(collation, verbatim_131_090)
{
    uint32_t const cps[2] = { 0x1F3A, 0x003F };

    // 1F3A 003F;	
    // (Ἲ) GREEK CAPITAL LETTER IOTA WITH PSILI AND VARIA	[202C 0267 | 0020 0022 0025 0020 | 0008 0002 0002 0002 |]
    uint32_t const ces_non_ignorable[13] = { 0x202C, 0x0267, 0x0000, 0x0020, 0x0022, 0x0025, 0x0020, 0x0000, 0x0008, 0x0002, 0x0002, 0x0002, 0x0000 };

    auto const non_ignorable = collate_for_tests(
        cps, cps + 2, boost::text::variable_weighting::non_ignorable);

    EXPECT_EQ(non_ignorable.size(), 13);
    EXPECT_TRUE(boost::algorithm::equal(non_ignorable.begin(), non_ignorable.end(), ces_non_ignorable, ces_non_ignorable + 13))
        << "from:     " << ce_dumper(cps)
        << "expected: " << ce_dumper(ces_non_ignorable)
        << "got:      " << ce_dumper(non_ignorable);

    // 1F3A 003F;	
    // (Ἲ) GREEK CAPITAL LETTER IOTA WITH PSILI AND VARIA	[202C | 0020 0022 0025 | 0008 0002 0002 | FFFF FFFF FFFF 0267 |]
    uint32_t const ces_shifted[15] = { 0x202C, 0x0000, 0x0020, 0x0022, 0x0025, 0x0000, 0x0008, 0x0002, 0x0002, 0x0000, 0xFFFF, 0xFFFF, 0xFFFF, 0x0267, 0x0000 };

    auto const shifted = collate_for_tests(
        cps, cps + 2, boost::text::variable_weighting::shifted);

    EXPECT_EQ(shifted.size(), 15);
    EXPECT_TRUE(boost::algorithm::equal(shifted.begin(), shifted.end(), ces_shifted, ces_shifted + 15))
        << "from:     " << ce_dumper(cps)
        << "expected: " << ce_dumper(ces_shifted)
        << "got:      " << ce_dumper(shifted);
}

TEST(collation, verbatim_131_091)
{
    uint32_t const cps[2] = { 0x1F36, 0x003F };

    // 1F36 003F;	
    // (ἶ) GREEK SMALL LETTER IOTA WITH PSILI AND PERISPOMENI	[202C 0267 | 0020 0022 002A 0020 | 0002 0002 0002 0002 |]
    uint32_t const ces_non_ignorable[13] = { 0x202C, 0x0267, 0x0000, 0x0020, 0x0022, 0x002A, 0x0020, 0x0000, 0x0002, 0x0002, 0x0002, 0x0002, 0x0000 };

    auto const non_ignorable = collate_for_tests(
        cps, cps + 2, boost::text::variable_weighting::non_ignorable);

    EXPECT_EQ(non_ignorable.size(), 13);
    EXPECT_TRUE(boost::algorithm::equal(non_ignorable.begin(), non_ignorable.end(), ces_non_ignorable, ces_non_ignorable + 13))
        << "from:     " << ce_dumper(cps)
        << "expected: " << ce_dumper(ces_non_ignorable)
        << "got:      " << ce_dumper(non_ignorable);

    // 1F36 003F;	
    // (ἶ) GREEK SMALL LETTER IOTA WITH PSILI AND PERISPOMENI	[202C | 0020 0022 002A | 0002 0002 0002 | FFFF FFFF FFFF 0267 |]
    uint32_t const ces_shifted[15] = { 0x202C, 0x0000, 0x0020, 0x0022, 0x002A, 0x0000, 0x0002, 0x0002, 0x0002, 0x0000, 0xFFFF, 0xFFFF, 0xFFFF, 0x0267, 0x0000 };

    auto const shifted = collate_for_tests(
        cps, cps + 2, boost::text::variable_weighting::shifted);

    EXPECT_EQ(shifted.size(), 15);
    EXPECT_TRUE(boost::algorithm::equal(shifted.begin(), shifted.end(), ces_shifted, ces_shifted + 15))
        << "from:     " << ce_dumper(cps)
        << "expected: " << ce_dumper(ces_shifted)
        << "got:      " << ce_dumper(shifted);
}

TEST(collation, verbatim_131_092)
{
    uint32_t const cps[2] = { 0x1F3E, 0x003F };

    // 1F3E 003F;	
    // (Ἶ) GREEK CAPITAL LETTER IOTA WITH PSILI AND PERISPOMENI	[202C 0267 | 0020 0022 002A 0020 | 0008 0002 0002 0002 |]
    uint32_t const ces_non_ignorable[13] = { 0x202C, 0x0267, 0x0000, 0x0020, 0x0022, 0x002A, 0x0020, 0x0000, 0x0008, 0x0002, 0x0002, 0x0002, 0x0000 };

    auto const non_ignorable = collate_for_tests(
        cps, cps + 2, boost::text::variable_weighting::non_ignorable);

    EXPECT_EQ(non_ignorable.size(), 13);
    EXPECT_TRUE(boost::algorithm::equal(non_ignorable.begin(), non_ignorable.end(), ces_non_ignorable, ces_non_ignorable + 13))
        << "from:     " << ce_dumper(cps)
        << "expected: " << ce_dumper(ces_non_ignorable)
        << "got:      " << ce_dumper(non_ignorable);

    // 1F3E 003F;	
    // (Ἶ) GREEK CAPITAL LETTER IOTA WITH PSILI AND PERISPOMENI	[202C | 0020 0022 002A | 0008 0002 0002 | FFFF FFFF FFFF 0267 |]
    uint32_t const ces_shifted[15] = { 0x202C, 0x0000, 0x0020, 0x0022, 0x002A, 0x0000, 0x0008, 0x0002, 0x0002, 0x0000, 0xFFFF, 0xFFFF, 0xFFFF, 0x0267, 0x0000 };

    auto const shifted = collate_for_tests(
        cps, cps + 2, boost::text::variable_weighting::shifted);

    EXPECT_EQ(shifted.size(), 15);
    EXPECT_TRUE(boost::algorithm::equal(shifted.begin(), shifted.end(), ces_shifted, ces_shifted + 15))
        << "from:     " << ce_dumper(cps)
        << "expected: " << ce_dumper(ces_shifted)
        << "got:      " << ce_dumper(shifted);
}

TEST(collation, verbatim_131_093)
{
    uint32_t const cps[2] = { 0x1F31, 0x003F };

    // 1F31 003F;	
    // (ἱ) GREEK SMALL LETTER IOTA WITH DASIA	[202C 0267 | 0020 0023 0020 | 0002 0002 0002 |]
    uint32_t const ces_non_ignorable[11] = { 0x202C, 0x0267, 0x0000, 0x0020, 0x0023, 0x0020, 0x0000, 0x0002, 0x0002, 0x0002, 0x0000 };

    auto const non_ignorable = collate_for_tests(
        cps, cps + 2, boost::text::variable_weighting::non_ignorable);

    EXPECT_EQ(non_ignorable.size(), 11);
    EXPECT_TRUE(boost::algorithm::equal(non_ignorable.begin(), non_ignorable.end(), ces_non_ignorable, ces_non_ignorable + 11))
        << "from:     " << ce_dumper(cps)
        << "expected: " << ce_dumper(ces_non_ignorable)
        << "got:      " << ce_dumper(non_ignorable);

    // 1F31 003F;	
    // (ἱ) GREEK SMALL LETTER IOTA WITH DASIA	[202C | 0020 0023 | 0002 0002 | FFFF FFFF 0267 |]
    uint32_t const ces_shifted[12] = { 0x202C, 0x0000, 0x0020, 0x0023, 0x0000, 0x0002, 0x0002, 0x0000, 0xFFFF, 0xFFFF, 0x0267, 0x0000 };

    auto const shifted = collate_for_tests(
        cps, cps + 2, boost::text::variable_weighting::shifted);

    EXPECT_EQ(shifted.size(), 12);
    EXPECT_TRUE(boost::algorithm::equal(shifted.begin(), shifted.end(), ces_shifted, ces_shifted + 12))
        << "from:     " << ce_dumper(cps)
        << "expected: " << ce_dumper(ces_shifted)
        << "got:      " << ce_dumper(shifted);
}

TEST(collation, verbatim_131_094)
{
    uint32_t const cps[2] = { 0x1F39, 0x003F };

    // 1F39 003F;	
    // (Ἱ) GREEK CAPITAL LETTER IOTA WITH DASIA	[202C 0267 | 0020 0023 0020 | 0008 0002 0002 |]
    uint32_t const ces_non_ignorable[11] = { 0x202C, 0x0267, 0x0000, 0x0020, 0x0023, 0x0020, 0x0000, 0x0008, 0x0002, 0x0002, 0x0000 };

    auto const non_ignorable = collate_for_tests(
        cps, cps + 2, boost::text::variable_weighting::non_ignorable);

    EXPECT_EQ(non_ignorable.size(), 11);
    EXPECT_TRUE(boost::algorithm::equal(non_ignorable.begin(), non_ignorable.end(), ces_non_ignorable, ces_non_ignorable + 11))
        << "from:     " << ce_dumper(cps)
        << "expected: " << ce_dumper(ces_non_ignorable)
        << "got:      " << ce_dumper(non_ignorable);

    // 1F39 003F;	
    // (Ἱ) GREEK CAPITAL LETTER IOTA WITH DASIA	[202C | 0020 0023 | 0008 0002 | FFFF FFFF 0267 |]
    uint32_t const ces_shifted[12] = { 0x202C, 0x0000, 0x0020, 0x0023, 0x0000, 0x0008, 0x0002, 0x0000, 0xFFFF, 0xFFFF, 0x0267, 0x0000 };

    auto const shifted = collate_for_tests(
        cps, cps + 2, boost::text::variable_weighting::shifted);

    EXPECT_EQ(shifted.size(), 12);
    EXPECT_TRUE(boost::algorithm::equal(shifted.begin(), shifted.end(), ces_shifted, ces_shifted + 12))
        << "from:     " << ce_dumper(cps)
        << "expected: " << ce_dumper(ces_shifted)
        << "got:      " << ce_dumper(shifted);
}

TEST(collation, verbatim_131_095)
{
    uint32_t const cps[2] = { 0x1F35, 0x003F };

    // 1F35 003F;	
    // (ἵ) GREEK SMALL LETTER IOTA WITH DASIA AND OXIA	[202C 0267 | 0020 0023 0024 0020 | 0002 0002 0002 0002 |]
    uint32_t const ces_non_ignorable[13] = { 0x202C, 0x0267, 0x0000, 0x0020, 0x0023, 0x0024, 0x0020, 0x0000, 0x0002, 0x0002, 0x0002, 0x0002, 0x0000 };

    auto const non_ignorable = collate_for_tests(
        cps, cps + 2, boost::text::variable_weighting::non_ignorable);

    EXPECT_EQ(non_ignorable.size(), 13);
    EXPECT_TRUE(boost::algorithm::equal(non_ignorable.begin(), non_ignorable.end(), ces_non_ignorable, ces_non_ignorable + 13))
        << "from:     " << ce_dumper(cps)
        << "expected: " << ce_dumper(ces_non_ignorable)
        << "got:      " << ce_dumper(non_ignorable);

    // 1F35 003F;	
    // (ἵ) GREEK SMALL LETTER IOTA WITH DASIA AND OXIA	[202C | 0020 0023 0024 | 0002 0002 0002 | FFFF FFFF FFFF 0267 |]
    uint32_t const ces_shifted[15] = { 0x202C, 0x0000, 0x0020, 0x0023, 0x0024, 0x0000, 0x0002, 0x0002, 0x0002, 0x0000, 0xFFFF, 0xFFFF, 0xFFFF, 0x0267, 0x0000 };

    auto const shifted = collate_for_tests(
        cps, cps + 2, boost::text::variable_weighting::shifted);

    EXPECT_EQ(shifted.size(), 15);
    EXPECT_TRUE(boost::algorithm::equal(shifted.begin(), shifted.end(), ces_shifted, ces_shifted + 15))
        << "from:     " << ce_dumper(cps)
        << "expected: " << ce_dumper(ces_shifted)
        << "got:      " << ce_dumper(shifted);
}

TEST(collation, verbatim_131_096)
{
    uint32_t const cps[2] = { 0x1F3D, 0x003F };

    // 1F3D 003F;	
    // (Ἵ) GREEK CAPITAL LETTER IOTA WITH DASIA AND OXIA	[202C 0267 | 0020 0023 0024 0020 | 0008 0002 0002 0002 |]
    uint32_t const ces_non_ignorable[13] = { 0x202C, 0x0267, 0x0000, 0x0020, 0x0023, 0x0024, 0x0020, 0x0000, 0x0008, 0x0002, 0x0002, 0x0002, 0x0000 };

    auto const non_ignorable = collate_for_tests(
        cps, cps + 2, boost::text::variable_weighting::non_ignorable);

    EXPECT_EQ(non_ignorable.size(), 13);
    EXPECT_TRUE(boost::algorithm::equal(non_ignorable.begin(), non_ignorable.end(), ces_non_ignorable, ces_non_ignorable + 13))
        << "from:     " << ce_dumper(cps)
        << "expected: " << ce_dumper(ces_non_ignorable)
        << "got:      " << ce_dumper(non_ignorable);

    // 1F3D 003F;	
    // (Ἵ) GREEK CAPITAL LETTER IOTA WITH DASIA AND OXIA	[202C | 0020 0023 0024 | 0008 0002 0002 | FFFF FFFF FFFF 0267 |]
    uint32_t const ces_shifted[15] = { 0x202C, 0x0000, 0x0020, 0x0023, 0x0024, 0x0000, 0x0008, 0x0002, 0x0002, 0x0000, 0xFFFF, 0xFFFF, 0xFFFF, 0x0267, 0x0000 };

    auto const shifted = collate_for_tests(
        cps, cps + 2, boost::text::variable_weighting::shifted);

    EXPECT_EQ(shifted.size(), 15);
    EXPECT_TRUE(boost::algorithm::equal(shifted.begin(), shifted.end(), ces_shifted, ces_shifted + 15))
        << "from:     " << ce_dumper(cps)
        << "expected: " << ce_dumper(ces_shifted)
        << "got:      " << ce_dumper(shifted);
}

TEST(collation, verbatim_131_097)
{
    uint32_t const cps[2] = { 0x1F33, 0x003F };

    // 1F33 003F;	
    // (ἳ) GREEK SMALL LETTER IOTA WITH DASIA AND VARIA	[202C 0267 | 0020 0023 0025 0020 | 0002 0002 0002 0002 |]
    uint32_t const ces_non_ignorable[13] = { 0x202C, 0x0267, 0x0000, 0x0020, 0x0023, 0x0025, 0x0020, 0x0000, 0x0002, 0x0002, 0x0002, 0x0002, 0x0000 };

    auto const non_ignorable = collate_for_tests(
        cps, cps + 2, boost::text::variable_weighting::non_ignorable);

    EXPECT_EQ(non_ignorable.size(), 13);
    EXPECT_TRUE(boost::algorithm::equal(non_ignorable.begin(), non_ignorable.end(), ces_non_ignorable, ces_non_ignorable + 13))
        << "from:     " << ce_dumper(cps)
        << "expected: " << ce_dumper(ces_non_ignorable)
        << "got:      " << ce_dumper(non_ignorable);

    // 1F33 003F;	
    // (ἳ) GREEK SMALL LETTER IOTA WITH DASIA AND VARIA	[202C | 0020 0023 0025 | 0002 0002 0002 | FFFF FFFF FFFF 0267 |]
    uint32_t const ces_shifted[15] = { 0x202C, 0x0000, 0x0020, 0x0023, 0x0025, 0x0000, 0x0002, 0x0002, 0x0002, 0x0000, 0xFFFF, 0xFFFF, 0xFFFF, 0x0267, 0x0000 };

    auto const shifted = collate_for_tests(
        cps, cps + 2, boost::text::variable_weighting::shifted);

    EXPECT_EQ(shifted.size(), 15);
    EXPECT_TRUE(boost::algorithm::equal(shifted.begin(), shifted.end(), ces_shifted, ces_shifted + 15))
        << "from:     " << ce_dumper(cps)
        << "expected: " << ce_dumper(ces_shifted)
        << "got:      " << ce_dumper(shifted);
}

TEST(collation, verbatim_131_098)
{
    uint32_t const cps[2] = { 0x1F3B, 0x003F };

    // 1F3B 003F;	
    // (Ἳ) GREEK CAPITAL LETTER IOTA WITH DASIA AND VARIA	[202C 0267 | 0020 0023 0025 0020 | 0008 0002 0002 0002 |]
    uint32_t const ces_non_ignorable[13] = { 0x202C, 0x0267, 0x0000, 0x0020, 0x0023, 0x0025, 0x0020, 0x0000, 0x0008, 0x0002, 0x0002, 0x0002, 0x0000 };

    auto const non_ignorable = collate_for_tests(
        cps, cps + 2, boost::text::variable_weighting::non_ignorable);

    EXPECT_EQ(non_ignorable.size(), 13);
    EXPECT_TRUE(boost::algorithm::equal(non_ignorable.begin(), non_ignorable.end(), ces_non_ignorable, ces_non_ignorable + 13))
        << "from:     " << ce_dumper(cps)
        << "expected: " << ce_dumper(ces_non_ignorable)
        << "got:      " << ce_dumper(non_ignorable);

    // 1F3B 003F;	
    // (Ἳ) GREEK CAPITAL LETTER IOTA WITH DASIA AND VARIA	[202C | 0020 0023 0025 | 0008 0002 0002 | FFFF FFFF FFFF 0267 |]
    uint32_t const ces_shifted[15] = { 0x202C, 0x0000, 0x0020, 0x0023, 0x0025, 0x0000, 0x0008, 0x0002, 0x0002, 0x0000, 0xFFFF, 0xFFFF, 0xFFFF, 0x0267, 0x0000 };

    auto const shifted = collate_for_tests(
        cps, cps + 2, boost::text::variable_weighting::shifted);

    EXPECT_EQ(shifted.size(), 15);
    EXPECT_TRUE(boost::algorithm::equal(shifted.begin(), shifted.end(), ces_shifted, ces_shifted + 15))
        << "from:     " << ce_dumper(cps)
        << "expected: " << ce_dumper(ces_shifted)
        << "got:      " << ce_dumper(shifted);
}

TEST(collation, verbatim_131_099)
{
    uint32_t const cps[2] = { 0x1F37, 0x003F };

    // 1F37 003F;	
    // (ἷ) GREEK SMALL LETTER IOTA WITH DASIA AND PERISPOMENI	[202C 0267 | 0020 0023 002A 0020 | 0002 0002 0002 0002 |]
    uint32_t const ces_non_ignorable[13] = { 0x202C, 0x0267, 0x0000, 0x0020, 0x0023, 0x002A, 0x0020, 0x0000, 0x0002, 0x0002, 0x0002, 0x0002, 0x0000 };

    auto const non_ignorable = collate_for_tests(
        cps, cps + 2, boost::text::variable_weighting::non_ignorable);

    EXPECT_EQ(non_ignorable.size(), 13);
    EXPECT_TRUE(boost::algorithm::equal(non_ignorable.begin(), non_ignorable.end(), ces_non_ignorable, ces_non_ignorable + 13))
        << "from:     " << ce_dumper(cps)
        << "expected: " << ce_dumper(ces_non_ignorable)
        << "got:      " << ce_dumper(non_ignorable);

    // 1F37 003F;	
    // (ἷ) GREEK SMALL LETTER IOTA WITH DASIA AND PERISPOMENI	[202C | 0020 0023 002A | 0002 0002 0002 | FFFF FFFF FFFF 0267 |]
    uint32_t const ces_shifted[15] = { 0x202C, 0x0000, 0x0020, 0x0023, 0x002A, 0x0000, 0x0002, 0x0002, 0x0002, 0x0000, 0xFFFF, 0xFFFF, 0xFFFF, 0x0267, 0x0000 };

    auto const shifted = collate_for_tests(
        cps, cps + 2, boost::text::variable_weighting::shifted);

    EXPECT_EQ(shifted.size(), 15);
    EXPECT_TRUE(boost::algorithm::equal(shifted.begin(), shifted.end(), ces_shifted, ces_shifted + 15))
        << "from:     " << ce_dumper(cps)
        << "expected: " << ce_dumper(ces_shifted)
        << "got:      " << ce_dumper(shifted);
}

TEST(collation, verbatim_131_100)
{
    uint32_t const cps[2] = { 0x1F3F, 0x003F };

    // 1F3F 003F;	
    // (Ἷ) GREEK CAPITAL LETTER IOTA WITH DASIA AND PERISPOMENI	[202C 0267 | 0020 0023 002A 0020 | 0008 0002 0002 0002 |]
    uint32_t const ces_non_ignorable[13] = { 0x202C, 0x0267, 0x0000, 0x0020, 0x0023, 0x002A, 0x0020, 0x0000, 0x0008, 0x0002, 0x0002, 0x0002, 0x0000 };

    auto const non_ignorable = collate_for_tests(
        cps, cps + 2, boost::text::variable_weighting::non_ignorable);

    EXPECT_EQ(non_ignorable.size(), 13);
    EXPECT_TRUE(boost::algorithm::equal(non_ignorable.begin(), non_ignorable.end(), ces_non_ignorable, ces_non_ignorable + 13))
        << "from:     " << ce_dumper(cps)
        << "expected: " << ce_dumper(ces_non_ignorable)
        << "got:      " << ce_dumper(non_ignorable);

    // 1F3F 003F;	
    // (Ἷ) GREEK CAPITAL LETTER IOTA WITH DASIA AND PERISPOMENI	[202C | 0020 0023 002A | 0008 0002 0002 | FFFF FFFF FFFF 0267 |]
    uint32_t const ces_shifted[15] = { 0x202C, 0x0000, 0x0020, 0x0023, 0x002A, 0x0000, 0x0008, 0x0002, 0x0002, 0x0000, 0xFFFF, 0xFFFF, 0xFFFF, 0x0267, 0x0000 };

    auto const shifted = collate_for_tests(
        cps, cps + 2, boost::text::variable_weighting::shifted);

    EXPECT_EQ(shifted.size(), 15);
    EXPECT_TRUE(boost::algorithm::equal(shifted.begin(), shifted.end(), ces_shifted, ces_shifted + 15))
        << "from:     " << ce_dumper(cps)
        << "expected: " << ce_dumper(ces_shifted)
        << "got:      " << ce_dumper(shifted);
}

TEST(collation, verbatim_131_101)
{
    uint32_t const cps[2] = { 0x03AF, 0x003F };

    // 03AF 003F;	
    // (ί) GREEK SMALL LETTER IOTA WITH TONOS	[202C 0267 | 0020 0024 0020 | 0002 0002 0002 |]
    uint32_t const ces_non_ignorable[11] = { 0x202C, 0x0267, 0x0000, 0x0020, 0x0024, 0x0020, 0x0000, 0x0002, 0x0002, 0x0002, 0x0000 };

    auto const non_ignorable = collate_for_tests(
        cps, cps + 2, boost::text::variable_weighting::non_ignorable);

    EXPECT_EQ(non_ignorable.size(), 11);
    EXPECT_TRUE(boost::algorithm::equal(non_ignorable.begin(), non_ignorable.end(), ces_non_ignorable, ces_non_ignorable + 11))
        << "from:     " << ce_dumper(cps)
        << "expected: " << ce_dumper(ces_non_ignorable)
        << "got:      " << ce_dumper(non_ignorable);

    // 03AF 003F;	
    // (ί) GREEK SMALL LETTER IOTA WITH TONOS	[202C | 0020 0024 | 0002 0002 | FFFF FFFF 0267 |]
    uint32_t const ces_shifted[12] = { 0x202C, 0x0000, 0x0020, 0x0024, 0x0000, 0x0002, 0x0002, 0x0000, 0xFFFF, 0xFFFF, 0x0267, 0x0000 };

    auto const shifted = collate_for_tests(
        cps, cps + 2, boost::text::variable_weighting::shifted);

    EXPECT_EQ(shifted.size(), 12);
    EXPECT_TRUE(boost::algorithm::equal(shifted.begin(), shifted.end(), ces_shifted, ces_shifted + 12))
        << "from:     " << ce_dumper(cps)
        << "expected: " << ce_dumper(ces_shifted)
        << "got:      " << ce_dumper(shifted);
}

TEST(collation, verbatim_131_102)
{
    uint32_t const cps[2] = { 0x1F77, 0x003F };

    // 1F77 003F;	
    // (ί) GREEK SMALL LETTER IOTA WITH OXIA	[202C 0267 | 0020 0024 0020 | 0002 0002 0002 |]
    uint32_t const ces_non_ignorable[11] = { 0x202C, 0x0267, 0x0000, 0x0020, 0x0024, 0x0020, 0x0000, 0x0002, 0x0002, 0x0002, 0x0000 };

    auto const non_ignorable = collate_for_tests(
        cps, cps + 2, boost::text::variable_weighting::non_ignorable);

    EXPECT_EQ(non_ignorable.size(), 11);
    EXPECT_TRUE(boost::algorithm::equal(non_ignorable.begin(), non_ignorable.end(), ces_non_ignorable, ces_non_ignorable + 11))
        << "from:     " << ce_dumper(cps)
        << "expected: " << ce_dumper(ces_non_ignorable)
        << "got:      " << ce_dumper(non_ignorable);

    // 1F77 003F;	
    // (ί) GREEK SMALL LETTER IOTA WITH OXIA	[202C | 0020 0024 | 0002 0002 | FFFF FFFF 0267 |]
    uint32_t const ces_shifted[12] = { 0x202C, 0x0000, 0x0020, 0x0024, 0x0000, 0x0002, 0x0002, 0x0000, 0xFFFF, 0xFFFF, 0x0267, 0x0000 };

    auto const shifted = collate_for_tests(
        cps, cps + 2, boost::text::variable_weighting::shifted);

    EXPECT_EQ(shifted.size(), 12);
    EXPECT_TRUE(boost::algorithm::equal(shifted.begin(), shifted.end(), ces_shifted, ces_shifted + 12))
        << "from:     " << ce_dumper(cps)
        << "expected: " << ce_dumper(ces_shifted)
        << "got:      " << ce_dumper(shifted);
}

TEST(collation, verbatim_131_103)
{
    uint32_t const cps[2] = { 0x038A, 0x003F };

    // 038A 003F;	
    // (Ί) GREEK CAPITAL LETTER IOTA WITH TONOS	[202C 0267 | 0020 0024 0020 | 0008 0002 0002 |]
    uint32_t const ces_non_ignorable[11] = { 0x202C, 0x0267, 0x0000, 0x0020, 0x0024, 0x0020, 0x0000, 0x0008, 0x0002, 0x0002, 0x0000 };

    auto const non_ignorable = collate_for_tests(
        cps, cps + 2, boost::text::variable_weighting::non_ignorable);

    EXPECT_EQ(non_ignorable.size(), 11);
    EXPECT_TRUE(boost::algorithm::equal(non_ignorable.begin(), non_ignorable.end(), ces_non_ignorable, ces_non_ignorable + 11))
        << "from:     " << ce_dumper(cps)
        << "expected: " << ce_dumper(ces_non_ignorable)
        << "got:      " << ce_dumper(non_ignorable);

    // 038A 003F;	
    // (Ί) GREEK CAPITAL LETTER IOTA WITH TONOS	[202C | 0020 0024 | 0008 0002 | FFFF FFFF 0267 |]
    uint32_t const ces_shifted[12] = { 0x202C, 0x0000, 0x0020, 0x0024, 0x0000, 0x0008, 0x0002, 0x0000, 0xFFFF, 0xFFFF, 0x0267, 0x0000 };

    auto const shifted = collate_for_tests(
        cps, cps + 2, boost::text::variable_weighting::shifted);

    EXPECT_EQ(shifted.size(), 12);
    EXPECT_TRUE(boost::algorithm::equal(shifted.begin(), shifted.end(), ces_shifted, ces_shifted + 12))
        << "from:     " << ce_dumper(cps)
        << "expected: " << ce_dumper(ces_shifted)
        << "got:      " << ce_dumper(shifted);
}

TEST(collation, verbatim_131_104)
{
    uint32_t const cps[2] = { 0x1FDB, 0x003F };

    // 1FDB 003F;	
    // (Ί) GREEK CAPITAL LETTER IOTA WITH OXIA	[202C 0267 | 0020 0024 0020 | 0008 0002 0002 |]
    uint32_t const ces_non_ignorable[11] = { 0x202C, 0x0267, 0x0000, 0x0020, 0x0024, 0x0020, 0x0000, 0x0008, 0x0002, 0x0002, 0x0000 };

    auto const non_ignorable = collate_for_tests(
        cps, cps + 2, boost::text::variable_weighting::non_ignorable);

    EXPECT_EQ(non_ignorable.size(), 11);
    EXPECT_TRUE(boost::algorithm::equal(non_ignorable.begin(), non_ignorable.end(), ces_non_ignorable, ces_non_ignorable + 11))
        << "from:     " << ce_dumper(cps)
        << "expected: " << ce_dumper(ces_non_ignorable)
        << "got:      " << ce_dumper(non_ignorable);

    // 1FDB 003F;	
    // (Ί) GREEK CAPITAL LETTER IOTA WITH OXIA	[202C | 0020 0024 | 0008 0002 | FFFF FFFF 0267 |]
    uint32_t const ces_shifted[12] = { 0x202C, 0x0000, 0x0020, 0x0024, 0x0000, 0x0008, 0x0002, 0x0000, 0xFFFF, 0xFFFF, 0x0267, 0x0000 };

    auto const shifted = collate_for_tests(
        cps, cps + 2, boost::text::variable_weighting::shifted);

    EXPECT_EQ(shifted.size(), 12);
    EXPECT_TRUE(boost::algorithm::equal(shifted.begin(), shifted.end(), ces_shifted, ces_shifted + 12))
        << "from:     " << ce_dumper(cps)
        << "expected: " << ce_dumper(ces_shifted)
        << "got:      " << ce_dumper(shifted);
}

TEST(collation, verbatim_131_105)
{
    uint32_t const cps[2] = { 0x1F76, 0x003F };

    // 1F76 003F;	
    // (ὶ) GREEK SMALL LETTER IOTA WITH VARIA	[202C 0267 | 0020 0025 0020 | 0002 0002 0002 |]
    uint32_t const ces_non_ignorable[11] = { 0x202C, 0x0267, 0x0000, 0x0020, 0x0025, 0x0020, 0x0000, 0x0002, 0x0002, 0x0002, 0x0000 };

    auto const non_ignorable = collate_for_tests(
        cps, cps + 2, boost::text::variable_weighting::non_ignorable);

    EXPECT_EQ(non_ignorable.size(), 11);
    EXPECT_TRUE(boost::algorithm::equal(non_ignorable.begin(), non_ignorable.end(), ces_non_ignorable, ces_non_ignorable + 11))
        << "from:     " << ce_dumper(cps)
        << "expected: " << ce_dumper(ces_non_ignorable)
        << "got:      " << ce_dumper(non_ignorable);

    // 1F76 003F;	
    // (ὶ) GREEK SMALL LETTER IOTA WITH VARIA	[202C | 0020 0025 | 0002 0002 | FFFF FFFF 0267 |]
    uint32_t const ces_shifted[12] = { 0x202C, 0x0000, 0x0020, 0x0025, 0x0000, 0x0002, 0x0002, 0x0000, 0xFFFF, 0xFFFF, 0x0267, 0x0000 };

    auto const shifted = collate_for_tests(
        cps, cps + 2, boost::text::variable_weighting::shifted);

    EXPECT_EQ(shifted.size(), 12);
    EXPECT_TRUE(boost::algorithm::equal(shifted.begin(), shifted.end(), ces_shifted, ces_shifted + 12))
        << "from:     " << ce_dumper(cps)
        << "expected: " << ce_dumper(ces_shifted)
        << "got:      " << ce_dumper(shifted);
}

TEST(collation, verbatim_131_106)
{
    uint32_t const cps[2] = { 0x1FDA, 0x003F };

    // 1FDA 003F;	
    // (Ὶ) GREEK CAPITAL LETTER IOTA WITH VARIA	[202C 0267 | 0020 0025 0020 | 0008 0002 0002 |]
    uint32_t const ces_non_ignorable[11] = { 0x202C, 0x0267, 0x0000, 0x0020, 0x0025, 0x0020, 0x0000, 0x0008, 0x0002, 0x0002, 0x0000 };

    auto const non_ignorable = collate_for_tests(
        cps, cps + 2, boost::text::variable_weighting::non_ignorable);

    EXPECT_EQ(non_ignorable.size(), 11);
    EXPECT_TRUE(boost::algorithm::equal(non_ignorable.begin(), non_ignorable.end(), ces_non_ignorable, ces_non_ignorable + 11))
        << "from:     " << ce_dumper(cps)
        << "expected: " << ce_dumper(ces_non_ignorable)
        << "got:      " << ce_dumper(non_ignorable);

    // 1FDA 003F;	
    // (Ὶ) GREEK CAPITAL LETTER IOTA WITH VARIA	[202C | 0020 0025 | 0008 0002 | FFFF FFFF 0267 |]
    uint32_t const ces_shifted[12] = { 0x202C, 0x0000, 0x0020, 0x0025, 0x0000, 0x0008, 0x0002, 0x0000, 0xFFFF, 0xFFFF, 0x0267, 0x0000 };

    auto const shifted = collate_for_tests(
        cps, cps + 2, boost::text::variable_weighting::shifted);

    EXPECT_EQ(shifted.size(), 12);
    EXPECT_TRUE(boost::algorithm::equal(shifted.begin(), shifted.end(), ces_shifted, ces_shifted + 12))
        << "from:     " << ce_dumper(cps)
        << "expected: " << ce_dumper(ces_shifted)
        << "got:      " << ce_dumper(shifted);
}

TEST(collation, verbatim_131_107)
{
    uint32_t const cps[2] = { 0x1FD0, 0x003F };

    // 1FD0 003F;	
    // (ῐ) GREEK SMALL LETTER IOTA WITH VRACHY	[202C 0267 | 0020 0026 0020 | 0002 0002 0002 |]
    uint32_t const ces_non_ignorable[11] = { 0x202C, 0x0267, 0x0000, 0x0020, 0x0026, 0x0020, 0x0000, 0x0002, 0x0002, 0x0002, 0x0000 };

    auto const non_ignorable = collate_for_tests(
        cps, cps + 2, boost::text::variable_weighting::non_ignorable);

    EXPECT_EQ(non_ignorable.size(), 11);
    EXPECT_TRUE(boost::algorithm::equal(non_ignorable.begin(), non_ignorable.end(), ces_non_ignorable, ces_non_ignorable + 11))
        << "from:     " << ce_dumper(cps)
        << "expected: " << ce_dumper(ces_non_ignorable)
        << "got:      " << ce_dumper(non_ignorable);

    // 1FD0 003F;	
    // (ῐ) GREEK SMALL LETTER IOTA WITH VRACHY	[202C | 0020 0026 | 0002 0002 | FFFF FFFF 0267 |]
    uint32_t const ces_shifted[12] = { 0x202C, 0x0000, 0x0020, 0x0026, 0x0000, 0x0002, 0x0002, 0x0000, 0xFFFF, 0xFFFF, 0x0267, 0x0000 };

    auto const shifted = collate_for_tests(
        cps, cps + 2, boost::text::variable_weighting::shifted);

    EXPECT_EQ(shifted.size(), 12);
    EXPECT_TRUE(boost::algorithm::equal(shifted.begin(), shifted.end(), ces_shifted, ces_shifted + 12))
        << "from:     " << ce_dumper(cps)
        << "expected: " << ce_dumper(ces_shifted)
        << "got:      " << ce_dumper(shifted);
}

TEST(collation, verbatim_131_108)
{
    uint32_t const cps[2] = { 0x1FD8, 0x003F };

    // 1FD8 003F;	
    // (Ῐ) GREEK CAPITAL LETTER IOTA WITH VRACHY	[202C 0267 | 0020 0026 0020 | 0008 0002 0002 |]
    uint32_t const ces_non_ignorable[11] = { 0x202C, 0x0267, 0x0000, 0x0020, 0x0026, 0x0020, 0x0000, 0x0008, 0x0002, 0x0002, 0x0000 };

    auto const non_ignorable = collate_for_tests(
        cps, cps + 2, boost::text::variable_weighting::non_ignorable);

    EXPECT_EQ(non_ignorable.size(), 11);
    EXPECT_TRUE(boost::algorithm::equal(non_ignorable.begin(), non_ignorable.end(), ces_non_ignorable, ces_non_ignorable + 11))
        << "from:     " << ce_dumper(cps)
        << "expected: " << ce_dumper(ces_non_ignorable)
        << "got:      " << ce_dumper(non_ignorable);

    // 1FD8 003F;	
    // (Ῐ) GREEK CAPITAL LETTER IOTA WITH VRACHY	[202C | 0020 0026 | 0008 0002 | FFFF FFFF 0267 |]
    uint32_t const ces_shifted[12] = { 0x202C, 0x0000, 0x0020, 0x0026, 0x0000, 0x0008, 0x0002, 0x0000, 0xFFFF, 0xFFFF, 0x0267, 0x0000 };

    auto const shifted = collate_for_tests(
        cps, cps + 2, boost::text::variable_weighting::shifted);

    EXPECT_EQ(shifted.size(), 12);
    EXPECT_TRUE(boost::algorithm::equal(shifted.begin(), shifted.end(), ces_shifted, ces_shifted + 12))
        << "from:     " << ce_dumper(cps)
        << "expected: " << ce_dumper(ces_shifted)
        << "got:      " << ce_dumper(shifted);
}

TEST(collation, verbatim_131_109)
{
    uint32_t const cps[2] = { 0x1FD6, 0x003F };

    // 1FD6 003F;	
    // (ῖ) GREEK SMALL LETTER IOTA WITH PERISPOMENI	[202C 0267 | 0020 002A 0020 | 0002 0002 0002 |]
    uint32_t const ces_non_ignorable[11] = { 0x202C, 0x0267, 0x0000, 0x0020, 0x002A, 0x0020, 0x0000, 0x0002, 0x0002, 0x0002, 0x0000 };

    auto const non_ignorable = collate_for_tests(
        cps, cps + 2, boost::text::variable_weighting::non_ignorable);

    EXPECT_EQ(non_ignorable.size(), 11);
    EXPECT_TRUE(boost::algorithm::equal(non_ignorable.begin(), non_ignorable.end(), ces_non_ignorable, ces_non_ignorable + 11))
        << "from:     " << ce_dumper(cps)
        << "expected: " << ce_dumper(ces_non_ignorable)
        << "got:      " << ce_dumper(non_ignorable);

    // 1FD6 003F;	
    // (ῖ) GREEK SMALL LETTER IOTA WITH PERISPOMENI	[202C | 0020 002A | 0002 0002 | FFFF FFFF 0267 |]
    uint32_t const ces_shifted[12] = { 0x202C, 0x0000, 0x0020, 0x002A, 0x0000, 0x0002, 0x0002, 0x0000, 0xFFFF, 0xFFFF, 0x0267, 0x0000 };

    auto const shifted = collate_for_tests(
        cps, cps + 2, boost::text::variable_weighting::shifted);

    EXPECT_EQ(shifted.size(), 12);
    EXPECT_TRUE(boost::algorithm::equal(shifted.begin(), shifted.end(), ces_shifted, ces_shifted + 12))
        << "from:     " << ce_dumper(cps)
        << "expected: " << ce_dumper(ces_shifted)
        << "got:      " << ce_dumper(shifted);
}

TEST(collation, verbatim_131_110)
{
    uint32_t const cps[2] = { 0x03CA, 0x003F };

    // 03CA 003F;	
    // (ϊ) GREEK SMALL LETTER IOTA WITH DIALYTIKA	[202C 0267 | 0020 002B 0020 | 0002 0002 0002 |]
    uint32_t const ces_non_ignorable[11] = { 0x202C, 0x0267, 0x0000, 0x0020, 0x002B, 0x0020, 0x0000, 0x0002, 0x0002, 0x0002, 0x0000 };

    auto const non_ignorable = collate_for_tests(
        cps, cps + 2, boost::text::variable_weighting::non_ignorable);

    EXPECT_EQ(non_ignorable.size(), 11);
    EXPECT_TRUE(boost::algorithm::equal(non_ignorable.begin(), non_ignorable.end(), ces_non_ignorable, ces_non_ignorable + 11))
        << "from:     " << ce_dumper(cps)
        << "expected: " << ce_dumper(ces_non_ignorable)
        << "got:      " << ce_dumper(non_ignorable);

    // 03CA 003F;	
    // (ϊ) GREEK SMALL LETTER IOTA WITH DIALYTIKA	[202C | 0020 002B | 0002 0002 | FFFF FFFF 0267 |]
    uint32_t const ces_shifted[12] = { 0x202C, 0x0000, 0x0020, 0x002B, 0x0000, 0x0002, 0x0002, 0x0000, 0xFFFF, 0xFFFF, 0x0267, 0x0000 };

    auto const shifted = collate_for_tests(
        cps, cps + 2, boost::text::variable_weighting::shifted);

    EXPECT_EQ(shifted.size(), 12);
    EXPECT_TRUE(boost::algorithm::equal(shifted.begin(), shifted.end(), ces_shifted, ces_shifted + 12))
        << "from:     " << ce_dumper(cps)
        << "expected: " << ce_dumper(ces_shifted)
        << "got:      " << ce_dumper(shifted);
}

TEST(collation, verbatim_131_111)
{
    uint32_t const cps[2] = { 0x03AA, 0x003F };

    // 03AA 003F;	
    // (Ϊ) GREEK CAPITAL LETTER IOTA WITH DIALYTIKA	[202C 0267 | 0020 002B 0020 | 0008 0002 0002 |]
    uint32_t const ces_non_ignorable[11] = { 0x202C, 0x0267, 0x0000, 0x0020, 0x002B, 0x0020, 0x0000, 0x0008, 0x0002, 0x0002, 0x0000 };

    auto const non_ignorable = collate_for_tests(
        cps, cps + 2, boost::text::variable_weighting::non_ignorable);

    EXPECT_EQ(non_ignorable.size(), 11);
    EXPECT_TRUE(boost::algorithm::equal(non_ignorable.begin(), non_ignorable.end(), ces_non_ignorable, ces_non_ignorable + 11))
        << "from:     " << ce_dumper(cps)
        << "expected: " << ce_dumper(ces_non_ignorable)
        << "got:      " << ce_dumper(non_ignorable);

    // 03AA 003F;	
    // (Ϊ) GREEK CAPITAL LETTER IOTA WITH DIALYTIKA	[202C | 0020 002B | 0008 0002 | FFFF FFFF 0267 |]
    uint32_t const ces_shifted[12] = { 0x202C, 0x0000, 0x0020, 0x002B, 0x0000, 0x0008, 0x0002, 0x0000, 0xFFFF, 0xFFFF, 0x0267, 0x0000 };

    auto const shifted = collate_for_tests(
        cps, cps + 2, boost::text::variable_weighting::shifted);

    EXPECT_EQ(shifted.size(), 12);
    EXPECT_TRUE(boost::algorithm::equal(shifted.begin(), shifted.end(), ces_shifted, ces_shifted + 12))
        << "from:     " << ce_dumper(cps)
        << "expected: " << ce_dumper(ces_shifted)
        << "got:      " << ce_dumper(shifted);
}

TEST(collation, verbatim_131_112)
{
    uint32_t const cps[2] = { 0x0390, 0x003F };

    // 0390 003F;	
    // (ΐ) GREEK SMALL LETTER IOTA WITH DIALYTIKA AND TONOS	[202C 0267 | 0020 002B 0024 0020 | 0002 0002 0002 0002 |]
    uint32_t const ces_non_ignorable[13] = { 0x202C, 0x0267, 0x0000, 0x0020, 0x002B, 0x0024, 0x0020, 0x0000, 0x0002, 0x0002, 0x0002, 0x0002, 0x0000 };

    auto const non_ignorable = collate_for_tests(
        cps, cps + 2, boost::text::variable_weighting::non_ignorable);

    EXPECT_EQ(non_ignorable.size(), 13);
    EXPECT_TRUE(boost::algorithm::equal(non_ignorable.begin(), non_ignorable.end(), ces_non_ignorable, ces_non_ignorable + 13))
        << "from:     " << ce_dumper(cps)
        << "expected: " << ce_dumper(ces_non_ignorable)
        << "got:      " << ce_dumper(non_ignorable);

    // 0390 003F;	
    // (ΐ) GREEK SMALL LETTER IOTA WITH DIALYTIKA AND TONOS	[202C | 0020 002B 0024 | 0002 0002 0002 | FFFF FFFF FFFF 0267 |]
    uint32_t const ces_shifted[15] = { 0x202C, 0x0000, 0x0020, 0x002B, 0x0024, 0x0000, 0x0002, 0x0002, 0x0002, 0x0000, 0xFFFF, 0xFFFF, 0xFFFF, 0x0267, 0x0000 };

    auto const shifted = collate_for_tests(
        cps, cps + 2, boost::text::variable_weighting::shifted);

    EXPECT_EQ(shifted.size(), 15);
    EXPECT_TRUE(boost::algorithm::equal(shifted.begin(), shifted.end(), ces_shifted, ces_shifted + 15))
        << "from:     " << ce_dumper(cps)
        << "expected: " << ce_dumper(ces_shifted)
        << "got:      " << ce_dumper(shifted);
}

TEST(collation, verbatim_131_113)
{
    uint32_t const cps[2] = { 0x1FD3, 0x003F };

    // 1FD3 003F;	
    // (ΐ) GREEK SMALL LETTER IOTA WITH DIALYTIKA AND OXIA	[202C 0267 | 0020 002B 0024 0020 | 0002 0002 0002 0002 |]
    uint32_t const ces_non_ignorable[13] = { 0x202C, 0x0267, 0x0000, 0x0020, 0x002B, 0x0024, 0x0020, 0x0000, 0x0002, 0x0002, 0x0002, 0x0002, 0x0000 };

    auto const non_ignorable = collate_for_tests(
        cps, cps + 2, boost::text::variable_weighting::non_ignorable);

    EXPECT_EQ(non_ignorable.size(), 13);
    EXPECT_TRUE(boost::algorithm::equal(non_ignorable.begin(), non_ignorable.end(), ces_non_ignorable, ces_non_ignorable + 13))
        << "from:     " << ce_dumper(cps)
        << "expected: " << ce_dumper(ces_non_ignorable)
        << "got:      " << ce_dumper(non_ignorable);

    // 1FD3 003F;	
    // (ΐ) GREEK SMALL LETTER IOTA WITH DIALYTIKA AND OXIA	[202C | 0020 002B 0024 | 0002 0002 0002 | FFFF FFFF FFFF 0267 |]
    uint32_t const ces_shifted[15] = { 0x202C, 0x0000, 0x0020, 0x002B, 0x0024, 0x0000, 0x0002, 0x0002, 0x0002, 0x0000, 0xFFFF, 0xFFFF, 0xFFFF, 0x0267, 0x0000 };

    auto const shifted = collate_for_tests(
        cps, cps + 2, boost::text::variable_weighting::shifted);

    EXPECT_EQ(shifted.size(), 15);
    EXPECT_TRUE(boost::algorithm::equal(shifted.begin(), shifted.end(), ces_shifted, ces_shifted + 15))
        << "from:     " << ce_dumper(cps)
        << "expected: " << ce_dumper(ces_shifted)
        << "got:      " << ce_dumper(shifted);
}

TEST(collation, verbatim_131_114)
{
    uint32_t const cps[2] = { 0x1FD2, 0x003F };

    // 1FD2 003F;	
    // (ῒ) GREEK SMALL LETTER IOTA WITH DIALYTIKA AND VARIA	[202C 0267 | 0020 002B 0025 0020 | 0002 0002 0002 0002 |]
    uint32_t const ces_non_ignorable[13] = { 0x202C, 0x0267, 0x0000, 0x0020, 0x002B, 0x0025, 0x0020, 0x0000, 0x0002, 0x0002, 0x0002, 0x0002, 0x0000 };

    auto const non_ignorable = collate_for_tests(
        cps, cps + 2, boost::text::variable_weighting::non_ignorable);

    EXPECT_EQ(non_ignorable.size(), 13);
    EXPECT_TRUE(boost::algorithm::equal(non_ignorable.begin(), non_ignorable.end(), ces_non_ignorable, ces_non_ignorable + 13))
        << "from:     " << ce_dumper(cps)
        << "expected: " << ce_dumper(ces_non_ignorable)
        << "got:      " << ce_dumper(non_ignorable);

    // 1FD2 003F;	
    // (ῒ) GREEK SMALL LETTER IOTA WITH DIALYTIKA AND VARIA	[202C | 0020 002B 0025 | 0002 0002 0002 | FFFF FFFF FFFF 0267 |]
    uint32_t const ces_shifted[15] = { 0x202C, 0x0000, 0x0020, 0x002B, 0x0025, 0x0000, 0x0002, 0x0002, 0x0002, 0x0000, 0xFFFF, 0xFFFF, 0xFFFF, 0x0267, 0x0000 };

    auto const shifted = collate_for_tests(
        cps, cps + 2, boost::text::variable_weighting::shifted);

    EXPECT_EQ(shifted.size(), 15);
    EXPECT_TRUE(boost::algorithm::equal(shifted.begin(), shifted.end(), ces_shifted, ces_shifted + 15))
        << "from:     " << ce_dumper(cps)
        << "expected: " << ce_dumper(ces_shifted)
        << "got:      " << ce_dumper(shifted);
}

TEST(collation, verbatim_131_115)
{
    uint32_t const cps[2] = { 0x1FD7, 0x003F };

    // 1FD7 003F;	
    // (ῗ) GREEK SMALL LETTER IOTA WITH DIALYTIKA AND PERISPOMENI	[202C 0267 | 0020 002B 002A 0020 | 0002 0002 0002 0002 |]
    uint32_t const ces_non_ignorable[13] = { 0x202C, 0x0267, 0x0000, 0x0020, 0x002B, 0x002A, 0x0020, 0x0000, 0x0002, 0x0002, 0x0002, 0x0002, 0x0000 };

    auto const non_ignorable = collate_for_tests(
        cps, cps + 2, boost::text::variable_weighting::non_ignorable);

    EXPECT_EQ(non_ignorable.size(), 13);
    EXPECT_TRUE(boost::algorithm::equal(non_ignorable.begin(), non_ignorable.end(), ces_non_ignorable, ces_non_ignorable + 13))
        << "from:     " << ce_dumper(cps)
        << "expected: " << ce_dumper(ces_non_ignorable)
        << "got:      " << ce_dumper(non_ignorable);

    // 1FD7 003F;	
    // (ῗ) GREEK SMALL LETTER IOTA WITH DIALYTIKA AND PERISPOMENI	[202C | 0020 002B 002A | 0002 0002 0002 | FFFF FFFF FFFF 0267 |]
    uint32_t const ces_shifted[15] = { 0x202C, 0x0000, 0x0020, 0x002B, 0x002A, 0x0000, 0x0002, 0x0002, 0x0002, 0x0000, 0xFFFF, 0xFFFF, 0xFFFF, 0x0267, 0x0000 };

    auto const shifted = collate_for_tests(
        cps, cps + 2, boost::text::variable_weighting::shifted);

    EXPECT_EQ(shifted.size(), 15);
    EXPECT_TRUE(boost::algorithm::equal(shifted.begin(), shifted.end(), ces_shifted, ces_shifted + 15))
        << "from:     " << ce_dumper(cps)
        << "expected: " << ce_dumper(ces_shifted)
        << "got:      " << ce_dumper(shifted);
}

TEST(collation, verbatim_131_116)
{
    uint32_t const cps[2] = { 0x1FD1, 0x003F };

    // 1FD1 003F;	
    // (ῑ) GREEK SMALL LETTER IOTA WITH MACRON	[202C 0267 | 0020 0032 0020 | 0002 0002 0002 |]
    uint32_t const ces_non_ignorable[11] = { 0x202C, 0x0267, 0x0000, 0x0020, 0x0032, 0x0020, 0x0000, 0x0002, 0x0002, 0x0002, 0x0000 };

    auto const non_ignorable = collate_for_tests(
        cps, cps + 2, boost::text::variable_weighting::non_ignorable);

    EXPECT_EQ(non_ignorable.size(), 11);
    EXPECT_TRUE(boost::algorithm::equal(non_ignorable.begin(), non_ignorable.end(), ces_non_ignorable, ces_non_ignorable + 11))
        << "from:     " << ce_dumper(cps)
        << "expected: " << ce_dumper(ces_non_ignorable)
        << "got:      " << ce_dumper(non_ignorable);

    // 1FD1 003F;	
    // (ῑ) GREEK SMALL LETTER IOTA WITH MACRON	[202C | 0020 0032 | 0002 0002 | FFFF FFFF 0267 |]
    uint32_t const ces_shifted[12] = { 0x202C, 0x0000, 0x0020, 0x0032, 0x0000, 0x0002, 0x0002, 0x0000, 0xFFFF, 0xFFFF, 0x0267, 0x0000 };

    auto const shifted = collate_for_tests(
        cps, cps + 2, boost::text::variable_weighting::shifted);

    EXPECT_EQ(shifted.size(), 12);
    EXPECT_TRUE(boost::algorithm::equal(shifted.begin(), shifted.end(), ces_shifted, ces_shifted + 12))
        << "from:     " << ce_dumper(cps)
        << "expected: " << ce_dumper(ces_shifted)
        << "got:      " << ce_dumper(shifted);
}

TEST(collation, verbatim_131_117)
{
    uint32_t const cps[2] = { 0x1FD9, 0x003F };

    // 1FD9 003F;	
    // (Ῑ) GREEK CAPITAL LETTER IOTA WITH MACRON	[202C 0267 | 0020 0032 0020 | 0008 0002 0002 |]
    uint32_t const ces_non_ignorable[11] = { 0x202C, 0x0267, 0x0000, 0x0020, 0x0032, 0x0020, 0x0000, 0x0008, 0x0002, 0x0002, 0x0000 };

    auto const non_ignorable = collate_for_tests(
        cps, cps + 2, boost::text::variable_weighting::non_ignorable);

    EXPECT_EQ(non_ignorable.size(), 11);
    EXPECT_TRUE(boost::algorithm::equal(non_ignorable.begin(), non_ignorable.end(), ces_non_ignorable, ces_non_ignorable + 11))
        << "from:     " << ce_dumper(cps)
        << "expected: " << ce_dumper(ces_non_ignorable)
        << "got:      " << ce_dumper(non_ignorable);

    // 1FD9 003F;	
    // (Ῑ) GREEK CAPITAL LETTER IOTA WITH MACRON	[202C | 0020 0032 | 0008 0002 | FFFF FFFF 0267 |]
    uint32_t const ces_shifted[12] = { 0x202C, 0x0000, 0x0020, 0x0032, 0x0000, 0x0008, 0x0002, 0x0000, 0xFFFF, 0xFFFF, 0x0267, 0x0000 };

    auto const shifted = collate_for_tests(
        cps, cps + 2, boost::text::variable_weighting::shifted);

    EXPECT_EQ(shifted.size(), 12);
    EXPECT_TRUE(boost::algorithm::equal(shifted.begin(), shifted.end(), ces_shifted, ces_shifted + 12))
        << "from:     " << ce_dumper(cps)
        << "expected: " << ce_dumper(ces_shifted)
        << "got:      " << ce_dumper(shifted);
}

TEST(collation, verbatim_131_118)
{
    uint32_t const cps[2] = { 0x03B9, 0x0061 };

    // 03B9 0061;	
    // (ι) GREEK SMALL LETTER IOTA	[202C 1CAD | 0020 0020 | 0002 0002 |]
    uint32_t const ces_non_ignorable[9] = { 0x202C, 0x1CAD, 0x0000, 0x0020, 0x0020, 0x0000, 0x0002, 0x0002, 0x0000 };

    auto const non_ignorable = collate_for_tests(
        cps, cps + 2, boost::text::variable_weighting::non_ignorable);

    EXPECT_EQ(non_ignorable.size(), 9);
    EXPECT_TRUE(boost::algorithm::equal(non_ignorable.begin(), non_ignorable.end(), ces_non_ignorable, ces_non_ignorable + 9))
        << "from:     " << ce_dumper(cps)
        << "expected: " << ce_dumper(ces_non_ignorable)
        << "got:      " << ce_dumper(non_ignorable);

    // 03B9 0061;	
    // (ι) GREEK SMALL LETTER IOTA	[202C 1CAD | 0020 0020 | 0002 0002 | FFFF FFFF |]
    uint32_t const ces_shifted[12] = { 0x202C, 0x1CAD, 0x0000, 0x0020, 0x0020, 0x0000, 0x0002, 0x0002, 0x0000, 0xFFFF, 0xFFFF, 0x0000 };

    auto const shifted = collate_for_tests(
        cps, cps + 2, boost::text::variable_weighting::shifted);

    EXPECT_EQ(shifted.size(), 12);
    EXPECT_TRUE(boost::algorithm::equal(shifted.begin(), shifted.end(), ces_shifted, ces_shifted + 12))
        << "from:     " << ce_dumper(cps)
        << "expected: " << ce_dumper(ces_shifted)
        << "got:      " << ce_dumper(shifted);
}

TEST(collation, verbatim_131_119)
{
    uint32_t const cps[2] = { 0x1FBE, 0x0061 };

    // 1FBE 0061;	
    // (ι) GREEK PROSGEGRAMMENI	[202C 1CAD | 0020 0020 | 0002 0002 |]
    uint32_t const ces_non_ignorable[9] = { 0x202C, 0x1CAD, 0x0000, 0x0020, 0x0020, 0x0000, 0x0002, 0x0002, 0x0000 };

    auto const non_ignorable = collate_for_tests(
        cps, cps + 2, boost::text::variable_weighting::non_ignorable);

    EXPECT_EQ(non_ignorable.size(), 9);
    EXPECT_TRUE(boost::algorithm::equal(non_ignorable.begin(), non_ignorable.end(), ces_non_ignorable, ces_non_ignorable + 9))
        << "from:     " << ce_dumper(cps)
        << "expected: " << ce_dumper(ces_non_ignorable)
        << "got:      " << ce_dumper(non_ignorable);

    // 1FBE 0061;	
    // (ι) GREEK PROSGEGRAMMENI	[202C 1CAD | 0020 0020 | 0002 0002 | FFFF FFFF |]
    uint32_t const ces_shifted[12] = { 0x202C, 0x1CAD, 0x0000, 0x0020, 0x0020, 0x0000, 0x0002, 0x0002, 0x0000, 0xFFFF, 0xFFFF, 0x0000 };

    auto const shifted = collate_for_tests(
        cps, cps + 2, boost::text::variable_weighting::shifted);

    EXPECT_EQ(shifted.size(), 12);
    EXPECT_TRUE(boost::algorithm::equal(shifted.begin(), shifted.end(), ces_shifted, ces_shifted + 12))
        << "from:     " << ce_dumper(cps)
        << "expected: " << ce_dumper(ces_shifted)
        << "got:      " << ce_dumper(shifted);
}

TEST(collation, verbatim_131_120)
{
    uint32_t const cps[2] = { 0x03B9, 0x0041 };

    // 03B9 0041;	
    // (ι) GREEK SMALL LETTER IOTA	[202C 1CAD | 0020 0020 | 0002 0008 |]
    uint32_t const ces_non_ignorable[9] = { 0x202C, 0x1CAD, 0x0000, 0x0020, 0x0020, 0x0000, 0x0002, 0x0008, 0x0000 };

    auto const non_ignorable = collate_for_tests(
        cps, cps + 2, boost::text::variable_weighting::non_ignorable);

    EXPECT_EQ(non_ignorable.size(), 9);
    EXPECT_TRUE(boost::algorithm::equal(non_ignorable.begin(), non_ignorable.end(), ces_non_ignorable, ces_non_ignorable + 9))
        << "from:     " << ce_dumper(cps)
        << "expected: " << ce_dumper(ces_non_ignorable)
        << "got:      " << ce_dumper(non_ignorable);

    // 03B9 0041;	
    // (ι) GREEK SMALL LETTER IOTA	[202C 1CAD | 0020 0020 | 0002 0008 | FFFF FFFF |]
    uint32_t const ces_shifted[12] = { 0x202C, 0x1CAD, 0x0000, 0x0020, 0x0020, 0x0000, 0x0002, 0x0008, 0x0000, 0xFFFF, 0xFFFF, 0x0000 };

    auto const shifted = collate_for_tests(
        cps, cps + 2, boost::text::variable_weighting::shifted);

    EXPECT_EQ(shifted.size(), 12);
    EXPECT_TRUE(boost::algorithm::equal(shifted.begin(), shifted.end(), ces_shifted, ces_shifted + 12))
        << "from:     " << ce_dumper(cps)
        << "expected: " << ce_dumper(ces_shifted)
        << "got:      " << ce_dumper(shifted);
}

TEST(collation, verbatim_131_121)
{
    uint32_t const cps[2] = { 0x1FBE, 0x0041 };

    // 1FBE 0041;	
    // (ι) GREEK PROSGEGRAMMENI	[202C 1CAD | 0020 0020 | 0002 0008 |]
    uint32_t const ces_non_ignorable[9] = { 0x202C, 0x1CAD, 0x0000, 0x0020, 0x0020, 0x0000, 0x0002, 0x0008, 0x0000 };

    auto const non_ignorable = collate_for_tests(
        cps, cps + 2, boost::text::variable_weighting::non_ignorable);

    EXPECT_EQ(non_ignorable.size(), 9);
    EXPECT_TRUE(boost::algorithm::equal(non_ignorable.begin(), non_ignorable.end(), ces_non_ignorable, ces_non_ignorable + 9))
        << "from:     " << ce_dumper(cps)
        << "expected: " << ce_dumper(ces_non_ignorable)
        << "got:      " << ce_dumper(non_ignorable);

    // 1FBE 0041;	
    // (ι) GREEK PROSGEGRAMMENI	[202C 1CAD | 0020 0020 | 0002 0008 | FFFF FFFF |]
    uint32_t const ces_shifted[12] = { 0x202C, 0x1CAD, 0x0000, 0x0020, 0x0020, 0x0000, 0x0002, 0x0008, 0x0000, 0xFFFF, 0xFFFF, 0x0000 };

    auto const shifted = collate_for_tests(
        cps, cps + 2, boost::text::variable_weighting::shifted);

    EXPECT_EQ(shifted.size(), 12);
    EXPECT_TRUE(boost::algorithm::equal(shifted.begin(), shifted.end(), ces_shifted, ces_shifted + 12))
        << "from:     " << ce_dumper(cps)
        << "expected: " << ce_dumper(ces_shifted)
        << "got:      " << ce_dumper(shifted);
}

TEST(collation, verbatim_131_122)
{
    uint32_t const cps[2] = { 0x037A, 0x0061 };

    // 037A 0061;	
    // (ͺ) GREEK YPOGEGRAMMENI	[202C 1CAD | 0020 0020 | 0004 0002 |]
    uint32_t const ces_non_ignorable[9] = { 0x202C, 0x1CAD, 0x0000, 0x0020, 0x0020, 0x0000, 0x0004, 0x0002, 0x0000 };

    auto const non_ignorable = collate_for_tests(
        cps, cps + 2, boost::text::variable_weighting::non_ignorable);

    EXPECT_EQ(non_ignorable.size(), 9);
    EXPECT_TRUE(boost::algorithm::equal(non_ignorable.begin(), non_ignorable.end(), ces_non_ignorable, ces_non_ignorable + 9))
        << "from:     " << ce_dumper(cps)
        << "expected: " << ce_dumper(ces_non_ignorable)
        << "got:      " << ce_dumper(non_ignorable);

    // 037A 0061;	
    // (ͺ) GREEK YPOGEGRAMMENI	[202C 1CAD | 0020 0020 | 0004 0002 | FFFF FFFF |]
    uint32_t const ces_shifted[12] = { 0x202C, 0x1CAD, 0x0000, 0x0020, 0x0020, 0x0000, 0x0004, 0x0002, 0x0000, 0xFFFF, 0xFFFF, 0x0000 };

    auto const shifted = collate_for_tests(
        cps, cps + 2, boost::text::variable_weighting::shifted);

    EXPECT_EQ(shifted.size(), 12);
    EXPECT_TRUE(boost::algorithm::equal(shifted.begin(), shifted.end(), ces_shifted, ces_shifted + 12))
        << "from:     " << ce_dumper(cps)
        << "expected: " << ce_dumper(ces_shifted)
        << "got:      " << ce_dumper(shifted);
}

TEST(collation, verbatim_131_123)
{
    uint32_t const cps[2] = { 0x037A, 0x0041 };

    // 037A 0041;	
    // (ͺ) GREEK YPOGEGRAMMENI	[202C 1CAD | 0020 0020 | 0004 0008 |]
    uint32_t const ces_non_ignorable[9] = { 0x202C, 0x1CAD, 0x0000, 0x0020, 0x0020, 0x0000, 0x0004, 0x0008, 0x0000 };

    auto const non_ignorable = collate_for_tests(
        cps, cps + 2, boost::text::variable_weighting::non_ignorable);

    EXPECT_EQ(non_ignorable.size(), 9);
    EXPECT_TRUE(boost::algorithm::equal(non_ignorable.begin(), non_ignorable.end(), ces_non_ignorable, ces_non_ignorable + 9))
        << "from:     " << ce_dumper(cps)
        << "expected: " << ce_dumper(ces_non_ignorable)
        << "got:      " << ce_dumper(non_ignorable);

    // 037A 0041;	
    // (ͺ) GREEK YPOGEGRAMMENI	[202C 1CAD | 0020 0020 | 0004 0008 | FFFF FFFF |]
    uint32_t const ces_shifted[12] = { 0x202C, 0x1CAD, 0x0000, 0x0020, 0x0020, 0x0000, 0x0004, 0x0008, 0x0000, 0xFFFF, 0xFFFF, 0x0000 };

    auto const shifted = collate_for_tests(
        cps, cps + 2, boost::text::variable_weighting::shifted);

    EXPECT_EQ(shifted.size(), 12);
    EXPECT_TRUE(boost::algorithm::equal(shifted.begin(), shifted.end(), ces_shifted, ces_shifted + 12))
        << "from:     " << ce_dumper(cps)
        << "expected: " << ce_dumper(ces_shifted)
        << "got:      " << ce_dumper(shifted);
}

TEST(collation, verbatim_131_124)
{
    uint32_t const cps[2] = { 0x1D6CA, 0x0061 };

    // 1D6CA 0061;	
    // (𝛊) MATHEMATICAL BOLD SMALL IOTA	[202C 1CAD | 0020 0020 | 0005 0002 |]
    uint32_t const ces_non_ignorable[9] = { 0x202C, 0x1CAD, 0x0000, 0x0020, 0x0020, 0x0000, 0x0005, 0x0002, 0x0000 };

    auto const non_ignorable = collate_for_tests(
        cps, cps + 2, boost::text::variable_weighting::non_ignorable);

    EXPECT_EQ(non_ignorable.size(), 9);
    EXPECT_TRUE(boost::algorithm::equal(non_ignorable.begin(), non_ignorable.end(), ces_non_ignorable, ces_non_ignorable + 9))
        << "from:     " << ce_dumper(cps)
        << "expected: " << ce_dumper(ces_non_ignorable)
        << "got:      " << ce_dumper(non_ignorable);

    // 1D6CA 0061;	
    // (𝛊) MATHEMATICAL BOLD SMALL IOTA	[202C 1CAD | 0020 0020 | 0005 0002 | FFFF FFFF |]
    uint32_t const ces_shifted[12] = { 0x202C, 0x1CAD, 0x0000, 0x0020, 0x0020, 0x0000, 0x0005, 0x0002, 0x0000, 0xFFFF, 0xFFFF, 0x0000 };

    auto const shifted = collate_for_tests(
        cps, cps + 2, boost::text::variable_weighting::shifted);

    EXPECT_EQ(shifted.size(), 12);
    EXPECT_TRUE(boost::algorithm::equal(shifted.begin(), shifted.end(), ces_shifted, ces_shifted + 12))
        << "from:     " << ce_dumper(cps)
        << "expected: " << ce_dumper(ces_shifted)
        << "got:      " << ce_dumper(shifted);
}

TEST(collation, verbatim_131_125)
{
    uint32_t const cps[2] = { 0x1D704, 0x0061 };

    // 1D704 0061;	
    // (𝜄) MATHEMATICAL ITALIC SMALL IOTA	[202C 1CAD | 0020 0020 | 0005 0002 |]
    uint32_t const ces_non_ignorable[9] = { 0x202C, 0x1CAD, 0x0000, 0x0020, 0x0020, 0x0000, 0x0005, 0x0002, 0x0000 };

    auto const non_ignorable = collate_for_tests(
        cps, cps + 2, boost::text::variable_weighting::non_ignorable);

    EXPECT_EQ(non_ignorable.size(), 9);
    EXPECT_TRUE(boost::algorithm::equal(non_ignorable.begin(), non_ignorable.end(), ces_non_ignorable, ces_non_ignorable + 9))
        << "from:     " << ce_dumper(cps)
        << "expected: " << ce_dumper(ces_non_ignorable)
        << "got:      " << ce_dumper(non_ignorable);

    // 1D704 0061;	
    // (𝜄) MATHEMATICAL ITALIC SMALL IOTA	[202C 1CAD | 0020 0020 | 0005 0002 | FFFF FFFF |]
    uint32_t const ces_shifted[12] = { 0x202C, 0x1CAD, 0x0000, 0x0020, 0x0020, 0x0000, 0x0005, 0x0002, 0x0000, 0xFFFF, 0xFFFF, 0x0000 };

    auto const shifted = collate_for_tests(
        cps, cps + 2, boost::text::variable_weighting::shifted);

    EXPECT_EQ(shifted.size(), 12);
    EXPECT_TRUE(boost::algorithm::equal(shifted.begin(), shifted.end(), ces_shifted, ces_shifted + 12))
        << "from:     " << ce_dumper(cps)
        << "expected: " << ce_dumper(ces_shifted)
        << "got:      " << ce_dumper(shifted);
}

TEST(collation, verbatim_131_126)
{
    uint32_t const cps[2] = { 0x1D73E, 0x0061 };

    // 1D73E 0061;	
    // (𝜾) MATHEMATICAL BOLD ITALIC SMALL IOTA	[202C 1CAD | 0020 0020 | 0005 0002 |]
    uint32_t const ces_non_ignorable[9] = { 0x202C, 0x1CAD, 0x0000, 0x0020, 0x0020, 0x0000, 0x0005, 0x0002, 0x0000 };

    auto const non_ignorable = collate_for_tests(
        cps, cps + 2, boost::text::variable_weighting::non_ignorable);

    EXPECT_EQ(non_ignorable.size(), 9);
    EXPECT_TRUE(boost::algorithm::equal(non_ignorable.begin(), non_ignorable.end(), ces_non_ignorable, ces_non_ignorable + 9))
        << "from:     " << ce_dumper(cps)
        << "expected: " << ce_dumper(ces_non_ignorable)
        << "got:      " << ce_dumper(non_ignorable);

    // 1D73E 0061;	
    // (𝜾) MATHEMATICAL BOLD ITALIC SMALL IOTA	[202C 1CAD | 0020 0020 | 0005 0002 | FFFF FFFF |]
    uint32_t const ces_shifted[12] = { 0x202C, 0x1CAD, 0x0000, 0x0020, 0x0020, 0x0000, 0x0005, 0x0002, 0x0000, 0xFFFF, 0xFFFF, 0x0000 };

    auto const shifted = collate_for_tests(
        cps, cps + 2, boost::text::variable_weighting::shifted);

    EXPECT_EQ(shifted.size(), 12);
    EXPECT_TRUE(boost::algorithm::equal(shifted.begin(), shifted.end(), ces_shifted, ces_shifted + 12))
        << "from:     " << ce_dumper(cps)
        << "expected: " << ce_dumper(ces_shifted)
        << "got:      " << ce_dumper(shifted);
}

TEST(collation, verbatim_131_127)
{
    uint32_t const cps[2] = { 0x1D778, 0x0061 };

    // 1D778 0061;	
    // (𝝸) MATHEMATICAL SANS-SERIF BOLD SMALL IOTA	[202C 1CAD | 0020 0020 | 0005 0002 |]
    uint32_t const ces_non_ignorable[9] = { 0x202C, 0x1CAD, 0x0000, 0x0020, 0x0020, 0x0000, 0x0005, 0x0002, 0x0000 };

    auto const non_ignorable = collate_for_tests(
        cps, cps + 2, boost::text::variable_weighting::non_ignorable);

    EXPECT_EQ(non_ignorable.size(), 9);
    EXPECT_TRUE(boost::algorithm::equal(non_ignorable.begin(), non_ignorable.end(), ces_non_ignorable, ces_non_ignorable + 9))
        << "from:     " << ce_dumper(cps)
        << "expected: " << ce_dumper(ces_non_ignorable)
        << "got:      " << ce_dumper(non_ignorable);

    // 1D778 0061;	
    // (𝝸) MATHEMATICAL SANS-SERIF BOLD SMALL IOTA	[202C 1CAD | 0020 0020 | 0005 0002 | FFFF FFFF |]
    uint32_t const ces_shifted[12] = { 0x202C, 0x1CAD, 0x0000, 0x0020, 0x0020, 0x0000, 0x0005, 0x0002, 0x0000, 0xFFFF, 0xFFFF, 0x0000 };

    auto const shifted = collate_for_tests(
        cps, cps + 2, boost::text::variable_weighting::shifted);

    EXPECT_EQ(shifted.size(), 12);
    EXPECT_TRUE(boost::algorithm::equal(shifted.begin(), shifted.end(), ces_shifted, ces_shifted + 12))
        << "from:     " << ce_dumper(cps)
        << "expected: " << ce_dumper(ces_shifted)
        << "got:      " << ce_dumper(shifted);
}

TEST(collation, verbatim_131_128)
{
    uint32_t const cps[2] = { 0x1D7B2, 0x0061 };

    // 1D7B2 0061;	
    // (𝞲) MATHEMATICAL SANS-SERIF BOLD ITALIC SMALL IOTA	[202C 1CAD | 0020 0020 | 0005 0002 |]
    uint32_t const ces_non_ignorable[9] = { 0x202C, 0x1CAD, 0x0000, 0x0020, 0x0020, 0x0000, 0x0005, 0x0002, 0x0000 };

    auto const non_ignorable = collate_for_tests(
        cps, cps + 2, boost::text::variable_weighting::non_ignorable);

    EXPECT_EQ(non_ignorable.size(), 9);
    EXPECT_TRUE(boost::algorithm::equal(non_ignorable.begin(), non_ignorable.end(), ces_non_ignorable, ces_non_ignorable + 9))
        << "from:     " << ce_dumper(cps)
        << "expected: " << ce_dumper(ces_non_ignorable)
        << "got:      " << ce_dumper(non_ignorable);

    // 1D7B2 0061;	
    // (𝞲) MATHEMATICAL SANS-SERIF BOLD ITALIC SMALL IOTA	[202C 1CAD | 0020 0020 | 0005 0002 | FFFF FFFF |]
    uint32_t const ces_shifted[12] = { 0x202C, 0x1CAD, 0x0000, 0x0020, 0x0020, 0x0000, 0x0005, 0x0002, 0x0000, 0xFFFF, 0xFFFF, 0x0000 };

    auto const shifted = collate_for_tests(
        cps, cps + 2, boost::text::variable_weighting::shifted);

    EXPECT_EQ(shifted.size(), 12);
    EXPECT_TRUE(boost::algorithm::equal(shifted.begin(), shifted.end(), ces_shifted, ces_shifted + 12))
        << "from:     " << ce_dumper(cps)
        << "expected: " << ce_dumper(ces_shifted)
        << "got:      " << ce_dumper(shifted);
}

TEST(collation, verbatim_131_129)
{
    uint32_t const cps[2] = { 0x1D6CA, 0x0041 };

    // 1D6CA 0041;	
    // (𝛊) MATHEMATICAL BOLD SMALL IOTA	[202C 1CAD | 0020 0020 | 0005 0008 |]
    uint32_t const ces_non_ignorable[9] = { 0x202C, 0x1CAD, 0x0000, 0x0020, 0x0020, 0x0000, 0x0005, 0x0008, 0x0000 };

    auto const non_ignorable = collate_for_tests(
        cps, cps + 2, boost::text::variable_weighting::non_ignorable);

    EXPECT_EQ(non_ignorable.size(), 9);
    EXPECT_TRUE(boost::algorithm::equal(non_ignorable.begin(), non_ignorable.end(), ces_non_ignorable, ces_non_ignorable + 9))
        << "from:     " << ce_dumper(cps)
        << "expected: " << ce_dumper(ces_non_ignorable)
        << "got:      " << ce_dumper(non_ignorable);

    // 1D6CA 0041;	
    // (𝛊) MATHEMATICAL BOLD SMALL IOTA	[202C 1CAD | 0020 0020 | 0005 0008 | FFFF FFFF |]
    uint32_t const ces_shifted[12] = { 0x202C, 0x1CAD, 0x0000, 0x0020, 0x0020, 0x0000, 0x0005, 0x0008, 0x0000, 0xFFFF, 0xFFFF, 0x0000 };

    auto const shifted = collate_for_tests(
        cps, cps + 2, boost::text::variable_weighting::shifted);

    EXPECT_EQ(shifted.size(), 12);
    EXPECT_TRUE(boost::algorithm::equal(shifted.begin(), shifted.end(), ces_shifted, ces_shifted + 12))
        << "from:     " << ce_dumper(cps)
        << "expected: " << ce_dumper(ces_shifted)
        << "got:      " << ce_dumper(shifted);
}

TEST(collation, verbatim_131_130)
{
    uint32_t const cps[2] = { 0x1D704, 0x0041 };

    // 1D704 0041;	
    // (𝜄) MATHEMATICAL ITALIC SMALL IOTA	[202C 1CAD | 0020 0020 | 0005 0008 |]
    uint32_t const ces_non_ignorable[9] = { 0x202C, 0x1CAD, 0x0000, 0x0020, 0x0020, 0x0000, 0x0005, 0x0008, 0x0000 };

    auto const non_ignorable = collate_for_tests(
        cps, cps + 2, boost::text::variable_weighting::non_ignorable);

    EXPECT_EQ(non_ignorable.size(), 9);
    EXPECT_TRUE(boost::algorithm::equal(non_ignorable.begin(), non_ignorable.end(), ces_non_ignorable, ces_non_ignorable + 9))
        << "from:     " << ce_dumper(cps)
        << "expected: " << ce_dumper(ces_non_ignorable)
        << "got:      " << ce_dumper(non_ignorable);

    // 1D704 0041;	
    // (𝜄) MATHEMATICAL ITALIC SMALL IOTA	[202C 1CAD | 0020 0020 | 0005 0008 | FFFF FFFF |]
    uint32_t const ces_shifted[12] = { 0x202C, 0x1CAD, 0x0000, 0x0020, 0x0020, 0x0000, 0x0005, 0x0008, 0x0000, 0xFFFF, 0xFFFF, 0x0000 };

    auto const shifted = collate_for_tests(
        cps, cps + 2, boost::text::variable_weighting::shifted);

    EXPECT_EQ(shifted.size(), 12);
    EXPECT_TRUE(boost::algorithm::equal(shifted.begin(), shifted.end(), ces_shifted, ces_shifted + 12))
        << "from:     " << ce_dumper(cps)
        << "expected: " << ce_dumper(ces_shifted)
        << "got:      " << ce_dumper(shifted);
}

TEST(collation, verbatim_131_131)
{
    uint32_t const cps[2] = { 0x1D73E, 0x0041 };

    // 1D73E 0041;	
    // (𝜾) MATHEMATICAL BOLD ITALIC SMALL IOTA	[202C 1CAD | 0020 0020 | 0005 0008 |]
    uint32_t const ces_non_ignorable[9] = { 0x202C, 0x1CAD, 0x0000, 0x0020, 0x0020, 0x0000, 0x0005, 0x0008, 0x0000 };

    auto const non_ignorable = collate_for_tests(
        cps, cps + 2, boost::text::variable_weighting::non_ignorable);

    EXPECT_EQ(non_ignorable.size(), 9);
    EXPECT_TRUE(boost::algorithm::equal(non_ignorable.begin(), non_ignorable.end(), ces_non_ignorable, ces_non_ignorable + 9))
        << "from:     " << ce_dumper(cps)
        << "expected: " << ce_dumper(ces_non_ignorable)
        << "got:      " << ce_dumper(non_ignorable);

    // 1D73E 0041;	
    // (𝜾) MATHEMATICAL BOLD ITALIC SMALL IOTA	[202C 1CAD | 0020 0020 | 0005 0008 | FFFF FFFF |]
    uint32_t const ces_shifted[12] = { 0x202C, 0x1CAD, 0x0000, 0x0020, 0x0020, 0x0000, 0x0005, 0x0008, 0x0000, 0xFFFF, 0xFFFF, 0x0000 };

    auto const shifted = collate_for_tests(
        cps, cps + 2, boost::text::variable_weighting::shifted);

    EXPECT_EQ(shifted.size(), 12);
    EXPECT_TRUE(boost::algorithm::equal(shifted.begin(), shifted.end(), ces_shifted, ces_shifted + 12))
        << "from:     " << ce_dumper(cps)
        << "expected: " << ce_dumper(ces_shifted)
        << "got:      " << ce_dumper(shifted);
}

TEST(collation, verbatim_131_132)
{
    uint32_t const cps[2] = { 0x1D778, 0x0041 };

    // 1D778 0041;	
    // (𝝸) MATHEMATICAL SANS-SERIF BOLD SMALL IOTA	[202C 1CAD | 0020 0020 | 0005 0008 |]
    uint32_t const ces_non_ignorable[9] = { 0x202C, 0x1CAD, 0x0000, 0x0020, 0x0020, 0x0000, 0x0005, 0x0008, 0x0000 };

    auto const non_ignorable = collate_for_tests(
        cps, cps + 2, boost::text::variable_weighting::non_ignorable);

    EXPECT_EQ(non_ignorable.size(), 9);
    EXPECT_TRUE(boost::algorithm::equal(non_ignorable.begin(), non_ignorable.end(), ces_non_ignorable, ces_non_ignorable + 9))
        << "from:     " << ce_dumper(cps)
        << "expected: " << ce_dumper(ces_non_ignorable)
        << "got:      " << ce_dumper(non_ignorable);

    // 1D778 0041;	
    // (𝝸) MATHEMATICAL SANS-SERIF BOLD SMALL IOTA	[202C 1CAD | 0020 0020 | 0005 0008 | FFFF FFFF |]
    uint32_t const ces_shifted[12] = { 0x202C, 0x1CAD, 0x0000, 0x0020, 0x0020, 0x0000, 0x0005, 0x0008, 0x0000, 0xFFFF, 0xFFFF, 0x0000 };

    auto const shifted = collate_for_tests(
        cps, cps + 2, boost::text::variable_weighting::shifted);

    EXPECT_EQ(shifted.size(), 12);
    EXPECT_TRUE(boost::algorithm::equal(shifted.begin(), shifted.end(), ces_shifted, ces_shifted + 12))
        << "from:     " << ce_dumper(cps)
        << "expected: " << ce_dumper(ces_shifted)
        << "got:      " << ce_dumper(shifted);
}

TEST(collation, verbatim_131_133)
{
    uint32_t const cps[2] = { 0x1D7B2, 0x0041 };

    // 1D7B2 0041;	
    // (𝞲) MATHEMATICAL SANS-SERIF BOLD ITALIC SMALL IOTA	[202C 1CAD | 0020 0020 | 0005 0008 |]
    uint32_t const ces_non_ignorable[9] = { 0x202C, 0x1CAD, 0x0000, 0x0020, 0x0020, 0x0000, 0x0005, 0x0008, 0x0000 };

    auto const non_ignorable = collate_for_tests(
        cps, cps + 2, boost::text::variable_weighting::non_ignorable);

    EXPECT_EQ(non_ignorable.size(), 9);
    EXPECT_TRUE(boost::algorithm::equal(non_ignorable.begin(), non_ignorable.end(), ces_non_ignorable, ces_non_ignorable + 9))
        << "from:     " << ce_dumper(cps)
        << "expected: " << ce_dumper(ces_non_ignorable)
        << "got:      " << ce_dumper(non_ignorable);

    // 1D7B2 0041;	
    // (𝞲) MATHEMATICAL SANS-SERIF BOLD ITALIC SMALL IOTA	[202C 1CAD | 0020 0020 | 0005 0008 | FFFF FFFF |]
    uint32_t const ces_shifted[12] = { 0x202C, 0x1CAD, 0x0000, 0x0020, 0x0020, 0x0000, 0x0005, 0x0008, 0x0000, 0xFFFF, 0xFFFF, 0x0000 };

    auto const shifted = collate_for_tests(
        cps, cps + 2, boost::text::variable_weighting::shifted);

    EXPECT_EQ(shifted.size(), 12);
    EXPECT_TRUE(boost::algorithm::equal(shifted.begin(), shifted.end(), ces_shifted, ces_shifted + 12))
        << "from:     " << ce_dumper(cps)
        << "expected: " << ce_dumper(ces_shifted)
        << "got:      " << ce_dumper(shifted);
}

TEST(collation, verbatim_131_134)
{
    uint32_t const cps[2] = { 0x0399, 0x0061 };

    // 0399 0061;	
    // (Ι) GREEK CAPITAL LETTER IOTA	[202C 1CAD | 0020 0020 | 0008 0002 |]
    uint32_t const ces_non_ignorable[9] = { 0x202C, 0x1CAD, 0x0000, 0x0020, 0x0020, 0x0000, 0x0008, 0x0002, 0x0000 };

    auto const non_ignorable = collate_for_tests(
        cps, cps + 2, boost::text::variable_weighting::non_ignorable);

    EXPECT_EQ(non_ignorable.size(), 9);
    EXPECT_TRUE(boost::algorithm::equal(non_ignorable.begin(), non_ignorable.end(), ces_non_ignorable, ces_non_ignorable + 9))
        << "from:     " << ce_dumper(cps)
        << "expected: " << ce_dumper(ces_non_ignorable)
        << "got:      " << ce_dumper(non_ignorable);

    // 0399 0061;	
    // (Ι) GREEK CAPITAL LETTER IOTA	[202C 1CAD | 0020 0020 | 0008 0002 | FFFF FFFF |]
    uint32_t const ces_shifted[12] = { 0x202C, 0x1CAD, 0x0000, 0x0020, 0x0020, 0x0000, 0x0008, 0x0002, 0x0000, 0xFFFF, 0xFFFF, 0x0000 };

    auto const shifted = collate_for_tests(
        cps, cps + 2, boost::text::variable_weighting::shifted);

    EXPECT_EQ(shifted.size(), 12);
    EXPECT_TRUE(boost::algorithm::equal(shifted.begin(), shifted.end(), ces_shifted, ces_shifted + 12))
        << "from:     " << ce_dumper(cps)
        << "expected: " << ce_dumper(ces_shifted)
        << "got:      " << ce_dumper(shifted);
}

TEST(collation, verbatim_131_135)
{
    uint32_t const cps[2] = { 0x0399, 0x0041 };

    // 0399 0041;	
    // (Ι) GREEK CAPITAL LETTER IOTA	[202C 1CAD | 0020 0020 | 0008 0008 |]
    uint32_t const ces_non_ignorable[9] = { 0x202C, 0x1CAD, 0x0000, 0x0020, 0x0020, 0x0000, 0x0008, 0x0008, 0x0000 };

    auto const non_ignorable = collate_for_tests(
        cps, cps + 2, boost::text::variable_weighting::non_ignorable);

    EXPECT_EQ(non_ignorable.size(), 9);
    EXPECT_TRUE(boost::algorithm::equal(non_ignorable.begin(), non_ignorable.end(), ces_non_ignorable, ces_non_ignorable + 9))
        << "from:     " << ce_dumper(cps)
        << "expected: " << ce_dumper(ces_non_ignorable)
        << "got:      " << ce_dumper(non_ignorable);

    // 0399 0041;	
    // (Ι) GREEK CAPITAL LETTER IOTA	[202C 1CAD | 0020 0020 | 0008 0008 | FFFF FFFF |]
    uint32_t const ces_shifted[12] = { 0x202C, 0x1CAD, 0x0000, 0x0020, 0x0020, 0x0000, 0x0008, 0x0008, 0x0000, 0xFFFF, 0xFFFF, 0x0000 };

    auto const shifted = collate_for_tests(
        cps, cps + 2, boost::text::variable_weighting::shifted);

    EXPECT_EQ(shifted.size(), 12);
    EXPECT_TRUE(boost::algorithm::equal(shifted.begin(), shifted.end(), ces_shifted, ces_shifted + 12))
        << "from:     " << ce_dumper(cps)
        << "expected: " << ce_dumper(ces_shifted)
        << "got:      " << ce_dumper(shifted);
}

TEST(collation, verbatim_131_136)
{
    uint32_t const cps[2] = { 0x1D6B0, 0x0061 };

    // 1D6B0 0061;	
    // (𝚰) MATHEMATICAL BOLD CAPITAL IOTA	[202C 1CAD | 0020 0020 | 000B 0002 |]
    uint32_t const ces_non_ignorable[9] = { 0x202C, 0x1CAD, 0x0000, 0x0020, 0x0020, 0x0000, 0x000B, 0x0002, 0x0000 };

    auto const non_ignorable = collate_for_tests(
        cps, cps + 2, boost::text::variable_weighting::non_ignorable);

    EXPECT_EQ(non_ignorable.size(), 9);
    EXPECT_TRUE(boost::algorithm::equal(non_ignorable.begin(), non_ignorable.end(), ces_non_ignorable, ces_non_ignorable + 9))
        << "from:     " << ce_dumper(cps)
        << "expected: " << ce_dumper(ces_non_ignorable)
        << "got:      " << ce_dumper(non_ignorable);

    // 1D6B0 0061;	
    // (𝚰) MATHEMATICAL BOLD CAPITAL IOTA	[202C 1CAD | 0020 0020 | 000B 0002 | FFFF FFFF |]
    uint32_t const ces_shifted[12] = { 0x202C, 0x1CAD, 0x0000, 0x0020, 0x0020, 0x0000, 0x000B, 0x0002, 0x0000, 0xFFFF, 0xFFFF, 0x0000 };

    auto const shifted = collate_for_tests(
        cps, cps + 2, boost::text::variable_weighting::shifted);

    EXPECT_EQ(shifted.size(), 12);
    EXPECT_TRUE(boost::algorithm::equal(shifted.begin(), shifted.end(), ces_shifted, ces_shifted + 12))
        << "from:     " << ce_dumper(cps)
        << "expected: " << ce_dumper(ces_shifted)
        << "got:      " << ce_dumper(shifted);
}

TEST(collation, verbatim_131_137)
{
    uint32_t const cps[2] = { 0x1D6EA, 0x0061 };

    // 1D6EA 0061;	
    // (𝛪) MATHEMATICAL ITALIC CAPITAL IOTA	[202C 1CAD | 0020 0020 | 000B 0002 |]
    uint32_t const ces_non_ignorable[9] = { 0x202C, 0x1CAD, 0x0000, 0x0020, 0x0020, 0x0000, 0x000B, 0x0002, 0x0000 };

    auto const non_ignorable = collate_for_tests(
        cps, cps + 2, boost::text::variable_weighting::non_ignorable);

    EXPECT_EQ(non_ignorable.size(), 9);
    EXPECT_TRUE(boost::algorithm::equal(non_ignorable.begin(), non_ignorable.end(), ces_non_ignorable, ces_non_ignorable + 9))
        << "from:     " << ce_dumper(cps)
        << "expected: " << ce_dumper(ces_non_ignorable)
        << "got:      " << ce_dumper(non_ignorable);

    // 1D6EA 0061;	
    // (𝛪) MATHEMATICAL ITALIC CAPITAL IOTA	[202C 1CAD | 0020 0020 | 000B 0002 | FFFF FFFF |]
    uint32_t const ces_shifted[12] = { 0x202C, 0x1CAD, 0x0000, 0x0020, 0x0020, 0x0000, 0x000B, 0x0002, 0x0000, 0xFFFF, 0xFFFF, 0x0000 };

    auto const shifted = collate_for_tests(
        cps, cps + 2, boost::text::variable_weighting::shifted);

    EXPECT_EQ(shifted.size(), 12);
    EXPECT_TRUE(boost::algorithm::equal(shifted.begin(), shifted.end(), ces_shifted, ces_shifted + 12))
        << "from:     " << ce_dumper(cps)
        << "expected: " << ce_dumper(ces_shifted)
        << "got:      " << ce_dumper(shifted);
}

TEST(collation, verbatim_131_138)
{
    uint32_t const cps[2] = { 0x1D724, 0x0061 };

    // 1D724 0061;	
    // (𝜤) MATHEMATICAL BOLD ITALIC CAPITAL IOTA	[202C 1CAD | 0020 0020 | 000B 0002 |]
    uint32_t const ces_non_ignorable[9] = { 0x202C, 0x1CAD, 0x0000, 0x0020, 0x0020, 0x0000, 0x000B, 0x0002, 0x0000 };

    auto const non_ignorable = collate_for_tests(
        cps, cps + 2, boost::text::variable_weighting::non_ignorable);

    EXPECT_EQ(non_ignorable.size(), 9);
    EXPECT_TRUE(boost::algorithm::equal(non_ignorable.begin(), non_ignorable.end(), ces_non_ignorable, ces_non_ignorable + 9))
        << "from:     " << ce_dumper(cps)
        << "expected: " << ce_dumper(ces_non_ignorable)
        << "got:      " << ce_dumper(non_ignorable);

    // 1D724 0061;	
    // (𝜤) MATHEMATICAL BOLD ITALIC CAPITAL IOTA	[202C 1CAD | 0020 0020 | 000B 0002 | FFFF FFFF |]
    uint32_t const ces_shifted[12] = { 0x202C, 0x1CAD, 0x0000, 0x0020, 0x0020, 0x0000, 0x000B, 0x0002, 0x0000, 0xFFFF, 0xFFFF, 0x0000 };

    auto const shifted = collate_for_tests(
        cps, cps + 2, boost::text::variable_weighting::shifted);

    EXPECT_EQ(shifted.size(), 12);
    EXPECT_TRUE(boost::algorithm::equal(shifted.begin(), shifted.end(), ces_shifted, ces_shifted + 12))
        << "from:     " << ce_dumper(cps)
        << "expected: " << ce_dumper(ces_shifted)
        << "got:      " << ce_dumper(shifted);
}

TEST(collation, verbatim_131_139)
{
    uint32_t const cps[2] = { 0x1D75E, 0x0061 };

    // 1D75E 0061;	
    // (𝝞) MATHEMATICAL SANS-SERIF BOLD CAPITAL IOTA	[202C 1CAD | 0020 0020 | 000B 0002 |]
    uint32_t const ces_non_ignorable[9] = { 0x202C, 0x1CAD, 0x0000, 0x0020, 0x0020, 0x0000, 0x000B, 0x0002, 0x0000 };

    auto const non_ignorable = collate_for_tests(
        cps, cps + 2, boost::text::variable_weighting::non_ignorable);

    EXPECT_EQ(non_ignorable.size(), 9);
    EXPECT_TRUE(boost::algorithm::equal(non_ignorable.begin(), non_ignorable.end(), ces_non_ignorable, ces_non_ignorable + 9))
        << "from:     " << ce_dumper(cps)
        << "expected: " << ce_dumper(ces_non_ignorable)
        << "got:      " << ce_dumper(non_ignorable);

    // 1D75E 0061;	
    // (𝝞) MATHEMATICAL SANS-SERIF BOLD CAPITAL IOTA	[202C 1CAD | 0020 0020 | 000B 0002 | FFFF FFFF |]
    uint32_t const ces_shifted[12] = { 0x202C, 0x1CAD, 0x0000, 0x0020, 0x0020, 0x0000, 0x000B, 0x0002, 0x0000, 0xFFFF, 0xFFFF, 0x0000 };

    auto const shifted = collate_for_tests(
        cps, cps + 2, boost::text::variable_weighting::shifted);

    EXPECT_EQ(shifted.size(), 12);
    EXPECT_TRUE(boost::algorithm::equal(shifted.begin(), shifted.end(), ces_shifted, ces_shifted + 12))
        << "from:     " << ce_dumper(cps)
        << "expected: " << ce_dumper(ces_shifted)
        << "got:      " << ce_dumper(shifted);
}

TEST(collation, verbatim_131_140)
{
    uint32_t const cps[2] = { 0x1D798, 0x0061 };

    // 1D798 0061;	
    // (𝞘) MATHEMATICAL SANS-SERIF BOLD ITALIC CAPITAL IOTA	[202C 1CAD | 0020 0020 | 000B 0002 |]
    uint32_t const ces_non_ignorable[9] = { 0x202C, 0x1CAD, 0x0000, 0x0020, 0x0020, 0x0000, 0x000B, 0x0002, 0x0000 };

    auto const non_ignorable = collate_for_tests(
        cps, cps + 2, boost::text::variable_weighting::non_ignorable);

    EXPECT_EQ(non_ignorable.size(), 9);
    EXPECT_TRUE(boost::algorithm::equal(non_ignorable.begin(), non_ignorable.end(), ces_non_ignorable, ces_non_ignorable + 9))
        << "from:     " << ce_dumper(cps)
        << "expected: " << ce_dumper(ces_non_ignorable)
        << "got:      " << ce_dumper(non_ignorable);

    // 1D798 0061;	
    // (𝞘) MATHEMATICAL SANS-SERIF BOLD ITALIC CAPITAL IOTA	[202C 1CAD | 0020 0020 | 000B 0002 | FFFF FFFF |]
    uint32_t const ces_shifted[12] = { 0x202C, 0x1CAD, 0x0000, 0x0020, 0x0020, 0x0000, 0x000B, 0x0002, 0x0000, 0xFFFF, 0xFFFF, 0x0000 };

    auto const shifted = collate_for_tests(
        cps, cps + 2, boost::text::variable_weighting::shifted);

    EXPECT_EQ(shifted.size(), 12);
    EXPECT_TRUE(boost::algorithm::equal(shifted.begin(), shifted.end(), ces_shifted, ces_shifted + 12))
        << "from:     " << ce_dumper(cps)
        << "expected: " << ce_dumper(ces_shifted)
        << "got:      " << ce_dumper(shifted);
}

TEST(collation, verbatim_131_141)
{
    uint32_t const cps[2] = { 0x1D6B0, 0x0041 };

    // 1D6B0 0041;	
    // (𝚰) MATHEMATICAL BOLD CAPITAL IOTA	[202C 1CAD | 0020 0020 | 000B 0008 |]
    uint32_t const ces_non_ignorable[9] = { 0x202C, 0x1CAD, 0x0000, 0x0020, 0x0020, 0x0000, 0x000B, 0x0008, 0x0000 };

    auto const non_ignorable = collate_for_tests(
        cps, cps + 2, boost::text::variable_weighting::non_ignorable);

    EXPECT_EQ(non_ignorable.size(), 9);
    EXPECT_TRUE(boost::algorithm::equal(non_ignorable.begin(), non_ignorable.end(), ces_non_ignorable, ces_non_ignorable + 9))
        << "from:     " << ce_dumper(cps)
        << "expected: " << ce_dumper(ces_non_ignorable)
        << "got:      " << ce_dumper(non_ignorable);

    // 1D6B0 0041;	
    // (𝚰) MATHEMATICAL BOLD CAPITAL IOTA	[202C 1CAD | 0020 0020 | 000B 0008 | FFFF FFFF |]
    uint32_t const ces_shifted[12] = { 0x202C, 0x1CAD, 0x0000, 0x0020, 0x0020, 0x0000, 0x000B, 0x0008, 0x0000, 0xFFFF, 0xFFFF, 0x0000 };

    auto const shifted = collate_for_tests(
        cps, cps + 2, boost::text::variable_weighting::shifted);

    EXPECT_EQ(shifted.size(), 12);
    EXPECT_TRUE(boost::algorithm::equal(shifted.begin(), shifted.end(), ces_shifted, ces_shifted + 12))
        << "from:     " << ce_dumper(cps)
        << "expected: " << ce_dumper(ces_shifted)
        << "got:      " << ce_dumper(shifted);
}

TEST(collation, verbatim_131_142)
{
    uint32_t const cps[2] = { 0x1D6EA, 0x0041 };

    // 1D6EA 0041;	
    // (𝛪) MATHEMATICAL ITALIC CAPITAL IOTA	[202C 1CAD | 0020 0020 | 000B 0008 |]
    uint32_t const ces_non_ignorable[9] = { 0x202C, 0x1CAD, 0x0000, 0x0020, 0x0020, 0x0000, 0x000B, 0x0008, 0x0000 };

    auto const non_ignorable = collate_for_tests(
        cps, cps + 2, boost::text::variable_weighting::non_ignorable);

    EXPECT_EQ(non_ignorable.size(), 9);
    EXPECT_TRUE(boost::algorithm::equal(non_ignorable.begin(), non_ignorable.end(), ces_non_ignorable, ces_non_ignorable + 9))
        << "from:     " << ce_dumper(cps)
        << "expected: " << ce_dumper(ces_non_ignorable)
        << "got:      " << ce_dumper(non_ignorable);

    // 1D6EA 0041;	
    // (𝛪) MATHEMATICAL ITALIC CAPITAL IOTA	[202C 1CAD | 0020 0020 | 000B 0008 | FFFF FFFF |]
    uint32_t const ces_shifted[12] = { 0x202C, 0x1CAD, 0x0000, 0x0020, 0x0020, 0x0000, 0x000B, 0x0008, 0x0000, 0xFFFF, 0xFFFF, 0x0000 };

    auto const shifted = collate_for_tests(
        cps, cps + 2, boost::text::variable_weighting::shifted);

    EXPECT_EQ(shifted.size(), 12);
    EXPECT_TRUE(boost::algorithm::equal(shifted.begin(), shifted.end(), ces_shifted, ces_shifted + 12))
        << "from:     " << ce_dumper(cps)
        << "expected: " << ce_dumper(ces_shifted)
        << "got:      " << ce_dumper(shifted);
}

TEST(collation, verbatim_131_143)
{
    uint32_t const cps[2] = { 0x1D724, 0x0041 };

    // 1D724 0041;	
    // (𝜤) MATHEMATICAL BOLD ITALIC CAPITAL IOTA	[202C 1CAD | 0020 0020 | 000B 0008 |]
    uint32_t const ces_non_ignorable[9] = { 0x202C, 0x1CAD, 0x0000, 0x0020, 0x0020, 0x0000, 0x000B, 0x0008, 0x0000 };

    auto const non_ignorable = collate_for_tests(
        cps, cps + 2, boost::text::variable_weighting::non_ignorable);

    EXPECT_EQ(non_ignorable.size(), 9);
    EXPECT_TRUE(boost::algorithm::equal(non_ignorable.begin(), non_ignorable.end(), ces_non_ignorable, ces_non_ignorable + 9))
        << "from:     " << ce_dumper(cps)
        << "expected: " << ce_dumper(ces_non_ignorable)
        << "got:      " << ce_dumper(non_ignorable);

    // 1D724 0041;	
    // (𝜤) MATHEMATICAL BOLD ITALIC CAPITAL IOTA	[202C 1CAD | 0020 0020 | 000B 0008 | FFFF FFFF |]
    uint32_t const ces_shifted[12] = { 0x202C, 0x1CAD, 0x0000, 0x0020, 0x0020, 0x0000, 0x000B, 0x0008, 0x0000, 0xFFFF, 0xFFFF, 0x0000 };

    auto const shifted = collate_for_tests(
        cps, cps + 2, boost::text::variable_weighting::shifted);

    EXPECT_EQ(shifted.size(), 12);
    EXPECT_TRUE(boost::algorithm::equal(shifted.begin(), shifted.end(), ces_shifted, ces_shifted + 12))
        << "from:     " << ce_dumper(cps)
        << "expected: " << ce_dumper(ces_shifted)
        << "got:      " << ce_dumper(shifted);
}

TEST(collation, verbatim_131_144)
{
    uint32_t const cps[2] = { 0x1D75E, 0x0041 };

    // 1D75E 0041;	
    // (𝝞) MATHEMATICAL SANS-SERIF BOLD CAPITAL IOTA	[202C 1CAD | 0020 0020 | 000B 0008 |]
    uint32_t const ces_non_ignorable[9] = { 0x202C, 0x1CAD, 0x0000, 0x0020, 0x0020, 0x0000, 0x000B, 0x0008, 0x0000 };

    auto const non_ignorable = collate_for_tests(
        cps, cps + 2, boost::text::variable_weighting::non_ignorable);

    EXPECT_EQ(non_ignorable.size(), 9);
    EXPECT_TRUE(boost::algorithm::equal(non_ignorable.begin(), non_ignorable.end(), ces_non_ignorable, ces_non_ignorable + 9))
        << "from:     " << ce_dumper(cps)
        << "expected: " << ce_dumper(ces_non_ignorable)
        << "got:      " << ce_dumper(non_ignorable);

    // 1D75E 0041;	
    // (𝝞) MATHEMATICAL SANS-SERIF BOLD CAPITAL IOTA	[202C 1CAD | 0020 0020 | 000B 0008 | FFFF FFFF |]
    uint32_t const ces_shifted[12] = { 0x202C, 0x1CAD, 0x0000, 0x0020, 0x0020, 0x0000, 0x000B, 0x0008, 0x0000, 0xFFFF, 0xFFFF, 0x0000 };

    auto const shifted = collate_for_tests(
        cps, cps + 2, boost::text::variable_weighting::shifted);

    EXPECT_EQ(shifted.size(), 12);
    EXPECT_TRUE(boost::algorithm::equal(shifted.begin(), shifted.end(), ces_shifted, ces_shifted + 12))
        << "from:     " << ce_dumper(cps)
        << "expected: " << ce_dumper(ces_shifted)
        << "got:      " << ce_dumper(shifted);
}

TEST(collation, verbatim_131_145)
{
    uint32_t const cps[2] = { 0x1D798, 0x0041 };

    // 1D798 0041;	
    // (𝞘) MATHEMATICAL SANS-SERIF BOLD ITALIC CAPITAL IOTA	[202C 1CAD | 0020 0020 | 000B 0008 |]
    uint32_t const ces_non_ignorable[9] = { 0x202C, 0x1CAD, 0x0000, 0x0020, 0x0020, 0x0000, 0x000B, 0x0008, 0x0000 };

    auto const non_ignorable = collate_for_tests(
        cps, cps + 2, boost::text::variable_weighting::non_ignorable);

    EXPECT_EQ(non_ignorable.size(), 9);
    EXPECT_TRUE(boost::algorithm::equal(non_ignorable.begin(), non_ignorable.end(), ces_non_ignorable, ces_non_ignorable + 9))
        << "from:     " << ce_dumper(cps)
        << "expected: " << ce_dumper(ces_non_ignorable)
        << "got:      " << ce_dumper(non_ignorable);

    // 1D798 0041;	
    // (𝞘) MATHEMATICAL SANS-SERIF BOLD ITALIC CAPITAL IOTA	[202C 1CAD | 0020 0020 | 000B 0008 | FFFF FFFF |]
    uint32_t const ces_shifted[12] = { 0x202C, 0x1CAD, 0x0000, 0x0020, 0x0020, 0x0000, 0x000B, 0x0008, 0x0000, 0xFFFF, 0xFFFF, 0x0000 };

    auto const shifted = collate_for_tests(
        cps, cps + 2, boost::text::variable_weighting::shifted);

    EXPECT_EQ(shifted.size(), 12);
    EXPECT_TRUE(boost::algorithm::equal(shifted.begin(), shifted.end(), ces_shifted, ces_shifted + 12))
        << "from:     " << ce_dumper(cps)
        << "expected: " << ce_dumper(ces_shifted)
        << "got:      " << ce_dumper(shifted);
}

TEST(collation, verbatim_131_146)
{
    uint32_t const cps[2] = { 0x1F30, 0x0061 };

    // 1F30 0061;	
    // (ἰ) GREEK SMALL LETTER IOTA WITH PSILI	[202C 1CAD | 0020 0022 0020 | 0002 0002 0002 |]
    uint32_t const ces_non_ignorable[11] = { 0x202C, 0x1CAD, 0x0000, 0x0020, 0x0022, 0x0020, 0x0000, 0x0002, 0x0002, 0x0002, 0x0000 };

    auto const non_ignorable = collate_for_tests(
        cps, cps + 2, boost::text::variable_weighting::non_ignorable);

    EXPECT_EQ(non_ignorable.size(), 11);
    EXPECT_TRUE(boost::algorithm::equal(non_ignorable.begin(), non_ignorable.end(), ces_non_ignorable, ces_non_ignorable + 11))
        << "from:     " << ce_dumper(cps)
        << "expected: " << ce_dumper(ces_non_ignorable)
        << "got:      " << ce_dumper(non_ignorable);

    // 1F30 0061;	
    // (ἰ) GREEK SMALL LETTER IOTA WITH PSILI	[202C 1CAD | 0020 0022 0020 | 0002 0002 0002 | FFFF FFFF FFFF |]
    uint32_t const ces_shifted[15] = { 0x202C, 0x1CAD, 0x0000, 0x0020, 0x0022, 0x0020, 0x0000, 0x0002, 0x0002, 0x0002, 0x0000, 0xFFFF, 0xFFFF, 0xFFFF, 0x0000 };

    auto const shifted = collate_for_tests(
        cps, cps + 2, boost::text::variable_weighting::shifted);

    EXPECT_EQ(shifted.size(), 15);
    EXPECT_TRUE(boost::algorithm::equal(shifted.begin(), shifted.end(), ces_shifted, ces_shifted + 15))
        << "from:     " << ce_dumper(cps)
        << "expected: " << ce_dumper(ces_shifted)
        << "got:      " << ce_dumper(shifted);
}

TEST(collation, verbatim_131_147)
{
    uint32_t const cps[2] = { 0x1F30, 0x0041 };

    // 1F30 0041;	
    // (ἰ) GREEK SMALL LETTER IOTA WITH PSILI	[202C 1CAD | 0020 0022 0020 | 0002 0002 0008 |]
    uint32_t const ces_non_ignorable[11] = { 0x202C, 0x1CAD, 0x0000, 0x0020, 0x0022, 0x0020, 0x0000, 0x0002, 0x0002, 0x0008, 0x0000 };

    auto const non_ignorable = collate_for_tests(
        cps, cps + 2, boost::text::variable_weighting::non_ignorable);

    EXPECT_EQ(non_ignorable.size(), 11);
    EXPECT_TRUE(boost::algorithm::equal(non_ignorable.begin(), non_ignorable.end(), ces_non_ignorable, ces_non_ignorable + 11))
        << "from:     " << ce_dumper(cps)
        << "expected: " << ce_dumper(ces_non_ignorable)
        << "got:      " << ce_dumper(non_ignorable);

    // 1F30 0041;	
    // (ἰ) GREEK SMALL LETTER IOTA WITH PSILI	[202C 1CAD | 0020 0022 0020 | 0002 0002 0008 | FFFF FFFF FFFF |]
    uint32_t const ces_shifted[15] = { 0x202C, 0x1CAD, 0x0000, 0x0020, 0x0022, 0x0020, 0x0000, 0x0002, 0x0002, 0x0008, 0x0000, 0xFFFF, 0xFFFF, 0xFFFF, 0x0000 };

    auto const shifted = collate_for_tests(
        cps, cps + 2, boost::text::variable_weighting::shifted);

    EXPECT_EQ(shifted.size(), 15);
    EXPECT_TRUE(boost::algorithm::equal(shifted.begin(), shifted.end(), ces_shifted, ces_shifted + 15))
        << "from:     " << ce_dumper(cps)
        << "expected: " << ce_dumper(ces_shifted)
        << "got:      " << ce_dumper(shifted);
}

TEST(collation, verbatim_131_148)
{
    uint32_t const cps[2] = { 0x1F38, 0x0061 };

    // 1F38 0061;	
    // (Ἰ) GREEK CAPITAL LETTER IOTA WITH PSILI	[202C 1CAD | 0020 0022 0020 | 0008 0002 0002 |]
    uint32_t const ces_non_ignorable[11] = { 0x202C, 0x1CAD, 0x0000, 0x0020, 0x0022, 0x0020, 0x0000, 0x0008, 0x0002, 0x0002, 0x0000 };

    auto const non_ignorable = collate_for_tests(
        cps, cps + 2, boost::text::variable_weighting::non_ignorable);

    EXPECT_EQ(non_ignorable.size(), 11);
    EXPECT_TRUE(boost::algorithm::equal(non_ignorable.begin(), non_ignorable.end(), ces_non_ignorable, ces_non_ignorable + 11))
        << "from:     " << ce_dumper(cps)
        << "expected: " << ce_dumper(ces_non_ignorable)
        << "got:      " << ce_dumper(non_ignorable);

    // 1F38 0061;	
    // (Ἰ) GREEK CAPITAL LETTER IOTA WITH PSILI	[202C 1CAD | 0020 0022 0020 | 0008 0002 0002 | FFFF FFFF FFFF |]
    uint32_t const ces_shifted[15] = { 0x202C, 0x1CAD, 0x0000, 0x0020, 0x0022, 0x0020, 0x0000, 0x0008, 0x0002, 0x0002, 0x0000, 0xFFFF, 0xFFFF, 0xFFFF, 0x0000 };

    auto const shifted = collate_for_tests(
        cps, cps + 2, boost::text::variable_weighting::shifted);

    EXPECT_EQ(shifted.size(), 15);
    EXPECT_TRUE(boost::algorithm::equal(shifted.begin(), shifted.end(), ces_shifted, ces_shifted + 15))
        << "from:     " << ce_dumper(cps)
        << "expected: " << ce_dumper(ces_shifted)
        << "got:      " << ce_dumper(shifted);
}

TEST(collation, verbatim_131_149)
{
    uint32_t const cps[2] = { 0x1F38, 0x0041 };

    // 1F38 0041;	
    // (Ἰ) GREEK CAPITAL LETTER IOTA WITH PSILI	[202C 1CAD | 0020 0022 0020 | 0008 0002 0008 |]
    uint32_t const ces_non_ignorable[11] = { 0x202C, 0x1CAD, 0x0000, 0x0020, 0x0022, 0x0020, 0x0000, 0x0008, 0x0002, 0x0008, 0x0000 };

    auto const non_ignorable = collate_for_tests(
        cps, cps + 2, boost::text::variable_weighting::non_ignorable);

    EXPECT_EQ(non_ignorable.size(), 11);
    EXPECT_TRUE(boost::algorithm::equal(non_ignorable.begin(), non_ignorable.end(), ces_non_ignorable, ces_non_ignorable + 11))
        << "from:     " << ce_dumper(cps)
        << "expected: " << ce_dumper(ces_non_ignorable)
        << "got:      " << ce_dumper(non_ignorable);

    // 1F38 0041;	
    // (Ἰ) GREEK CAPITAL LETTER IOTA WITH PSILI	[202C 1CAD | 0020 0022 0020 | 0008 0002 0008 | FFFF FFFF FFFF |]
    uint32_t const ces_shifted[15] = { 0x202C, 0x1CAD, 0x0000, 0x0020, 0x0022, 0x0020, 0x0000, 0x0008, 0x0002, 0x0008, 0x0000, 0xFFFF, 0xFFFF, 0xFFFF, 0x0000 };

    auto const shifted = collate_for_tests(
        cps, cps + 2, boost::text::variable_weighting::shifted);

    EXPECT_EQ(shifted.size(), 15);
    EXPECT_TRUE(boost::algorithm::equal(shifted.begin(), shifted.end(), ces_shifted, ces_shifted + 15))
        << "from:     " << ce_dumper(cps)
        << "expected: " << ce_dumper(ces_shifted)
        << "got:      " << ce_dumper(shifted);
}

TEST(collation, verbatim_131_150)
{
    uint32_t const cps[2] = { 0x1F34, 0x0061 };

    // 1F34 0061;	
    // (ἴ) GREEK SMALL LETTER IOTA WITH PSILI AND OXIA	[202C 1CAD | 0020 0022 0024 0020 | 0002 0002 0002 0002 |]
    uint32_t const ces_non_ignorable[13] = { 0x202C, 0x1CAD, 0x0000, 0x0020, 0x0022, 0x0024, 0x0020, 0x0000, 0x0002, 0x0002, 0x0002, 0x0002, 0x0000 };

    auto const non_ignorable = collate_for_tests(
        cps, cps + 2, boost::text::variable_weighting::non_ignorable);

    EXPECT_EQ(non_ignorable.size(), 13);
    EXPECT_TRUE(boost::algorithm::equal(non_ignorable.begin(), non_ignorable.end(), ces_non_ignorable, ces_non_ignorable + 13))
        << "from:     " << ce_dumper(cps)
        << "expected: " << ce_dumper(ces_non_ignorable)
        << "got:      " << ce_dumper(non_ignorable);

    // 1F34 0061;	
    // (ἴ) GREEK SMALL LETTER IOTA WITH PSILI AND OXIA	[202C 1CAD | 0020 0022 0024 0020 | 0002 0002 0002 0002 | FFFF FFFF FFFF FFFF |]
    uint32_t const ces_shifted[18] = { 0x202C, 0x1CAD, 0x0000, 0x0020, 0x0022, 0x0024, 0x0020, 0x0000, 0x0002, 0x0002, 0x0002, 0x0002, 0x0000, 0xFFFF, 0xFFFF, 0xFFFF, 0xFFFF, 0x0000 };

    auto const shifted = collate_for_tests(
        cps, cps + 2, boost::text::variable_weighting::shifted);

    EXPECT_EQ(shifted.size(), 18);
    EXPECT_TRUE(boost::algorithm::equal(shifted.begin(), shifted.end(), ces_shifted, ces_shifted + 18))
        << "from:     " << ce_dumper(cps)
        << "expected: " << ce_dumper(ces_shifted)
        << "got:      " << ce_dumper(shifted);
}

TEST(collation, verbatim_131_151)
{
    uint32_t const cps[2] = { 0x1F34, 0x0041 };

    // 1F34 0041;	
    // (ἴ) GREEK SMALL LETTER IOTA WITH PSILI AND OXIA	[202C 1CAD | 0020 0022 0024 0020 | 0002 0002 0002 0008 |]
    uint32_t const ces_non_ignorable[13] = { 0x202C, 0x1CAD, 0x0000, 0x0020, 0x0022, 0x0024, 0x0020, 0x0000, 0x0002, 0x0002, 0x0002, 0x0008, 0x0000 };

    auto const non_ignorable = collate_for_tests(
        cps, cps + 2, boost::text::variable_weighting::non_ignorable);

    EXPECT_EQ(non_ignorable.size(), 13);
    EXPECT_TRUE(boost::algorithm::equal(non_ignorable.begin(), non_ignorable.end(), ces_non_ignorable, ces_non_ignorable + 13))
        << "from:     " << ce_dumper(cps)
        << "expected: " << ce_dumper(ces_non_ignorable)
        << "got:      " << ce_dumper(non_ignorable);

    // 1F34 0041;	
    // (ἴ) GREEK SMALL LETTER IOTA WITH PSILI AND OXIA	[202C 1CAD | 0020 0022 0024 0020 | 0002 0002 0002 0008 | FFFF FFFF FFFF FFFF |]
    uint32_t const ces_shifted[18] = { 0x202C, 0x1CAD, 0x0000, 0x0020, 0x0022, 0x0024, 0x0020, 0x0000, 0x0002, 0x0002, 0x0002, 0x0008, 0x0000, 0xFFFF, 0xFFFF, 0xFFFF, 0xFFFF, 0x0000 };

    auto const shifted = collate_for_tests(
        cps, cps + 2, boost::text::variable_weighting::shifted);

    EXPECT_EQ(shifted.size(), 18);
    EXPECT_TRUE(boost::algorithm::equal(shifted.begin(), shifted.end(), ces_shifted, ces_shifted + 18))
        << "from:     " << ce_dumper(cps)
        << "expected: " << ce_dumper(ces_shifted)
        << "got:      " << ce_dumper(shifted);
}

TEST(collation, verbatim_131_152)
{
    uint32_t const cps[2] = { 0x1F3C, 0x0061 };

    // 1F3C 0061;	
    // (Ἴ) GREEK CAPITAL LETTER IOTA WITH PSILI AND OXIA	[202C 1CAD | 0020 0022 0024 0020 | 0008 0002 0002 0002 |]
    uint32_t const ces_non_ignorable[13] = { 0x202C, 0x1CAD, 0x0000, 0x0020, 0x0022, 0x0024, 0x0020, 0x0000, 0x0008, 0x0002, 0x0002, 0x0002, 0x0000 };

    auto const non_ignorable = collate_for_tests(
        cps, cps + 2, boost::text::variable_weighting::non_ignorable);

    EXPECT_EQ(non_ignorable.size(), 13);
    EXPECT_TRUE(boost::algorithm::equal(non_ignorable.begin(), non_ignorable.end(), ces_non_ignorable, ces_non_ignorable + 13))
        << "from:     " << ce_dumper(cps)
        << "expected: " << ce_dumper(ces_non_ignorable)
        << "got:      " << ce_dumper(non_ignorable);

    // 1F3C 0061;	
    // (Ἴ) GREEK CAPITAL LETTER IOTA WITH PSILI AND OXIA	[202C 1CAD | 0020 0022 0024 0020 | 0008 0002 0002 0002 | FFFF FFFF FFFF FFFF |]
    uint32_t const ces_shifted[18] = { 0x202C, 0x1CAD, 0x0000, 0x0020, 0x0022, 0x0024, 0x0020, 0x0000, 0x0008, 0x0002, 0x0002, 0x0002, 0x0000, 0xFFFF, 0xFFFF, 0xFFFF, 0xFFFF, 0x0000 };

    auto const shifted = collate_for_tests(
        cps, cps + 2, boost::text::variable_weighting::shifted);

    EXPECT_EQ(shifted.size(), 18);
    EXPECT_TRUE(boost::algorithm::equal(shifted.begin(), shifted.end(), ces_shifted, ces_shifted + 18))
        << "from:     " << ce_dumper(cps)
        << "expected: " << ce_dumper(ces_shifted)
        << "got:      " << ce_dumper(shifted);
}

TEST(collation, verbatim_131_153)
{
    uint32_t const cps[2] = { 0x1F3C, 0x0041 };

    // 1F3C 0041;	
    // (Ἴ) GREEK CAPITAL LETTER IOTA WITH PSILI AND OXIA	[202C 1CAD | 0020 0022 0024 0020 | 0008 0002 0002 0008 |]
    uint32_t const ces_non_ignorable[13] = { 0x202C, 0x1CAD, 0x0000, 0x0020, 0x0022, 0x0024, 0x0020, 0x0000, 0x0008, 0x0002, 0x0002, 0x0008, 0x0000 };

    auto const non_ignorable = collate_for_tests(
        cps, cps + 2, boost::text::variable_weighting::non_ignorable);

    EXPECT_EQ(non_ignorable.size(), 13);
    EXPECT_TRUE(boost::algorithm::equal(non_ignorable.begin(), non_ignorable.end(), ces_non_ignorable, ces_non_ignorable + 13))
        << "from:     " << ce_dumper(cps)
        << "expected: " << ce_dumper(ces_non_ignorable)
        << "got:      " << ce_dumper(non_ignorable);

    // 1F3C 0041;	
    // (Ἴ) GREEK CAPITAL LETTER IOTA WITH PSILI AND OXIA	[202C 1CAD | 0020 0022 0024 0020 | 0008 0002 0002 0008 | FFFF FFFF FFFF FFFF |]
    uint32_t const ces_shifted[18] = { 0x202C, 0x1CAD, 0x0000, 0x0020, 0x0022, 0x0024, 0x0020, 0x0000, 0x0008, 0x0002, 0x0002, 0x0008, 0x0000, 0xFFFF, 0xFFFF, 0xFFFF, 0xFFFF, 0x0000 };

    auto const shifted = collate_for_tests(
        cps, cps + 2, boost::text::variable_weighting::shifted);

    EXPECT_EQ(shifted.size(), 18);
    EXPECT_TRUE(boost::algorithm::equal(shifted.begin(), shifted.end(), ces_shifted, ces_shifted + 18))
        << "from:     " << ce_dumper(cps)
        << "expected: " << ce_dumper(ces_shifted)
        << "got:      " << ce_dumper(shifted);
}

TEST(collation, verbatim_131_154)
{
    uint32_t const cps[2] = { 0x1F32, 0x0061 };

    // 1F32 0061;	
    // (ἲ) GREEK SMALL LETTER IOTA WITH PSILI AND VARIA	[202C 1CAD | 0020 0022 0025 0020 | 0002 0002 0002 0002 |]
    uint32_t const ces_non_ignorable[13] = { 0x202C, 0x1CAD, 0x0000, 0x0020, 0x0022, 0x0025, 0x0020, 0x0000, 0x0002, 0x0002, 0x0002, 0x0002, 0x0000 };

    auto const non_ignorable = collate_for_tests(
        cps, cps + 2, boost::text::variable_weighting::non_ignorable);

    EXPECT_EQ(non_ignorable.size(), 13);
    EXPECT_TRUE(boost::algorithm::equal(non_ignorable.begin(), non_ignorable.end(), ces_non_ignorable, ces_non_ignorable + 13))
        << "from:     " << ce_dumper(cps)
        << "expected: " << ce_dumper(ces_non_ignorable)
        << "got:      " << ce_dumper(non_ignorable);

    // 1F32 0061;	
    // (ἲ) GREEK SMALL LETTER IOTA WITH PSILI AND VARIA	[202C 1CAD | 0020 0022 0025 0020 | 0002 0002 0002 0002 | FFFF FFFF FFFF FFFF |]
    uint32_t const ces_shifted[18] = { 0x202C, 0x1CAD, 0x0000, 0x0020, 0x0022, 0x0025, 0x0020, 0x0000, 0x0002, 0x0002, 0x0002, 0x0002, 0x0000, 0xFFFF, 0xFFFF, 0xFFFF, 0xFFFF, 0x0000 };

    auto const shifted = collate_for_tests(
        cps, cps + 2, boost::text::variable_weighting::shifted);

    EXPECT_EQ(shifted.size(), 18);
    EXPECT_TRUE(boost::algorithm::equal(shifted.begin(), shifted.end(), ces_shifted, ces_shifted + 18))
        << "from:     " << ce_dumper(cps)
        << "expected: " << ce_dumper(ces_shifted)
        << "got:      " << ce_dumper(shifted);
}

TEST(collation, verbatim_131_155)
{
    uint32_t const cps[2] = { 0x1F32, 0x0041 };

    // 1F32 0041;	
    // (ἲ) GREEK SMALL LETTER IOTA WITH PSILI AND VARIA	[202C 1CAD | 0020 0022 0025 0020 | 0002 0002 0002 0008 |]
    uint32_t const ces_non_ignorable[13] = { 0x202C, 0x1CAD, 0x0000, 0x0020, 0x0022, 0x0025, 0x0020, 0x0000, 0x0002, 0x0002, 0x0002, 0x0008, 0x0000 };

    auto const non_ignorable = collate_for_tests(
        cps, cps + 2, boost::text::variable_weighting::non_ignorable);

    EXPECT_EQ(non_ignorable.size(), 13);
    EXPECT_TRUE(boost::algorithm::equal(non_ignorable.begin(), non_ignorable.end(), ces_non_ignorable, ces_non_ignorable + 13))
        << "from:     " << ce_dumper(cps)
        << "expected: " << ce_dumper(ces_non_ignorable)
        << "got:      " << ce_dumper(non_ignorable);

    // 1F32 0041;	
    // (ἲ) GREEK SMALL LETTER IOTA WITH PSILI AND VARIA	[202C 1CAD | 0020 0022 0025 0020 | 0002 0002 0002 0008 | FFFF FFFF FFFF FFFF |]
    uint32_t const ces_shifted[18] = { 0x202C, 0x1CAD, 0x0000, 0x0020, 0x0022, 0x0025, 0x0020, 0x0000, 0x0002, 0x0002, 0x0002, 0x0008, 0x0000, 0xFFFF, 0xFFFF, 0xFFFF, 0xFFFF, 0x0000 };

    auto const shifted = collate_for_tests(
        cps, cps + 2, boost::text::variable_weighting::shifted);

    EXPECT_EQ(shifted.size(), 18);
    EXPECT_TRUE(boost::algorithm::equal(shifted.begin(), shifted.end(), ces_shifted, ces_shifted + 18))
        << "from:     " << ce_dumper(cps)
        << "expected: " << ce_dumper(ces_shifted)
        << "got:      " << ce_dumper(shifted);
}

TEST(collation, verbatim_131_156)
{
    uint32_t const cps[2] = { 0x1F3A, 0x0061 };

    // 1F3A 0061;	
    // (Ἲ) GREEK CAPITAL LETTER IOTA WITH PSILI AND VARIA	[202C 1CAD | 0020 0022 0025 0020 | 0008 0002 0002 0002 |]
    uint32_t const ces_non_ignorable[13] = { 0x202C, 0x1CAD, 0x0000, 0x0020, 0x0022, 0x0025, 0x0020, 0x0000, 0x0008, 0x0002, 0x0002, 0x0002, 0x0000 };

    auto const non_ignorable = collate_for_tests(
        cps, cps + 2, boost::text::variable_weighting::non_ignorable);

    EXPECT_EQ(non_ignorable.size(), 13);
    EXPECT_TRUE(boost::algorithm::equal(non_ignorable.begin(), non_ignorable.end(), ces_non_ignorable, ces_non_ignorable + 13))
        << "from:     " << ce_dumper(cps)
        << "expected: " << ce_dumper(ces_non_ignorable)
        << "got:      " << ce_dumper(non_ignorable);

    // 1F3A 0061;	
    // (Ἲ) GREEK CAPITAL LETTER IOTA WITH PSILI AND VARIA	[202C 1CAD | 0020 0022 0025 0020 | 0008 0002 0002 0002 | FFFF FFFF FFFF FFFF |]
    uint32_t const ces_shifted[18] = { 0x202C, 0x1CAD, 0x0000, 0x0020, 0x0022, 0x0025, 0x0020, 0x0000, 0x0008, 0x0002, 0x0002, 0x0002, 0x0000, 0xFFFF, 0xFFFF, 0xFFFF, 0xFFFF, 0x0000 };

    auto const shifted = collate_for_tests(
        cps, cps + 2, boost::text::variable_weighting::shifted);

    EXPECT_EQ(shifted.size(), 18);
    EXPECT_TRUE(boost::algorithm::equal(shifted.begin(), shifted.end(), ces_shifted, ces_shifted + 18))
        << "from:     " << ce_dumper(cps)
        << "expected: " << ce_dumper(ces_shifted)
        << "got:      " << ce_dumper(shifted);
}

TEST(collation, verbatim_131_157)
{
    uint32_t const cps[2] = { 0x1F3A, 0x0041 };

    // 1F3A 0041;	
    // (Ἲ) GREEK CAPITAL LETTER IOTA WITH PSILI AND VARIA	[202C 1CAD | 0020 0022 0025 0020 | 0008 0002 0002 0008 |]
    uint32_t const ces_non_ignorable[13] = { 0x202C, 0x1CAD, 0x0000, 0x0020, 0x0022, 0x0025, 0x0020, 0x0000, 0x0008, 0x0002, 0x0002, 0x0008, 0x0000 };

    auto const non_ignorable = collate_for_tests(
        cps, cps + 2, boost::text::variable_weighting::non_ignorable);

    EXPECT_EQ(non_ignorable.size(), 13);
    EXPECT_TRUE(boost::algorithm::equal(non_ignorable.begin(), non_ignorable.end(), ces_non_ignorable, ces_non_ignorable + 13))
        << "from:     " << ce_dumper(cps)
        << "expected: " << ce_dumper(ces_non_ignorable)
        << "got:      " << ce_dumper(non_ignorable);

    // 1F3A 0041;	
    // (Ἲ) GREEK CAPITAL LETTER IOTA WITH PSILI AND VARIA	[202C 1CAD | 0020 0022 0025 0020 | 0008 0002 0002 0008 | FFFF FFFF FFFF FFFF |]
    uint32_t const ces_shifted[18] = { 0x202C, 0x1CAD, 0x0000, 0x0020, 0x0022, 0x0025, 0x0020, 0x0000, 0x0008, 0x0002, 0x0002, 0x0008, 0x0000, 0xFFFF, 0xFFFF, 0xFFFF, 0xFFFF, 0x0000 };

    auto const shifted = collate_for_tests(
        cps, cps + 2, boost::text::variable_weighting::shifted);

    EXPECT_EQ(shifted.size(), 18);
    EXPECT_TRUE(boost::algorithm::equal(shifted.begin(), shifted.end(), ces_shifted, ces_shifted + 18))
        << "from:     " << ce_dumper(cps)
        << "expected: " << ce_dumper(ces_shifted)
        << "got:      " << ce_dumper(shifted);
}

TEST(collation, verbatim_131_158)
{
    uint32_t const cps[2] = { 0x1F36, 0x0061 };

    // 1F36 0061;	
    // (ἶ) GREEK SMALL LETTER IOTA WITH PSILI AND PERISPOMENI	[202C 1CAD | 0020 0022 002A 0020 | 0002 0002 0002 0002 |]
    uint32_t const ces_non_ignorable[13] = { 0x202C, 0x1CAD, 0x0000, 0x0020, 0x0022, 0x002A, 0x0020, 0x0000, 0x0002, 0x0002, 0x0002, 0x0002, 0x0000 };

    auto const non_ignorable = collate_for_tests(
        cps, cps + 2, boost::text::variable_weighting::non_ignorable);

    EXPECT_EQ(non_ignorable.size(), 13);
    EXPECT_TRUE(boost::algorithm::equal(non_ignorable.begin(), non_ignorable.end(), ces_non_ignorable, ces_non_ignorable + 13))
        << "from:     " << ce_dumper(cps)
        << "expected: " << ce_dumper(ces_non_ignorable)
        << "got:      " << ce_dumper(non_ignorable);

    // 1F36 0061;	
    // (ἶ) GREEK SMALL LETTER IOTA WITH PSILI AND PERISPOMENI	[202C 1CAD | 0020 0022 002A 0020 | 0002 0002 0002 0002 | FFFF FFFF FFFF FFFF |]
    uint32_t const ces_shifted[18] = { 0x202C, 0x1CAD, 0x0000, 0x0020, 0x0022, 0x002A, 0x0020, 0x0000, 0x0002, 0x0002, 0x0002, 0x0002, 0x0000, 0xFFFF, 0xFFFF, 0xFFFF, 0xFFFF, 0x0000 };

    auto const shifted = collate_for_tests(
        cps, cps + 2, boost::text::variable_weighting::shifted);

    EXPECT_EQ(shifted.size(), 18);
    EXPECT_TRUE(boost::algorithm::equal(shifted.begin(), shifted.end(), ces_shifted, ces_shifted + 18))
        << "from:     " << ce_dumper(cps)
        << "expected: " << ce_dumper(ces_shifted)
        << "got:      " << ce_dumper(shifted);
}

TEST(collation, verbatim_131_159)
{
    uint32_t const cps[2] = { 0x1F36, 0x0041 };

    // 1F36 0041;	
    // (ἶ) GREEK SMALL LETTER IOTA WITH PSILI AND PERISPOMENI	[202C 1CAD | 0020 0022 002A 0020 | 0002 0002 0002 0008 |]
    uint32_t const ces_non_ignorable[13] = { 0x202C, 0x1CAD, 0x0000, 0x0020, 0x0022, 0x002A, 0x0020, 0x0000, 0x0002, 0x0002, 0x0002, 0x0008, 0x0000 };

    auto const non_ignorable = collate_for_tests(
        cps, cps + 2, boost::text::variable_weighting::non_ignorable);

    EXPECT_EQ(non_ignorable.size(), 13);
    EXPECT_TRUE(boost::algorithm::equal(non_ignorable.begin(), non_ignorable.end(), ces_non_ignorable, ces_non_ignorable + 13))
        << "from:     " << ce_dumper(cps)
        << "expected: " << ce_dumper(ces_non_ignorable)
        << "got:      " << ce_dumper(non_ignorable);

    // 1F36 0041;	
    // (ἶ) GREEK SMALL LETTER IOTA WITH PSILI AND PERISPOMENI	[202C 1CAD | 0020 0022 002A 0020 | 0002 0002 0002 0008 | FFFF FFFF FFFF FFFF |]
    uint32_t const ces_shifted[18] = { 0x202C, 0x1CAD, 0x0000, 0x0020, 0x0022, 0x002A, 0x0020, 0x0000, 0x0002, 0x0002, 0x0002, 0x0008, 0x0000, 0xFFFF, 0xFFFF, 0xFFFF, 0xFFFF, 0x0000 };

    auto const shifted = collate_for_tests(
        cps, cps + 2, boost::text::variable_weighting::shifted);

    EXPECT_EQ(shifted.size(), 18);
    EXPECT_TRUE(boost::algorithm::equal(shifted.begin(), shifted.end(), ces_shifted, ces_shifted + 18))
        << "from:     " << ce_dumper(cps)
        << "expected: " << ce_dumper(ces_shifted)
        << "got:      " << ce_dumper(shifted);
}

TEST(collation, verbatim_131_160)
{
    uint32_t const cps[2] = { 0x1F3E, 0x0061 };

    // 1F3E 0061;	
    // (Ἶ) GREEK CAPITAL LETTER IOTA WITH PSILI AND PERISPOMENI	[202C 1CAD | 0020 0022 002A 0020 | 0008 0002 0002 0002 |]
    uint32_t const ces_non_ignorable[13] = { 0x202C, 0x1CAD, 0x0000, 0x0020, 0x0022, 0x002A, 0x0020, 0x0000, 0x0008, 0x0002, 0x0002, 0x0002, 0x0000 };

    auto const non_ignorable = collate_for_tests(
        cps, cps + 2, boost::text::variable_weighting::non_ignorable);

    EXPECT_EQ(non_ignorable.size(), 13);
    EXPECT_TRUE(boost::algorithm::equal(non_ignorable.begin(), non_ignorable.end(), ces_non_ignorable, ces_non_ignorable + 13))
        << "from:     " << ce_dumper(cps)
        << "expected: " << ce_dumper(ces_non_ignorable)
        << "got:      " << ce_dumper(non_ignorable);

    // 1F3E 0061;	
    // (Ἶ) GREEK CAPITAL LETTER IOTA WITH PSILI AND PERISPOMENI	[202C 1CAD | 0020 0022 002A 0020 | 0008 0002 0002 0002 | FFFF FFFF FFFF FFFF |]
    uint32_t const ces_shifted[18] = { 0x202C, 0x1CAD, 0x0000, 0x0020, 0x0022, 0x002A, 0x0020, 0x0000, 0x0008, 0x0002, 0x0002, 0x0002, 0x0000, 0xFFFF, 0xFFFF, 0xFFFF, 0xFFFF, 0x0000 };

    auto const shifted = collate_for_tests(
        cps, cps + 2, boost::text::variable_weighting::shifted);

    EXPECT_EQ(shifted.size(), 18);
    EXPECT_TRUE(boost::algorithm::equal(shifted.begin(), shifted.end(), ces_shifted, ces_shifted + 18))
        << "from:     " << ce_dumper(cps)
        << "expected: " << ce_dumper(ces_shifted)
        << "got:      " << ce_dumper(shifted);
}

TEST(collation, verbatim_131_161)
{
    uint32_t const cps[2] = { 0x1F3E, 0x0041 };

    // 1F3E 0041;	
    // (Ἶ) GREEK CAPITAL LETTER IOTA WITH PSILI AND PERISPOMENI	[202C 1CAD | 0020 0022 002A 0020 | 0008 0002 0002 0008 |]
    uint32_t const ces_non_ignorable[13] = { 0x202C, 0x1CAD, 0x0000, 0x0020, 0x0022, 0x002A, 0x0020, 0x0000, 0x0008, 0x0002, 0x0002, 0x0008, 0x0000 };

    auto const non_ignorable = collate_for_tests(
        cps, cps + 2, boost::text::variable_weighting::non_ignorable);

    EXPECT_EQ(non_ignorable.size(), 13);
    EXPECT_TRUE(boost::algorithm::equal(non_ignorable.begin(), non_ignorable.end(), ces_non_ignorable, ces_non_ignorable + 13))
        << "from:     " << ce_dumper(cps)
        << "expected: " << ce_dumper(ces_non_ignorable)
        << "got:      " << ce_dumper(non_ignorable);

    // 1F3E 0041;	
    // (Ἶ) GREEK CAPITAL LETTER IOTA WITH PSILI AND PERISPOMENI	[202C 1CAD | 0020 0022 002A 0020 | 0008 0002 0002 0008 | FFFF FFFF FFFF FFFF |]
    uint32_t const ces_shifted[18] = { 0x202C, 0x1CAD, 0x0000, 0x0020, 0x0022, 0x002A, 0x0020, 0x0000, 0x0008, 0x0002, 0x0002, 0x0008, 0x0000, 0xFFFF, 0xFFFF, 0xFFFF, 0xFFFF, 0x0000 };

    auto const shifted = collate_for_tests(
        cps, cps + 2, boost::text::variable_weighting::shifted);

    EXPECT_EQ(shifted.size(), 18);
    EXPECT_TRUE(boost::algorithm::equal(shifted.begin(), shifted.end(), ces_shifted, ces_shifted + 18))
        << "from:     " << ce_dumper(cps)
        << "expected: " << ce_dumper(ces_shifted)
        << "got:      " << ce_dumper(shifted);
}

TEST(collation, verbatim_131_162)
{
    uint32_t const cps[2] = { 0x1F31, 0x0061 };

    // 1F31 0061;	
    // (ἱ) GREEK SMALL LETTER IOTA WITH DASIA	[202C 1CAD | 0020 0023 0020 | 0002 0002 0002 |]
    uint32_t const ces_non_ignorable[11] = { 0x202C, 0x1CAD, 0x0000, 0x0020, 0x0023, 0x0020, 0x0000, 0x0002, 0x0002, 0x0002, 0x0000 };

    auto const non_ignorable = collate_for_tests(
        cps, cps + 2, boost::text::variable_weighting::non_ignorable);

    EXPECT_EQ(non_ignorable.size(), 11);
    EXPECT_TRUE(boost::algorithm::equal(non_ignorable.begin(), non_ignorable.end(), ces_non_ignorable, ces_non_ignorable + 11))
        << "from:     " << ce_dumper(cps)
        << "expected: " << ce_dumper(ces_non_ignorable)
        << "got:      " << ce_dumper(non_ignorable);

    // 1F31 0061;	
    // (ἱ) GREEK SMALL LETTER IOTA WITH DASIA	[202C 1CAD | 0020 0023 0020 | 0002 0002 0002 | FFFF FFFF FFFF |]
    uint32_t const ces_shifted[15] = { 0x202C, 0x1CAD, 0x0000, 0x0020, 0x0023, 0x0020, 0x0000, 0x0002, 0x0002, 0x0002, 0x0000, 0xFFFF, 0xFFFF, 0xFFFF, 0x0000 };

    auto const shifted = collate_for_tests(
        cps, cps + 2, boost::text::variable_weighting::shifted);

    EXPECT_EQ(shifted.size(), 15);
    EXPECT_TRUE(boost::algorithm::equal(shifted.begin(), shifted.end(), ces_shifted, ces_shifted + 15))
        << "from:     " << ce_dumper(cps)
        << "expected: " << ce_dumper(ces_shifted)
        << "got:      " << ce_dumper(shifted);
}

TEST(collation, verbatim_131_163)
{
    uint32_t const cps[2] = { 0x1F31, 0x0041 };

    // 1F31 0041;	
    // (ἱ) GREEK SMALL LETTER IOTA WITH DASIA	[202C 1CAD | 0020 0023 0020 | 0002 0002 0008 |]
    uint32_t const ces_non_ignorable[11] = { 0x202C, 0x1CAD, 0x0000, 0x0020, 0x0023, 0x0020, 0x0000, 0x0002, 0x0002, 0x0008, 0x0000 };

    auto const non_ignorable = collate_for_tests(
        cps, cps + 2, boost::text::variable_weighting::non_ignorable);

    EXPECT_EQ(non_ignorable.size(), 11);
    EXPECT_TRUE(boost::algorithm::equal(non_ignorable.begin(), non_ignorable.end(), ces_non_ignorable, ces_non_ignorable + 11))
        << "from:     " << ce_dumper(cps)
        << "expected: " << ce_dumper(ces_non_ignorable)
        << "got:      " << ce_dumper(non_ignorable);

    // 1F31 0041;	
    // (ἱ) GREEK SMALL LETTER IOTA WITH DASIA	[202C 1CAD | 0020 0023 0020 | 0002 0002 0008 | FFFF FFFF FFFF |]
    uint32_t const ces_shifted[15] = { 0x202C, 0x1CAD, 0x0000, 0x0020, 0x0023, 0x0020, 0x0000, 0x0002, 0x0002, 0x0008, 0x0000, 0xFFFF, 0xFFFF, 0xFFFF, 0x0000 };

    auto const shifted = collate_for_tests(
        cps, cps + 2, boost::text::variable_weighting::shifted);

    EXPECT_EQ(shifted.size(), 15);
    EXPECT_TRUE(boost::algorithm::equal(shifted.begin(), shifted.end(), ces_shifted, ces_shifted + 15))
        << "from:     " << ce_dumper(cps)
        << "expected: " << ce_dumper(ces_shifted)
        << "got:      " << ce_dumper(shifted);
}

TEST(collation, verbatim_131_164)
{
    uint32_t const cps[2] = { 0x1F39, 0x0061 };

    // 1F39 0061;	
    // (Ἱ) GREEK CAPITAL LETTER IOTA WITH DASIA	[202C 1CAD | 0020 0023 0020 | 0008 0002 0002 |]
    uint32_t const ces_non_ignorable[11] = { 0x202C, 0x1CAD, 0x0000, 0x0020, 0x0023, 0x0020, 0x0000, 0x0008, 0x0002, 0x0002, 0x0000 };

    auto const non_ignorable = collate_for_tests(
        cps, cps + 2, boost::text::variable_weighting::non_ignorable);

    EXPECT_EQ(non_ignorable.size(), 11);
    EXPECT_TRUE(boost::algorithm::equal(non_ignorable.begin(), non_ignorable.end(), ces_non_ignorable, ces_non_ignorable + 11))
        << "from:     " << ce_dumper(cps)
        << "expected: " << ce_dumper(ces_non_ignorable)
        << "got:      " << ce_dumper(non_ignorable);

    // 1F39 0061;	
    // (Ἱ) GREEK CAPITAL LETTER IOTA WITH DASIA	[202C 1CAD | 0020 0023 0020 | 0008 0002 0002 | FFFF FFFF FFFF |]
    uint32_t const ces_shifted[15] = { 0x202C, 0x1CAD, 0x0000, 0x0020, 0x0023, 0x0020, 0x0000, 0x0008, 0x0002, 0x0002, 0x0000, 0xFFFF, 0xFFFF, 0xFFFF, 0x0000 };

    auto const shifted = collate_for_tests(
        cps, cps + 2, boost::text::variable_weighting::shifted);

    EXPECT_EQ(shifted.size(), 15);
    EXPECT_TRUE(boost::algorithm::equal(shifted.begin(), shifted.end(), ces_shifted, ces_shifted + 15))
        << "from:     " << ce_dumper(cps)
        << "expected: " << ce_dumper(ces_shifted)
        << "got:      " << ce_dumper(shifted);
}

TEST(collation, verbatim_131_165)
{
    uint32_t const cps[2] = { 0x1F39, 0x0041 };

    // 1F39 0041;	
    // (Ἱ) GREEK CAPITAL LETTER IOTA WITH DASIA	[202C 1CAD | 0020 0023 0020 | 0008 0002 0008 |]
    uint32_t const ces_non_ignorable[11] = { 0x202C, 0x1CAD, 0x0000, 0x0020, 0x0023, 0x0020, 0x0000, 0x0008, 0x0002, 0x0008, 0x0000 };

    auto const non_ignorable = collate_for_tests(
        cps, cps + 2, boost::text::variable_weighting::non_ignorable);

    EXPECT_EQ(non_ignorable.size(), 11);
    EXPECT_TRUE(boost::algorithm::equal(non_ignorable.begin(), non_ignorable.end(), ces_non_ignorable, ces_non_ignorable + 11))
        << "from:     " << ce_dumper(cps)
        << "expected: " << ce_dumper(ces_non_ignorable)
        << "got:      " << ce_dumper(non_ignorable);

    // 1F39 0041;	
    // (Ἱ) GREEK CAPITAL LETTER IOTA WITH DASIA	[202C 1CAD | 0020 0023 0020 | 0008 0002 0008 | FFFF FFFF FFFF |]
    uint32_t const ces_shifted[15] = { 0x202C, 0x1CAD, 0x0000, 0x0020, 0x0023, 0x0020, 0x0000, 0x0008, 0x0002, 0x0008, 0x0000, 0xFFFF, 0xFFFF, 0xFFFF, 0x0000 };

    auto const shifted = collate_for_tests(
        cps, cps + 2, boost::text::variable_weighting::shifted);

    EXPECT_EQ(shifted.size(), 15);
    EXPECT_TRUE(boost::algorithm::equal(shifted.begin(), shifted.end(), ces_shifted, ces_shifted + 15))
        << "from:     " << ce_dumper(cps)
        << "expected: " << ce_dumper(ces_shifted)
        << "got:      " << ce_dumper(shifted);
}

TEST(collation, verbatim_131_166)
{
    uint32_t const cps[2] = { 0x1F35, 0x0061 };

    // 1F35 0061;	
    // (ἵ) GREEK SMALL LETTER IOTA WITH DASIA AND OXIA	[202C 1CAD | 0020 0023 0024 0020 | 0002 0002 0002 0002 |]
    uint32_t const ces_non_ignorable[13] = { 0x202C, 0x1CAD, 0x0000, 0x0020, 0x0023, 0x0024, 0x0020, 0x0000, 0x0002, 0x0002, 0x0002, 0x0002, 0x0000 };

    auto const non_ignorable = collate_for_tests(
        cps, cps + 2, boost::text::variable_weighting::non_ignorable);

    EXPECT_EQ(non_ignorable.size(), 13);
    EXPECT_TRUE(boost::algorithm::equal(non_ignorable.begin(), non_ignorable.end(), ces_non_ignorable, ces_non_ignorable + 13))
        << "from:     " << ce_dumper(cps)
        << "expected: " << ce_dumper(ces_non_ignorable)
        << "got:      " << ce_dumper(non_ignorable);

    // 1F35 0061;	
    // (ἵ) GREEK SMALL LETTER IOTA WITH DASIA AND OXIA	[202C 1CAD | 0020 0023 0024 0020 | 0002 0002 0002 0002 | FFFF FFFF FFFF FFFF |]
    uint32_t const ces_shifted[18] = { 0x202C, 0x1CAD, 0x0000, 0x0020, 0x0023, 0x0024, 0x0020, 0x0000, 0x0002, 0x0002, 0x0002, 0x0002, 0x0000, 0xFFFF, 0xFFFF, 0xFFFF, 0xFFFF, 0x0000 };

    auto const shifted = collate_for_tests(
        cps, cps + 2, boost::text::variable_weighting::shifted);

    EXPECT_EQ(shifted.size(), 18);
    EXPECT_TRUE(boost::algorithm::equal(shifted.begin(), shifted.end(), ces_shifted, ces_shifted + 18))
        << "from:     " << ce_dumper(cps)
        << "expected: " << ce_dumper(ces_shifted)
        << "got:      " << ce_dumper(shifted);
}

TEST(collation, verbatim_131_167)
{
    uint32_t const cps[2] = { 0x1F35, 0x0041 };

    // 1F35 0041;	
    // (ἵ) GREEK SMALL LETTER IOTA WITH DASIA AND OXIA	[202C 1CAD | 0020 0023 0024 0020 | 0002 0002 0002 0008 |]
    uint32_t const ces_non_ignorable[13] = { 0x202C, 0x1CAD, 0x0000, 0x0020, 0x0023, 0x0024, 0x0020, 0x0000, 0x0002, 0x0002, 0x0002, 0x0008, 0x0000 };

    auto const non_ignorable = collate_for_tests(
        cps, cps + 2, boost::text::variable_weighting::non_ignorable);

    EXPECT_EQ(non_ignorable.size(), 13);
    EXPECT_TRUE(boost::algorithm::equal(non_ignorable.begin(), non_ignorable.end(), ces_non_ignorable, ces_non_ignorable + 13))
        << "from:     " << ce_dumper(cps)
        << "expected: " << ce_dumper(ces_non_ignorable)
        << "got:      " << ce_dumper(non_ignorable);

    // 1F35 0041;	
    // (ἵ) GREEK SMALL LETTER IOTA WITH DASIA AND OXIA	[202C 1CAD | 0020 0023 0024 0020 | 0002 0002 0002 0008 | FFFF FFFF FFFF FFFF |]
    uint32_t const ces_shifted[18] = { 0x202C, 0x1CAD, 0x0000, 0x0020, 0x0023, 0x0024, 0x0020, 0x0000, 0x0002, 0x0002, 0x0002, 0x0008, 0x0000, 0xFFFF, 0xFFFF, 0xFFFF, 0xFFFF, 0x0000 };

    auto const shifted = collate_for_tests(
        cps, cps + 2, boost::text::variable_weighting::shifted);

    EXPECT_EQ(shifted.size(), 18);
    EXPECT_TRUE(boost::algorithm::equal(shifted.begin(), shifted.end(), ces_shifted, ces_shifted + 18))
        << "from:     " << ce_dumper(cps)
        << "expected: " << ce_dumper(ces_shifted)
        << "got:      " << ce_dumper(shifted);
}

TEST(collation, verbatim_131_168)
{
    uint32_t const cps[2] = { 0x1F3D, 0x0061 };

    // 1F3D 0061;	
    // (Ἵ) GREEK CAPITAL LETTER IOTA WITH DASIA AND OXIA	[202C 1CAD | 0020 0023 0024 0020 | 0008 0002 0002 0002 |]
    uint32_t const ces_non_ignorable[13] = { 0x202C, 0x1CAD, 0x0000, 0x0020, 0x0023, 0x0024, 0x0020, 0x0000, 0x0008, 0x0002, 0x0002, 0x0002, 0x0000 };

    auto const non_ignorable = collate_for_tests(
        cps, cps + 2, boost::text::variable_weighting::non_ignorable);

    EXPECT_EQ(non_ignorable.size(), 13);
    EXPECT_TRUE(boost::algorithm::equal(non_ignorable.begin(), non_ignorable.end(), ces_non_ignorable, ces_non_ignorable + 13))
        << "from:     " << ce_dumper(cps)
        << "expected: " << ce_dumper(ces_non_ignorable)
        << "got:      " << ce_dumper(non_ignorable);

    // 1F3D 0061;	
    // (Ἵ) GREEK CAPITAL LETTER IOTA WITH DASIA AND OXIA	[202C 1CAD | 0020 0023 0024 0020 | 0008 0002 0002 0002 | FFFF FFFF FFFF FFFF |]
    uint32_t const ces_shifted[18] = { 0x202C, 0x1CAD, 0x0000, 0x0020, 0x0023, 0x0024, 0x0020, 0x0000, 0x0008, 0x0002, 0x0002, 0x0002, 0x0000, 0xFFFF, 0xFFFF, 0xFFFF, 0xFFFF, 0x0000 };

    auto const shifted = collate_for_tests(
        cps, cps + 2, boost::text::variable_weighting::shifted);

    EXPECT_EQ(shifted.size(), 18);
    EXPECT_TRUE(boost::algorithm::equal(shifted.begin(), shifted.end(), ces_shifted, ces_shifted + 18))
        << "from:     " << ce_dumper(cps)
        << "expected: " << ce_dumper(ces_shifted)
        << "got:      " << ce_dumper(shifted);
}

TEST(collation, verbatim_131_169)
{
    uint32_t const cps[2] = { 0x1F3D, 0x0041 };

    // 1F3D 0041;	
    // (Ἵ) GREEK CAPITAL LETTER IOTA WITH DASIA AND OXIA	[202C 1CAD | 0020 0023 0024 0020 | 0008 0002 0002 0008 |]
    uint32_t const ces_non_ignorable[13] = { 0x202C, 0x1CAD, 0x0000, 0x0020, 0x0023, 0x0024, 0x0020, 0x0000, 0x0008, 0x0002, 0x0002, 0x0008, 0x0000 };

    auto const non_ignorable = collate_for_tests(
        cps, cps + 2, boost::text::variable_weighting::non_ignorable);

    EXPECT_EQ(non_ignorable.size(), 13);
    EXPECT_TRUE(boost::algorithm::equal(non_ignorable.begin(), non_ignorable.end(), ces_non_ignorable, ces_non_ignorable + 13))
        << "from:     " << ce_dumper(cps)
        << "expected: " << ce_dumper(ces_non_ignorable)
        << "got:      " << ce_dumper(non_ignorable);

    // 1F3D 0041;	
    // (Ἵ) GREEK CAPITAL LETTER IOTA WITH DASIA AND OXIA	[202C 1CAD | 0020 0023 0024 0020 | 0008 0002 0002 0008 | FFFF FFFF FFFF FFFF |]
    uint32_t const ces_shifted[18] = { 0x202C, 0x1CAD, 0x0000, 0x0020, 0x0023, 0x0024, 0x0020, 0x0000, 0x0008, 0x0002, 0x0002, 0x0008, 0x0000, 0xFFFF, 0xFFFF, 0xFFFF, 0xFFFF, 0x0000 };

    auto const shifted = collate_for_tests(
        cps, cps + 2, boost::text::variable_weighting::shifted);

    EXPECT_EQ(shifted.size(), 18);
    EXPECT_TRUE(boost::algorithm::equal(shifted.begin(), shifted.end(), ces_shifted, ces_shifted + 18))
        << "from:     " << ce_dumper(cps)
        << "expected: " << ce_dumper(ces_shifted)
        << "got:      " << ce_dumper(shifted);
}

TEST(collation, verbatim_131_170)
{
    uint32_t const cps[2] = { 0x1F33, 0x0061 };

    // 1F33 0061;	
    // (ἳ) GREEK SMALL LETTER IOTA WITH DASIA AND VARIA	[202C 1CAD | 0020 0023 0025 0020 | 0002 0002 0002 0002 |]
    uint32_t const ces_non_ignorable[13] = { 0x202C, 0x1CAD, 0x0000, 0x0020, 0x0023, 0x0025, 0x0020, 0x0000, 0x0002, 0x0002, 0x0002, 0x0002, 0x0000 };

    auto const non_ignorable = collate_for_tests(
        cps, cps + 2, boost::text::variable_weighting::non_ignorable);

    EXPECT_EQ(non_ignorable.size(), 13);
    EXPECT_TRUE(boost::algorithm::equal(non_ignorable.begin(), non_ignorable.end(), ces_non_ignorable, ces_non_ignorable + 13))
        << "from:     " << ce_dumper(cps)
        << "expected: " << ce_dumper(ces_non_ignorable)
        << "got:      " << ce_dumper(non_ignorable);

    // 1F33 0061;	
    // (ἳ) GREEK SMALL LETTER IOTA WITH DASIA AND VARIA	[202C 1CAD | 0020 0023 0025 0020 | 0002 0002 0002 0002 | FFFF FFFF FFFF FFFF |]
    uint32_t const ces_shifted[18] = { 0x202C, 0x1CAD, 0x0000, 0x0020, 0x0023, 0x0025, 0x0020, 0x0000, 0x0002, 0x0002, 0x0002, 0x0002, 0x0000, 0xFFFF, 0xFFFF, 0xFFFF, 0xFFFF, 0x0000 };

    auto const shifted = collate_for_tests(
        cps, cps + 2, boost::text::variable_weighting::shifted);

    EXPECT_EQ(shifted.size(), 18);
    EXPECT_TRUE(boost::algorithm::equal(shifted.begin(), shifted.end(), ces_shifted, ces_shifted + 18))
        << "from:     " << ce_dumper(cps)
        << "expected: " << ce_dumper(ces_shifted)
        << "got:      " << ce_dumper(shifted);
}

TEST(collation, verbatim_131_171)
{
    uint32_t const cps[2] = { 0x1F33, 0x0041 };

    // 1F33 0041;	
    // (ἳ) GREEK SMALL LETTER IOTA WITH DASIA AND VARIA	[202C 1CAD | 0020 0023 0025 0020 | 0002 0002 0002 0008 |]
    uint32_t const ces_non_ignorable[13] = { 0x202C, 0x1CAD, 0x0000, 0x0020, 0x0023, 0x0025, 0x0020, 0x0000, 0x0002, 0x0002, 0x0002, 0x0008, 0x0000 };

    auto const non_ignorable = collate_for_tests(
        cps, cps + 2, boost::text::variable_weighting::non_ignorable);

    EXPECT_EQ(non_ignorable.size(), 13);
    EXPECT_TRUE(boost::algorithm::equal(non_ignorable.begin(), non_ignorable.end(), ces_non_ignorable, ces_non_ignorable + 13))
        << "from:     " << ce_dumper(cps)
        << "expected: " << ce_dumper(ces_non_ignorable)
        << "got:      " << ce_dumper(non_ignorable);

    // 1F33 0041;	
    // (ἳ) GREEK SMALL LETTER IOTA WITH DASIA AND VARIA	[202C 1CAD | 0020 0023 0025 0020 | 0002 0002 0002 0008 | FFFF FFFF FFFF FFFF |]
    uint32_t const ces_shifted[18] = { 0x202C, 0x1CAD, 0x0000, 0x0020, 0x0023, 0x0025, 0x0020, 0x0000, 0x0002, 0x0002, 0x0002, 0x0008, 0x0000, 0xFFFF, 0xFFFF, 0xFFFF, 0xFFFF, 0x0000 };

    auto const shifted = collate_for_tests(
        cps, cps + 2, boost::text::variable_weighting::shifted);

    EXPECT_EQ(shifted.size(), 18);
    EXPECT_TRUE(boost::algorithm::equal(shifted.begin(), shifted.end(), ces_shifted, ces_shifted + 18))
        << "from:     " << ce_dumper(cps)
        << "expected: " << ce_dumper(ces_shifted)
        << "got:      " << ce_dumper(shifted);
}

TEST(collation, verbatim_131_172)
{
    uint32_t const cps[2] = { 0x1F3B, 0x0061 };

    // 1F3B 0061;	
    // (Ἳ) GREEK CAPITAL LETTER IOTA WITH DASIA AND VARIA	[202C 1CAD | 0020 0023 0025 0020 | 0008 0002 0002 0002 |]
    uint32_t const ces_non_ignorable[13] = { 0x202C, 0x1CAD, 0x0000, 0x0020, 0x0023, 0x0025, 0x0020, 0x0000, 0x0008, 0x0002, 0x0002, 0x0002, 0x0000 };

    auto const non_ignorable = collate_for_tests(
        cps, cps + 2, boost::text::variable_weighting::non_ignorable);

    EXPECT_EQ(non_ignorable.size(), 13);
    EXPECT_TRUE(boost::algorithm::equal(non_ignorable.begin(), non_ignorable.end(), ces_non_ignorable, ces_non_ignorable + 13))
        << "from:     " << ce_dumper(cps)
        << "expected: " << ce_dumper(ces_non_ignorable)
        << "got:      " << ce_dumper(non_ignorable);

    // 1F3B 0061;	
    // (Ἳ) GREEK CAPITAL LETTER IOTA WITH DASIA AND VARIA	[202C 1CAD | 0020 0023 0025 0020 | 0008 0002 0002 0002 | FFFF FFFF FFFF FFFF |]
    uint32_t const ces_shifted[18] = { 0x202C, 0x1CAD, 0x0000, 0x0020, 0x0023, 0x0025, 0x0020, 0x0000, 0x0008, 0x0002, 0x0002, 0x0002, 0x0000, 0xFFFF, 0xFFFF, 0xFFFF, 0xFFFF, 0x0000 };

    auto const shifted = collate_for_tests(
        cps, cps + 2, boost::text::variable_weighting::shifted);

    EXPECT_EQ(shifted.size(), 18);
    EXPECT_TRUE(boost::algorithm::equal(shifted.begin(), shifted.end(), ces_shifted, ces_shifted + 18))
        << "from:     " << ce_dumper(cps)
        << "expected: " << ce_dumper(ces_shifted)
        << "got:      " << ce_dumper(shifted);
}

TEST(collation, verbatim_131_173)
{
    uint32_t const cps[2] = { 0x1F3B, 0x0041 };

    // 1F3B 0041;	
    // (Ἳ) GREEK CAPITAL LETTER IOTA WITH DASIA AND VARIA	[202C 1CAD | 0020 0023 0025 0020 | 0008 0002 0002 0008 |]
    uint32_t const ces_non_ignorable[13] = { 0x202C, 0x1CAD, 0x0000, 0x0020, 0x0023, 0x0025, 0x0020, 0x0000, 0x0008, 0x0002, 0x0002, 0x0008, 0x0000 };

    auto const non_ignorable = collate_for_tests(
        cps, cps + 2, boost::text::variable_weighting::non_ignorable);

    EXPECT_EQ(non_ignorable.size(), 13);
    EXPECT_TRUE(boost::algorithm::equal(non_ignorable.begin(), non_ignorable.end(), ces_non_ignorable, ces_non_ignorable + 13))
        << "from:     " << ce_dumper(cps)
        << "expected: " << ce_dumper(ces_non_ignorable)
        << "got:      " << ce_dumper(non_ignorable);

    // 1F3B 0041;	
    // (Ἳ) GREEK CAPITAL LETTER IOTA WITH DASIA AND VARIA	[202C 1CAD | 0020 0023 0025 0020 | 0008 0002 0002 0008 | FFFF FFFF FFFF FFFF |]
    uint32_t const ces_shifted[18] = { 0x202C, 0x1CAD, 0x0000, 0x0020, 0x0023, 0x0025, 0x0020, 0x0000, 0x0008, 0x0002, 0x0002, 0x0008, 0x0000, 0xFFFF, 0xFFFF, 0xFFFF, 0xFFFF, 0x0000 };

    auto const shifted = collate_for_tests(
        cps, cps + 2, boost::text::variable_weighting::shifted);

    EXPECT_EQ(shifted.size(), 18);
    EXPECT_TRUE(boost::algorithm::equal(shifted.begin(), shifted.end(), ces_shifted, ces_shifted + 18))
        << "from:     " << ce_dumper(cps)
        << "expected: " << ce_dumper(ces_shifted)
        << "got:      " << ce_dumper(shifted);
}

TEST(collation, verbatim_131_174)
{
    uint32_t const cps[2] = { 0x1F37, 0x0061 };

    // 1F37 0061;	
    // (ἷ) GREEK SMALL LETTER IOTA WITH DASIA AND PERISPOMENI	[202C 1CAD | 0020 0023 002A 0020 | 0002 0002 0002 0002 |]
    uint32_t const ces_non_ignorable[13] = { 0x202C, 0x1CAD, 0x0000, 0x0020, 0x0023, 0x002A, 0x0020, 0x0000, 0x0002, 0x0002, 0x0002, 0x0002, 0x0000 };

    auto const non_ignorable = collate_for_tests(
        cps, cps + 2, boost::text::variable_weighting::non_ignorable);

    EXPECT_EQ(non_ignorable.size(), 13);
    EXPECT_TRUE(boost::algorithm::equal(non_ignorable.begin(), non_ignorable.end(), ces_non_ignorable, ces_non_ignorable + 13))
        << "from:     " << ce_dumper(cps)
        << "expected: " << ce_dumper(ces_non_ignorable)
        << "got:      " << ce_dumper(non_ignorable);

    // 1F37 0061;	
    // (ἷ) GREEK SMALL LETTER IOTA WITH DASIA AND PERISPOMENI	[202C 1CAD | 0020 0023 002A 0020 | 0002 0002 0002 0002 | FFFF FFFF FFFF FFFF |]
    uint32_t const ces_shifted[18] = { 0x202C, 0x1CAD, 0x0000, 0x0020, 0x0023, 0x002A, 0x0020, 0x0000, 0x0002, 0x0002, 0x0002, 0x0002, 0x0000, 0xFFFF, 0xFFFF, 0xFFFF, 0xFFFF, 0x0000 };

    auto const shifted = collate_for_tests(
        cps, cps + 2, boost::text::variable_weighting::shifted);

    EXPECT_EQ(shifted.size(), 18);
    EXPECT_TRUE(boost::algorithm::equal(shifted.begin(), shifted.end(), ces_shifted, ces_shifted + 18))
        << "from:     " << ce_dumper(cps)
        << "expected: " << ce_dumper(ces_shifted)
        << "got:      " << ce_dumper(shifted);
}

TEST(collation, verbatim_131_175)
{
    uint32_t const cps[2] = { 0x1F37, 0x0041 };

    // 1F37 0041;	
    // (ἷ) GREEK SMALL LETTER IOTA WITH DASIA AND PERISPOMENI	[202C 1CAD | 0020 0023 002A 0020 | 0002 0002 0002 0008 |]
    uint32_t const ces_non_ignorable[13] = { 0x202C, 0x1CAD, 0x0000, 0x0020, 0x0023, 0x002A, 0x0020, 0x0000, 0x0002, 0x0002, 0x0002, 0x0008, 0x0000 };

    auto const non_ignorable = collate_for_tests(
        cps, cps + 2, boost::text::variable_weighting::non_ignorable);

    EXPECT_EQ(non_ignorable.size(), 13);
    EXPECT_TRUE(boost::algorithm::equal(non_ignorable.begin(), non_ignorable.end(), ces_non_ignorable, ces_non_ignorable + 13))
        << "from:     " << ce_dumper(cps)
        << "expected: " << ce_dumper(ces_non_ignorable)
        << "got:      " << ce_dumper(non_ignorable);

    // 1F37 0041;	
    // (ἷ) GREEK SMALL LETTER IOTA WITH DASIA AND PERISPOMENI	[202C 1CAD | 0020 0023 002A 0020 | 0002 0002 0002 0008 | FFFF FFFF FFFF FFFF |]
    uint32_t const ces_shifted[18] = { 0x202C, 0x1CAD, 0x0000, 0x0020, 0x0023, 0x002A, 0x0020, 0x0000, 0x0002, 0x0002, 0x0002, 0x0008, 0x0000, 0xFFFF, 0xFFFF, 0xFFFF, 0xFFFF, 0x0000 };

    auto const shifted = collate_for_tests(
        cps, cps + 2, boost::text::variable_weighting::shifted);

    EXPECT_EQ(shifted.size(), 18);
    EXPECT_TRUE(boost::algorithm::equal(shifted.begin(), shifted.end(), ces_shifted, ces_shifted + 18))
        << "from:     " << ce_dumper(cps)
        << "expected: " << ce_dumper(ces_shifted)
        << "got:      " << ce_dumper(shifted);
}

TEST(collation, verbatim_131_176)
{
    uint32_t const cps[2] = { 0x1F3F, 0x0061 };

    // 1F3F 0061;	
    // (Ἷ) GREEK CAPITAL LETTER IOTA WITH DASIA AND PERISPOMENI	[202C 1CAD | 0020 0023 002A 0020 | 0008 0002 0002 0002 |]
    uint32_t const ces_non_ignorable[13] = { 0x202C, 0x1CAD, 0x0000, 0x0020, 0x0023, 0x002A, 0x0020, 0x0000, 0x0008, 0x0002, 0x0002, 0x0002, 0x0000 };

    auto const non_ignorable = collate_for_tests(
        cps, cps + 2, boost::text::variable_weighting::non_ignorable);

    EXPECT_EQ(non_ignorable.size(), 13);
    EXPECT_TRUE(boost::algorithm::equal(non_ignorable.begin(), non_ignorable.end(), ces_non_ignorable, ces_non_ignorable + 13))
        << "from:     " << ce_dumper(cps)
        << "expected: " << ce_dumper(ces_non_ignorable)
        << "got:      " << ce_dumper(non_ignorable);

    // 1F3F 0061;	
    // (Ἷ) GREEK CAPITAL LETTER IOTA WITH DASIA AND PERISPOMENI	[202C 1CAD | 0020 0023 002A 0020 | 0008 0002 0002 0002 | FFFF FFFF FFFF FFFF |]
    uint32_t const ces_shifted[18] = { 0x202C, 0x1CAD, 0x0000, 0x0020, 0x0023, 0x002A, 0x0020, 0x0000, 0x0008, 0x0002, 0x0002, 0x0002, 0x0000, 0xFFFF, 0xFFFF, 0xFFFF, 0xFFFF, 0x0000 };

    auto const shifted = collate_for_tests(
        cps, cps + 2, boost::text::variable_weighting::shifted);

    EXPECT_EQ(shifted.size(), 18);
    EXPECT_TRUE(boost::algorithm::equal(shifted.begin(), shifted.end(), ces_shifted, ces_shifted + 18))
        << "from:     " << ce_dumper(cps)
        << "expected: " << ce_dumper(ces_shifted)
        << "got:      " << ce_dumper(shifted);
}

TEST(collation, verbatim_131_177)
{
    uint32_t const cps[2] = { 0x1F3F, 0x0041 };

    // 1F3F 0041;	
    // (Ἷ) GREEK CAPITAL LETTER IOTA WITH DASIA AND PERISPOMENI	[202C 1CAD | 0020 0023 002A 0020 | 0008 0002 0002 0008 |]
    uint32_t const ces_non_ignorable[13] = { 0x202C, 0x1CAD, 0x0000, 0x0020, 0x0023, 0x002A, 0x0020, 0x0000, 0x0008, 0x0002, 0x0002, 0x0008, 0x0000 };

    auto const non_ignorable = collate_for_tests(
        cps, cps + 2, boost::text::variable_weighting::non_ignorable);

    EXPECT_EQ(non_ignorable.size(), 13);
    EXPECT_TRUE(boost::algorithm::equal(non_ignorable.begin(), non_ignorable.end(), ces_non_ignorable, ces_non_ignorable + 13))
        << "from:     " << ce_dumper(cps)
        << "expected: " << ce_dumper(ces_non_ignorable)
        << "got:      " << ce_dumper(non_ignorable);

    // 1F3F 0041;	
    // (Ἷ) GREEK CAPITAL LETTER IOTA WITH DASIA AND PERISPOMENI	[202C 1CAD | 0020 0023 002A 0020 | 0008 0002 0002 0008 | FFFF FFFF FFFF FFFF |]
    uint32_t const ces_shifted[18] = { 0x202C, 0x1CAD, 0x0000, 0x0020, 0x0023, 0x002A, 0x0020, 0x0000, 0x0008, 0x0002, 0x0002, 0x0008, 0x0000, 0xFFFF, 0xFFFF, 0xFFFF, 0xFFFF, 0x0000 };

    auto const shifted = collate_for_tests(
        cps, cps + 2, boost::text::variable_weighting::shifted);

    EXPECT_EQ(shifted.size(), 18);
    EXPECT_TRUE(boost::algorithm::equal(shifted.begin(), shifted.end(), ces_shifted, ces_shifted + 18))
        << "from:     " << ce_dumper(cps)
        << "expected: " << ce_dumper(ces_shifted)
        << "got:      " << ce_dumper(shifted);
}

TEST(collation, verbatim_131_178)
{
    uint32_t const cps[2] = { 0x03AF, 0x0061 };

    // 03AF 0061;	
    // (ί) GREEK SMALL LETTER IOTA WITH TONOS	[202C 1CAD | 0020 0024 0020 | 0002 0002 0002 |]
    uint32_t const ces_non_ignorable[11] = { 0x202C, 0x1CAD, 0x0000, 0x0020, 0x0024, 0x0020, 0x0000, 0x0002, 0x0002, 0x0002, 0x0000 };

    auto const non_ignorable = collate_for_tests(
        cps, cps + 2, boost::text::variable_weighting::non_ignorable);

    EXPECT_EQ(non_ignorable.size(), 11);
    EXPECT_TRUE(boost::algorithm::equal(non_ignorable.begin(), non_ignorable.end(), ces_non_ignorable, ces_non_ignorable + 11))
        << "from:     " << ce_dumper(cps)
        << "expected: " << ce_dumper(ces_non_ignorable)
        << "got:      " << ce_dumper(non_ignorable);

    // 03AF 0061;	
    // (ί) GREEK SMALL LETTER IOTA WITH TONOS	[202C 1CAD | 0020 0024 0020 | 0002 0002 0002 | FFFF FFFF FFFF |]
    uint32_t const ces_shifted[15] = { 0x202C, 0x1CAD, 0x0000, 0x0020, 0x0024, 0x0020, 0x0000, 0x0002, 0x0002, 0x0002, 0x0000, 0xFFFF, 0xFFFF, 0xFFFF, 0x0000 };

    auto const shifted = collate_for_tests(
        cps, cps + 2, boost::text::variable_weighting::shifted);

    EXPECT_EQ(shifted.size(), 15);
    EXPECT_TRUE(boost::algorithm::equal(shifted.begin(), shifted.end(), ces_shifted, ces_shifted + 15))
        << "from:     " << ce_dumper(cps)
        << "expected: " << ce_dumper(ces_shifted)
        << "got:      " << ce_dumper(shifted);
}

TEST(collation, verbatim_131_179)
{
    uint32_t const cps[2] = { 0x1F77, 0x0061 };

    // 1F77 0061;	
    // (ί) GREEK SMALL LETTER IOTA WITH OXIA	[202C 1CAD | 0020 0024 0020 | 0002 0002 0002 |]
    uint32_t const ces_non_ignorable[11] = { 0x202C, 0x1CAD, 0x0000, 0x0020, 0x0024, 0x0020, 0x0000, 0x0002, 0x0002, 0x0002, 0x0000 };

    auto const non_ignorable = collate_for_tests(
        cps, cps + 2, boost::text::variable_weighting::non_ignorable);

    EXPECT_EQ(non_ignorable.size(), 11);
    EXPECT_TRUE(boost::algorithm::equal(non_ignorable.begin(), non_ignorable.end(), ces_non_ignorable, ces_non_ignorable + 11))
        << "from:     " << ce_dumper(cps)
        << "expected: " << ce_dumper(ces_non_ignorable)
        << "got:      " << ce_dumper(non_ignorable);

    // 1F77 0061;	
    // (ί) GREEK SMALL LETTER IOTA WITH OXIA	[202C 1CAD | 0020 0024 0020 | 0002 0002 0002 | FFFF FFFF FFFF |]
    uint32_t const ces_shifted[15] = { 0x202C, 0x1CAD, 0x0000, 0x0020, 0x0024, 0x0020, 0x0000, 0x0002, 0x0002, 0x0002, 0x0000, 0xFFFF, 0xFFFF, 0xFFFF, 0x0000 };

    auto const shifted = collate_for_tests(
        cps, cps + 2, boost::text::variable_weighting::shifted);

    EXPECT_EQ(shifted.size(), 15);
    EXPECT_TRUE(boost::algorithm::equal(shifted.begin(), shifted.end(), ces_shifted, ces_shifted + 15))
        << "from:     " << ce_dumper(cps)
        << "expected: " << ce_dumper(ces_shifted)
        << "got:      " << ce_dumper(shifted);
}

TEST(collation, verbatim_131_180)
{
    uint32_t const cps[2] = { 0x03AF, 0x0041 };

    // 03AF 0041;	
    // (ί) GREEK SMALL LETTER IOTA WITH TONOS	[202C 1CAD | 0020 0024 0020 | 0002 0002 0008 |]
    uint32_t const ces_non_ignorable[11] = { 0x202C, 0x1CAD, 0x0000, 0x0020, 0x0024, 0x0020, 0x0000, 0x0002, 0x0002, 0x0008, 0x0000 };

    auto const non_ignorable = collate_for_tests(
        cps, cps + 2, boost::text::variable_weighting::non_ignorable);

    EXPECT_EQ(non_ignorable.size(), 11);
    EXPECT_TRUE(boost::algorithm::equal(non_ignorable.begin(), non_ignorable.end(), ces_non_ignorable, ces_non_ignorable + 11))
        << "from:     " << ce_dumper(cps)
        << "expected: " << ce_dumper(ces_non_ignorable)
        << "got:      " << ce_dumper(non_ignorable);

    // 03AF 0041;	
    // (ί) GREEK SMALL LETTER IOTA WITH TONOS	[202C 1CAD | 0020 0024 0020 | 0002 0002 0008 | FFFF FFFF FFFF |]
    uint32_t const ces_shifted[15] = { 0x202C, 0x1CAD, 0x0000, 0x0020, 0x0024, 0x0020, 0x0000, 0x0002, 0x0002, 0x0008, 0x0000, 0xFFFF, 0xFFFF, 0xFFFF, 0x0000 };

    auto const shifted = collate_for_tests(
        cps, cps + 2, boost::text::variable_weighting::shifted);

    EXPECT_EQ(shifted.size(), 15);
    EXPECT_TRUE(boost::algorithm::equal(shifted.begin(), shifted.end(), ces_shifted, ces_shifted + 15))
        << "from:     " << ce_dumper(cps)
        << "expected: " << ce_dumper(ces_shifted)
        << "got:      " << ce_dumper(shifted);
}

TEST(collation, verbatim_131_181)
{
    uint32_t const cps[2] = { 0x1F77, 0x0041 };

    // 1F77 0041;	
    // (ί) GREEK SMALL LETTER IOTA WITH OXIA	[202C 1CAD | 0020 0024 0020 | 0002 0002 0008 |]
    uint32_t const ces_non_ignorable[11] = { 0x202C, 0x1CAD, 0x0000, 0x0020, 0x0024, 0x0020, 0x0000, 0x0002, 0x0002, 0x0008, 0x0000 };

    auto const non_ignorable = collate_for_tests(
        cps, cps + 2, boost::text::variable_weighting::non_ignorable);

    EXPECT_EQ(non_ignorable.size(), 11);
    EXPECT_TRUE(boost::algorithm::equal(non_ignorable.begin(), non_ignorable.end(), ces_non_ignorable, ces_non_ignorable + 11))
        << "from:     " << ce_dumper(cps)
        << "expected: " << ce_dumper(ces_non_ignorable)
        << "got:      " << ce_dumper(non_ignorable);

    // 1F77 0041;	
    // (ί) GREEK SMALL LETTER IOTA WITH OXIA	[202C 1CAD | 0020 0024 0020 | 0002 0002 0008 | FFFF FFFF FFFF |]
    uint32_t const ces_shifted[15] = { 0x202C, 0x1CAD, 0x0000, 0x0020, 0x0024, 0x0020, 0x0000, 0x0002, 0x0002, 0x0008, 0x0000, 0xFFFF, 0xFFFF, 0xFFFF, 0x0000 };

    auto const shifted = collate_for_tests(
        cps, cps + 2, boost::text::variable_weighting::shifted);

    EXPECT_EQ(shifted.size(), 15);
    EXPECT_TRUE(boost::algorithm::equal(shifted.begin(), shifted.end(), ces_shifted, ces_shifted + 15))
        << "from:     " << ce_dumper(cps)
        << "expected: " << ce_dumper(ces_shifted)
        << "got:      " << ce_dumper(shifted);
}

TEST(collation, verbatim_131_182)
{
    uint32_t const cps[2] = { 0x038A, 0x0061 };

    // 038A 0061;	
    // (Ί) GREEK CAPITAL LETTER IOTA WITH TONOS	[202C 1CAD | 0020 0024 0020 | 0008 0002 0002 |]
    uint32_t const ces_non_ignorable[11] = { 0x202C, 0x1CAD, 0x0000, 0x0020, 0x0024, 0x0020, 0x0000, 0x0008, 0x0002, 0x0002, 0x0000 };

    auto const non_ignorable = collate_for_tests(
        cps, cps + 2, boost::text::variable_weighting::non_ignorable);

    EXPECT_EQ(non_ignorable.size(), 11);
    EXPECT_TRUE(boost::algorithm::equal(non_ignorable.begin(), non_ignorable.end(), ces_non_ignorable, ces_non_ignorable + 11))
        << "from:     " << ce_dumper(cps)
        << "expected: " << ce_dumper(ces_non_ignorable)
        << "got:      " << ce_dumper(non_ignorable);

    // 038A 0061;	
    // (Ί) GREEK CAPITAL LETTER IOTA WITH TONOS	[202C 1CAD | 0020 0024 0020 | 0008 0002 0002 | FFFF FFFF FFFF |]
    uint32_t const ces_shifted[15] = { 0x202C, 0x1CAD, 0x0000, 0x0020, 0x0024, 0x0020, 0x0000, 0x0008, 0x0002, 0x0002, 0x0000, 0xFFFF, 0xFFFF, 0xFFFF, 0x0000 };

    auto const shifted = collate_for_tests(
        cps, cps + 2, boost::text::variable_weighting::shifted);

    EXPECT_EQ(shifted.size(), 15);
    EXPECT_TRUE(boost::algorithm::equal(shifted.begin(), shifted.end(), ces_shifted, ces_shifted + 15))
        << "from:     " << ce_dumper(cps)
        << "expected: " << ce_dumper(ces_shifted)
        << "got:      " << ce_dumper(shifted);
}

TEST(collation, verbatim_131_183)
{
    uint32_t const cps[2] = { 0x1FDB, 0x0061 };

    // 1FDB 0061;	
    // (Ί) GREEK CAPITAL LETTER IOTA WITH OXIA	[202C 1CAD | 0020 0024 0020 | 0008 0002 0002 |]
    uint32_t const ces_non_ignorable[11] = { 0x202C, 0x1CAD, 0x0000, 0x0020, 0x0024, 0x0020, 0x0000, 0x0008, 0x0002, 0x0002, 0x0000 };

    auto const non_ignorable = collate_for_tests(
        cps, cps + 2, boost::text::variable_weighting::non_ignorable);

    EXPECT_EQ(non_ignorable.size(), 11);
    EXPECT_TRUE(boost::algorithm::equal(non_ignorable.begin(), non_ignorable.end(), ces_non_ignorable, ces_non_ignorable + 11))
        << "from:     " << ce_dumper(cps)
        << "expected: " << ce_dumper(ces_non_ignorable)
        << "got:      " << ce_dumper(non_ignorable);

    // 1FDB 0061;	
    // (Ί) GREEK CAPITAL LETTER IOTA WITH OXIA	[202C 1CAD | 0020 0024 0020 | 0008 0002 0002 | FFFF FFFF FFFF |]
    uint32_t const ces_shifted[15] = { 0x202C, 0x1CAD, 0x0000, 0x0020, 0x0024, 0x0020, 0x0000, 0x0008, 0x0002, 0x0002, 0x0000, 0xFFFF, 0xFFFF, 0xFFFF, 0x0000 };

    auto const shifted = collate_for_tests(
        cps, cps + 2, boost::text::variable_weighting::shifted);

    EXPECT_EQ(shifted.size(), 15);
    EXPECT_TRUE(boost::algorithm::equal(shifted.begin(), shifted.end(), ces_shifted, ces_shifted + 15))
        << "from:     " << ce_dumper(cps)
        << "expected: " << ce_dumper(ces_shifted)
        << "got:      " << ce_dumper(shifted);
}

TEST(collation, verbatim_131_184)
{
    uint32_t const cps[2] = { 0x038A, 0x0041 };

    // 038A 0041;	
    // (Ί) GREEK CAPITAL LETTER IOTA WITH TONOS	[202C 1CAD | 0020 0024 0020 | 0008 0002 0008 |]
    uint32_t const ces_non_ignorable[11] = { 0x202C, 0x1CAD, 0x0000, 0x0020, 0x0024, 0x0020, 0x0000, 0x0008, 0x0002, 0x0008, 0x0000 };

    auto const non_ignorable = collate_for_tests(
        cps, cps + 2, boost::text::variable_weighting::non_ignorable);

    EXPECT_EQ(non_ignorable.size(), 11);
    EXPECT_TRUE(boost::algorithm::equal(non_ignorable.begin(), non_ignorable.end(), ces_non_ignorable, ces_non_ignorable + 11))
        << "from:     " << ce_dumper(cps)
        << "expected: " << ce_dumper(ces_non_ignorable)
        << "got:      " << ce_dumper(non_ignorable);

    // 038A 0041;	
    // (Ί) GREEK CAPITAL LETTER IOTA WITH TONOS	[202C 1CAD | 0020 0024 0020 | 0008 0002 0008 | FFFF FFFF FFFF |]
    uint32_t const ces_shifted[15] = { 0x202C, 0x1CAD, 0x0000, 0x0020, 0x0024, 0x0020, 0x0000, 0x0008, 0x0002, 0x0008, 0x0000, 0xFFFF, 0xFFFF, 0xFFFF, 0x0000 };

    auto const shifted = collate_for_tests(
        cps, cps + 2, boost::text::variable_weighting::shifted);

    EXPECT_EQ(shifted.size(), 15);
    EXPECT_TRUE(boost::algorithm::equal(shifted.begin(), shifted.end(), ces_shifted, ces_shifted + 15))
        << "from:     " << ce_dumper(cps)
        << "expected: " << ce_dumper(ces_shifted)
        << "got:      " << ce_dumper(shifted);
}

TEST(collation, verbatim_131_185)
{
    uint32_t const cps[2] = { 0x1FDB, 0x0041 };

    // 1FDB 0041;	
    // (Ί) GREEK CAPITAL LETTER IOTA WITH OXIA	[202C 1CAD | 0020 0024 0020 | 0008 0002 0008 |]
    uint32_t const ces_non_ignorable[11] = { 0x202C, 0x1CAD, 0x0000, 0x0020, 0x0024, 0x0020, 0x0000, 0x0008, 0x0002, 0x0008, 0x0000 };

    auto const non_ignorable = collate_for_tests(
        cps, cps + 2, boost::text::variable_weighting::non_ignorable);

    EXPECT_EQ(non_ignorable.size(), 11);
    EXPECT_TRUE(boost::algorithm::equal(non_ignorable.begin(), non_ignorable.end(), ces_non_ignorable, ces_non_ignorable + 11))
        << "from:     " << ce_dumper(cps)
        << "expected: " << ce_dumper(ces_non_ignorable)
        << "got:      " << ce_dumper(non_ignorable);

    // 1FDB 0041;	
    // (Ί) GREEK CAPITAL LETTER IOTA WITH OXIA	[202C 1CAD | 0020 0024 0020 | 0008 0002 0008 | FFFF FFFF FFFF |]
    uint32_t const ces_shifted[15] = { 0x202C, 0x1CAD, 0x0000, 0x0020, 0x0024, 0x0020, 0x0000, 0x0008, 0x0002, 0x0008, 0x0000, 0xFFFF, 0xFFFF, 0xFFFF, 0x0000 };

    auto const shifted = collate_for_tests(
        cps, cps + 2, boost::text::variable_weighting::shifted);

    EXPECT_EQ(shifted.size(), 15);
    EXPECT_TRUE(boost::algorithm::equal(shifted.begin(), shifted.end(), ces_shifted, ces_shifted + 15))
        << "from:     " << ce_dumper(cps)
        << "expected: " << ce_dumper(ces_shifted)
        << "got:      " << ce_dumper(shifted);
}

TEST(collation, verbatim_131_186)
{
    uint32_t const cps[2] = { 0x1F76, 0x0061 };

    // 1F76 0061;	
    // (ὶ) GREEK SMALL LETTER IOTA WITH VARIA	[202C 1CAD | 0020 0025 0020 | 0002 0002 0002 |]
    uint32_t const ces_non_ignorable[11] = { 0x202C, 0x1CAD, 0x0000, 0x0020, 0x0025, 0x0020, 0x0000, 0x0002, 0x0002, 0x0002, 0x0000 };

    auto const non_ignorable = collate_for_tests(
        cps, cps + 2, boost::text::variable_weighting::non_ignorable);

    EXPECT_EQ(non_ignorable.size(), 11);
    EXPECT_TRUE(boost::algorithm::equal(non_ignorable.begin(), non_ignorable.end(), ces_non_ignorable, ces_non_ignorable + 11))
        << "from:     " << ce_dumper(cps)
        << "expected: " << ce_dumper(ces_non_ignorable)
        << "got:      " << ce_dumper(non_ignorable);

    // 1F76 0061;	
    // (ὶ) GREEK SMALL LETTER IOTA WITH VARIA	[202C 1CAD | 0020 0025 0020 | 0002 0002 0002 | FFFF FFFF FFFF |]
    uint32_t const ces_shifted[15] = { 0x202C, 0x1CAD, 0x0000, 0x0020, 0x0025, 0x0020, 0x0000, 0x0002, 0x0002, 0x0002, 0x0000, 0xFFFF, 0xFFFF, 0xFFFF, 0x0000 };

    auto const shifted = collate_for_tests(
        cps, cps + 2, boost::text::variable_weighting::shifted);

    EXPECT_EQ(shifted.size(), 15);
    EXPECT_TRUE(boost::algorithm::equal(shifted.begin(), shifted.end(), ces_shifted, ces_shifted + 15))
        << "from:     " << ce_dumper(cps)
        << "expected: " << ce_dumper(ces_shifted)
        << "got:      " << ce_dumper(shifted);
}

TEST(collation, verbatim_131_187)
{
    uint32_t const cps[2] = { 0x1F76, 0x0041 };

    // 1F76 0041;	
    // (ὶ) GREEK SMALL LETTER IOTA WITH VARIA	[202C 1CAD | 0020 0025 0020 | 0002 0002 0008 |]
    uint32_t const ces_non_ignorable[11] = { 0x202C, 0x1CAD, 0x0000, 0x0020, 0x0025, 0x0020, 0x0000, 0x0002, 0x0002, 0x0008, 0x0000 };

    auto const non_ignorable = collate_for_tests(
        cps, cps + 2, boost::text::variable_weighting::non_ignorable);

    EXPECT_EQ(non_ignorable.size(), 11);
    EXPECT_TRUE(boost::algorithm::equal(non_ignorable.begin(), non_ignorable.end(), ces_non_ignorable, ces_non_ignorable + 11))
        << "from:     " << ce_dumper(cps)
        << "expected: " << ce_dumper(ces_non_ignorable)
        << "got:      " << ce_dumper(non_ignorable);

    // 1F76 0041;	
    // (ὶ) GREEK SMALL LETTER IOTA WITH VARIA	[202C 1CAD | 0020 0025 0020 | 0002 0002 0008 | FFFF FFFF FFFF |]
    uint32_t const ces_shifted[15] = { 0x202C, 0x1CAD, 0x0000, 0x0020, 0x0025, 0x0020, 0x0000, 0x0002, 0x0002, 0x0008, 0x0000, 0xFFFF, 0xFFFF, 0xFFFF, 0x0000 };

    auto const shifted = collate_for_tests(
        cps, cps + 2, boost::text::variable_weighting::shifted);

    EXPECT_EQ(shifted.size(), 15);
    EXPECT_TRUE(boost::algorithm::equal(shifted.begin(), shifted.end(), ces_shifted, ces_shifted + 15))
        << "from:     " << ce_dumper(cps)
        << "expected: " << ce_dumper(ces_shifted)
        << "got:      " << ce_dumper(shifted);
}

TEST(collation, verbatim_131_188)
{
    uint32_t const cps[2] = { 0x1FDA, 0x0061 };

    // 1FDA 0061;	
    // (Ὶ) GREEK CAPITAL LETTER IOTA WITH VARIA	[202C 1CAD | 0020 0025 0020 | 0008 0002 0002 |]
    uint32_t const ces_non_ignorable[11] = { 0x202C, 0x1CAD, 0x0000, 0x0020, 0x0025, 0x0020, 0x0000, 0x0008, 0x0002, 0x0002, 0x0000 };

    auto const non_ignorable = collate_for_tests(
        cps, cps + 2, boost::text::variable_weighting::non_ignorable);

    EXPECT_EQ(non_ignorable.size(), 11);
    EXPECT_TRUE(boost::algorithm::equal(non_ignorable.begin(), non_ignorable.end(), ces_non_ignorable, ces_non_ignorable + 11))
        << "from:     " << ce_dumper(cps)
        << "expected: " << ce_dumper(ces_non_ignorable)
        << "got:      " << ce_dumper(non_ignorable);

    // 1FDA 0061;	
    // (Ὶ) GREEK CAPITAL LETTER IOTA WITH VARIA	[202C 1CAD | 0020 0025 0020 | 0008 0002 0002 | FFFF FFFF FFFF |]
    uint32_t const ces_shifted[15] = { 0x202C, 0x1CAD, 0x0000, 0x0020, 0x0025, 0x0020, 0x0000, 0x0008, 0x0002, 0x0002, 0x0000, 0xFFFF, 0xFFFF, 0xFFFF, 0x0000 };

    auto const shifted = collate_for_tests(
        cps, cps + 2, boost::text::variable_weighting::shifted);

    EXPECT_EQ(shifted.size(), 15);
    EXPECT_TRUE(boost::algorithm::equal(shifted.begin(), shifted.end(), ces_shifted, ces_shifted + 15))
        << "from:     " << ce_dumper(cps)
        << "expected: " << ce_dumper(ces_shifted)
        << "got:      " << ce_dumper(shifted);
}

TEST(collation, verbatim_131_189)
{
    uint32_t const cps[2] = { 0x1FDA, 0x0041 };

    // 1FDA 0041;	
    // (Ὶ) GREEK CAPITAL LETTER IOTA WITH VARIA	[202C 1CAD | 0020 0025 0020 | 0008 0002 0008 |]
    uint32_t const ces_non_ignorable[11] = { 0x202C, 0x1CAD, 0x0000, 0x0020, 0x0025, 0x0020, 0x0000, 0x0008, 0x0002, 0x0008, 0x0000 };

    auto const non_ignorable = collate_for_tests(
        cps, cps + 2, boost::text::variable_weighting::non_ignorable);

    EXPECT_EQ(non_ignorable.size(), 11);
    EXPECT_TRUE(boost::algorithm::equal(non_ignorable.begin(), non_ignorable.end(), ces_non_ignorable, ces_non_ignorable + 11))
        << "from:     " << ce_dumper(cps)
        << "expected: " << ce_dumper(ces_non_ignorable)
        << "got:      " << ce_dumper(non_ignorable);

    // 1FDA 0041;	
    // (Ὶ) GREEK CAPITAL LETTER IOTA WITH VARIA	[202C 1CAD | 0020 0025 0020 | 0008 0002 0008 | FFFF FFFF FFFF |]
    uint32_t const ces_shifted[15] = { 0x202C, 0x1CAD, 0x0000, 0x0020, 0x0025, 0x0020, 0x0000, 0x0008, 0x0002, 0x0008, 0x0000, 0xFFFF, 0xFFFF, 0xFFFF, 0x0000 };

    auto const shifted = collate_for_tests(
        cps, cps + 2, boost::text::variable_weighting::shifted);

    EXPECT_EQ(shifted.size(), 15);
    EXPECT_TRUE(boost::algorithm::equal(shifted.begin(), shifted.end(), ces_shifted, ces_shifted + 15))
        << "from:     " << ce_dumper(cps)
        << "expected: " << ce_dumper(ces_shifted)
        << "got:      " << ce_dumper(shifted);
}

TEST(collation, verbatim_131_190)
{
    uint32_t const cps[2] = { 0x1FD0, 0x0061 };

    // 1FD0 0061;	
    // (ῐ) GREEK SMALL LETTER IOTA WITH VRACHY	[202C 1CAD | 0020 0026 0020 | 0002 0002 0002 |]
    uint32_t const ces_non_ignorable[11] = { 0x202C, 0x1CAD, 0x0000, 0x0020, 0x0026, 0x0020, 0x0000, 0x0002, 0x0002, 0x0002, 0x0000 };

    auto const non_ignorable = collate_for_tests(
        cps, cps + 2, boost::text::variable_weighting::non_ignorable);

    EXPECT_EQ(non_ignorable.size(), 11);
    EXPECT_TRUE(boost::algorithm::equal(non_ignorable.begin(), non_ignorable.end(), ces_non_ignorable, ces_non_ignorable + 11))
        << "from:     " << ce_dumper(cps)
        << "expected: " << ce_dumper(ces_non_ignorable)
        << "got:      " << ce_dumper(non_ignorable);

    // 1FD0 0061;	
    // (ῐ) GREEK SMALL LETTER IOTA WITH VRACHY	[202C 1CAD | 0020 0026 0020 | 0002 0002 0002 | FFFF FFFF FFFF |]
    uint32_t const ces_shifted[15] = { 0x202C, 0x1CAD, 0x0000, 0x0020, 0x0026, 0x0020, 0x0000, 0x0002, 0x0002, 0x0002, 0x0000, 0xFFFF, 0xFFFF, 0xFFFF, 0x0000 };

    auto const shifted = collate_for_tests(
        cps, cps + 2, boost::text::variable_weighting::shifted);

    EXPECT_EQ(shifted.size(), 15);
    EXPECT_TRUE(boost::algorithm::equal(shifted.begin(), shifted.end(), ces_shifted, ces_shifted + 15))
        << "from:     " << ce_dumper(cps)
        << "expected: " << ce_dumper(ces_shifted)
        << "got:      " << ce_dumper(shifted);
}

TEST(collation, verbatim_131_191)
{
    uint32_t const cps[2] = { 0x1FD0, 0x0041 };

    // 1FD0 0041;	
    // (ῐ) GREEK SMALL LETTER IOTA WITH VRACHY	[202C 1CAD | 0020 0026 0020 | 0002 0002 0008 |]
    uint32_t const ces_non_ignorable[11] = { 0x202C, 0x1CAD, 0x0000, 0x0020, 0x0026, 0x0020, 0x0000, 0x0002, 0x0002, 0x0008, 0x0000 };

    auto const non_ignorable = collate_for_tests(
        cps, cps + 2, boost::text::variable_weighting::non_ignorable);

    EXPECT_EQ(non_ignorable.size(), 11);
    EXPECT_TRUE(boost::algorithm::equal(non_ignorable.begin(), non_ignorable.end(), ces_non_ignorable, ces_non_ignorable + 11))
        << "from:     " << ce_dumper(cps)
        << "expected: " << ce_dumper(ces_non_ignorable)
        << "got:      " << ce_dumper(non_ignorable);

    // 1FD0 0041;	
    // (ῐ) GREEK SMALL LETTER IOTA WITH VRACHY	[202C 1CAD | 0020 0026 0020 | 0002 0002 0008 | FFFF FFFF FFFF |]
    uint32_t const ces_shifted[15] = { 0x202C, 0x1CAD, 0x0000, 0x0020, 0x0026, 0x0020, 0x0000, 0x0002, 0x0002, 0x0008, 0x0000, 0xFFFF, 0xFFFF, 0xFFFF, 0x0000 };

    auto const shifted = collate_for_tests(
        cps, cps + 2, boost::text::variable_weighting::shifted);

    EXPECT_EQ(shifted.size(), 15);
    EXPECT_TRUE(boost::algorithm::equal(shifted.begin(), shifted.end(), ces_shifted, ces_shifted + 15))
        << "from:     " << ce_dumper(cps)
        << "expected: " << ce_dumper(ces_shifted)
        << "got:      " << ce_dumper(shifted);
}

TEST(collation, verbatim_131_192)
{
    uint32_t const cps[2] = { 0x1FD8, 0x0061 };

    // 1FD8 0061;	
    // (Ῐ) GREEK CAPITAL LETTER IOTA WITH VRACHY	[202C 1CAD | 0020 0026 0020 | 0008 0002 0002 |]
    uint32_t const ces_non_ignorable[11] = { 0x202C, 0x1CAD, 0x0000, 0x0020, 0x0026, 0x0020, 0x0000, 0x0008, 0x0002, 0x0002, 0x0000 };

    auto const non_ignorable = collate_for_tests(
        cps, cps + 2, boost::text::variable_weighting::non_ignorable);

    EXPECT_EQ(non_ignorable.size(), 11);
    EXPECT_TRUE(boost::algorithm::equal(non_ignorable.begin(), non_ignorable.end(), ces_non_ignorable, ces_non_ignorable + 11))
        << "from:     " << ce_dumper(cps)
        << "expected: " << ce_dumper(ces_non_ignorable)
        << "got:      " << ce_dumper(non_ignorable);

    // 1FD8 0061;	
    // (Ῐ) GREEK CAPITAL LETTER IOTA WITH VRACHY	[202C 1CAD | 0020 0026 0020 | 0008 0002 0002 | FFFF FFFF FFFF |]
    uint32_t const ces_shifted[15] = { 0x202C, 0x1CAD, 0x0000, 0x0020, 0x0026, 0x0020, 0x0000, 0x0008, 0x0002, 0x0002, 0x0000, 0xFFFF, 0xFFFF, 0xFFFF, 0x0000 };

    auto const shifted = collate_for_tests(
        cps, cps + 2, boost::text::variable_weighting::shifted);

    EXPECT_EQ(shifted.size(), 15);
    EXPECT_TRUE(boost::algorithm::equal(shifted.begin(), shifted.end(), ces_shifted, ces_shifted + 15))
        << "from:     " << ce_dumper(cps)
        << "expected: " << ce_dumper(ces_shifted)
        << "got:      " << ce_dumper(shifted);
}

TEST(collation, verbatim_131_193)
{
    uint32_t const cps[2] = { 0x1FD8, 0x0041 };

    // 1FD8 0041;	
    // (Ῐ) GREEK CAPITAL LETTER IOTA WITH VRACHY	[202C 1CAD | 0020 0026 0020 | 0008 0002 0008 |]
    uint32_t const ces_non_ignorable[11] = { 0x202C, 0x1CAD, 0x0000, 0x0020, 0x0026, 0x0020, 0x0000, 0x0008, 0x0002, 0x0008, 0x0000 };

    auto const non_ignorable = collate_for_tests(
        cps, cps + 2, boost::text::variable_weighting::non_ignorable);

    EXPECT_EQ(non_ignorable.size(), 11);
    EXPECT_TRUE(boost::algorithm::equal(non_ignorable.begin(), non_ignorable.end(), ces_non_ignorable, ces_non_ignorable + 11))
        << "from:     " << ce_dumper(cps)
        << "expected: " << ce_dumper(ces_non_ignorable)
        << "got:      " << ce_dumper(non_ignorable);

    // 1FD8 0041;	
    // (Ῐ) GREEK CAPITAL LETTER IOTA WITH VRACHY	[202C 1CAD | 0020 0026 0020 | 0008 0002 0008 | FFFF FFFF FFFF |]
    uint32_t const ces_shifted[15] = { 0x202C, 0x1CAD, 0x0000, 0x0020, 0x0026, 0x0020, 0x0000, 0x0008, 0x0002, 0x0008, 0x0000, 0xFFFF, 0xFFFF, 0xFFFF, 0x0000 };

    auto const shifted = collate_for_tests(
        cps, cps + 2, boost::text::variable_weighting::shifted);

    EXPECT_EQ(shifted.size(), 15);
    EXPECT_TRUE(boost::algorithm::equal(shifted.begin(), shifted.end(), ces_shifted, ces_shifted + 15))
        << "from:     " << ce_dumper(cps)
        << "expected: " << ce_dumper(ces_shifted)
        << "got:      " << ce_dumper(shifted);
}

TEST(collation, verbatim_131_194)
{
    uint32_t const cps[2] = { 0x1FD6, 0x0061 };

    // 1FD6 0061;	
    // (ῖ) GREEK SMALL LETTER IOTA WITH PERISPOMENI	[202C 1CAD | 0020 002A 0020 | 0002 0002 0002 |]
    uint32_t const ces_non_ignorable[11] = { 0x202C, 0x1CAD, 0x0000, 0x0020, 0x002A, 0x0020, 0x0000, 0x0002, 0x0002, 0x0002, 0x0000 };

    auto const non_ignorable = collate_for_tests(
        cps, cps + 2, boost::text::variable_weighting::non_ignorable);

    EXPECT_EQ(non_ignorable.size(), 11);
    EXPECT_TRUE(boost::algorithm::equal(non_ignorable.begin(), non_ignorable.end(), ces_non_ignorable, ces_non_ignorable + 11))
        << "from:     " << ce_dumper(cps)
        << "expected: " << ce_dumper(ces_non_ignorable)
        << "got:      " << ce_dumper(non_ignorable);

    // 1FD6 0061;	
    // (ῖ) GREEK SMALL LETTER IOTA WITH PERISPOMENI	[202C 1CAD | 0020 002A 0020 | 0002 0002 0002 | FFFF FFFF FFFF |]
    uint32_t const ces_shifted[15] = { 0x202C, 0x1CAD, 0x0000, 0x0020, 0x002A, 0x0020, 0x0000, 0x0002, 0x0002, 0x0002, 0x0000, 0xFFFF, 0xFFFF, 0xFFFF, 0x0000 };

    auto const shifted = collate_for_tests(
        cps, cps + 2, boost::text::variable_weighting::shifted);

    EXPECT_EQ(shifted.size(), 15);
    EXPECT_TRUE(boost::algorithm::equal(shifted.begin(), shifted.end(), ces_shifted, ces_shifted + 15))
        << "from:     " << ce_dumper(cps)
        << "expected: " << ce_dumper(ces_shifted)
        << "got:      " << ce_dumper(shifted);
}

TEST(collation, verbatim_131_195)
{
    uint32_t const cps[2] = { 0x1FD6, 0x0041 };

    // 1FD6 0041;	
    // (ῖ) GREEK SMALL LETTER IOTA WITH PERISPOMENI	[202C 1CAD | 0020 002A 0020 | 0002 0002 0008 |]
    uint32_t const ces_non_ignorable[11] = { 0x202C, 0x1CAD, 0x0000, 0x0020, 0x002A, 0x0020, 0x0000, 0x0002, 0x0002, 0x0008, 0x0000 };

    auto const non_ignorable = collate_for_tests(
        cps, cps + 2, boost::text::variable_weighting::non_ignorable);

    EXPECT_EQ(non_ignorable.size(), 11);
    EXPECT_TRUE(boost::algorithm::equal(non_ignorable.begin(), non_ignorable.end(), ces_non_ignorable, ces_non_ignorable + 11))
        << "from:     " << ce_dumper(cps)
        << "expected: " << ce_dumper(ces_non_ignorable)
        << "got:      " << ce_dumper(non_ignorable);

    // 1FD6 0041;	
    // (ῖ) GREEK SMALL LETTER IOTA WITH PERISPOMENI	[202C 1CAD | 0020 002A 0020 | 0002 0002 0008 | FFFF FFFF FFFF |]
    uint32_t const ces_shifted[15] = { 0x202C, 0x1CAD, 0x0000, 0x0020, 0x002A, 0x0020, 0x0000, 0x0002, 0x0002, 0x0008, 0x0000, 0xFFFF, 0xFFFF, 0xFFFF, 0x0000 };

    auto const shifted = collate_for_tests(
        cps, cps + 2, boost::text::variable_weighting::shifted);

    EXPECT_EQ(shifted.size(), 15);
    EXPECT_TRUE(boost::algorithm::equal(shifted.begin(), shifted.end(), ces_shifted, ces_shifted + 15))
        << "from:     " << ce_dumper(cps)
        << "expected: " << ce_dumper(ces_shifted)
        << "got:      " << ce_dumper(shifted);
}

TEST(collation, verbatim_131_196)
{
    uint32_t const cps[2] = { 0x03CA, 0x0061 };

    // 03CA 0061;	
    // (ϊ) GREEK SMALL LETTER IOTA WITH DIALYTIKA	[202C 1CAD | 0020 002B 0020 | 0002 0002 0002 |]
    uint32_t const ces_non_ignorable[11] = { 0x202C, 0x1CAD, 0x0000, 0x0020, 0x002B, 0x0020, 0x0000, 0x0002, 0x0002, 0x0002, 0x0000 };

    auto const non_ignorable = collate_for_tests(
        cps, cps + 2, boost::text::variable_weighting::non_ignorable);

    EXPECT_EQ(non_ignorable.size(), 11);
    EXPECT_TRUE(boost::algorithm::equal(non_ignorable.begin(), non_ignorable.end(), ces_non_ignorable, ces_non_ignorable + 11))
        << "from:     " << ce_dumper(cps)
        << "expected: " << ce_dumper(ces_non_ignorable)
        << "got:      " << ce_dumper(non_ignorable);

    // 03CA 0061;	
    // (ϊ) GREEK SMALL LETTER IOTA WITH DIALYTIKA	[202C 1CAD | 0020 002B 0020 | 0002 0002 0002 | FFFF FFFF FFFF |]
    uint32_t const ces_shifted[15] = { 0x202C, 0x1CAD, 0x0000, 0x0020, 0x002B, 0x0020, 0x0000, 0x0002, 0x0002, 0x0002, 0x0000, 0xFFFF, 0xFFFF, 0xFFFF, 0x0000 };

    auto const shifted = collate_for_tests(
        cps, cps + 2, boost::text::variable_weighting::shifted);

    EXPECT_EQ(shifted.size(), 15);
    EXPECT_TRUE(boost::algorithm::equal(shifted.begin(), shifted.end(), ces_shifted, ces_shifted + 15))
        << "from:     " << ce_dumper(cps)
        << "expected: " << ce_dumper(ces_shifted)
        << "got:      " << ce_dumper(shifted);
}

TEST(collation, verbatim_131_197)
{
    uint32_t const cps[2] = { 0x03CA, 0x0041 };

    // 03CA 0041;	
    // (ϊ) GREEK SMALL LETTER IOTA WITH DIALYTIKA	[202C 1CAD | 0020 002B 0020 | 0002 0002 0008 |]
    uint32_t const ces_non_ignorable[11] = { 0x202C, 0x1CAD, 0x0000, 0x0020, 0x002B, 0x0020, 0x0000, 0x0002, 0x0002, 0x0008, 0x0000 };

    auto const non_ignorable = collate_for_tests(
        cps, cps + 2, boost::text::variable_weighting::non_ignorable);

    EXPECT_EQ(non_ignorable.size(), 11);
    EXPECT_TRUE(boost::algorithm::equal(non_ignorable.begin(), non_ignorable.end(), ces_non_ignorable, ces_non_ignorable + 11))
        << "from:     " << ce_dumper(cps)
        << "expected: " << ce_dumper(ces_non_ignorable)
        << "got:      " << ce_dumper(non_ignorable);

    // 03CA 0041;	
    // (ϊ) GREEK SMALL LETTER IOTA WITH DIALYTIKA	[202C 1CAD | 0020 002B 0020 | 0002 0002 0008 | FFFF FFFF FFFF |]
    uint32_t const ces_shifted[15] = { 0x202C, 0x1CAD, 0x0000, 0x0020, 0x002B, 0x0020, 0x0000, 0x0002, 0x0002, 0x0008, 0x0000, 0xFFFF, 0xFFFF, 0xFFFF, 0x0000 };

    auto const shifted = collate_for_tests(
        cps, cps + 2, boost::text::variable_weighting::shifted);

    EXPECT_EQ(shifted.size(), 15);
    EXPECT_TRUE(boost::algorithm::equal(shifted.begin(), shifted.end(), ces_shifted, ces_shifted + 15))
        << "from:     " << ce_dumper(cps)
        << "expected: " << ce_dumper(ces_shifted)
        << "got:      " << ce_dumper(shifted);
}

TEST(collation, verbatim_131_198)
{
    uint32_t const cps[2] = { 0x03AA, 0x0061 };

    // 03AA 0061;	
    // (Ϊ) GREEK CAPITAL LETTER IOTA WITH DIALYTIKA	[202C 1CAD | 0020 002B 0020 | 0008 0002 0002 |]
    uint32_t const ces_non_ignorable[11] = { 0x202C, 0x1CAD, 0x0000, 0x0020, 0x002B, 0x0020, 0x0000, 0x0008, 0x0002, 0x0002, 0x0000 };

    auto const non_ignorable = collate_for_tests(
        cps, cps + 2, boost::text::variable_weighting::non_ignorable);

    EXPECT_EQ(non_ignorable.size(), 11);
    EXPECT_TRUE(boost::algorithm::equal(non_ignorable.begin(), non_ignorable.end(), ces_non_ignorable, ces_non_ignorable + 11))
        << "from:     " << ce_dumper(cps)
        << "expected: " << ce_dumper(ces_non_ignorable)
        << "got:      " << ce_dumper(non_ignorable);

    // 03AA 0061;	
    // (Ϊ) GREEK CAPITAL LETTER IOTA WITH DIALYTIKA	[202C 1CAD | 0020 002B 0020 | 0008 0002 0002 | FFFF FFFF FFFF |]
    uint32_t const ces_shifted[15] = { 0x202C, 0x1CAD, 0x0000, 0x0020, 0x002B, 0x0020, 0x0000, 0x0008, 0x0002, 0x0002, 0x0000, 0xFFFF, 0xFFFF, 0xFFFF, 0x0000 };

    auto const shifted = collate_for_tests(
        cps, cps + 2, boost::text::variable_weighting::shifted);

    EXPECT_EQ(shifted.size(), 15);
    EXPECT_TRUE(boost::algorithm::equal(shifted.begin(), shifted.end(), ces_shifted, ces_shifted + 15))
        << "from:     " << ce_dumper(cps)
        << "expected: " << ce_dumper(ces_shifted)
        << "got:      " << ce_dumper(shifted);
}

TEST(collation, verbatim_131_199)
{
    uint32_t const cps[2] = { 0x03AA, 0x0041 };

    // 03AA 0041;	
    // (Ϊ) GREEK CAPITAL LETTER IOTA WITH DIALYTIKA	[202C 1CAD | 0020 002B 0020 | 0008 0002 0008 |]
    uint32_t const ces_non_ignorable[11] = { 0x202C, 0x1CAD, 0x0000, 0x0020, 0x002B, 0x0020, 0x0000, 0x0008, 0x0002, 0x0008, 0x0000 };

    auto const non_ignorable = collate_for_tests(
        cps, cps + 2, boost::text::variable_weighting::non_ignorable);

    EXPECT_EQ(non_ignorable.size(), 11);
    EXPECT_TRUE(boost::algorithm::equal(non_ignorable.begin(), non_ignorable.end(), ces_non_ignorable, ces_non_ignorable + 11))
        << "from:     " << ce_dumper(cps)
        << "expected: " << ce_dumper(ces_non_ignorable)
        << "got:      " << ce_dumper(non_ignorable);

    // 03AA 0041;	
    // (Ϊ) GREEK CAPITAL LETTER IOTA WITH DIALYTIKA	[202C 1CAD | 0020 002B 0020 | 0008 0002 0008 | FFFF FFFF FFFF |]
    uint32_t const ces_shifted[15] = { 0x202C, 0x1CAD, 0x0000, 0x0020, 0x002B, 0x0020, 0x0000, 0x0008, 0x0002, 0x0008, 0x0000, 0xFFFF, 0xFFFF, 0xFFFF, 0x0000 };

    auto const shifted = collate_for_tests(
        cps, cps + 2, boost::text::variable_weighting::shifted);

    EXPECT_EQ(shifted.size(), 15);
    EXPECT_TRUE(boost::algorithm::equal(shifted.begin(), shifted.end(), ces_shifted, ces_shifted + 15))
        << "from:     " << ce_dumper(cps)
        << "expected: " << ce_dumper(ces_shifted)
        << "got:      " << ce_dumper(shifted);
}

TEST(collation, verbatim_131_200)
{
    uint32_t const cps[2] = { 0x0390, 0x0061 };

    // 0390 0061;	
    // (ΐ) GREEK SMALL LETTER IOTA WITH DIALYTIKA AND TONOS	[202C 1CAD | 0020 002B 0024 0020 | 0002 0002 0002 0002 |]
    uint32_t const ces_non_ignorable[13] = { 0x202C, 0x1CAD, 0x0000, 0x0020, 0x002B, 0x0024, 0x0020, 0x0000, 0x0002, 0x0002, 0x0002, 0x0002, 0x0000 };

    auto const non_ignorable = collate_for_tests(
        cps, cps + 2, boost::text::variable_weighting::non_ignorable);

    EXPECT_EQ(non_ignorable.size(), 13);
    EXPECT_TRUE(boost::algorithm::equal(non_ignorable.begin(), non_ignorable.end(), ces_non_ignorable, ces_non_ignorable + 13))
        << "from:     " << ce_dumper(cps)
        << "expected: " << ce_dumper(ces_non_ignorable)
        << "got:      " << ce_dumper(non_ignorable);

    // 0390 0061;	
    // (ΐ) GREEK SMALL LETTER IOTA WITH DIALYTIKA AND TONOS	[202C 1CAD | 0020 002B 0024 0020 | 0002 0002 0002 0002 | FFFF FFFF FFFF FFFF |]
    uint32_t const ces_shifted[18] = { 0x202C, 0x1CAD, 0x0000, 0x0020, 0x002B, 0x0024, 0x0020, 0x0000, 0x0002, 0x0002, 0x0002, 0x0002, 0x0000, 0xFFFF, 0xFFFF, 0xFFFF, 0xFFFF, 0x0000 };

    auto const shifted = collate_for_tests(
        cps, cps + 2, boost::text::variable_weighting::shifted);

    EXPECT_EQ(shifted.size(), 18);
    EXPECT_TRUE(boost::algorithm::equal(shifted.begin(), shifted.end(), ces_shifted, ces_shifted + 18))
        << "from:     " << ce_dumper(cps)
        << "expected: " << ce_dumper(ces_shifted)
        << "got:      " << ce_dumper(shifted);
}

TEST(collation, verbatim_131_201)
{
    uint32_t const cps[2] = { 0x1FD3, 0x0061 };

    // 1FD3 0061;	
    // (ΐ) GREEK SMALL LETTER IOTA WITH DIALYTIKA AND OXIA	[202C 1CAD | 0020 002B 0024 0020 | 0002 0002 0002 0002 |]
    uint32_t const ces_non_ignorable[13] = { 0x202C, 0x1CAD, 0x0000, 0x0020, 0x002B, 0x0024, 0x0020, 0x0000, 0x0002, 0x0002, 0x0002, 0x0002, 0x0000 };

    auto const non_ignorable = collate_for_tests(
        cps, cps + 2, boost::text::variable_weighting::non_ignorable);

    EXPECT_EQ(non_ignorable.size(), 13);
    EXPECT_TRUE(boost::algorithm::equal(non_ignorable.begin(), non_ignorable.end(), ces_non_ignorable, ces_non_ignorable + 13))
        << "from:     " << ce_dumper(cps)
        << "expected: " << ce_dumper(ces_non_ignorable)
        << "got:      " << ce_dumper(non_ignorable);

    // 1FD3 0061;	
    // (ΐ) GREEK SMALL LETTER IOTA WITH DIALYTIKA AND OXIA	[202C 1CAD | 0020 002B 0024 0020 | 0002 0002 0002 0002 | FFFF FFFF FFFF FFFF |]
    uint32_t const ces_shifted[18] = { 0x202C, 0x1CAD, 0x0000, 0x0020, 0x002B, 0x0024, 0x0020, 0x0000, 0x0002, 0x0002, 0x0002, 0x0002, 0x0000, 0xFFFF, 0xFFFF, 0xFFFF, 0xFFFF, 0x0000 };

    auto const shifted = collate_for_tests(
        cps, cps + 2, boost::text::variable_weighting::shifted);

    EXPECT_EQ(shifted.size(), 18);
    EXPECT_TRUE(boost::algorithm::equal(shifted.begin(), shifted.end(), ces_shifted, ces_shifted + 18))
        << "from:     " << ce_dumper(cps)
        << "expected: " << ce_dumper(ces_shifted)
        << "got:      " << ce_dumper(shifted);
}

TEST(collation, verbatim_131_202)
{
    uint32_t const cps[2] = { 0x0390, 0x0041 };

    // 0390 0041;	
    // (ΐ) GREEK SMALL LETTER IOTA WITH DIALYTIKA AND TONOS	[202C 1CAD | 0020 002B 0024 0020 | 0002 0002 0002 0008 |]
    uint32_t const ces_non_ignorable[13] = { 0x202C, 0x1CAD, 0x0000, 0x0020, 0x002B, 0x0024, 0x0020, 0x0000, 0x0002, 0x0002, 0x0002, 0x0008, 0x0000 };

    auto const non_ignorable = collate_for_tests(
        cps, cps + 2, boost::text::variable_weighting::non_ignorable);

    EXPECT_EQ(non_ignorable.size(), 13);
    EXPECT_TRUE(boost::algorithm::equal(non_ignorable.begin(), non_ignorable.end(), ces_non_ignorable, ces_non_ignorable + 13))
        << "from:     " << ce_dumper(cps)
        << "expected: " << ce_dumper(ces_non_ignorable)
        << "got:      " << ce_dumper(non_ignorable);

    // 0390 0041;	
    // (ΐ) GREEK SMALL LETTER IOTA WITH DIALYTIKA AND TONOS	[202C 1CAD | 0020 002B 0024 0020 | 0002 0002 0002 0008 | FFFF FFFF FFFF FFFF |]
    uint32_t const ces_shifted[18] = { 0x202C, 0x1CAD, 0x0000, 0x0020, 0x002B, 0x0024, 0x0020, 0x0000, 0x0002, 0x0002, 0x0002, 0x0008, 0x0000, 0xFFFF, 0xFFFF, 0xFFFF, 0xFFFF, 0x0000 };

    auto const shifted = collate_for_tests(
        cps, cps + 2, boost::text::variable_weighting::shifted);

    EXPECT_EQ(shifted.size(), 18);
    EXPECT_TRUE(boost::algorithm::equal(shifted.begin(), shifted.end(), ces_shifted, ces_shifted + 18))
        << "from:     " << ce_dumper(cps)
        << "expected: " << ce_dumper(ces_shifted)
        << "got:      " << ce_dumper(shifted);
}

TEST(collation, verbatim_131_203)
{
    uint32_t const cps[2] = { 0x1FD3, 0x0041 };

    // 1FD3 0041;	
    // (ΐ) GREEK SMALL LETTER IOTA WITH DIALYTIKA AND OXIA	[202C 1CAD | 0020 002B 0024 0020 | 0002 0002 0002 0008 |]
    uint32_t const ces_non_ignorable[13] = { 0x202C, 0x1CAD, 0x0000, 0x0020, 0x002B, 0x0024, 0x0020, 0x0000, 0x0002, 0x0002, 0x0002, 0x0008, 0x0000 };

    auto const non_ignorable = collate_for_tests(
        cps, cps + 2, boost::text::variable_weighting::non_ignorable);

    EXPECT_EQ(non_ignorable.size(), 13);
    EXPECT_TRUE(boost::algorithm::equal(non_ignorable.begin(), non_ignorable.end(), ces_non_ignorable, ces_non_ignorable + 13))
        << "from:     " << ce_dumper(cps)
        << "expected: " << ce_dumper(ces_non_ignorable)
        << "got:      " << ce_dumper(non_ignorable);

    // 1FD3 0041;	
    // (ΐ) GREEK SMALL LETTER IOTA WITH DIALYTIKA AND OXIA	[202C 1CAD | 0020 002B 0024 0020 | 0002 0002 0002 0008 | FFFF FFFF FFFF FFFF |]
    uint32_t const ces_shifted[18] = { 0x202C, 0x1CAD, 0x0000, 0x0020, 0x002B, 0x0024, 0x0020, 0x0000, 0x0002, 0x0002, 0x0002, 0x0008, 0x0000, 0xFFFF, 0xFFFF, 0xFFFF, 0xFFFF, 0x0000 };

    auto const shifted = collate_for_tests(
        cps, cps + 2, boost::text::variable_weighting::shifted);

    EXPECT_EQ(shifted.size(), 18);
    EXPECT_TRUE(boost::algorithm::equal(shifted.begin(), shifted.end(), ces_shifted, ces_shifted + 18))
        << "from:     " << ce_dumper(cps)
        << "expected: " << ce_dumper(ces_shifted)
        << "got:      " << ce_dumper(shifted);
}

TEST(collation, verbatim_131_204)
{
    uint32_t const cps[2] = { 0x1FD2, 0x0061 };

    // 1FD2 0061;	
    // (ῒ) GREEK SMALL LETTER IOTA WITH DIALYTIKA AND VARIA	[202C 1CAD | 0020 002B 0025 0020 | 0002 0002 0002 0002 |]
    uint32_t const ces_non_ignorable[13] = { 0x202C, 0x1CAD, 0x0000, 0x0020, 0x002B, 0x0025, 0x0020, 0x0000, 0x0002, 0x0002, 0x0002, 0x0002, 0x0000 };

    auto const non_ignorable = collate_for_tests(
        cps, cps + 2, boost::text::variable_weighting::non_ignorable);

    EXPECT_EQ(non_ignorable.size(), 13);
    EXPECT_TRUE(boost::algorithm::equal(non_ignorable.begin(), non_ignorable.end(), ces_non_ignorable, ces_non_ignorable + 13))
        << "from:     " << ce_dumper(cps)
        << "expected: " << ce_dumper(ces_non_ignorable)
        << "got:      " << ce_dumper(non_ignorable);

    // 1FD2 0061;	
    // (ῒ) GREEK SMALL LETTER IOTA WITH DIALYTIKA AND VARIA	[202C 1CAD | 0020 002B 0025 0020 | 0002 0002 0002 0002 | FFFF FFFF FFFF FFFF |]
    uint32_t const ces_shifted[18] = { 0x202C, 0x1CAD, 0x0000, 0x0020, 0x002B, 0x0025, 0x0020, 0x0000, 0x0002, 0x0002, 0x0002, 0x0002, 0x0000, 0xFFFF, 0xFFFF, 0xFFFF, 0xFFFF, 0x0000 };

    auto const shifted = collate_for_tests(
        cps, cps + 2, boost::text::variable_weighting::shifted);

    EXPECT_EQ(shifted.size(), 18);
    EXPECT_TRUE(boost::algorithm::equal(shifted.begin(), shifted.end(), ces_shifted, ces_shifted + 18))
        << "from:     " << ce_dumper(cps)
        << "expected: " << ce_dumper(ces_shifted)
        << "got:      " << ce_dumper(shifted);
}

TEST(collation, verbatim_131_205)
{
    uint32_t const cps[2] = { 0x1FD2, 0x0041 };

    // 1FD2 0041;	
    // (ῒ) GREEK SMALL LETTER IOTA WITH DIALYTIKA AND VARIA	[202C 1CAD | 0020 002B 0025 0020 | 0002 0002 0002 0008 |]
    uint32_t const ces_non_ignorable[13] = { 0x202C, 0x1CAD, 0x0000, 0x0020, 0x002B, 0x0025, 0x0020, 0x0000, 0x0002, 0x0002, 0x0002, 0x0008, 0x0000 };

    auto const non_ignorable = collate_for_tests(
        cps, cps + 2, boost::text::variable_weighting::non_ignorable);

    EXPECT_EQ(non_ignorable.size(), 13);
    EXPECT_TRUE(boost::algorithm::equal(non_ignorable.begin(), non_ignorable.end(), ces_non_ignorable, ces_non_ignorable + 13))
        << "from:     " << ce_dumper(cps)
        << "expected: " << ce_dumper(ces_non_ignorable)
        << "got:      " << ce_dumper(non_ignorable);

    // 1FD2 0041;	
    // (ῒ) GREEK SMALL LETTER IOTA WITH DIALYTIKA AND VARIA	[202C 1CAD | 0020 002B 0025 0020 | 0002 0002 0002 0008 | FFFF FFFF FFFF FFFF |]
    uint32_t const ces_shifted[18] = { 0x202C, 0x1CAD, 0x0000, 0x0020, 0x002B, 0x0025, 0x0020, 0x0000, 0x0002, 0x0002, 0x0002, 0x0008, 0x0000, 0xFFFF, 0xFFFF, 0xFFFF, 0xFFFF, 0x0000 };

    auto const shifted = collate_for_tests(
        cps, cps + 2, boost::text::variable_weighting::shifted);

    EXPECT_EQ(shifted.size(), 18);
    EXPECT_TRUE(boost::algorithm::equal(shifted.begin(), shifted.end(), ces_shifted, ces_shifted + 18))
        << "from:     " << ce_dumper(cps)
        << "expected: " << ce_dumper(ces_shifted)
        << "got:      " << ce_dumper(shifted);
}

TEST(collation, verbatim_131_206)
{
    uint32_t const cps[2] = { 0x1FD7, 0x0061 };

    // 1FD7 0061;	
    // (ῗ) GREEK SMALL LETTER IOTA WITH DIALYTIKA AND PERISPOMENI	[202C 1CAD | 0020 002B 002A 0020 | 0002 0002 0002 0002 |]
    uint32_t const ces_non_ignorable[13] = { 0x202C, 0x1CAD, 0x0000, 0x0020, 0x002B, 0x002A, 0x0020, 0x0000, 0x0002, 0x0002, 0x0002, 0x0002, 0x0000 };

    auto const non_ignorable = collate_for_tests(
        cps, cps + 2, boost::text::variable_weighting::non_ignorable);

    EXPECT_EQ(non_ignorable.size(), 13);
    EXPECT_TRUE(boost::algorithm::equal(non_ignorable.begin(), non_ignorable.end(), ces_non_ignorable, ces_non_ignorable + 13))
        << "from:     " << ce_dumper(cps)
        << "expected: " << ce_dumper(ces_non_ignorable)
        << "got:      " << ce_dumper(non_ignorable);

    // 1FD7 0061;	
    // (ῗ) GREEK SMALL LETTER IOTA WITH DIALYTIKA AND PERISPOMENI	[202C 1CAD | 0020 002B 002A 0020 | 0002 0002 0002 0002 | FFFF FFFF FFFF FFFF |]
    uint32_t const ces_shifted[18] = { 0x202C, 0x1CAD, 0x0000, 0x0020, 0x002B, 0x002A, 0x0020, 0x0000, 0x0002, 0x0002, 0x0002, 0x0002, 0x0000, 0xFFFF, 0xFFFF, 0xFFFF, 0xFFFF, 0x0000 };

    auto const shifted = collate_for_tests(
        cps, cps + 2, boost::text::variable_weighting::shifted);

    EXPECT_EQ(shifted.size(), 18);
    EXPECT_TRUE(boost::algorithm::equal(shifted.begin(), shifted.end(), ces_shifted, ces_shifted + 18))
        << "from:     " << ce_dumper(cps)
        << "expected: " << ce_dumper(ces_shifted)
        << "got:      " << ce_dumper(shifted);
}

TEST(collation, verbatim_131_207)
{
    uint32_t const cps[2] = { 0x1FD7, 0x0041 };

    // 1FD7 0041;	
    // (ῗ) GREEK SMALL LETTER IOTA WITH DIALYTIKA AND PERISPOMENI	[202C 1CAD | 0020 002B 002A 0020 | 0002 0002 0002 0008 |]
    uint32_t const ces_non_ignorable[13] = { 0x202C, 0x1CAD, 0x0000, 0x0020, 0x002B, 0x002A, 0x0020, 0x0000, 0x0002, 0x0002, 0x0002, 0x0008, 0x0000 };

    auto const non_ignorable = collate_for_tests(
        cps, cps + 2, boost::text::variable_weighting::non_ignorable);

    EXPECT_EQ(non_ignorable.size(), 13);
    EXPECT_TRUE(boost::algorithm::equal(non_ignorable.begin(), non_ignorable.end(), ces_non_ignorable, ces_non_ignorable + 13))
        << "from:     " << ce_dumper(cps)
        << "expected: " << ce_dumper(ces_non_ignorable)
        << "got:      " << ce_dumper(non_ignorable);

    // 1FD7 0041;	
    // (ῗ) GREEK SMALL LETTER IOTA WITH DIALYTIKA AND PERISPOMENI	[202C 1CAD | 0020 002B 002A 0020 | 0002 0002 0002 0008 | FFFF FFFF FFFF FFFF |]
    uint32_t const ces_shifted[18] = { 0x202C, 0x1CAD, 0x0000, 0x0020, 0x002B, 0x002A, 0x0020, 0x0000, 0x0002, 0x0002, 0x0002, 0x0008, 0x0000, 0xFFFF, 0xFFFF, 0xFFFF, 0xFFFF, 0x0000 };

    auto const shifted = collate_for_tests(
        cps, cps + 2, boost::text::variable_weighting::shifted);

    EXPECT_EQ(shifted.size(), 18);
    EXPECT_TRUE(boost::algorithm::equal(shifted.begin(), shifted.end(), ces_shifted, ces_shifted + 18))
        << "from:     " << ce_dumper(cps)
        << "expected: " << ce_dumper(ces_shifted)
        << "got:      " << ce_dumper(shifted);
}

TEST(collation, verbatim_131_208)
{
    uint32_t const cps[2] = { 0x1FD1, 0x0061 };

    // 1FD1 0061;	
    // (ῑ) GREEK SMALL LETTER IOTA WITH MACRON	[202C 1CAD | 0020 0032 0020 | 0002 0002 0002 |]
    uint32_t const ces_non_ignorable[11] = { 0x202C, 0x1CAD, 0x0000, 0x0020, 0x0032, 0x0020, 0x0000, 0x0002, 0x0002, 0x0002, 0x0000 };

    auto const non_ignorable = collate_for_tests(
        cps, cps + 2, boost::text::variable_weighting::non_ignorable);

    EXPECT_EQ(non_ignorable.size(), 11);
    EXPECT_TRUE(boost::algorithm::equal(non_ignorable.begin(), non_ignorable.end(), ces_non_ignorable, ces_non_ignorable + 11))
        << "from:     " << ce_dumper(cps)
        << "expected: " << ce_dumper(ces_non_ignorable)
        << "got:      " << ce_dumper(non_ignorable);

    // 1FD1 0061;	
    // (ῑ) GREEK SMALL LETTER IOTA WITH MACRON	[202C 1CAD | 0020 0032 0020 | 0002 0002 0002 | FFFF FFFF FFFF |]
    uint32_t const ces_shifted[15] = { 0x202C, 0x1CAD, 0x0000, 0x0020, 0x0032, 0x0020, 0x0000, 0x0002, 0x0002, 0x0002, 0x0000, 0xFFFF, 0xFFFF, 0xFFFF, 0x0000 };

    auto const shifted = collate_for_tests(
        cps, cps + 2, boost::text::variable_weighting::shifted);

    EXPECT_EQ(shifted.size(), 15);
    EXPECT_TRUE(boost::algorithm::equal(shifted.begin(), shifted.end(), ces_shifted, ces_shifted + 15))
        << "from:     " << ce_dumper(cps)
        << "expected: " << ce_dumper(ces_shifted)
        << "got:      " << ce_dumper(shifted);
}

TEST(collation, verbatim_131_209)
{
    uint32_t const cps[2] = { 0x1FD1, 0x0041 };

    // 1FD1 0041;	
    // (ῑ) GREEK SMALL LETTER IOTA WITH MACRON	[202C 1CAD | 0020 0032 0020 | 0002 0002 0008 |]
    uint32_t const ces_non_ignorable[11] = { 0x202C, 0x1CAD, 0x0000, 0x0020, 0x0032, 0x0020, 0x0000, 0x0002, 0x0002, 0x0008, 0x0000 };

    auto const non_ignorable = collate_for_tests(
        cps, cps + 2, boost::text::variable_weighting::non_ignorable);

    EXPECT_EQ(non_ignorable.size(), 11);
    EXPECT_TRUE(boost::algorithm::equal(non_ignorable.begin(), non_ignorable.end(), ces_non_ignorable, ces_non_ignorable + 11))
        << "from:     " << ce_dumper(cps)
        << "expected: " << ce_dumper(ces_non_ignorable)
        << "got:      " << ce_dumper(non_ignorable);

    // 1FD1 0041;	
    // (ῑ) GREEK SMALL LETTER IOTA WITH MACRON	[202C 1CAD | 0020 0032 0020 | 0002 0002 0008 | FFFF FFFF FFFF |]
    uint32_t const ces_shifted[15] = { 0x202C, 0x1CAD, 0x0000, 0x0020, 0x0032, 0x0020, 0x0000, 0x0002, 0x0002, 0x0008, 0x0000, 0xFFFF, 0xFFFF, 0xFFFF, 0x0000 };

    auto const shifted = collate_for_tests(
        cps, cps + 2, boost::text::variable_weighting::shifted);

    EXPECT_EQ(shifted.size(), 15);
    EXPECT_TRUE(boost::algorithm::equal(shifted.begin(), shifted.end(), ces_shifted, ces_shifted + 15))
        << "from:     " << ce_dumper(cps)
        << "expected: " << ce_dumper(ces_shifted)
        << "got:      " << ce_dumper(shifted);
}

TEST(collation, verbatim_131_210)
{
    uint32_t const cps[2] = { 0x1FD9, 0x0061 };

    // 1FD9 0061;	
    // (Ῑ) GREEK CAPITAL LETTER IOTA WITH MACRON	[202C 1CAD | 0020 0032 0020 | 0008 0002 0002 |]
    uint32_t const ces_non_ignorable[11] = { 0x202C, 0x1CAD, 0x0000, 0x0020, 0x0032, 0x0020, 0x0000, 0x0008, 0x0002, 0x0002, 0x0000 };

    auto const non_ignorable = collate_for_tests(
        cps, cps + 2, boost::text::variable_weighting::non_ignorable);

    EXPECT_EQ(non_ignorable.size(), 11);
    EXPECT_TRUE(boost::algorithm::equal(non_ignorable.begin(), non_ignorable.end(), ces_non_ignorable, ces_non_ignorable + 11))
        << "from:     " << ce_dumper(cps)
        << "expected: " << ce_dumper(ces_non_ignorable)
        << "got:      " << ce_dumper(non_ignorable);

    // 1FD9 0061;	
    // (Ῑ) GREEK CAPITAL LETTER IOTA WITH MACRON	[202C 1CAD | 0020 0032 0020 | 0008 0002 0002 | FFFF FFFF FFFF |]
    uint32_t const ces_shifted[15] = { 0x202C, 0x1CAD, 0x0000, 0x0020, 0x0032, 0x0020, 0x0000, 0x0008, 0x0002, 0x0002, 0x0000, 0xFFFF, 0xFFFF, 0xFFFF, 0x0000 };

    auto const shifted = collate_for_tests(
        cps, cps + 2, boost::text::variable_weighting::shifted);

    EXPECT_EQ(shifted.size(), 15);
    EXPECT_TRUE(boost::algorithm::equal(shifted.begin(), shifted.end(), ces_shifted, ces_shifted + 15))
        << "from:     " << ce_dumper(cps)
        << "expected: " << ce_dumper(ces_shifted)
        << "got:      " << ce_dumper(shifted);
}

TEST(collation, verbatim_131_211)
{
    uint32_t const cps[2] = { 0x1FD9, 0x0041 };

    // 1FD9 0041;	
    // (Ῑ) GREEK CAPITAL LETTER IOTA WITH MACRON	[202C 1CAD | 0020 0032 0020 | 0008 0002 0008 |]
    uint32_t const ces_non_ignorable[11] = { 0x202C, 0x1CAD, 0x0000, 0x0020, 0x0032, 0x0020, 0x0000, 0x0008, 0x0002, 0x0008, 0x0000 };

    auto const non_ignorable = collate_for_tests(
        cps, cps + 2, boost::text::variable_weighting::non_ignorable);

    EXPECT_EQ(non_ignorable.size(), 11);
    EXPECT_TRUE(boost::algorithm::equal(non_ignorable.begin(), non_ignorable.end(), ces_non_ignorable, ces_non_ignorable + 11))
        << "from:     " << ce_dumper(cps)
        << "expected: " << ce_dumper(ces_non_ignorable)
        << "got:      " << ce_dumper(non_ignorable);

    // 1FD9 0041;	
    // (Ῑ) GREEK CAPITAL LETTER IOTA WITH MACRON	[202C 1CAD | 0020 0032 0020 | 0008 0002 0008 | FFFF FFFF FFFF |]
    uint32_t const ces_shifted[15] = { 0x202C, 0x1CAD, 0x0000, 0x0020, 0x0032, 0x0020, 0x0000, 0x0008, 0x0002, 0x0008, 0x0000, 0xFFFF, 0xFFFF, 0xFFFF, 0x0000 };

    auto const shifted = collate_for_tests(
        cps, cps + 2, boost::text::variable_weighting::shifted);

    EXPECT_EQ(shifted.size(), 15);
    EXPECT_TRUE(boost::algorithm::equal(shifted.begin(), shifted.end(), ces_shifted, ces_shifted + 15))
        << "from:     " << ce_dumper(cps)
        << "expected: " << ce_dumper(ces_shifted)
        << "got:      " << ce_dumper(shifted);
}

TEST(collation, verbatim_131_212)
{
    uint32_t const cps[2] = { 0x03B9, 0x0062 };

    // 03B9 0062;	
    // (ι) GREEK SMALL LETTER IOTA	[202C 1CC6 | 0020 0020 | 0002 0002 |]
    uint32_t const ces_non_ignorable[9] = { 0x202C, 0x1CC6, 0x0000, 0x0020, 0x0020, 0x0000, 0x0002, 0x0002, 0x0000 };

    auto const non_ignorable = collate_for_tests(
        cps, cps + 2, boost::text::variable_weighting::non_ignorable);

    EXPECT_EQ(non_ignorable.size(), 9);
    EXPECT_TRUE(boost::algorithm::equal(non_ignorable.begin(), non_ignorable.end(), ces_non_ignorable, ces_non_ignorable + 9))
        << "from:     " << ce_dumper(cps)
        << "expected: " << ce_dumper(ces_non_ignorable)
        << "got:      " << ce_dumper(non_ignorable);

    // 03B9 0062;	
    // (ι) GREEK SMALL LETTER IOTA	[202C 1CC6 | 0020 0020 | 0002 0002 | FFFF FFFF |]
    uint32_t const ces_shifted[12] = { 0x202C, 0x1CC6, 0x0000, 0x0020, 0x0020, 0x0000, 0x0002, 0x0002, 0x0000, 0xFFFF, 0xFFFF, 0x0000 };

    auto const shifted = collate_for_tests(
        cps, cps + 2, boost::text::variable_weighting::shifted);

    EXPECT_EQ(shifted.size(), 12);
    EXPECT_TRUE(boost::algorithm::equal(shifted.begin(), shifted.end(), ces_shifted, ces_shifted + 12))
        << "from:     " << ce_dumper(cps)
        << "expected: " << ce_dumper(ces_shifted)
        << "got:      " << ce_dumper(shifted);
}

TEST(collation, verbatim_131_213)
{
    uint32_t const cps[2] = { 0x1FBE, 0x0062 };

    // 1FBE 0062;	
    // (ι) GREEK PROSGEGRAMMENI	[202C 1CC6 | 0020 0020 | 0002 0002 |]
    uint32_t const ces_non_ignorable[9] = { 0x202C, 0x1CC6, 0x0000, 0x0020, 0x0020, 0x0000, 0x0002, 0x0002, 0x0000 };

    auto const non_ignorable = collate_for_tests(
        cps, cps + 2, boost::text::variable_weighting::non_ignorable);

    EXPECT_EQ(non_ignorable.size(), 9);
    EXPECT_TRUE(boost::algorithm::equal(non_ignorable.begin(), non_ignorable.end(), ces_non_ignorable, ces_non_ignorable + 9))
        << "from:     " << ce_dumper(cps)
        << "expected: " << ce_dumper(ces_non_ignorable)
        << "got:      " << ce_dumper(non_ignorable);

    // 1FBE 0062;	
    // (ι) GREEK PROSGEGRAMMENI	[202C 1CC6 | 0020 0020 | 0002 0002 | FFFF FFFF |]
    uint32_t const ces_shifted[12] = { 0x202C, 0x1CC6, 0x0000, 0x0020, 0x0020, 0x0000, 0x0002, 0x0002, 0x0000, 0xFFFF, 0xFFFF, 0x0000 };

    auto const shifted = collate_for_tests(
        cps, cps + 2, boost::text::variable_weighting::shifted);

    EXPECT_EQ(shifted.size(), 12);
    EXPECT_TRUE(boost::algorithm::equal(shifted.begin(), shifted.end(), ces_shifted, ces_shifted + 12))
        << "from:     " << ce_dumper(cps)
        << "expected: " << ce_dumper(ces_shifted)
        << "got:      " << ce_dumper(shifted);
}

TEST(collation, verbatim_131_214)
{
    uint32_t const cps[2] = { 0x037A, 0x0062 };

    // 037A 0062;	
    // (ͺ) GREEK YPOGEGRAMMENI	[202C 1CC6 | 0020 0020 | 0004 0002 |]
    uint32_t const ces_non_ignorable[9] = { 0x202C, 0x1CC6, 0x0000, 0x0020, 0x0020, 0x0000, 0x0004, 0x0002, 0x0000 };

    auto const non_ignorable = collate_for_tests(
        cps, cps + 2, boost::text::variable_weighting::non_ignorable);

    EXPECT_EQ(non_ignorable.size(), 9);
    EXPECT_TRUE(boost::algorithm::equal(non_ignorable.begin(), non_ignorable.end(), ces_non_ignorable, ces_non_ignorable + 9))
        << "from:     " << ce_dumper(cps)
        << "expected: " << ce_dumper(ces_non_ignorable)
        << "got:      " << ce_dumper(non_ignorable);

    // 037A 0062;	
    // (ͺ) GREEK YPOGEGRAMMENI	[202C 1CC6 | 0020 0020 | 0004 0002 | FFFF FFFF |]
    uint32_t const ces_shifted[12] = { 0x202C, 0x1CC6, 0x0000, 0x0020, 0x0020, 0x0000, 0x0004, 0x0002, 0x0000, 0xFFFF, 0xFFFF, 0x0000 };

    auto const shifted = collate_for_tests(
        cps, cps + 2, boost::text::variable_weighting::shifted);

    EXPECT_EQ(shifted.size(), 12);
    EXPECT_TRUE(boost::algorithm::equal(shifted.begin(), shifted.end(), ces_shifted, ces_shifted + 12))
        << "from:     " << ce_dumper(cps)
        << "expected: " << ce_dumper(ces_shifted)
        << "got:      " << ce_dumper(shifted);
}

TEST(collation, verbatim_131_215)
{
    uint32_t const cps[2] = { 0x1D6CA, 0x0062 };

    // 1D6CA 0062;	
    // (𝛊) MATHEMATICAL BOLD SMALL IOTA	[202C 1CC6 | 0020 0020 | 0005 0002 |]
    uint32_t const ces_non_ignorable[9] = { 0x202C, 0x1CC6, 0x0000, 0x0020, 0x0020, 0x0000, 0x0005, 0x0002, 0x0000 };

    auto const non_ignorable = collate_for_tests(
        cps, cps + 2, boost::text::variable_weighting::non_ignorable);

    EXPECT_EQ(non_ignorable.size(), 9);
    EXPECT_TRUE(boost::algorithm::equal(non_ignorable.begin(), non_ignorable.end(), ces_non_ignorable, ces_non_ignorable + 9))
        << "from:     " << ce_dumper(cps)
        << "expected: " << ce_dumper(ces_non_ignorable)
        << "got:      " << ce_dumper(non_ignorable);

    // 1D6CA 0062;	
    // (𝛊) MATHEMATICAL BOLD SMALL IOTA	[202C 1CC6 | 0020 0020 | 0005 0002 | FFFF FFFF |]
    uint32_t const ces_shifted[12] = { 0x202C, 0x1CC6, 0x0000, 0x0020, 0x0020, 0x0000, 0x0005, 0x0002, 0x0000, 0xFFFF, 0xFFFF, 0x0000 };

    auto const shifted = collate_for_tests(
        cps, cps + 2, boost::text::variable_weighting::shifted);

    EXPECT_EQ(shifted.size(), 12);
    EXPECT_TRUE(boost::algorithm::equal(shifted.begin(), shifted.end(), ces_shifted, ces_shifted + 12))
        << "from:     " << ce_dumper(cps)
        << "expected: " << ce_dumper(ces_shifted)
        << "got:      " << ce_dumper(shifted);
}

TEST(collation, verbatim_131_216)
{
    uint32_t const cps[2] = { 0x1D704, 0x0062 };

    // 1D704 0062;	
    // (𝜄) MATHEMATICAL ITALIC SMALL IOTA	[202C 1CC6 | 0020 0020 | 0005 0002 |]
    uint32_t const ces_non_ignorable[9] = { 0x202C, 0x1CC6, 0x0000, 0x0020, 0x0020, 0x0000, 0x0005, 0x0002, 0x0000 };

    auto const non_ignorable = collate_for_tests(
        cps, cps + 2, boost::text::variable_weighting::non_ignorable);

    EXPECT_EQ(non_ignorable.size(), 9);
    EXPECT_TRUE(boost::algorithm::equal(non_ignorable.begin(), non_ignorable.end(), ces_non_ignorable, ces_non_ignorable + 9))
        << "from:     " << ce_dumper(cps)
        << "expected: " << ce_dumper(ces_non_ignorable)
        << "got:      " << ce_dumper(non_ignorable);

    // 1D704 0062;	
    // (𝜄) MATHEMATICAL ITALIC SMALL IOTA	[202C 1CC6 | 0020 0020 | 0005 0002 | FFFF FFFF |]
    uint32_t const ces_shifted[12] = { 0x202C, 0x1CC6, 0x0000, 0x0020, 0x0020, 0x0000, 0x0005, 0x0002, 0x0000, 0xFFFF, 0xFFFF, 0x0000 };

    auto const shifted = collate_for_tests(
        cps, cps + 2, boost::text::variable_weighting::shifted);

    EXPECT_EQ(shifted.size(), 12);
    EXPECT_TRUE(boost::algorithm::equal(shifted.begin(), shifted.end(), ces_shifted, ces_shifted + 12))
        << "from:     " << ce_dumper(cps)
        << "expected: " << ce_dumper(ces_shifted)
        << "got:      " << ce_dumper(shifted);
}

TEST(collation, verbatim_131_217)
{
    uint32_t const cps[2] = { 0x1D73E, 0x0062 };

    // 1D73E 0062;	
    // (𝜾) MATHEMATICAL BOLD ITALIC SMALL IOTA	[202C 1CC6 | 0020 0020 | 0005 0002 |]
    uint32_t const ces_non_ignorable[9] = { 0x202C, 0x1CC6, 0x0000, 0x0020, 0x0020, 0x0000, 0x0005, 0x0002, 0x0000 };

    auto const non_ignorable = collate_for_tests(
        cps, cps + 2, boost::text::variable_weighting::non_ignorable);

    EXPECT_EQ(non_ignorable.size(), 9);
    EXPECT_TRUE(boost::algorithm::equal(non_ignorable.begin(), non_ignorable.end(), ces_non_ignorable, ces_non_ignorable + 9))
        << "from:     " << ce_dumper(cps)
        << "expected: " << ce_dumper(ces_non_ignorable)
        << "got:      " << ce_dumper(non_ignorable);

    // 1D73E 0062;	
    // (𝜾) MATHEMATICAL BOLD ITALIC SMALL IOTA	[202C 1CC6 | 0020 0020 | 0005 0002 | FFFF FFFF |]
    uint32_t const ces_shifted[12] = { 0x202C, 0x1CC6, 0x0000, 0x0020, 0x0020, 0x0000, 0x0005, 0x0002, 0x0000, 0xFFFF, 0xFFFF, 0x0000 };

    auto const shifted = collate_for_tests(
        cps, cps + 2, boost::text::variable_weighting::shifted);

    EXPECT_EQ(shifted.size(), 12);
    EXPECT_TRUE(boost::algorithm::equal(shifted.begin(), shifted.end(), ces_shifted, ces_shifted + 12))
        << "from:     " << ce_dumper(cps)
        << "expected: " << ce_dumper(ces_shifted)
        << "got:      " << ce_dumper(shifted);
}

TEST(collation, verbatim_131_218)
{
    uint32_t const cps[2] = { 0x1D778, 0x0062 };

    // 1D778 0062;	
    // (𝝸) MATHEMATICAL SANS-SERIF BOLD SMALL IOTA	[202C 1CC6 | 0020 0020 | 0005 0002 |]
    uint32_t const ces_non_ignorable[9] = { 0x202C, 0x1CC6, 0x0000, 0x0020, 0x0020, 0x0000, 0x0005, 0x0002, 0x0000 };

    auto const non_ignorable = collate_for_tests(
        cps, cps + 2, boost::text::variable_weighting::non_ignorable);

    EXPECT_EQ(non_ignorable.size(), 9);
    EXPECT_TRUE(boost::algorithm::equal(non_ignorable.begin(), non_ignorable.end(), ces_non_ignorable, ces_non_ignorable + 9))
        << "from:     " << ce_dumper(cps)
        << "expected: " << ce_dumper(ces_non_ignorable)
        << "got:      " << ce_dumper(non_ignorable);

    // 1D778 0062;	
    // (𝝸) MATHEMATICAL SANS-SERIF BOLD SMALL IOTA	[202C 1CC6 | 0020 0020 | 0005 0002 | FFFF FFFF |]
    uint32_t const ces_shifted[12] = { 0x202C, 0x1CC6, 0x0000, 0x0020, 0x0020, 0x0000, 0x0005, 0x0002, 0x0000, 0xFFFF, 0xFFFF, 0x0000 };

    auto const shifted = collate_for_tests(
        cps, cps + 2, boost::text::variable_weighting::shifted);

    EXPECT_EQ(shifted.size(), 12);
    EXPECT_TRUE(boost::algorithm::equal(shifted.begin(), shifted.end(), ces_shifted, ces_shifted + 12))
        << "from:     " << ce_dumper(cps)
        << "expected: " << ce_dumper(ces_shifted)
        << "got:      " << ce_dumper(shifted);
}

TEST(collation, verbatim_131_219)
{
    uint32_t const cps[2] = { 0x1D7B2, 0x0062 };

    // 1D7B2 0062;	
    // (𝞲) MATHEMATICAL SANS-SERIF BOLD ITALIC SMALL IOTA	[202C 1CC6 | 0020 0020 | 0005 0002 |]
    uint32_t const ces_non_ignorable[9] = { 0x202C, 0x1CC6, 0x0000, 0x0020, 0x0020, 0x0000, 0x0005, 0x0002, 0x0000 };

    auto const non_ignorable = collate_for_tests(
        cps, cps + 2, boost::text::variable_weighting::non_ignorable);

    EXPECT_EQ(non_ignorable.size(), 9);
    EXPECT_TRUE(boost::algorithm::equal(non_ignorable.begin(), non_ignorable.end(), ces_non_ignorable, ces_non_ignorable + 9))
        << "from:     " << ce_dumper(cps)
        << "expected: " << ce_dumper(ces_non_ignorable)
        << "got:      " << ce_dumper(non_ignorable);

    // 1D7B2 0062;	
    // (𝞲) MATHEMATICAL SANS-SERIF BOLD ITALIC SMALL IOTA	[202C 1CC6 | 0020 0020 | 0005 0002 | FFFF FFFF |]
    uint32_t const ces_shifted[12] = { 0x202C, 0x1CC6, 0x0000, 0x0020, 0x0020, 0x0000, 0x0005, 0x0002, 0x0000, 0xFFFF, 0xFFFF, 0x0000 };

    auto const shifted = collate_for_tests(
        cps, cps + 2, boost::text::variable_weighting::shifted);

    EXPECT_EQ(shifted.size(), 12);
    EXPECT_TRUE(boost::algorithm::equal(shifted.begin(), shifted.end(), ces_shifted, ces_shifted + 12))
        << "from:     " << ce_dumper(cps)
        << "expected: " << ce_dumper(ces_shifted)
        << "got:      " << ce_dumper(shifted);
}

TEST(collation, verbatim_131_220)
{
    uint32_t const cps[2] = { 0x0399, 0x0062 };

    // 0399 0062;	
    // (Ι) GREEK CAPITAL LETTER IOTA	[202C 1CC6 | 0020 0020 | 0008 0002 |]
    uint32_t const ces_non_ignorable[9] = { 0x202C, 0x1CC6, 0x0000, 0x0020, 0x0020, 0x0000, 0x0008, 0x0002, 0x0000 };

    auto const non_ignorable = collate_for_tests(
        cps, cps + 2, boost::text::variable_weighting::non_ignorable);

    EXPECT_EQ(non_ignorable.size(), 9);
    EXPECT_TRUE(boost::algorithm::equal(non_ignorable.begin(), non_ignorable.end(), ces_non_ignorable, ces_non_ignorable + 9))
        << "from:     " << ce_dumper(cps)
        << "expected: " << ce_dumper(ces_non_ignorable)
        << "got:      " << ce_dumper(non_ignorable);

    // 0399 0062;	
    // (Ι) GREEK CAPITAL LETTER IOTA	[202C 1CC6 | 0020 0020 | 0008 0002 | FFFF FFFF |]
    uint32_t const ces_shifted[12] = { 0x202C, 0x1CC6, 0x0000, 0x0020, 0x0020, 0x0000, 0x0008, 0x0002, 0x0000, 0xFFFF, 0xFFFF, 0x0000 };

    auto const shifted = collate_for_tests(
        cps, cps + 2, boost::text::variable_weighting::shifted);

    EXPECT_EQ(shifted.size(), 12);
    EXPECT_TRUE(boost::algorithm::equal(shifted.begin(), shifted.end(), ces_shifted, ces_shifted + 12))
        << "from:     " << ce_dumper(cps)
        << "expected: " << ce_dumper(ces_shifted)
        << "got:      " << ce_dumper(shifted);
}

TEST(collation, verbatim_131_221)
{
    uint32_t const cps[2] = { 0x1D6B0, 0x0062 };

    // 1D6B0 0062;	
    // (𝚰) MATHEMATICAL BOLD CAPITAL IOTA	[202C 1CC6 | 0020 0020 | 000B 0002 |]
    uint32_t const ces_non_ignorable[9] = { 0x202C, 0x1CC6, 0x0000, 0x0020, 0x0020, 0x0000, 0x000B, 0x0002, 0x0000 };

    auto const non_ignorable = collate_for_tests(
        cps, cps + 2, boost::text::variable_weighting::non_ignorable);

    EXPECT_EQ(non_ignorable.size(), 9);
    EXPECT_TRUE(boost::algorithm::equal(non_ignorable.begin(), non_ignorable.end(), ces_non_ignorable, ces_non_ignorable + 9))
        << "from:     " << ce_dumper(cps)
        << "expected: " << ce_dumper(ces_non_ignorable)
        << "got:      " << ce_dumper(non_ignorable);

    // 1D6B0 0062;	
    // (𝚰) MATHEMATICAL BOLD CAPITAL IOTA	[202C 1CC6 | 0020 0020 | 000B 0002 | FFFF FFFF |]
    uint32_t const ces_shifted[12] = { 0x202C, 0x1CC6, 0x0000, 0x0020, 0x0020, 0x0000, 0x000B, 0x0002, 0x0000, 0xFFFF, 0xFFFF, 0x0000 };

    auto const shifted = collate_for_tests(
        cps, cps + 2, boost::text::variable_weighting::shifted);

    EXPECT_EQ(shifted.size(), 12);
    EXPECT_TRUE(boost::algorithm::equal(shifted.begin(), shifted.end(), ces_shifted, ces_shifted + 12))
        << "from:     " << ce_dumper(cps)
        << "expected: " << ce_dumper(ces_shifted)
        << "got:      " << ce_dumper(shifted);
}

TEST(collation, verbatim_131_222)
{
    uint32_t const cps[2] = { 0x1D6EA, 0x0062 };

    // 1D6EA 0062;	
    // (𝛪) MATHEMATICAL ITALIC CAPITAL IOTA	[202C 1CC6 | 0020 0020 | 000B 0002 |]
    uint32_t const ces_non_ignorable[9] = { 0x202C, 0x1CC6, 0x0000, 0x0020, 0x0020, 0x0000, 0x000B, 0x0002, 0x0000 };

    auto const non_ignorable = collate_for_tests(
        cps, cps + 2, boost::text::variable_weighting::non_ignorable);

    EXPECT_EQ(non_ignorable.size(), 9);
    EXPECT_TRUE(boost::algorithm::equal(non_ignorable.begin(), non_ignorable.end(), ces_non_ignorable, ces_non_ignorable + 9))
        << "from:     " << ce_dumper(cps)
        << "expected: " << ce_dumper(ces_non_ignorable)
        << "got:      " << ce_dumper(non_ignorable);

    // 1D6EA 0062;	
    // (𝛪) MATHEMATICAL ITALIC CAPITAL IOTA	[202C 1CC6 | 0020 0020 | 000B 0002 | FFFF FFFF |]
    uint32_t const ces_shifted[12] = { 0x202C, 0x1CC6, 0x0000, 0x0020, 0x0020, 0x0000, 0x000B, 0x0002, 0x0000, 0xFFFF, 0xFFFF, 0x0000 };

    auto const shifted = collate_for_tests(
        cps, cps + 2, boost::text::variable_weighting::shifted);

    EXPECT_EQ(shifted.size(), 12);
    EXPECT_TRUE(boost::algorithm::equal(shifted.begin(), shifted.end(), ces_shifted, ces_shifted + 12))
        << "from:     " << ce_dumper(cps)
        << "expected: " << ce_dumper(ces_shifted)
        << "got:      " << ce_dumper(shifted);
}

TEST(collation, verbatim_131_223)
{
    uint32_t const cps[2] = { 0x1D724, 0x0062 };

    // 1D724 0062;	
    // (𝜤) MATHEMATICAL BOLD ITALIC CAPITAL IOTA	[202C 1CC6 | 0020 0020 | 000B 0002 |]
    uint32_t const ces_non_ignorable[9] = { 0x202C, 0x1CC6, 0x0000, 0x0020, 0x0020, 0x0000, 0x000B, 0x0002, 0x0000 };

    auto const non_ignorable = collate_for_tests(
        cps, cps + 2, boost::text::variable_weighting::non_ignorable);

    EXPECT_EQ(non_ignorable.size(), 9);
    EXPECT_TRUE(boost::algorithm::equal(non_ignorable.begin(), non_ignorable.end(), ces_non_ignorable, ces_non_ignorable + 9))
        << "from:     " << ce_dumper(cps)
        << "expected: " << ce_dumper(ces_non_ignorable)
        << "got:      " << ce_dumper(non_ignorable);

    // 1D724 0062;	
    // (𝜤) MATHEMATICAL BOLD ITALIC CAPITAL IOTA	[202C 1CC6 | 0020 0020 | 000B 0002 | FFFF FFFF |]
    uint32_t const ces_shifted[12] = { 0x202C, 0x1CC6, 0x0000, 0x0020, 0x0020, 0x0000, 0x000B, 0x0002, 0x0000, 0xFFFF, 0xFFFF, 0x0000 };

    auto const shifted = collate_for_tests(
        cps, cps + 2, boost::text::variable_weighting::shifted);

    EXPECT_EQ(shifted.size(), 12);
    EXPECT_TRUE(boost::algorithm::equal(shifted.begin(), shifted.end(), ces_shifted, ces_shifted + 12))
        << "from:     " << ce_dumper(cps)
        << "expected: " << ce_dumper(ces_shifted)
        << "got:      " << ce_dumper(shifted);
}

TEST(collation, verbatim_131_224)
{
    uint32_t const cps[2] = { 0x1D75E, 0x0062 };

    // 1D75E 0062;	
    // (𝝞) MATHEMATICAL SANS-SERIF BOLD CAPITAL IOTA	[202C 1CC6 | 0020 0020 | 000B 0002 |]
    uint32_t const ces_non_ignorable[9] = { 0x202C, 0x1CC6, 0x0000, 0x0020, 0x0020, 0x0000, 0x000B, 0x0002, 0x0000 };

    auto const non_ignorable = collate_for_tests(
        cps, cps + 2, boost::text::variable_weighting::non_ignorable);

    EXPECT_EQ(non_ignorable.size(), 9);
    EXPECT_TRUE(boost::algorithm::equal(non_ignorable.begin(), non_ignorable.end(), ces_non_ignorable, ces_non_ignorable + 9))
        << "from:     " << ce_dumper(cps)
        << "expected: " << ce_dumper(ces_non_ignorable)
        << "got:      " << ce_dumper(non_ignorable);

    // 1D75E 0062;	
    // (𝝞) MATHEMATICAL SANS-SERIF BOLD CAPITAL IOTA	[202C 1CC6 | 0020 0020 | 000B 0002 | FFFF FFFF |]
    uint32_t const ces_shifted[12] = { 0x202C, 0x1CC6, 0x0000, 0x0020, 0x0020, 0x0000, 0x000B, 0x0002, 0x0000, 0xFFFF, 0xFFFF, 0x0000 };

    auto const shifted = collate_for_tests(
        cps, cps + 2, boost::text::variable_weighting::shifted);

    EXPECT_EQ(shifted.size(), 12);
    EXPECT_TRUE(boost::algorithm::equal(shifted.begin(), shifted.end(), ces_shifted, ces_shifted + 12))
        << "from:     " << ce_dumper(cps)
        << "expected: " << ce_dumper(ces_shifted)
        << "got:      " << ce_dumper(shifted);
}

TEST(collation, verbatim_131_225)
{
    uint32_t const cps[2] = { 0x1D798, 0x0062 };

    // 1D798 0062;	
    // (𝞘) MATHEMATICAL SANS-SERIF BOLD ITALIC CAPITAL IOTA	[202C 1CC6 | 0020 0020 | 000B 0002 |]
    uint32_t const ces_non_ignorable[9] = { 0x202C, 0x1CC6, 0x0000, 0x0020, 0x0020, 0x0000, 0x000B, 0x0002, 0x0000 };

    auto const non_ignorable = collate_for_tests(
        cps, cps + 2, boost::text::variable_weighting::non_ignorable);

    EXPECT_EQ(non_ignorable.size(), 9);
    EXPECT_TRUE(boost::algorithm::equal(non_ignorable.begin(), non_ignorable.end(), ces_non_ignorable, ces_non_ignorable + 9))
        << "from:     " << ce_dumper(cps)
        << "expected: " << ce_dumper(ces_non_ignorable)
        << "got:      " << ce_dumper(non_ignorable);

    // 1D798 0062;	
    // (𝞘) MATHEMATICAL SANS-SERIF BOLD ITALIC CAPITAL IOTA	[202C 1CC6 | 0020 0020 | 000B 0002 | FFFF FFFF |]
    uint32_t const ces_shifted[12] = { 0x202C, 0x1CC6, 0x0000, 0x0020, 0x0020, 0x0000, 0x000B, 0x0002, 0x0000, 0xFFFF, 0xFFFF, 0x0000 };

    auto const shifted = collate_for_tests(
        cps, cps + 2, boost::text::variable_weighting::shifted);

    EXPECT_EQ(shifted.size(), 12);
    EXPECT_TRUE(boost::algorithm::equal(shifted.begin(), shifted.end(), ces_shifted, ces_shifted + 12))
        << "from:     " << ce_dumper(cps)
        << "expected: " << ce_dumper(ces_shifted)
        << "got:      " << ce_dumper(shifted);
}

TEST(collation, verbatim_131_226)
{
    uint32_t const cps[2] = { 0x1F30, 0x0062 };

    // 1F30 0062;	
    // (ἰ) GREEK SMALL LETTER IOTA WITH PSILI	[202C 1CC6 | 0020 0022 0020 | 0002 0002 0002 |]
    uint32_t const ces_non_ignorable[11] = { 0x202C, 0x1CC6, 0x0000, 0x0020, 0x0022, 0x0020, 0x0000, 0x0002, 0x0002, 0x0002, 0x0000 };

    auto const non_ignorable = collate_for_tests(
        cps, cps + 2, boost::text::variable_weighting::non_ignorable);

    EXPECT_EQ(non_ignorable.size(), 11);
    EXPECT_TRUE(boost::algorithm::equal(non_ignorable.begin(), non_ignorable.end(), ces_non_ignorable, ces_non_ignorable + 11))
        << "from:     " << ce_dumper(cps)
        << "expected: " << ce_dumper(ces_non_ignorable)
        << "got:      " << ce_dumper(non_ignorable);

    // 1F30 0062;	
    // (ἰ) GREEK SMALL LETTER IOTA WITH PSILI	[202C 1CC6 | 0020 0022 0020 | 0002 0002 0002 | FFFF FFFF FFFF |]
    uint32_t const ces_shifted[15] = { 0x202C, 0x1CC6, 0x0000, 0x0020, 0x0022, 0x0020, 0x0000, 0x0002, 0x0002, 0x0002, 0x0000, 0xFFFF, 0xFFFF, 0xFFFF, 0x0000 };

    auto const shifted = collate_for_tests(
        cps, cps + 2, boost::text::variable_weighting::shifted);

    EXPECT_EQ(shifted.size(), 15);
    EXPECT_TRUE(boost::algorithm::equal(shifted.begin(), shifted.end(), ces_shifted, ces_shifted + 15))
        << "from:     " << ce_dumper(cps)
        << "expected: " << ce_dumper(ces_shifted)
        << "got:      " << ce_dumper(shifted);
}

TEST(collation, verbatim_131_227)
{
    uint32_t const cps[2] = { 0x1F38, 0x0062 };

    // 1F38 0062;	
    // (Ἰ) GREEK CAPITAL LETTER IOTA WITH PSILI	[202C 1CC6 | 0020 0022 0020 | 0008 0002 0002 |]
    uint32_t const ces_non_ignorable[11] = { 0x202C, 0x1CC6, 0x0000, 0x0020, 0x0022, 0x0020, 0x0000, 0x0008, 0x0002, 0x0002, 0x0000 };

    auto const non_ignorable = collate_for_tests(
        cps, cps + 2, boost::text::variable_weighting::non_ignorable);

    EXPECT_EQ(non_ignorable.size(), 11);
    EXPECT_TRUE(boost::algorithm::equal(non_ignorable.begin(), non_ignorable.end(), ces_non_ignorable, ces_non_ignorable + 11))
        << "from:     " << ce_dumper(cps)
        << "expected: " << ce_dumper(ces_non_ignorable)
        << "got:      " << ce_dumper(non_ignorable);

    // 1F38 0062;	
    // (Ἰ) GREEK CAPITAL LETTER IOTA WITH PSILI	[202C 1CC6 | 0020 0022 0020 | 0008 0002 0002 | FFFF FFFF FFFF |]
    uint32_t const ces_shifted[15] = { 0x202C, 0x1CC6, 0x0000, 0x0020, 0x0022, 0x0020, 0x0000, 0x0008, 0x0002, 0x0002, 0x0000, 0xFFFF, 0xFFFF, 0xFFFF, 0x0000 };

    auto const shifted = collate_for_tests(
        cps, cps + 2, boost::text::variable_weighting::shifted);

    EXPECT_EQ(shifted.size(), 15);
    EXPECT_TRUE(boost::algorithm::equal(shifted.begin(), shifted.end(), ces_shifted, ces_shifted + 15))
        << "from:     " << ce_dumper(cps)
        << "expected: " << ce_dumper(ces_shifted)
        << "got:      " << ce_dumper(shifted);
}

TEST(collation, verbatim_131_228)
{
    uint32_t const cps[2] = { 0x1F34, 0x0062 };

    // 1F34 0062;	
    // (ἴ) GREEK SMALL LETTER IOTA WITH PSILI AND OXIA	[202C 1CC6 | 0020 0022 0024 0020 | 0002 0002 0002 0002 |]
    uint32_t const ces_non_ignorable[13] = { 0x202C, 0x1CC6, 0x0000, 0x0020, 0x0022, 0x0024, 0x0020, 0x0000, 0x0002, 0x0002, 0x0002, 0x0002, 0x0000 };

    auto const non_ignorable = collate_for_tests(
        cps, cps + 2, boost::text::variable_weighting::non_ignorable);

    EXPECT_EQ(non_ignorable.size(), 13);
    EXPECT_TRUE(boost::algorithm::equal(non_ignorable.begin(), non_ignorable.end(), ces_non_ignorable, ces_non_ignorable + 13))
        << "from:     " << ce_dumper(cps)
        << "expected: " << ce_dumper(ces_non_ignorable)
        << "got:      " << ce_dumper(non_ignorable);

    // 1F34 0062;	
    // (ἴ) GREEK SMALL LETTER IOTA WITH PSILI AND OXIA	[202C 1CC6 | 0020 0022 0024 0020 | 0002 0002 0002 0002 | FFFF FFFF FFFF FFFF |]
    uint32_t const ces_shifted[18] = { 0x202C, 0x1CC6, 0x0000, 0x0020, 0x0022, 0x0024, 0x0020, 0x0000, 0x0002, 0x0002, 0x0002, 0x0002, 0x0000, 0xFFFF, 0xFFFF, 0xFFFF, 0xFFFF, 0x0000 };

    auto const shifted = collate_for_tests(
        cps, cps + 2, boost::text::variable_weighting::shifted);

    EXPECT_EQ(shifted.size(), 18);
    EXPECT_TRUE(boost::algorithm::equal(shifted.begin(), shifted.end(), ces_shifted, ces_shifted + 18))
        << "from:     " << ce_dumper(cps)
        << "expected: " << ce_dumper(ces_shifted)
        << "got:      " << ce_dumper(shifted);
}

TEST(collation, verbatim_131_229)
{
    uint32_t const cps[2] = { 0x1F3C, 0x0062 };

    // 1F3C 0062;	
    // (Ἴ) GREEK CAPITAL LETTER IOTA WITH PSILI AND OXIA	[202C 1CC6 | 0020 0022 0024 0020 | 0008 0002 0002 0002 |]
    uint32_t const ces_non_ignorable[13] = { 0x202C, 0x1CC6, 0x0000, 0x0020, 0x0022, 0x0024, 0x0020, 0x0000, 0x0008, 0x0002, 0x0002, 0x0002, 0x0000 };

    auto const non_ignorable = collate_for_tests(
        cps, cps + 2, boost::text::variable_weighting::non_ignorable);

    EXPECT_EQ(non_ignorable.size(), 13);
    EXPECT_TRUE(boost::algorithm::equal(non_ignorable.begin(), non_ignorable.end(), ces_non_ignorable, ces_non_ignorable + 13))
        << "from:     " << ce_dumper(cps)
        << "expected: " << ce_dumper(ces_non_ignorable)
        << "got:      " << ce_dumper(non_ignorable);

    // 1F3C 0062;	
    // (Ἴ) GREEK CAPITAL LETTER IOTA WITH PSILI AND OXIA	[202C 1CC6 | 0020 0022 0024 0020 | 0008 0002 0002 0002 | FFFF FFFF FFFF FFFF |]
    uint32_t const ces_shifted[18] = { 0x202C, 0x1CC6, 0x0000, 0x0020, 0x0022, 0x0024, 0x0020, 0x0000, 0x0008, 0x0002, 0x0002, 0x0002, 0x0000, 0xFFFF, 0xFFFF, 0xFFFF, 0xFFFF, 0x0000 };

    auto const shifted = collate_for_tests(
        cps, cps + 2, boost::text::variable_weighting::shifted);

    EXPECT_EQ(shifted.size(), 18);
    EXPECT_TRUE(boost::algorithm::equal(shifted.begin(), shifted.end(), ces_shifted, ces_shifted + 18))
        << "from:     " << ce_dumper(cps)
        << "expected: " << ce_dumper(ces_shifted)
        << "got:      " << ce_dumper(shifted);
}

TEST(collation, verbatim_131_230)
{
    uint32_t const cps[2] = { 0x1F32, 0x0062 };

    // 1F32 0062;	
    // (ἲ) GREEK SMALL LETTER IOTA WITH PSILI AND VARIA	[202C 1CC6 | 0020 0022 0025 0020 | 0002 0002 0002 0002 |]
    uint32_t const ces_non_ignorable[13] = { 0x202C, 0x1CC6, 0x0000, 0x0020, 0x0022, 0x0025, 0x0020, 0x0000, 0x0002, 0x0002, 0x0002, 0x0002, 0x0000 };

    auto const non_ignorable = collate_for_tests(
        cps, cps + 2, boost::text::variable_weighting::non_ignorable);

    EXPECT_EQ(non_ignorable.size(), 13);
    EXPECT_TRUE(boost::algorithm::equal(non_ignorable.begin(), non_ignorable.end(), ces_non_ignorable, ces_non_ignorable + 13))
        << "from:     " << ce_dumper(cps)
        << "expected: " << ce_dumper(ces_non_ignorable)
        << "got:      " << ce_dumper(non_ignorable);

    // 1F32 0062;	
    // (ἲ) GREEK SMALL LETTER IOTA WITH PSILI AND VARIA	[202C 1CC6 | 0020 0022 0025 0020 | 0002 0002 0002 0002 | FFFF FFFF FFFF FFFF |]
    uint32_t const ces_shifted[18] = { 0x202C, 0x1CC6, 0x0000, 0x0020, 0x0022, 0x0025, 0x0020, 0x0000, 0x0002, 0x0002, 0x0002, 0x0002, 0x0000, 0xFFFF, 0xFFFF, 0xFFFF, 0xFFFF, 0x0000 };

    auto const shifted = collate_for_tests(
        cps, cps + 2, boost::text::variable_weighting::shifted);

    EXPECT_EQ(shifted.size(), 18);
    EXPECT_TRUE(boost::algorithm::equal(shifted.begin(), shifted.end(), ces_shifted, ces_shifted + 18))
        << "from:     " << ce_dumper(cps)
        << "expected: " << ce_dumper(ces_shifted)
        << "got:      " << ce_dumper(shifted);
}

TEST(collation, verbatim_131_231)
{
    uint32_t const cps[2] = { 0x1F3A, 0x0062 };

    // 1F3A 0062;	
    // (Ἲ) GREEK CAPITAL LETTER IOTA WITH PSILI AND VARIA	[202C 1CC6 | 0020 0022 0025 0020 | 0008 0002 0002 0002 |]
    uint32_t const ces_non_ignorable[13] = { 0x202C, 0x1CC6, 0x0000, 0x0020, 0x0022, 0x0025, 0x0020, 0x0000, 0x0008, 0x0002, 0x0002, 0x0002, 0x0000 };

    auto const non_ignorable = collate_for_tests(
        cps, cps + 2, boost::text::variable_weighting::non_ignorable);

    EXPECT_EQ(non_ignorable.size(), 13);
    EXPECT_TRUE(boost::algorithm::equal(non_ignorable.begin(), non_ignorable.end(), ces_non_ignorable, ces_non_ignorable + 13))
        << "from:     " << ce_dumper(cps)
        << "expected: " << ce_dumper(ces_non_ignorable)
        << "got:      " << ce_dumper(non_ignorable);

    // 1F3A 0062;	
    // (Ἲ) GREEK CAPITAL LETTER IOTA WITH PSILI AND VARIA	[202C 1CC6 | 0020 0022 0025 0020 | 0008 0002 0002 0002 | FFFF FFFF FFFF FFFF |]
    uint32_t const ces_shifted[18] = { 0x202C, 0x1CC6, 0x0000, 0x0020, 0x0022, 0x0025, 0x0020, 0x0000, 0x0008, 0x0002, 0x0002, 0x0002, 0x0000, 0xFFFF, 0xFFFF, 0xFFFF, 0xFFFF, 0x0000 };

    auto const shifted = collate_for_tests(
        cps, cps + 2, boost::text::variable_weighting::shifted);

    EXPECT_EQ(shifted.size(), 18);
    EXPECT_TRUE(boost::algorithm::equal(shifted.begin(), shifted.end(), ces_shifted, ces_shifted + 18))
        << "from:     " << ce_dumper(cps)
        << "expected: " << ce_dumper(ces_shifted)
        << "got:      " << ce_dumper(shifted);
}

TEST(collation, verbatim_131_232)
{
    uint32_t const cps[2] = { 0x1F36, 0x0062 };

    // 1F36 0062;	
    // (ἶ) GREEK SMALL LETTER IOTA WITH PSILI AND PERISPOMENI	[202C 1CC6 | 0020 0022 002A 0020 | 0002 0002 0002 0002 |]
    uint32_t const ces_non_ignorable[13] = { 0x202C, 0x1CC6, 0x0000, 0x0020, 0x0022, 0x002A, 0x0020, 0x0000, 0x0002, 0x0002, 0x0002, 0x0002, 0x0000 };

    auto const non_ignorable = collate_for_tests(
        cps, cps + 2, boost::text::variable_weighting::non_ignorable);

    EXPECT_EQ(non_ignorable.size(), 13);
    EXPECT_TRUE(boost::algorithm::equal(non_ignorable.begin(), non_ignorable.end(), ces_non_ignorable, ces_non_ignorable + 13))
        << "from:     " << ce_dumper(cps)
        << "expected: " << ce_dumper(ces_non_ignorable)
        << "got:      " << ce_dumper(non_ignorable);

    // 1F36 0062;	
    // (ἶ) GREEK SMALL LETTER IOTA WITH PSILI AND PERISPOMENI	[202C 1CC6 | 0020 0022 002A 0020 | 0002 0002 0002 0002 | FFFF FFFF FFFF FFFF |]
    uint32_t const ces_shifted[18] = { 0x202C, 0x1CC6, 0x0000, 0x0020, 0x0022, 0x002A, 0x0020, 0x0000, 0x0002, 0x0002, 0x0002, 0x0002, 0x0000, 0xFFFF, 0xFFFF, 0xFFFF, 0xFFFF, 0x0000 };

    auto const shifted = collate_for_tests(
        cps, cps + 2, boost::text::variable_weighting::shifted);

    EXPECT_EQ(shifted.size(), 18);
    EXPECT_TRUE(boost::algorithm::equal(shifted.begin(), shifted.end(), ces_shifted, ces_shifted + 18))
        << "from:     " << ce_dumper(cps)
        << "expected: " << ce_dumper(ces_shifted)
        << "got:      " << ce_dumper(shifted);
}

TEST(collation, verbatim_131_233)
{
    uint32_t const cps[2] = { 0x1F3E, 0x0062 };

    // 1F3E 0062;	
    // (Ἶ) GREEK CAPITAL LETTER IOTA WITH PSILI AND PERISPOMENI	[202C 1CC6 | 0020 0022 002A 0020 | 0008 0002 0002 0002 |]
    uint32_t const ces_non_ignorable[13] = { 0x202C, 0x1CC6, 0x0000, 0x0020, 0x0022, 0x002A, 0x0020, 0x0000, 0x0008, 0x0002, 0x0002, 0x0002, 0x0000 };

    auto const non_ignorable = collate_for_tests(
        cps, cps + 2, boost::text::variable_weighting::non_ignorable);

    EXPECT_EQ(non_ignorable.size(), 13);
    EXPECT_TRUE(boost::algorithm::equal(non_ignorable.begin(), non_ignorable.end(), ces_non_ignorable, ces_non_ignorable + 13))
        << "from:     " << ce_dumper(cps)
        << "expected: " << ce_dumper(ces_non_ignorable)
        << "got:      " << ce_dumper(non_ignorable);

    // 1F3E 0062;	
    // (Ἶ) GREEK CAPITAL LETTER IOTA WITH PSILI AND PERISPOMENI	[202C 1CC6 | 0020 0022 002A 0020 | 0008 0002 0002 0002 | FFFF FFFF FFFF FFFF |]
    uint32_t const ces_shifted[18] = { 0x202C, 0x1CC6, 0x0000, 0x0020, 0x0022, 0x002A, 0x0020, 0x0000, 0x0008, 0x0002, 0x0002, 0x0002, 0x0000, 0xFFFF, 0xFFFF, 0xFFFF, 0xFFFF, 0x0000 };

    auto const shifted = collate_for_tests(
        cps, cps + 2, boost::text::variable_weighting::shifted);

    EXPECT_EQ(shifted.size(), 18);
    EXPECT_TRUE(boost::algorithm::equal(shifted.begin(), shifted.end(), ces_shifted, ces_shifted + 18))
        << "from:     " << ce_dumper(cps)
        << "expected: " << ce_dumper(ces_shifted)
        << "got:      " << ce_dumper(shifted);
}

TEST(collation, verbatim_131_234)
{
    uint32_t const cps[2] = { 0x1F31, 0x0062 };

    // 1F31 0062;	
    // (ἱ) GREEK SMALL LETTER IOTA WITH DASIA	[202C 1CC6 | 0020 0023 0020 | 0002 0002 0002 |]
    uint32_t const ces_non_ignorable[11] = { 0x202C, 0x1CC6, 0x0000, 0x0020, 0x0023, 0x0020, 0x0000, 0x0002, 0x0002, 0x0002, 0x0000 };

    auto const non_ignorable = collate_for_tests(
        cps, cps + 2, boost::text::variable_weighting::non_ignorable);

    EXPECT_EQ(non_ignorable.size(), 11);
    EXPECT_TRUE(boost::algorithm::equal(non_ignorable.begin(), non_ignorable.end(), ces_non_ignorable, ces_non_ignorable + 11))
        << "from:     " << ce_dumper(cps)
        << "expected: " << ce_dumper(ces_non_ignorable)
        << "got:      " << ce_dumper(non_ignorable);

    // 1F31 0062;	
    // (ἱ) GREEK SMALL LETTER IOTA WITH DASIA	[202C 1CC6 | 0020 0023 0020 | 0002 0002 0002 | FFFF FFFF FFFF |]
    uint32_t const ces_shifted[15] = { 0x202C, 0x1CC6, 0x0000, 0x0020, 0x0023, 0x0020, 0x0000, 0x0002, 0x0002, 0x0002, 0x0000, 0xFFFF, 0xFFFF, 0xFFFF, 0x0000 };

    auto const shifted = collate_for_tests(
        cps, cps + 2, boost::text::variable_weighting::shifted);

    EXPECT_EQ(shifted.size(), 15);
    EXPECT_TRUE(boost::algorithm::equal(shifted.begin(), shifted.end(), ces_shifted, ces_shifted + 15))
        << "from:     " << ce_dumper(cps)
        << "expected: " << ce_dumper(ces_shifted)
        << "got:      " << ce_dumper(shifted);
}

TEST(collation, verbatim_131_235)
{
    uint32_t const cps[2] = { 0x1F39, 0x0062 };

    // 1F39 0062;	
    // (Ἱ) GREEK CAPITAL LETTER IOTA WITH DASIA	[202C 1CC6 | 0020 0023 0020 | 0008 0002 0002 |]
    uint32_t const ces_non_ignorable[11] = { 0x202C, 0x1CC6, 0x0000, 0x0020, 0x0023, 0x0020, 0x0000, 0x0008, 0x0002, 0x0002, 0x0000 };

    auto const non_ignorable = collate_for_tests(
        cps, cps + 2, boost::text::variable_weighting::non_ignorable);

    EXPECT_EQ(non_ignorable.size(), 11);
    EXPECT_TRUE(boost::algorithm::equal(non_ignorable.begin(), non_ignorable.end(), ces_non_ignorable, ces_non_ignorable + 11))
        << "from:     " << ce_dumper(cps)
        << "expected: " << ce_dumper(ces_non_ignorable)
        << "got:      " << ce_dumper(non_ignorable);

    // 1F39 0062;	
    // (Ἱ) GREEK CAPITAL LETTER IOTA WITH DASIA	[202C 1CC6 | 0020 0023 0020 | 0008 0002 0002 | FFFF FFFF FFFF |]
    uint32_t const ces_shifted[15] = { 0x202C, 0x1CC6, 0x0000, 0x0020, 0x0023, 0x0020, 0x0000, 0x0008, 0x0002, 0x0002, 0x0000, 0xFFFF, 0xFFFF, 0xFFFF, 0x0000 };

    auto const shifted = collate_for_tests(
        cps, cps + 2, boost::text::variable_weighting::shifted);

    EXPECT_EQ(shifted.size(), 15);
    EXPECT_TRUE(boost::algorithm::equal(shifted.begin(), shifted.end(), ces_shifted, ces_shifted + 15))
        << "from:     " << ce_dumper(cps)
        << "expected: " << ce_dumper(ces_shifted)
        << "got:      " << ce_dumper(shifted);
}

TEST(collation, verbatim_131_236)
{
    uint32_t const cps[2] = { 0x1F35, 0x0062 };

    // 1F35 0062;	
    // (ἵ) GREEK SMALL LETTER IOTA WITH DASIA AND OXIA	[202C 1CC6 | 0020 0023 0024 0020 | 0002 0002 0002 0002 |]
    uint32_t const ces_non_ignorable[13] = { 0x202C, 0x1CC6, 0x0000, 0x0020, 0x0023, 0x0024, 0x0020, 0x0000, 0x0002, 0x0002, 0x0002, 0x0002, 0x0000 };

    auto const non_ignorable = collate_for_tests(
        cps, cps + 2, boost::text::variable_weighting::non_ignorable);

    EXPECT_EQ(non_ignorable.size(), 13);
    EXPECT_TRUE(boost::algorithm::equal(non_ignorable.begin(), non_ignorable.end(), ces_non_ignorable, ces_non_ignorable + 13))
        << "from:     " << ce_dumper(cps)
        << "expected: " << ce_dumper(ces_non_ignorable)
        << "got:      " << ce_dumper(non_ignorable);

    // 1F35 0062;	
    // (ἵ) GREEK SMALL LETTER IOTA WITH DASIA AND OXIA	[202C 1CC6 | 0020 0023 0024 0020 | 0002 0002 0002 0002 | FFFF FFFF FFFF FFFF |]
    uint32_t const ces_shifted[18] = { 0x202C, 0x1CC6, 0x0000, 0x0020, 0x0023, 0x0024, 0x0020, 0x0000, 0x0002, 0x0002, 0x0002, 0x0002, 0x0000, 0xFFFF, 0xFFFF, 0xFFFF, 0xFFFF, 0x0000 };

    auto const shifted = collate_for_tests(
        cps, cps + 2, boost::text::variable_weighting::shifted);

    EXPECT_EQ(shifted.size(), 18);
    EXPECT_TRUE(boost::algorithm::equal(shifted.begin(), shifted.end(), ces_shifted, ces_shifted + 18))
        << "from:     " << ce_dumper(cps)
        << "expected: " << ce_dumper(ces_shifted)
        << "got:      " << ce_dumper(shifted);
}

TEST(collation, verbatim_131_237)
{
    uint32_t const cps[2] = { 0x1F3D, 0x0062 };

    // 1F3D 0062;	
    // (Ἵ) GREEK CAPITAL LETTER IOTA WITH DASIA AND OXIA	[202C 1CC6 | 0020 0023 0024 0020 | 0008 0002 0002 0002 |]
    uint32_t const ces_non_ignorable[13] = { 0x202C, 0x1CC6, 0x0000, 0x0020, 0x0023, 0x0024, 0x0020, 0x0000, 0x0008, 0x0002, 0x0002, 0x0002, 0x0000 };

    auto const non_ignorable = collate_for_tests(
        cps, cps + 2, boost::text::variable_weighting::non_ignorable);

    EXPECT_EQ(non_ignorable.size(), 13);
    EXPECT_TRUE(boost::algorithm::equal(non_ignorable.begin(), non_ignorable.end(), ces_non_ignorable, ces_non_ignorable + 13))
        << "from:     " << ce_dumper(cps)
        << "expected: " << ce_dumper(ces_non_ignorable)
        << "got:      " << ce_dumper(non_ignorable);

    // 1F3D 0062;	
    // (Ἵ) GREEK CAPITAL LETTER IOTA WITH DASIA AND OXIA	[202C 1CC6 | 0020 0023 0024 0020 | 0008 0002 0002 0002 | FFFF FFFF FFFF FFFF |]
    uint32_t const ces_shifted[18] = { 0x202C, 0x1CC6, 0x0000, 0x0020, 0x0023, 0x0024, 0x0020, 0x0000, 0x0008, 0x0002, 0x0002, 0x0002, 0x0000, 0xFFFF, 0xFFFF, 0xFFFF, 0xFFFF, 0x0000 };

    auto const shifted = collate_for_tests(
        cps, cps + 2, boost::text::variable_weighting::shifted);

    EXPECT_EQ(shifted.size(), 18);
    EXPECT_TRUE(boost::algorithm::equal(shifted.begin(), shifted.end(), ces_shifted, ces_shifted + 18))
        << "from:     " << ce_dumper(cps)
        << "expected: " << ce_dumper(ces_shifted)
        << "got:      " << ce_dumper(shifted);
}

TEST(collation, verbatim_131_238)
{
    uint32_t const cps[2] = { 0x1F33, 0x0062 };

    // 1F33 0062;	
    // (ἳ) GREEK SMALL LETTER IOTA WITH DASIA AND VARIA	[202C 1CC6 | 0020 0023 0025 0020 | 0002 0002 0002 0002 |]
    uint32_t const ces_non_ignorable[13] = { 0x202C, 0x1CC6, 0x0000, 0x0020, 0x0023, 0x0025, 0x0020, 0x0000, 0x0002, 0x0002, 0x0002, 0x0002, 0x0000 };

    auto const non_ignorable = collate_for_tests(
        cps, cps + 2, boost::text::variable_weighting::non_ignorable);

    EXPECT_EQ(non_ignorable.size(), 13);
    EXPECT_TRUE(boost::algorithm::equal(non_ignorable.begin(), non_ignorable.end(), ces_non_ignorable, ces_non_ignorable + 13))
        << "from:     " << ce_dumper(cps)
        << "expected: " << ce_dumper(ces_non_ignorable)
        << "got:      " << ce_dumper(non_ignorable);

    // 1F33 0062;	
    // (ἳ) GREEK SMALL LETTER IOTA WITH DASIA AND VARIA	[202C 1CC6 | 0020 0023 0025 0020 | 0002 0002 0002 0002 | FFFF FFFF FFFF FFFF |]
    uint32_t const ces_shifted[18] = { 0x202C, 0x1CC6, 0x0000, 0x0020, 0x0023, 0x0025, 0x0020, 0x0000, 0x0002, 0x0002, 0x0002, 0x0002, 0x0000, 0xFFFF, 0xFFFF, 0xFFFF, 0xFFFF, 0x0000 };

    auto const shifted = collate_for_tests(
        cps, cps + 2, boost::text::variable_weighting::shifted);

    EXPECT_EQ(shifted.size(), 18);
    EXPECT_TRUE(boost::algorithm::equal(shifted.begin(), shifted.end(), ces_shifted, ces_shifted + 18))
        << "from:     " << ce_dumper(cps)
        << "expected: " << ce_dumper(ces_shifted)
        << "got:      " << ce_dumper(shifted);
}

TEST(collation, verbatim_131_239)
{
    uint32_t const cps[2] = { 0x1F3B, 0x0062 };

    // 1F3B 0062;	
    // (Ἳ) GREEK CAPITAL LETTER IOTA WITH DASIA AND VARIA	[202C 1CC6 | 0020 0023 0025 0020 | 0008 0002 0002 0002 |]
    uint32_t const ces_non_ignorable[13] = { 0x202C, 0x1CC6, 0x0000, 0x0020, 0x0023, 0x0025, 0x0020, 0x0000, 0x0008, 0x0002, 0x0002, 0x0002, 0x0000 };

    auto const non_ignorable = collate_for_tests(
        cps, cps + 2, boost::text::variable_weighting::non_ignorable);

    EXPECT_EQ(non_ignorable.size(), 13);
    EXPECT_TRUE(boost::algorithm::equal(non_ignorable.begin(), non_ignorable.end(), ces_non_ignorable, ces_non_ignorable + 13))
        << "from:     " << ce_dumper(cps)
        << "expected: " << ce_dumper(ces_non_ignorable)
        << "got:      " << ce_dumper(non_ignorable);

    // 1F3B 0062;	
    // (Ἳ) GREEK CAPITAL LETTER IOTA WITH DASIA AND VARIA	[202C 1CC6 | 0020 0023 0025 0020 | 0008 0002 0002 0002 | FFFF FFFF FFFF FFFF |]
    uint32_t const ces_shifted[18] = { 0x202C, 0x1CC6, 0x0000, 0x0020, 0x0023, 0x0025, 0x0020, 0x0000, 0x0008, 0x0002, 0x0002, 0x0002, 0x0000, 0xFFFF, 0xFFFF, 0xFFFF, 0xFFFF, 0x0000 };

    auto const shifted = collate_for_tests(
        cps, cps + 2, boost::text::variable_weighting::shifted);

    EXPECT_EQ(shifted.size(), 18);
    EXPECT_TRUE(boost::algorithm::equal(shifted.begin(), shifted.end(), ces_shifted, ces_shifted + 18))
        << "from:     " << ce_dumper(cps)
        << "expected: " << ce_dumper(ces_shifted)
        << "got:      " << ce_dumper(shifted);
}

TEST(collation, verbatim_131_240)
{
    uint32_t const cps[2] = { 0x1F37, 0x0062 };

    // 1F37 0062;	
    // (ἷ) GREEK SMALL LETTER IOTA WITH DASIA AND PERISPOMENI	[202C 1CC6 | 0020 0023 002A 0020 | 0002 0002 0002 0002 |]
    uint32_t const ces_non_ignorable[13] = { 0x202C, 0x1CC6, 0x0000, 0x0020, 0x0023, 0x002A, 0x0020, 0x0000, 0x0002, 0x0002, 0x0002, 0x0002, 0x0000 };

    auto const non_ignorable = collate_for_tests(
        cps, cps + 2, boost::text::variable_weighting::non_ignorable);

    EXPECT_EQ(non_ignorable.size(), 13);
    EXPECT_TRUE(boost::algorithm::equal(non_ignorable.begin(), non_ignorable.end(), ces_non_ignorable, ces_non_ignorable + 13))
        << "from:     " << ce_dumper(cps)
        << "expected: " << ce_dumper(ces_non_ignorable)
        << "got:      " << ce_dumper(non_ignorable);

    // 1F37 0062;	
    // (ἷ) GREEK SMALL LETTER IOTA WITH DASIA AND PERISPOMENI	[202C 1CC6 | 0020 0023 002A 0020 | 0002 0002 0002 0002 | FFFF FFFF FFFF FFFF |]
    uint32_t const ces_shifted[18] = { 0x202C, 0x1CC6, 0x0000, 0x0020, 0x0023, 0x002A, 0x0020, 0x0000, 0x0002, 0x0002, 0x0002, 0x0002, 0x0000, 0xFFFF, 0xFFFF, 0xFFFF, 0xFFFF, 0x0000 };

    auto const shifted = collate_for_tests(
        cps, cps + 2, boost::text::variable_weighting::shifted);

    EXPECT_EQ(shifted.size(), 18);
    EXPECT_TRUE(boost::algorithm::equal(shifted.begin(), shifted.end(), ces_shifted, ces_shifted + 18))
        << "from:     " << ce_dumper(cps)
        << "expected: " << ce_dumper(ces_shifted)
        << "got:      " << ce_dumper(shifted);
}

TEST(collation, verbatim_131_241)
{
    uint32_t const cps[2] = { 0x1F3F, 0x0062 };

    // 1F3F 0062;	
    // (Ἷ) GREEK CAPITAL LETTER IOTA WITH DASIA AND PERISPOMENI	[202C 1CC6 | 0020 0023 002A 0020 | 0008 0002 0002 0002 |]
    uint32_t const ces_non_ignorable[13] = { 0x202C, 0x1CC6, 0x0000, 0x0020, 0x0023, 0x002A, 0x0020, 0x0000, 0x0008, 0x0002, 0x0002, 0x0002, 0x0000 };

    auto const non_ignorable = collate_for_tests(
        cps, cps + 2, boost::text::variable_weighting::non_ignorable);

    EXPECT_EQ(non_ignorable.size(), 13);
    EXPECT_TRUE(boost::algorithm::equal(non_ignorable.begin(), non_ignorable.end(), ces_non_ignorable, ces_non_ignorable + 13))
        << "from:     " << ce_dumper(cps)
        << "expected: " << ce_dumper(ces_non_ignorable)
        << "got:      " << ce_dumper(non_ignorable);

    // 1F3F 0062;	
    // (Ἷ) GREEK CAPITAL LETTER IOTA WITH DASIA AND PERISPOMENI	[202C 1CC6 | 0020 0023 002A 0020 | 0008 0002 0002 0002 | FFFF FFFF FFFF FFFF |]
    uint32_t const ces_shifted[18] = { 0x202C, 0x1CC6, 0x0000, 0x0020, 0x0023, 0x002A, 0x0020, 0x0000, 0x0008, 0x0002, 0x0002, 0x0002, 0x0000, 0xFFFF, 0xFFFF, 0xFFFF, 0xFFFF, 0x0000 };

    auto const shifted = collate_for_tests(
        cps, cps + 2, boost::text::variable_weighting::shifted);

    EXPECT_EQ(shifted.size(), 18);
    EXPECT_TRUE(boost::algorithm::equal(shifted.begin(), shifted.end(), ces_shifted, ces_shifted + 18))
        << "from:     " << ce_dumper(cps)
        << "expected: " << ce_dumper(ces_shifted)
        << "got:      " << ce_dumper(shifted);
}

TEST(collation, verbatim_131_242)
{
    uint32_t const cps[2] = { 0x03AF, 0x0062 };

    // 03AF 0062;	
    // (ί) GREEK SMALL LETTER IOTA WITH TONOS	[202C 1CC6 | 0020 0024 0020 | 0002 0002 0002 |]
    uint32_t const ces_non_ignorable[11] = { 0x202C, 0x1CC6, 0x0000, 0x0020, 0x0024, 0x0020, 0x0000, 0x0002, 0x0002, 0x0002, 0x0000 };

    auto const non_ignorable = collate_for_tests(
        cps, cps + 2, boost::text::variable_weighting::non_ignorable);

    EXPECT_EQ(non_ignorable.size(), 11);
    EXPECT_TRUE(boost::algorithm::equal(non_ignorable.begin(), non_ignorable.end(), ces_non_ignorable, ces_non_ignorable + 11))
        << "from:     " << ce_dumper(cps)
        << "expected: " << ce_dumper(ces_non_ignorable)
        << "got:      " << ce_dumper(non_ignorable);

    // 03AF 0062;	
    // (ί) GREEK SMALL LETTER IOTA WITH TONOS	[202C 1CC6 | 0020 0024 0020 | 0002 0002 0002 | FFFF FFFF FFFF |]
    uint32_t const ces_shifted[15] = { 0x202C, 0x1CC6, 0x0000, 0x0020, 0x0024, 0x0020, 0x0000, 0x0002, 0x0002, 0x0002, 0x0000, 0xFFFF, 0xFFFF, 0xFFFF, 0x0000 };

    auto const shifted = collate_for_tests(
        cps, cps + 2, boost::text::variable_weighting::shifted);

    EXPECT_EQ(shifted.size(), 15);
    EXPECT_TRUE(boost::algorithm::equal(shifted.begin(), shifted.end(), ces_shifted, ces_shifted + 15))
        << "from:     " << ce_dumper(cps)
        << "expected: " << ce_dumper(ces_shifted)
        << "got:      " << ce_dumper(shifted);
}

TEST(collation, verbatim_131_243)
{
    uint32_t const cps[2] = { 0x1F77, 0x0062 };

    // 1F77 0062;	
    // (ί) GREEK SMALL LETTER IOTA WITH OXIA	[202C 1CC6 | 0020 0024 0020 | 0002 0002 0002 |]
    uint32_t const ces_non_ignorable[11] = { 0x202C, 0x1CC6, 0x0000, 0x0020, 0x0024, 0x0020, 0x0000, 0x0002, 0x0002, 0x0002, 0x0000 };

    auto const non_ignorable = collate_for_tests(
        cps, cps + 2, boost::text::variable_weighting::non_ignorable);

    EXPECT_EQ(non_ignorable.size(), 11);
    EXPECT_TRUE(boost::algorithm::equal(non_ignorable.begin(), non_ignorable.end(), ces_non_ignorable, ces_non_ignorable + 11))
        << "from:     " << ce_dumper(cps)
        << "expected: " << ce_dumper(ces_non_ignorable)
        << "got:      " << ce_dumper(non_ignorable);

    // 1F77 0062;	
    // (ί) GREEK SMALL LETTER IOTA WITH OXIA	[202C 1CC6 | 0020 0024 0020 | 0002 0002 0002 | FFFF FFFF FFFF |]
    uint32_t const ces_shifted[15] = { 0x202C, 0x1CC6, 0x0000, 0x0020, 0x0024, 0x0020, 0x0000, 0x0002, 0x0002, 0x0002, 0x0000, 0xFFFF, 0xFFFF, 0xFFFF, 0x0000 };

    auto const shifted = collate_for_tests(
        cps, cps + 2, boost::text::variable_weighting::shifted);

    EXPECT_EQ(shifted.size(), 15);
    EXPECT_TRUE(boost::algorithm::equal(shifted.begin(), shifted.end(), ces_shifted, ces_shifted + 15))
        << "from:     " << ce_dumper(cps)
        << "expected: " << ce_dumper(ces_shifted)
        << "got:      " << ce_dumper(shifted);
}

TEST(collation, verbatim_131_244)
{
    uint32_t const cps[2] = { 0x038A, 0x0062 };

    // 038A 0062;	
    // (Ί) GREEK CAPITAL LETTER IOTA WITH TONOS	[202C 1CC6 | 0020 0024 0020 | 0008 0002 0002 |]
    uint32_t const ces_non_ignorable[11] = { 0x202C, 0x1CC6, 0x0000, 0x0020, 0x0024, 0x0020, 0x0000, 0x0008, 0x0002, 0x0002, 0x0000 };

    auto const non_ignorable = collate_for_tests(
        cps, cps + 2, boost::text::variable_weighting::non_ignorable);

    EXPECT_EQ(non_ignorable.size(), 11);
    EXPECT_TRUE(boost::algorithm::equal(non_ignorable.begin(), non_ignorable.end(), ces_non_ignorable, ces_non_ignorable + 11))
        << "from:     " << ce_dumper(cps)
        << "expected: " << ce_dumper(ces_non_ignorable)
        << "got:      " << ce_dumper(non_ignorable);

    // 038A 0062;	
    // (Ί) GREEK CAPITAL LETTER IOTA WITH TONOS	[202C 1CC6 | 0020 0024 0020 | 0008 0002 0002 | FFFF FFFF FFFF |]
    uint32_t const ces_shifted[15] = { 0x202C, 0x1CC6, 0x0000, 0x0020, 0x0024, 0x0020, 0x0000, 0x0008, 0x0002, 0x0002, 0x0000, 0xFFFF, 0xFFFF, 0xFFFF, 0x0000 };

    auto const shifted = collate_for_tests(
        cps, cps + 2, boost::text::variable_weighting::shifted);

    EXPECT_EQ(shifted.size(), 15);
    EXPECT_TRUE(boost::algorithm::equal(shifted.begin(), shifted.end(), ces_shifted, ces_shifted + 15))
        << "from:     " << ce_dumper(cps)
        << "expected: " << ce_dumper(ces_shifted)
        << "got:      " << ce_dumper(shifted);
}

TEST(collation, verbatim_131_245)
{
    uint32_t const cps[2] = { 0x1FDB, 0x0062 };

    // 1FDB 0062;	
    // (Ί) GREEK CAPITAL LETTER IOTA WITH OXIA	[202C 1CC6 | 0020 0024 0020 | 0008 0002 0002 |]
    uint32_t const ces_non_ignorable[11] = { 0x202C, 0x1CC6, 0x0000, 0x0020, 0x0024, 0x0020, 0x0000, 0x0008, 0x0002, 0x0002, 0x0000 };

    auto const non_ignorable = collate_for_tests(
        cps, cps + 2, boost::text::variable_weighting::non_ignorable);

    EXPECT_EQ(non_ignorable.size(), 11);
    EXPECT_TRUE(boost::algorithm::equal(non_ignorable.begin(), non_ignorable.end(), ces_non_ignorable, ces_non_ignorable + 11))
        << "from:     " << ce_dumper(cps)
        << "expected: " << ce_dumper(ces_non_ignorable)
        << "got:      " << ce_dumper(non_ignorable);

    // 1FDB 0062;	
    // (Ί) GREEK CAPITAL LETTER IOTA WITH OXIA	[202C 1CC6 | 0020 0024 0020 | 0008 0002 0002 | FFFF FFFF FFFF |]
    uint32_t const ces_shifted[15] = { 0x202C, 0x1CC6, 0x0000, 0x0020, 0x0024, 0x0020, 0x0000, 0x0008, 0x0002, 0x0002, 0x0000, 0xFFFF, 0xFFFF, 0xFFFF, 0x0000 };

    auto const shifted = collate_for_tests(
        cps, cps + 2, boost::text::variable_weighting::shifted);

    EXPECT_EQ(shifted.size(), 15);
    EXPECT_TRUE(boost::algorithm::equal(shifted.begin(), shifted.end(), ces_shifted, ces_shifted + 15))
        << "from:     " << ce_dumper(cps)
        << "expected: " << ce_dumper(ces_shifted)
        << "got:      " << ce_dumper(shifted);
}

TEST(collation, verbatim_131_246)
{
    uint32_t const cps[2] = { 0x1F76, 0x0062 };

    // 1F76 0062;	
    // (ὶ) GREEK SMALL LETTER IOTA WITH VARIA	[202C 1CC6 | 0020 0025 0020 | 0002 0002 0002 |]
    uint32_t const ces_non_ignorable[11] = { 0x202C, 0x1CC6, 0x0000, 0x0020, 0x0025, 0x0020, 0x0000, 0x0002, 0x0002, 0x0002, 0x0000 };

    auto const non_ignorable = collate_for_tests(
        cps, cps + 2, boost::text::variable_weighting::non_ignorable);

    EXPECT_EQ(non_ignorable.size(), 11);
    EXPECT_TRUE(boost::algorithm::equal(non_ignorable.begin(), non_ignorable.end(), ces_non_ignorable, ces_non_ignorable + 11))
        << "from:     " << ce_dumper(cps)
        << "expected: " << ce_dumper(ces_non_ignorable)
        << "got:      " << ce_dumper(non_ignorable);

    // 1F76 0062;	
    // (ὶ) GREEK SMALL LETTER IOTA WITH VARIA	[202C 1CC6 | 0020 0025 0020 | 0002 0002 0002 | FFFF FFFF FFFF |]
    uint32_t const ces_shifted[15] = { 0x202C, 0x1CC6, 0x0000, 0x0020, 0x0025, 0x0020, 0x0000, 0x0002, 0x0002, 0x0002, 0x0000, 0xFFFF, 0xFFFF, 0xFFFF, 0x0000 };

    auto const shifted = collate_for_tests(
        cps, cps + 2, boost::text::variable_weighting::shifted);

    EXPECT_EQ(shifted.size(), 15);
    EXPECT_TRUE(boost::algorithm::equal(shifted.begin(), shifted.end(), ces_shifted, ces_shifted + 15))
        << "from:     " << ce_dumper(cps)
        << "expected: " << ce_dumper(ces_shifted)
        << "got:      " << ce_dumper(shifted);
}

TEST(collation, verbatim_131_247)
{
    uint32_t const cps[2] = { 0x1FDA, 0x0062 };

    // 1FDA 0062;	
    // (Ὶ) GREEK CAPITAL LETTER IOTA WITH VARIA	[202C 1CC6 | 0020 0025 0020 | 0008 0002 0002 |]
    uint32_t const ces_non_ignorable[11] = { 0x202C, 0x1CC6, 0x0000, 0x0020, 0x0025, 0x0020, 0x0000, 0x0008, 0x0002, 0x0002, 0x0000 };

    auto const non_ignorable = collate_for_tests(
        cps, cps + 2, boost::text::variable_weighting::non_ignorable);

    EXPECT_EQ(non_ignorable.size(), 11);
    EXPECT_TRUE(boost::algorithm::equal(non_ignorable.begin(), non_ignorable.end(), ces_non_ignorable, ces_non_ignorable + 11))
        << "from:     " << ce_dumper(cps)
        << "expected: " << ce_dumper(ces_non_ignorable)
        << "got:      " << ce_dumper(non_ignorable);

    // 1FDA 0062;	
    // (Ὶ) GREEK CAPITAL LETTER IOTA WITH VARIA	[202C 1CC6 | 0020 0025 0020 | 0008 0002 0002 | FFFF FFFF FFFF |]
    uint32_t const ces_shifted[15] = { 0x202C, 0x1CC6, 0x0000, 0x0020, 0x0025, 0x0020, 0x0000, 0x0008, 0x0002, 0x0002, 0x0000, 0xFFFF, 0xFFFF, 0xFFFF, 0x0000 };

    auto const shifted = collate_for_tests(
        cps, cps + 2, boost::text::variable_weighting::shifted);

    EXPECT_EQ(shifted.size(), 15);
    EXPECT_TRUE(boost::algorithm::equal(shifted.begin(), shifted.end(), ces_shifted, ces_shifted + 15))
        << "from:     " << ce_dumper(cps)
        << "expected: " << ce_dumper(ces_shifted)
        << "got:      " << ce_dumper(shifted);
}

TEST(collation, verbatim_131_248)
{
    uint32_t const cps[2] = { 0x1FD0, 0x0062 };

    // 1FD0 0062;	
    // (ῐ) GREEK SMALL LETTER IOTA WITH VRACHY	[202C 1CC6 | 0020 0026 0020 | 0002 0002 0002 |]
    uint32_t const ces_non_ignorable[11] = { 0x202C, 0x1CC6, 0x0000, 0x0020, 0x0026, 0x0020, 0x0000, 0x0002, 0x0002, 0x0002, 0x0000 };

    auto const non_ignorable = collate_for_tests(
        cps, cps + 2, boost::text::variable_weighting::non_ignorable);

    EXPECT_EQ(non_ignorable.size(), 11);
    EXPECT_TRUE(boost::algorithm::equal(non_ignorable.begin(), non_ignorable.end(), ces_non_ignorable, ces_non_ignorable + 11))
        << "from:     " << ce_dumper(cps)
        << "expected: " << ce_dumper(ces_non_ignorable)
        << "got:      " << ce_dumper(non_ignorable);

    // 1FD0 0062;	
    // (ῐ) GREEK SMALL LETTER IOTA WITH VRACHY	[202C 1CC6 | 0020 0026 0020 | 0002 0002 0002 | FFFF FFFF FFFF |]
    uint32_t const ces_shifted[15] = { 0x202C, 0x1CC6, 0x0000, 0x0020, 0x0026, 0x0020, 0x0000, 0x0002, 0x0002, 0x0002, 0x0000, 0xFFFF, 0xFFFF, 0xFFFF, 0x0000 };

    auto const shifted = collate_for_tests(
        cps, cps + 2, boost::text::variable_weighting::shifted);

    EXPECT_EQ(shifted.size(), 15);
    EXPECT_TRUE(boost::algorithm::equal(shifted.begin(), shifted.end(), ces_shifted, ces_shifted + 15))
        << "from:     " << ce_dumper(cps)
        << "expected: " << ce_dumper(ces_shifted)
        << "got:      " << ce_dumper(shifted);
}

TEST(collation, verbatim_131_249)
{
    uint32_t const cps[2] = { 0x1FD8, 0x0062 };

    // 1FD8 0062;	
    // (Ῐ) GREEK CAPITAL LETTER IOTA WITH VRACHY	[202C 1CC6 | 0020 0026 0020 | 0008 0002 0002 |]
    uint32_t const ces_non_ignorable[11] = { 0x202C, 0x1CC6, 0x0000, 0x0020, 0x0026, 0x0020, 0x0000, 0x0008, 0x0002, 0x0002, 0x0000 };

    auto const non_ignorable = collate_for_tests(
        cps, cps + 2, boost::text::variable_weighting::non_ignorable);

    EXPECT_EQ(non_ignorable.size(), 11);
    EXPECT_TRUE(boost::algorithm::equal(non_ignorable.begin(), non_ignorable.end(), ces_non_ignorable, ces_non_ignorable + 11))
        << "from:     " << ce_dumper(cps)
        << "expected: " << ce_dumper(ces_non_ignorable)
        << "got:      " << ce_dumper(non_ignorable);

    // 1FD8 0062;	
    // (Ῐ) GREEK CAPITAL LETTER IOTA WITH VRACHY	[202C 1CC6 | 0020 0026 0020 | 0008 0002 0002 | FFFF FFFF FFFF |]
    uint32_t const ces_shifted[15] = { 0x202C, 0x1CC6, 0x0000, 0x0020, 0x0026, 0x0020, 0x0000, 0x0008, 0x0002, 0x0002, 0x0000, 0xFFFF, 0xFFFF, 0xFFFF, 0x0000 };

    auto const shifted = collate_for_tests(
        cps, cps + 2, boost::text::variable_weighting::shifted);

    EXPECT_EQ(shifted.size(), 15);
    EXPECT_TRUE(boost::algorithm::equal(shifted.begin(), shifted.end(), ces_shifted, ces_shifted + 15))
        << "from:     " << ce_dumper(cps)
        << "expected: " << ce_dumper(ces_shifted)
        << "got:      " << ce_dumper(shifted);
}

TEST(collation, verbatim_131_250)
{
    uint32_t const cps[2] = { 0x1FD6, 0x0062 };

    // 1FD6 0062;	
    // (ῖ) GREEK SMALL LETTER IOTA WITH PERISPOMENI	[202C 1CC6 | 0020 002A 0020 | 0002 0002 0002 |]
    uint32_t const ces_non_ignorable[11] = { 0x202C, 0x1CC6, 0x0000, 0x0020, 0x002A, 0x0020, 0x0000, 0x0002, 0x0002, 0x0002, 0x0000 };

    auto const non_ignorable = collate_for_tests(
        cps, cps + 2, boost::text::variable_weighting::non_ignorable);

    EXPECT_EQ(non_ignorable.size(), 11);
    EXPECT_TRUE(boost::algorithm::equal(non_ignorable.begin(), non_ignorable.end(), ces_non_ignorable, ces_non_ignorable + 11))
        << "from:     " << ce_dumper(cps)
        << "expected: " << ce_dumper(ces_non_ignorable)
        << "got:      " << ce_dumper(non_ignorable);

    // 1FD6 0062;	
    // (ῖ) GREEK SMALL LETTER IOTA WITH PERISPOMENI	[202C 1CC6 | 0020 002A 0020 | 0002 0002 0002 | FFFF FFFF FFFF |]
    uint32_t const ces_shifted[15] = { 0x202C, 0x1CC6, 0x0000, 0x0020, 0x002A, 0x0020, 0x0000, 0x0002, 0x0002, 0x0002, 0x0000, 0xFFFF, 0xFFFF, 0xFFFF, 0x0000 };

    auto const shifted = collate_for_tests(
        cps, cps + 2, boost::text::variable_weighting::shifted);

    EXPECT_EQ(shifted.size(), 15);
    EXPECT_TRUE(boost::algorithm::equal(shifted.begin(), shifted.end(), ces_shifted, ces_shifted + 15))
        << "from:     " << ce_dumper(cps)
        << "expected: " << ce_dumper(ces_shifted)
        << "got:      " << ce_dumper(shifted);
}

TEST(collation, verbatim_131_251)
{
    uint32_t const cps[2] = { 0x03CA, 0x0062 };

    // 03CA 0062;	
    // (ϊ) GREEK SMALL LETTER IOTA WITH DIALYTIKA	[202C 1CC6 | 0020 002B 0020 | 0002 0002 0002 |]
    uint32_t const ces_non_ignorable[11] = { 0x202C, 0x1CC6, 0x0000, 0x0020, 0x002B, 0x0020, 0x0000, 0x0002, 0x0002, 0x0002, 0x0000 };

    auto const non_ignorable = collate_for_tests(
        cps, cps + 2, boost::text::variable_weighting::non_ignorable);

    EXPECT_EQ(non_ignorable.size(), 11);
    EXPECT_TRUE(boost::algorithm::equal(non_ignorable.begin(), non_ignorable.end(), ces_non_ignorable, ces_non_ignorable + 11))
        << "from:     " << ce_dumper(cps)
        << "expected: " << ce_dumper(ces_non_ignorable)
        << "got:      " << ce_dumper(non_ignorable);

    // 03CA 0062;	
    // (ϊ) GREEK SMALL LETTER IOTA WITH DIALYTIKA	[202C 1CC6 | 0020 002B 0020 | 0002 0002 0002 | FFFF FFFF FFFF |]
    uint32_t const ces_shifted[15] = { 0x202C, 0x1CC6, 0x0000, 0x0020, 0x002B, 0x0020, 0x0000, 0x0002, 0x0002, 0x0002, 0x0000, 0xFFFF, 0xFFFF, 0xFFFF, 0x0000 };

    auto const shifted = collate_for_tests(
        cps, cps + 2, boost::text::variable_weighting::shifted);

    EXPECT_EQ(shifted.size(), 15);
    EXPECT_TRUE(boost::algorithm::equal(shifted.begin(), shifted.end(), ces_shifted, ces_shifted + 15))
        << "from:     " << ce_dumper(cps)
        << "expected: " << ce_dumper(ces_shifted)
        << "got:      " << ce_dumper(shifted);
}

TEST(collation, verbatim_131_252)
{
    uint32_t const cps[2] = { 0x03AA, 0x0062 };

    // 03AA 0062;	
    // (Ϊ) GREEK CAPITAL LETTER IOTA WITH DIALYTIKA	[202C 1CC6 | 0020 002B 0020 | 0008 0002 0002 |]
    uint32_t const ces_non_ignorable[11] = { 0x202C, 0x1CC6, 0x0000, 0x0020, 0x002B, 0x0020, 0x0000, 0x0008, 0x0002, 0x0002, 0x0000 };

    auto const non_ignorable = collate_for_tests(
        cps, cps + 2, boost::text::variable_weighting::non_ignorable);

    EXPECT_EQ(non_ignorable.size(), 11);
    EXPECT_TRUE(boost::algorithm::equal(non_ignorable.begin(), non_ignorable.end(), ces_non_ignorable, ces_non_ignorable + 11))
        << "from:     " << ce_dumper(cps)
        << "expected: " << ce_dumper(ces_non_ignorable)
        << "got:      " << ce_dumper(non_ignorable);

    // 03AA 0062;	
    // (Ϊ) GREEK CAPITAL LETTER IOTA WITH DIALYTIKA	[202C 1CC6 | 0020 002B 0020 | 0008 0002 0002 | FFFF FFFF FFFF |]
    uint32_t const ces_shifted[15] = { 0x202C, 0x1CC6, 0x0000, 0x0020, 0x002B, 0x0020, 0x0000, 0x0008, 0x0002, 0x0002, 0x0000, 0xFFFF, 0xFFFF, 0xFFFF, 0x0000 };

    auto const shifted = collate_for_tests(
        cps, cps + 2, boost::text::variable_weighting::shifted);

    EXPECT_EQ(shifted.size(), 15);
    EXPECT_TRUE(boost::algorithm::equal(shifted.begin(), shifted.end(), ces_shifted, ces_shifted + 15))
        << "from:     " << ce_dumper(cps)
        << "expected: " << ce_dumper(ces_shifted)
        << "got:      " << ce_dumper(shifted);
}

TEST(collation, verbatim_131_253)
{
    uint32_t const cps[2] = { 0x0390, 0x0062 };

    // 0390 0062;	
    // (ΐ) GREEK SMALL LETTER IOTA WITH DIALYTIKA AND TONOS	[202C 1CC6 | 0020 002B 0024 0020 | 0002 0002 0002 0002 |]
    uint32_t const ces_non_ignorable[13] = { 0x202C, 0x1CC6, 0x0000, 0x0020, 0x002B, 0x0024, 0x0020, 0x0000, 0x0002, 0x0002, 0x0002, 0x0002, 0x0000 };

    auto const non_ignorable = collate_for_tests(
        cps, cps + 2, boost::text::variable_weighting::non_ignorable);

    EXPECT_EQ(non_ignorable.size(), 13);
    EXPECT_TRUE(boost::algorithm::equal(non_ignorable.begin(), non_ignorable.end(), ces_non_ignorable, ces_non_ignorable + 13))
        << "from:     " << ce_dumper(cps)
        << "expected: " << ce_dumper(ces_non_ignorable)
        << "got:      " << ce_dumper(non_ignorable);

    // 0390 0062;	
    // (ΐ) GREEK SMALL LETTER IOTA WITH DIALYTIKA AND TONOS	[202C 1CC6 | 0020 002B 0024 0020 | 0002 0002 0002 0002 | FFFF FFFF FFFF FFFF |]
    uint32_t const ces_shifted[18] = { 0x202C, 0x1CC6, 0x0000, 0x0020, 0x002B, 0x0024, 0x0020, 0x0000, 0x0002, 0x0002, 0x0002, 0x0002, 0x0000, 0xFFFF, 0xFFFF, 0xFFFF, 0xFFFF, 0x0000 };

    auto const shifted = collate_for_tests(
        cps, cps + 2, boost::text::variable_weighting::shifted);

    EXPECT_EQ(shifted.size(), 18);
    EXPECT_TRUE(boost::algorithm::equal(shifted.begin(), shifted.end(), ces_shifted, ces_shifted + 18))
        << "from:     " << ce_dumper(cps)
        << "expected: " << ce_dumper(ces_shifted)
        << "got:      " << ce_dumper(shifted);
}

TEST(collation, verbatim_131_254)
{
    uint32_t const cps[2] = { 0x1FD3, 0x0062 };

    // 1FD3 0062;	
    // (ΐ) GREEK SMALL LETTER IOTA WITH DIALYTIKA AND OXIA	[202C 1CC6 | 0020 002B 0024 0020 | 0002 0002 0002 0002 |]
    uint32_t const ces_non_ignorable[13] = { 0x202C, 0x1CC6, 0x0000, 0x0020, 0x002B, 0x0024, 0x0020, 0x0000, 0x0002, 0x0002, 0x0002, 0x0002, 0x0000 };

    auto const non_ignorable = collate_for_tests(
        cps, cps + 2, boost::text::variable_weighting::non_ignorable);

    EXPECT_EQ(non_ignorable.size(), 13);
    EXPECT_TRUE(boost::algorithm::equal(non_ignorable.begin(), non_ignorable.end(), ces_non_ignorable, ces_non_ignorable + 13))
        << "from:     " << ce_dumper(cps)
        << "expected: " << ce_dumper(ces_non_ignorable)
        << "got:      " << ce_dumper(non_ignorable);

    // 1FD3 0062;	
    // (ΐ) GREEK SMALL LETTER IOTA WITH DIALYTIKA AND OXIA	[202C 1CC6 | 0020 002B 0024 0020 | 0002 0002 0002 0002 | FFFF FFFF FFFF FFFF |]
    uint32_t const ces_shifted[18] = { 0x202C, 0x1CC6, 0x0000, 0x0020, 0x002B, 0x0024, 0x0020, 0x0000, 0x0002, 0x0002, 0x0002, 0x0002, 0x0000, 0xFFFF, 0xFFFF, 0xFFFF, 0xFFFF, 0x0000 };

    auto const shifted = collate_for_tests(
        cps, cps + 2, boost::text::variable_weighting::shifted);

    EXPECT_EQ(shifted.size(), 18);
    EXPECT_TRUE(boost::algorithm::equal(shifted.begin(), shifted.end(), ces_shifted, ces_shifted + 18))
        << "from:     " << ce_dumper(cps)
        << "expected: " << ce_dumper(ces_shifted)
        << "got:      " << ce_dumper(shifted);
}

TEST(collation, verbatim_131_255)
{
    uint32_t const cps[2] = { 0x1FD2, 0x0062 };

    // 1FD2 0062;	
    // (ῒ) GREEK SMALL LETTER IOTA WITH DIALYTIKA AND VARIA	[202C 1CC6 | 0020 002B 0025 0020 | 0002 0002 0002 0002 |]
    uint32_t const ces_non_ignorable[13] = { 0x202C, 0x1CC6, 0x0000, 0x0020, 0x002B, 0x0025, 0x0020, 0x0000, 0x0002, 0x0002, 0x0002, 0x0002, 0x0000 };

    auto const non_ignorable = collate_for_tests(
        cps, cps + 2, boost::text::variable_weighting::non_ignorable);

    EXPECT_EQ(non_ignorable.size(), 13);
    EXPECT_TRUE(boost::algorithm::equal(non_ignorable.begin(), non_ignorable.end(), ces_non_ignorable, ces_non_ignorable + 13))
        << "from:     " << ce_dumper(cps)
        << "expected: " << ce_dumper(ces_non_ignorable)
        << "got:      " << ce_dumper(non_ignorable);

    // 1FD2 0062;	
    // (ῒ) GREEK SMALL LETTER IOTA WITH DIALYTIKA AND VARIA	[202C 1CC6 | 0020 002B 0025 0020 | 0002 0002 0002 0002 | FFFF FFFF FFFF FFFF |]
    uint32_t const ces_shifted[18] = { 0x202C, 0x1CC6, 0x0000, 0x0020, 0x002B, 0x0025, 0x0020, 0x0000, 0x0002, 0x0002, 0x0002, 0x0002, 0x0000, 0xFFFF, 0xFFFF, 0xFFFF, 0xFFFF, 0x0000 };

    auto const shifted = collate_for_tests(
        cps, cps + 2, boost::text::variable_weighting::shifted);

    EXPECT_EQ(shifted.size(), 18);
    EXPECT_TRUE(boost::algorithm::equal(shifted.begin(), shifted.end(), ces_shifted, ces_shifted + 18))
        << "from:     " << ce_dumper(cps)
        << "expected: " << ce_dumper(ces_shifted)
        << "got:      " << ce_dumper(shifted);
}

TEST(collation, verbatim_131_256)
{
    uint32_t const cps[2] = { 0x1FD7, 0x0062 };

    // 1FD7 0062;	
    // (ῗ) GREEK SMALL LETTER IOTA WITH DIALYTIKA AND PERISPOMENI	[202C 1CC6 | 0020 002B 002A 0020 | 0002 0002 0002 0002 |]
    uint32_t const ces_non_ignorable[13] = { 0x202C, 0x1CC6, 0x0000, 0x0020, 0x002B, 0x002A, 0x0020, 0x0000, 0x0002, 0x0002, 0x0002, 0x0002, 0x0000 };

    auto const non_ignorable = collate_for_tests(
        cps, cps + 2, boost::text::variable_weighting::non_ignorable);

    EXPECT_EQ(non_ignorable.size(), 13);
    EXPECT_TRUE(boost::algorithm::equal(non_ignorable.begin(), non_ignorable.end(), ces_non_ignorable, ces_non_ignorable + 13))
        << "from:     " << ce_dumper(cps)
        << "expected: " << ce_dumper(ces_non_ignorable)
        << "got:      " << ce_dumper(non_ignorable);

    // 1FD7 0062;	
    // (ῗ) GREEK SMALL LETTER IOTA WITH DIALYTIKA AND PERISPOMENI	[202C 1CC6 | 0020 002B 002A 0020 | 0002 0002 0002 0002 | FFFF FFFF FFFF FFFF |]
    uint32_t const ces_shifted[18] = { 0x202C, 0x1CC6, 0x0000, 0x0020, 0x002B, 0x002A, 0x0020, 0x0000, 0x0002, 0x0002, 0x0002, 0x0002, 0x0000, 0xFFFF, 0xFFFF, 0xFFFF, 0xFFFF, 0x0000 };

    auto const shifted = collate_for_tests(
        cps, cps + 2, boost::text::variable_weighting::shifted);

    EXPECT_EQ(shifted.size(), 18);
    EXPECT_TRUE(boost::algorithm::equal(shifted.begin(), shifted.end(), ces_shifted, ces_shifted + 18))
        << "from:     " << ce_dumper(cps)
        << "expected: " << ce_dumper(ces_shifted)
        << "got:      " << ce_dumper(shifted);
}

TEST(collation, verbatim_131_257)
{
    uint32_t const cps[2] = { 0x1FD1, 0x0062 };

    // 1FD1 0062;	
    // (ῑ) GREEK SMALL LETTER IOTA WITH MACRON	[202C 1CC6 | 0020 0032 0020 | 0002 0002 0002 |]
    uint32_t const ces_non_ignorable[11] = { 0x202C, 0x1CC6, 0x0000, 0x0020, 0x0032, 0x0020, 0x0000, 0x0002, 0x0002, 0x0002, 0x0000 };

    auto const non_ignorable = collate_for_tests(
        cps, cps + 2, boost::text::variable_weighting::non_ignorable);

    EXPECT_EQ(non_ignorable.size(), 11);
    EXPECT_TRUE(boost::algorithm::equal(non_ignorable.begin(), non_ignorable.end(), ces_non_ignorable, ces_non_ignorable + 11))
        << "from:     " << ce_dumper(cps)
        << "expected: " << ce_dumper(ces_non_ignorable)
        << "got:      " << ce_dumper(non_ignorable);

    // 1FD1 0062;	
    // (ῑ) GREEK SMALL LETTER IOTA WITH MACRON	[202C 1CC6 | 0020 0032 0020 | 0002 0002 0002 | FFFF FFFF FFFF |]
    uint32_t const ces_shifted[15] = { 0x202C, 0x1CC6, 0x0000, 0x0020, 0x0032, 0x0020, 0x0000, 0x0002, 0x0002, 0x0002, 0x0000, 0xFFFF, 0xFFFF, 0xFFFF, 0x0000 };

    auto const shifted = collate_for_tests(
        cps, cps + 2, boost::text::variable_weighting::shifted);

    EXPECT_EQ(shifted.size(), 15);
    EXPECT_TRUE(boost::algorithm::equal(shifted.begin(), shifted.end(), ces_shifted, ces_shifted + 15))
        << "from:     " << ce_dumper(cps)
        << "expected: " << ce_dumper(ces_shifted)
        << "got:      " << ce_dumper(shifted);
}

TEST(collation, verbatim_131_258)
{
    uint32_t const cps[2] = { 0x1FD9, 0x0062 };

    // 1FD9 0062;	
    // (Ῑ) GREEK CAPITAL LETTER IOTA WITH MACRON	[202C 1CC6 | 0020 0032 0020 | 0008 0002 0002 |]
    uint32_t const ces_non_ignorable[11] = { 0x202C, 0x1CC6, 0x0000, 0x0020, 0x0032, 0x0020, 0x0000, 0x0008, 0x0002, 0x0002, 0x0000 };

    auto const non_ignorable = collate_for_tests(
        cps, cps + 2, boost::text::variable_weighting::non_ignorable);

    EXPECT_EQ(non_ignorable.size(), 11);
    EXPECT_TRUE(boost::algorithm::equal(non_ignorable.begin(), non_ignorable.end(), ces_non_ignorable, ces_non_ignorable + 11))
        << "from:     " << ce_dumper(cps)
        << "expected: " << ce_dumper(ces_non_ignorable)
        << "got:      " << ce_dumper(non_ignorable);

    // 1FD9 0062;	
    // (Ῑ) GREEK CAPITAL LETTER IOTA WITH MACRON	[202C 1CC6 | 0020 0032 0020 | 0008 0002 0002 | FFFF FFFF FFFF |]
    uint32_t const ces_shifted[15] = { 0x202C, 0x1CC6, 0x0000, 0x0020, 0x0032, 0x0020, 0x0000, 0x0008, 0x0002, 0x0002, 0x0000, 0xFFFF, 0xFFFF, 0xFFFF, 0x0000 };

    auto const shifted = collate_for_tests(
        cps, cps + 2, boost::text::variable_weighting::shifted);

    EXPECT_EQ(shifted.size(), 15);
    EXPECT_TRUE(boost::algorithm::equal(shifted.begin(), shifted.end(), ces_shifted, ces_shifted + 15))
        << "from:     " << ce_dumper(cps)
        << "expected: " << ce_dumper(ces_shifted)
        << "got:      " << ce_dumper(shifted);
}

TEST(collation, verbatim_131_259)
{
    uint32_t const cps[2] = { 0x03F3, 0x0021 };

    // 03F3 0021;	
    // (ϳ) GREEK LETTER YOT	[202D 0261 | 0020 0020 | 0002 0002 |]
    uint32_t const ces_non_ignorable[9] = { 0x202D, 0x0261, 0x0000, 0x0020, 0x0020, 0x0000, 0x0002, 0x0002, 0x0000 };

    auto const non_ignorable = collate_for_tests(
        cps, cps + 2, boost::text::variable_weighting::non_ignorable);

    EXPECT_EQ(non_ignorable.size(), 9);
    EXPECT_TRUE(boost::algorithm::equal(non_ignorable.begin(), non_ignorable.end(), ces_non_ignorable, ces_non_ignorable + 9))
        << "from:     " << ce_dumper(cps)
        << "expected: " << ce_dumper(ces_non_ignorable)
        << "got:      " << ce_dumper(non_ignorable);

    // 03F3 0021;	
    // (ϳ) GREEK LETTER YOT	[202D | 0020 | 0002 | FFFF 0261 |]
    uint32_t const ces_shifted[9] = { 0x202D, 0x0000, 0x0020, 0x0000, 0x0002, 0x0000, 0xFFFF, 0x0261, 0x0000 };

    auto const shifted = collate_for_tests(
        cps, cps + 2, boost::text::variable_weighting::shifted);

    EXPECT_EQ(shifted.size(), 9);
    EXPECT_TRUE(boost::algorithm::equal(shifted.begin(), shifted.end(), ces_shifted, ces_shifted + 9))
        << "from:     " << ce_dumper(cps)
        << "expected: " << ce_dumper(ces_shifted)
        << "got:      " << ce_dumper(shifted);
}

TEST(collation, verbatim_131_260)
{
    uint32_t const cps[2] = { 0x037F, 0x0021 };

    // 037F 0021;	
    // (Ϳ) GREEK CAPITAL LETTER YOT	[202D 0261 | 0020 0020 | 0008 0002 |]
    uint32_t const ces_non_ignorable[9] = { 0x202D, 0x0261, 0x0000, 0x0020, 0x0020, 0x0000, 0x0008, 0x0002, 0x0000 };

    auto const non_ignorable = collate_for_tests(
        cps, cps + 2, boost::text::variable_weighting::non_ignorable);

    EXPECT_EQ(non_ignorable.size(), 9);
    EXPECT_TRUE(boost::algorithm::equal(non_ignorable.begin(), non_ignorable.end(), ces_non_ignorable, ces_non_ignorable + 9))
        << "from:     " << ce_dumper(cps)
        << "expected: " << ce_dumper(ces_non_ignorable)
        << "got:      " << ce_dumper(non_ignorable);

    // 037F 0021;	
    // (Ϳ) GREEK CAPITAL LETTER YOT	[202D | 0020 | 0008 | FFFF 0261 |]
    uint32_t const ces_shifted[9] = { 0x202D, 0x0000, 0x0020, 0x0000, 0x0008, 0x0000, 0xFFFF, 0x0261, 0x0000 };

    auto const shifted = collate_for_tests(
        cps, cps + 2, boost::text::variable_weighting::shifted);

    EXPECT_EQ(shifted.size(), 9);
    EXPECT_TRUE(boost::algorithm::equal(shifted.begin(), shifted.end(), ces_shifted, ces_shifted + 9))
        << "from:     " << ce_dumper(cps)
        << "expected: " << ce_dumper(ces_shifted)
        << "got:      " << ce_dumper(shifted);
}

TEST(collation, verbatim_131_261)
{
    uint32_t const cps[2] = { 0x03F3, 0x003F };

    // 03F3 003F;	
    // (ϳ) GREEK LETTER YOT	[202D 0267 | 0020 0020 | 0002 0002 |]
    uint32_t const ces_non_ignorable[9] = { 0x202D, 0x0267, 0x0000, 0x0020, 0x0020, 0x0000, 0x0002, 0x0002, 0x0000 };

    auto const non_ignorable = collate_for_tests(
        cps, cps + 2, boost::text::variable_weighting::non_ignorable);

    EXPECT_EQ(non_ignorable.size(), 9);
    EXPECT_TRUE(boost::algorithm::equal(non_ignorable.begin(), non_ignorable.end(), ces_non_ignorable, ces_non_ignorable + 9))
        << "from:     " << ce_dumper(cps)
        << "expected: " << ce_dumper(ces_non_ignorable)
        << "got:      " << ce_dumper(non_ignorable);

    // 03F3 003F;	
    // (ϳ) GREEK LETTER YOT	[202D | 0020 | 0002 | FFFF 0267 |]
    uint32_t const ces_shifted[9] = { 0x202D, 0x0000, 0x0020, 0x0000, 0x0002, 0x0000, 0xFFFF, 0x0267, 0x0000 };

    auto const shifted = collate_for_tests(
        cps, cps + 2, boost::text::variable_weighting::shifted);

    EXPECT_EQ(shifted.size(), 9);
    EXPECT_TRUE(boost::algorithm::equal(shifted.begin(), shifted.end(), ces_shifted, ces_shifted + 9))
        << "from:     " << ce_dumper(cps)
        << "expected: " << ce_dumper(ces_shifted)
        << "got:      " << ce_dumper(shifted);
}

TEST(collation, verbatim_131_262)
{
    uint32_t const cps[2] = { 0x037F, 0x003F };

    // 037F 003F;	
    // (Ϳ) GREEK CAPITAL LETTER YOT	[202D 0267 | 0020 0020 | 0008 0002 |]
    uint32_t const ces_non_ignorable[9] = { 0x202D, 0x0267, 0x0000, 0x0020, 0x0020, 0x0000, 0x0008, 0x0002, 0x0000 };

    auto const non_ignorable = collate_for_tests(
        cps, cps + 2, boost::text::variable_weighting::non_ignorable);

    EXPECT_EQ(non_ignorable.size(), 9);
    EXPECT_TRUE(boost::algorithm::equal(non_ignorable.begin(), non_ignorable.end(), ces_non_ignorable, ces_non_ignorable + 9))
        << "from:     " << ce_dumper(cps)
        << "expected: " << ce_dumper(ces_non_ignorable)
        << "got:      " << ce_dumper(non_ignorable);

    // 037F 003F;	
    // (Ϳ) GREEK CAPITAL LETTER YOT	[202D | 0020 | 0008 | FFFF 0267 |]
    uint32_t const ces_shifted[9] = { 0x202D, 0x0000, 0x0020, 0x0000, 0x0008, 0x0000, 0xFFFF, 0x0267, 0x0000 };

    auto const shifted = collate_for_tests(
        cps, cps + 2, boost::text::variable_weighting::shifted);

    EXPECT_EQ(shifted.size(), 9);
    EXPECT_TRUE(boost::algorithm::equal(shifted.begin(), shifted.end(), ces_shifted, ces_shifted + 9))
        << "from:     " << ce_dumper(cps)
        << "expected: " << ce_dumper(ces_shifted)
        << "got:      " << ce_dumper(shifted);
}

TEST(collation, verbatim_131_263)
{
    uint32_t const cps[2] = { 0x03F3, 0x0061 };

    // 03F3 0061;	
    // (ϳ) GREEK LETTER YOT	[202D 1CAD | 0020 0020 | 0002 0002 |]
    uint32_t const ces_non_ignorable[9] = { 0x202D, 0x1CAD, 0x0000, 0x0020, 0x0020, 0x0000, 0x0002, 0x0002, 0x0000 };

    auto const non_ignorable = collate_for_tests(
        cps, cps + 2, boost::text::variable_weighting::non_ignorable);

    EXPECT_EQ(non_ignorable.size(), 9);
    EXPECT_TRUE(boost::algorithm::equal(non_ignorable.begin(), non_ignorable.end(), ces_non_ignorable, ces_non_ignorable + 9))
        << "from:     " << ce_dumper(cps)
        << "expected: " << ce_dumper(ces_non_ignorable)
        << "got:      " << ce_dumper(non_ignorable);

    // 03F3 0061;	
    // (ϳ) GREEK LETTER YOT	[202D 1CAD | 0020 0020 | 0002 0002 | FFFF FFFF |]
    uint32_t const ces_shifted[12] = { 0x202D, 0x1CAD, 0x0000, 0x0020, 0x0020, 0x0000, 0x0002, 0x0002, 0x0000, 0xFFFF, 0xFFFF, 0x0000 };

    auto const shifted = collate_for_tests(
        cps, cps + 2, boost::text::variable_weighting::shifted);

    EXPECT_EQ(shifted.size(), 12);
    EXPECT_TRUE(boost::algorithm::equal(shifted.begin(), shifted.end(), ces_shifted, ces_shifted + 12))
        << "from:     " << ce_dumper(cps)
        << "expected: " << ce_dumper(ces_shifted)
        << "got:      " << ce_dumper(shifted);
}

TEST(collation, verbatim_131_264)
{
    uint32_t const cps[2] = { 0x03F3, 0x0041 };

    // 03F3 0041;	
    // (ϳ) GREEK LETTER YOT	[202D 1CAD | 0020 0020 | 0002 0008 |]
    uint32_t const ces_non_ignorable[9] = { 0x202D, 0x1CAD, 0x0000, 0x0020, 0x0020, 0x0000, 0x0002, 0x0008, 0x0000 };

    auto const non_ignorable = collate_for_tests(
        cps, cps + 2, boost::text::variable_weighting::non_ignorable);

    EXPECT_EQ(non_ignorable.size(), 9);
    EXPECT_TRUE(boost::algorithm::equal(non_ignorable.begin(), non_ignorable.end(), ces_non_ignorable, ces_non_ignorable + 9))
        << "from:     " << ce_dumper(cps)
        << "expected: " << ce_dumper(ces_non_ignorable)
        << "got:      " << ce_dumper(non_ignorable);

    // 03F3 0041;	
    // (ϳ) GREEK LETTER YOT	[202D 1CAD | 0020 0020 | 0002 0008 | FFFF FFFF |]
    uint32_t const ces_shifted[12] = { 0x202D, 0x1CAD, 0x0000, 0x0020, 0x0020, 0x0000, 0x0002, 0x0008, 0x0000, 0xFFFF, 0xFFFF, 0x0000 };

    auto const shifted = collate_for_tests(
        cps, cps + 2, boost::text::variable_weighting::shifted);

    EXPECT_EQ(shifted.size(), 12);
    EXPECT_TRUE(boost::algorithm::equal(shifted.begin(), shifted.end(), ces_shifted, ces_shifted + 12))
        << "from:     " << ce_dumper(cps)
        << "expected: " << ce_dumper(ces_shifted)
        << "got:      " << ce_dumper(shifted);
}

TEST(collation, verbatim_131_265)
{
    uint32_t const cps[2] = { 0x037F, 0x0061 };

    // 037F 0061;	
    // (Ϳ) GREEK CAPITAL LETTER YOT	[202D 1CAD | 0020 0020 | 0008 0002 |]
    uint32_t const ces_non_ignorable[9] = { 0x202D, 0x1CAD, 0x0000, 0x0020, 0x0020, 0x0000, 0x0008, 0x0002, 0x0000 };

    auto const non_ignorable = collate_for_tests(
        cps, cps + 2, boost::text::variable_weighting::non_ignorable);

    EXPECT_EQ(non_ignorable.size(), 9);
    EXPECT_TRUE(boost::algorithm::equal(non_ignorable.begin(), non_ignorable.end(), ces_non_ignorable, ces_non_ignorable + 9))
        << "from:     " << ce_dumper(cps)
        << "expected: " << ce_dumper(ces_non_ignorable)
        << "got:      " << ce_dumper(non_ignorable);

    // 037F 0061;	
    // (Ϳ) GREEK CAPITAL LETTER YOT	[202D 1CAD | 0020 0020 | 0008 0002 | FFFF FFFF |]
    uint32_t const ces_shifted[12] = { 0x202D, 0x1CAD, 0x0000, 0x0020, 0x0020, 0x0000, 0x0008, 0x0002, 0x0000, 0xFFFF, 0xFFFF, 0x0000 };

    auto const shifted = collate_for_tests(
        cps, cps + 2, boost::text::variable_weighting::shifted);

    EXPECT_EQ(shifted.size(), 12);
    EXPECT_TRUE(boost::algorithm::equal(shifted.begin(), shifted.end(), ces_shifted, ces_shifted + 12))
        << "from:     " << ce_dumper(cps)
        << "expected: " << ce_dumper(ces_shifted)
        << "got:      " << ce_dumper(shifted);
}

TEST(collation, verbatim_131_266)
{
    uint32_t const cps[2] = { 0x037F, 0x0041 };

    // 037F 0041;	
    // (Ϳ) GREEK CAPITAL LETTER YOT	[202D 1CAD | 0020 0020 | 0008 0008 |]
    uint32_t const ces_non_ignorable[9] = { 0x202D, 0x1CAD, 0x0000, 0x0020, 0x0020, 0x0000, 0x0008, 0x0008, 0x0000 };

    auto const non_ignorable = collate_for_tests(
        cps, cps + 2, boost::text::variable_weighting::non_ignorable);

    EXPECT_EQ(non_ignorable.size(), 9);
    EXPECT_TRUE(boost::algorithm::equal(non_ignorable.begin(), non_ignorable.end(), ces_non_ignorable, ces_non_ignorable + 9))
        << "from:     " << ce_dumper(cps)
        << "expected: " << ce_dumper(ces_non_ignorable)
        << "got:      " << ce_dumper(non_ignorable);

    // 037F 0041;	
    // (Ϳ) GREEK CAPITAL LETTER YOT	[202D 1CAD | 0020 0020 | 0008 0008 | FFFF FFFF |]
    uint32_t const ces_shifted[12] = { 0x202D, 0x1CAD, 0x0000, 0x0020, 0x0020, 0x0000, 0x0008, 0x0008, 0x0000, 0xFFFF, 0xFFFF, 0x0000 };

    auto const shifted = collate_for_tests(
        cps, cps + 2, boost::text::variable_weighting::shifted);

    EXPECT_EQ(shifted.size(), 12);
    EXPECT_TRUE(boost::algorithm::equal(shifted.begin(), shifted.end(), ces_shifted, ces_shifted + 12))
        << "from:     " << ce_dumper(cps)
        << "expected: " << ce_dumper(ces_shifted)
        << "got:      " << ce_dumper(shifted);
}

TEST(collation, verbatim_131_267)
{
    uint32_t const cps[2] = { 0x03F3, 0x0062 };

    // 03F3 0062;	
    // (ϳ) GREEK LETTER YOT	[202D 1CC6 | 0020 0020 | 0002 0002 |]
    uint32_t const ces_non_ignorable[9] = { 0x202D, 0x1CC6, 0x0000, 0x0020, 0x0020, 0x0000, 0x0002, 0x0002, 0x0000 };

    auto const non_ignorable = collate_for_tests(
        cps, cps + 2, boost::text::variable_weighting::non_ignorable);

    EXPECT_EQ(non_ignorable.size(), 9);
    EXPECT_TRUE(boost::algorithm::equal(non_ignorable.begin(), non_ignorable.end(), ces_non_ignorable, ces_non_ignorable + 9))
        << "from:     " << ce_dumper(cps)
        << "expected: " << ce_dumper(ces_non_ignorable)
        << "got:      " << ce_dumper(non_ignorable);

    // 03F3 0062;	
    // (ϳ) GREEK LETTER YOT	[202D 1CC6 | 0020 0020 | 0002 0002 | FFFF FFFF |]
    uint32_t const ces_shifted[12] = { 0x202D, 0x1CC6, 0x0000, 0x0020, 0x0020, 0x0000, 0x0002, 0x0002, 0x0000, 0xFFFF, 0xFFFF, 0x0000 };

    auto const shifted = collate_for_tests(
        cps, cps + 2, boost::text::variable_weighting::shifted);

    EXPECT_EQ(shifted.size(), 12);
    EXPECT_TRUE(boost::algorithm::equal(shifted.begin(), shifted.end(), ces_shifted, ces_shifted + 12))
        << "from:     " << ce_dumper(cps)
        << "expected: " << ce_dumper(ces_shifted)
        << "got:      " << ce_dumper(shifted);
}

TEST(collation, verbatim_131_268)
{
    uint32_t const cps[2] = { 0x037F, 0x0062 };

    // 037F 0062;	
    // (Ϳ) GREEK CAPITAL LETTER YOT	[202D 1CC6 | 0020 0020 | 0008 0002 |]
    uint32_t const ces_non_ignorable[9] = { 0x202D, 0x1CC6, 0x0000, 0x0020, 0x0020, 0x0000, 0x0008, 0x0002, 0x0000 };

    auto const non_ignorable = collate_for_tests(
        cps, cps + 2, boost::text::variable_weighting::non_ignorable);

    EXPECT_EQ(non_ignorable.size(), 9);
    EXPECT_TRUE(boost::algorithm::equal(non_ignorable.begin(), non_ignorable.end(), ces_non_ignorable, ces_non_ignorable + 9))
        << "from:     " << ce_dumper(cps)
        << "expected: " << ce_dumper(ces_non_ignorable)
        << "got:      " << ce_dumper(non_ignorable);

    // 037F 0062;	
    // (Ϳ) GREEK CAPITAL LETTER YOT	[202D 1CC6 | 0020 0020 | 0008 0002 | FFFF FFFF |]
    uint32_t const ces_shifted[12] = { 0x202D, 0x1CC6, 0x0000, 0x0020, 0x0020, 0x0000, 0x0008, 0x0002, 0x0000, 0xFFFF, 0xFFFF, 0x0000 };

    auto const shifted = collate_for_tests(
        cps, cps + 2, boost::text::variable_weighting::shifted);

    EXPECT_EQ(shifted.size(), 12);
    EXPECT_TRUE(boost::algorithm::equal(shifted.begin(), shifted.end(), ces_shifted, ces_shifted + 12))
        << "from:     " << ce_dumper(cps)
        << "expected: " << ce_dumper(ces_shifted)
        << "got:      " << ce_dumper(shifted);
}

TEST(collation, verbatim_131_269)
{
    uint32_t const cps[2] = { 0x03BA, 0x0021 };

    // 03BA 0021;	
    // (κ) GREEK SMALL LETTER KAPPA	[202E 0261 | 0020 0020 | 0002 0002 |]
    uint32_t const ces_non_ignorable[9] = { 0x202E, 0x0261, 0x0000, 0x0020, 0x0020, 0x0000, 0x0002, 0x0002, 0x0000 };

    auto const non_ignorable = collate_for_tests(
        cps, cps + 2, boost::text::variable_weighting::non_ignorable);

    EXPECT_EQ(non_ignorable.size(), 9);
    EXPECT_TRUE(boost::algorithm::equal(non_ignorable.begin(), non_ignorable.end(), ces_non_ignorable, ces_non_ignorable + 9))
        << "from:     " << ce_dumper(cps)
        << "expected: " << ce_dumper(ces_non_ignorable)
        << "got:      " << ce_dumper(non_ignorable);

    // 03BA 0021;	
    // (κ) GREEK SMALL LETTER KAPPA	[202E | 0020 | 0002 | FFFF 0261 |]
    uint32_t const ces_shifted[9] = { 0x202E, 0x0000, 0x0020, 0x0000, 0x0002, 0x0000, 0xFFFF, 0x0261, 0x0000 };

    auto const shifted = collate_for_tests(
        cps, cps + 2, boost::text::variable_weighting::shifted);

    EXPECT_EQ(shifted.size(), 9);
    EXPECT_TRUE(boost::algorithm::equal(shifted.begin(), shifted.end(), ces_shifted, ces_shifted + 9))
        << "from:     " << ce_dumper(cps)
        << "expected: " << ce_dumper(ces_shifted)
        << "got:      " << ce_dumper(shifted);
}

TEST(collation, verbatim_131_270)
{
    uint32_t const cps[2] = { 0x03F0, 0x0021 };

    // 03F0 0021;	
    // (ϰ) GREEK KAPPA SYMBOL	[202E 0261 | 0020 0020 | 0004 0002 |]
    uint32_t const ces_non_ignorable[9] = { 0x202E, 0x0261, 0x0000, 0x0020, 0x0020, 0x0000, 0x0004, 0x0002, 0x0000 };

    auto const non_ignorable = collate_for_tests(
        cps, cps + 2, boost::text::variable_weighting::non_ignorable);

    EXPECT_EQ(non_ignorable.size(), 9);
    EXPECT_TRUE(boost::algorithm::equal(non_ignorable.begin(), non_ignorable.end(), ces_non_ignorable, ces_non_ignorable + 9))
        << "from:     " << ce_dumper(cps)
        << "expected: " << ce_dumper(ces_non_ignorable)
        << "got:      " << ce_dumper(non_ignorable);

    // 03F0 0021;	
    // (ϰ) GREEK KAPPA SYMBOL	[202E | 0020 | 0004 | FFFF 0261 |]
    uint32_t const ces_shifted[9] = { 0x202E, 0x0000, 0x0020, 0x0000, 0x0004, 0x0000, 0xFFFF, 0x0261, 0x0000 };

    auto const shifted = collate_for_tests(
        cps, cps + 2, boost::text::variable_weighting::shifted);

    EXPECT_EQ(shifted.size(), 9);
    EXPECT_TRUE(boost::algorithm::equal(shifted.begin(), shifted.end(), ces_shifted, ces_shifted + 9))
        << "from:     " << ce_dumper(cps)
        << "expected: " << ce_dumper(ces_shifted)
        << "got:      " << ce_dumper(shifted);
}

TEST(collation, verbatim_131_271)
{
    uint32_t const cps[2] = { 0x1D6CB, 0x0021 };

    // 1D6CB 0021;	
    // (𝛋) MATHEMATICAL BOLD SMALL KAPPA	[202E 0261 | 0020 0020 | 0005 0002 |]
    uint32_t const ces_non_ignorable[9] = { 0x202E, 0x0261, 0x0000, 0x0020, 0x0020, 0x0000, 0x0005, 0x0002, 0x0000 };

    auto const non_ignorable = collate_for_tests(
        cps, cps + 2, boost::text::variable_weighting::non_ignorable);

    EXPECT_EQ(non_ignorable.size(), 9);
    EXPECT_TRUE(boost::algorithm::equal(non_ignorable.begin(), non_ignorable.end(), ces_non_ignorable, ces_non_ignorable + 9))
        << "from:     " << ce_dumper(cps)
        << "expected: " << ce_dumper(ces_non_ignorable)
        << "got:      " << ce_dumper(non_ignorable);

    // 1D6CB 0021;	
    // (𝛋) MATHEMATICAL BOLD SMALL KAPPA	[202E | 0020 | 0005 | FFFF 0261 |]
    uint32_t const ces_shifted[9] = { 0x202E, 0x0000, 0x0020, 0x0000, 0x0005, 0x0000, 0xFFFF, 0x0261, 0x0000 };

    auto const shifted = collate_for_tests(
        cps, cps + 2, boost::text::variable_weighting::shifted);

    EXPECT_EQ(shifted.size(), 9);
    EXPECT_TRUE(boost::algorithm::equal(shifted.begin(), shifted.end(), ces_shifted, ces_shifted + 9))
        << "from:     " << ce_dumper(cps)
        << "expected: " << ce_dumper(ces_shifted)
        << "got:      " << ce_dumper(shifted);
}

TEST(collation, verbatim_131_272)
{
    uint32_t const cps[2] = { 0x1D6DE, 0x0021 };

    // 1D6DE 0021;	
    // (𝛞) MATHEMATICAL BOLD KAPPA SYMBOL	[202E 0261 | 0020 0020 | 0005 0002 |]
    uint32_t const ces_non_ignorable[9] = { 0x202E, 0x0261, 0x0000, 0x0020, 0x0020, 0x0000, 0x0005, 0x0002, 0x0000 };

    auto const non_ignorable = collate_for_tests(
        cps, cps + 2, boost::text::variable_weighting::non_ignorable);

    EXPECT_EQ(non_ignorable.size(), 9);
    EXPECT_TRUE(boost::algorithm::equal(non_ignorable.begin(), non_ignorable.end(), ces_non_ignorable, ces_non_ignorable + 9))
        << "from:     " << ce_dumper(cps)
        << "expected: " << ce_dumper(ces_non_ignorable)
        << "got:      " << ce_dumper(non_ignorable);

    // 1D6DE 0021;	
    // (𝛞) MATHEMATICAL BOLD KAPPA SYMBOL	[202E | 0020 | 0005 | FFFF 0261 |]
    uint32_t const ces_shifted[9] = { 0x202E, 0x0000, 0x0020, 0x0000, 0x0005, 0x0000, 0xFFFF, 0x0261, 0x0000 };

    auto const shifted = collate_for_tests(
        cps, cps + 2, boost::text::variable_weighting::shifted);

    EXPECT_EQ(shifted.size(), 9);
    EXPECT_TRUE(boost::algorithm::equal(shifted.begin(), shifted.end(), ces_shifted, ces_shifted + 9))
        << "from:     " << ce_dumper(cps)
        << "expected: " << ce_dumper(ces_shifted)
        << "got:      " << ce_dumper(shifted);
}

TEST(collation, verbatim_131_273)
{
    uint32_t const cps[2] = { 0x1D705, 0x0021 };

    // 1D705 0021;	
    // (𝜅) MATHEMATICAL ITALIC SMALL KAPPA	[202E 0261 | 0020 0020 | 0005 0002 |]
    uint32_t const ces_non_ignorable[9] = { 0x202E, 0x0261, 0x0000, 0x0020, 0x0020, 0x0000, 0x0005, 0x0002, 0x0000 };

    auto const non_ignorable = collate_for_tests(
        cps, cps + 2, boost::text::variable_weighting::non_ignorable);

    EXPECT_EQ(non_ignorable.size(), 9);
    EXPECT_TRUE(boost::algorithm::equal(non_ignorable.begin(), non_ignorable.end(), ces_non_ignorable, ces_non_ignorable + 9))
        << "from:     " << ce_dumper(cps)
        << "expected: " << ce_dumper(ces_non_ignorable)
        << "got:      " << ce_dumper(non_ignorable);

    // 1D705 0021;	
    // (𝜅) MATHEMATICAL ITALIC SMALL KAPPA	[202E | 0020 | 0005 | FFFF 0261 |]
    uint32_t const ces_shifted[9] = { 0x202E, 0x0000, 0x0020, 0x0000, 0x0005, 0x0000, 0xFFFF, 0x0261, 0x0000 };

    auto const shifted = collate_for_tests(
        cps, cps + 2, boost::text::variable_weighting::shifted);

    EXPECT_EQ(shifted.size(), 9);
    EXPECT_TRUE(boost::algorithm::equal(shifted.begin(), shifted.end(), ces_shifted, ces_shifted + 9))
        << "from:     " << ce_dumper(cps)
        << "expected: " << ce_dumper(ces_shifted)
        << "got:      " << ce_dumper(shifted);
}

TEST(collation, verbatim_131_274)
{
    uint32_t const cps[2] = { 0x1D718, 0x0021 };

    // 1D718 0021;	
    // (𝜘) MATHEMATICAL ITALIC KAPPA SYMBOL	[202E 0261 | 0020 0020 | 0005 0002 |]
    uint32_t const ces_non_ignorable[9] = { 0x202E, 0x0261, 0x0000, 0x0020, 0x0020, 0x0000, 0x0005, 0x0002, 0x0000 };

    auto const non_ignorable = collate_for_tests(
        cps, cps + 2, boost::text::variable_weighting::non_ignorable);

    EXPECT_EQ(non_ignorable.size(), 9);
    EXPECT_TRUE(boost::algorithm::equal(non_ignorable.begin(), non_ignorable.end(), ces_non_ignorable, ces_non_ignorable + 9))
        << "from:     " << ce_dumper(cps)
        << "expected: " << ce_dumper(ces_non_ignorable)
        << "got:      " << ce_dumper(non_ignorable);

    // 1D718 0021;	
    // (𝜘) MATHEMATICAL ITALIC KAPPA SYMBOL	[202E | 0020 | 0005 | FFFF 0261 |]
    uint32_t const ces_shifted[9] = { 0x202E, 0x0000, 0x0020, 0x0000, 0x0005, 0x0000, 0xFFFF, 0x0261, 0x0000 };

    auto const shifted = collate_for_tests(
        cps, cps + 2, boost::text::variable_weighting::shifted);

    EXPECT_EQ(shifted.size(), 9);
    EXPECT_TRUE(boost::algorithm::equal(shifted.begin(), shifted.end(), ces_shifted, ces_shifted + 9))
        << "from:     " << ce_dumper(cps)
        << "expected: " << ce_dumper(ces_shifted)
        << "got:      " << ce_dumper(shifted);
}

TEST(collation, verbatim_131_275)
{
    uint32_t const cps[2] = { 0x1D73F, 0x0021 };

    // 1D73F 0021;	
    // (𝜿) MATHEMATICAL BOLD ITALIC SMALL KAPPA	[202E 0261 | 0020 0020 | 0005 0002 |]
    uint32_t const ces_non_ignorable[9] = { 0x202E, 0x0261, 0x0000, 0x0020, 0x0020, 0x0000, 0x0005, 0x0002, 0x0000 };

    auto const non_ignorable = collate_for_tests(
        cps, cps + 2, boost::text::variable_weighting::non_ignorable);

    EXPECT_EQ(non_ignorable.size(), 9);
    EXPECT_TRUE(boost::algorithm::equal(non_ignorable.begin(), non_ignorable.end(), ces_non_ignorable, ces_non_ignorable + 9))
        << "from:     " << ce_dumper(cps)
        << "expected: " << ce_dumper(ces_non_ignorable)
        << "got:      " << ce_dumper(non_ignorable);

    // 1D73F 0021;	
    // (𝜿) MATHEMATICAL BOLD ITALIC SMALL KAPPA	[202E | 0020 | 0005 | FFFF 0261 |]
    uint32_t const ces_shifted[9] = { 0x202E, 0x0000, 0x0020, 0x0000, 0x0005, 0x0000, 0xFFFF, 0x0261, 0x0000 };

    auto const shifted = collate_for_tests(
        cps, cps + 2, boost::text::variable_weighting::shifted);

    EXPECT_EQ(shifted.size(), 9);
    EXPECT_TRUE(boost::algorithm::equal(shifted.begin(), shifted.end(), ces_shifted, ces_shifted + 9))
        << "from:     " << ce_dumper(cps)
        << "expected: " << ce_dumper(ces_shifted)
        << "got:      " << ce_dumper(shifted);
}

TEST(collation, verbatim_131_276)
{
    uint32_t const cps[2] = { 0x1D752, 0x0021 };

    // 1D752 0021;	
    // (𝝒) MATHEMATICAL BOLD ITALIC KAPPA SYMBOL	[202E 0261 | 0020 0020 | 0005 0002 |]
    uint32_t const ces_non_ignorable[9] = { 0x202E, 0x0261, 0x0000, 0x0020, 0x0020, 0x0000, 0x0005, 0x0002, 0x0000 };

    auto const non_ignorable = collate_for_tests(
        cps, cps + 2, boost::text::variable_weighting::non_ignorable);

    EXPECT_EQ(non_ignorable.size(), 9);
    EXPECT_TRUE(boost::algorithm::equal(non_ignorable.begin(), non_ignorable.end(), ces_non_ignorable, ces_non_ignorable + 9))
        << "from:     " << ce_dumper(cps)
        << "expected: " << ce_dumper(ces_non_ignorable)
        << "got:      " << ce_dumper(non_ignorable);

    // 1D752 0021;	
    // (𝝒) MATHEMATICAL BOLD ITALIC KAPPA SYMBOL	[202E | 0020 | 0005 | FFFF 0261 |]
    uint32_t const ces_shifted[9] = { 0x202E, 0x0000, 0x0020, 0x0000, 0x0005, 0x0000, 0xFFFF, 0x0261, 0x0000 };

    auto const shifted = collate_for_tests(
        cps, cps + 2, boost::text::variable_weighting::shifted);

    EXPECT_EQ(shifted.size(), 9);
    EXPECT_TRUE(boost::algorithm::equal(shifted.begin(), shifted.end(), ces_shifted, ces_shifted + 9))
        << "from:     " << ce_dumper(cps)
        << "expected: " << ce_dumper(ces_shifted)
        << "got:      " << ce_dumper(shifted);
}

TEST(collation, verbatim_131_277)
{
    uint32_t const cps[2] = { 0x1D779, 0x0021 };

    // 1D779 0021;	
    // (𝝹) MATHEMATICAL SANS-SERIF BOLD SMALL KAPPA	[202E 0261 | 0020 0020 | 0005 0002 |]
    uint32_t const ces_non_ignorable[9] = { 0x202E, 0x0261, 0x0000, 0x0020, 0x0020, 0x0000, 0x0005, 0x0002, 0x0000 };

    auto const non_ignorable = collate_for_tests(
        cps, cps + 2, boost::text::variable_weighting::non_ignorable);

    EXPECT_EQ(non_ignorable.size(), 9);
    EXPECT_TRUE(boost::algorithm::equal(non_ignorable.begin(), non_ignorable.end(), ces_non_ignorable, ces_non_ignorable + 9))
        << "from:     " << ce_dumper(cps)
        << "expected: " << ce_dumper(ces_non_ignorable)
        << "got:      " << ce_dumper(non_ignorable);

    // 1D779 0021;	
    // (𝝹) MATHEMATICAL SANS-SERIF BOLD SMALL KAPPA	[202E | 0020 | 0005 | FFFF 0261 |]
    uint32_t const ces_shifted[9] = { 0x202E, 0x0000, 0x0020, 0x0000, 0x0005, 0x0000, 0xFFFF, 0x0261, 0x0000 };

    auto const shifted = collate_for_tests(
        cps, cps + 2, boost::text::variable_weighting::shifted);

    EXPECT_EQ(shifted.size(), 9);
    EXPECT_TRUE(boost::algorithm::equal(shifted.begin(), shifted.end(), ces_shifted, ces_shifted + 9))
        << "from:     " << ce_dumper(cps)
        << "expected: " << ce_dumper(ces_shifted)
        << "got:      " << ce_dumper(shifted);
}

TEST(collation, verbatim_131_278)
{
    uint32_t const cps[2] = { 0x1D78C, 0x0021 };

    // 1D78C 0021;	
    // (𝞌) MATHEMATICAL SANS-SERIF BOLD KAPPA SYMBOL	[202E 0261 | 0020 0020 | 0005 0002 |]
    uint32_t const ces_non_ignorable[9] = { 0x202E, 0x0261, 0x0000, 0x0020, 0x0020, 0x0000, 0x0005, 0x0002, 0x0000 };

    auto const non_ignorable = collate_for_tests(
        cps, cps + 2, boost::text::variable_weighting::non_ignorable);

    EXPECT_EQ(non_ignorable.size(), 9);
    EXPECT_TRUE(boost::algorithm::equal(non_ignorable.begin(), non_ignorable.end(), ces_non_ignorable, ces_non_ignorable + 9))
        << "from:     " << ce_dumper(cps)
        << "expected: " << ce_dumper(ces_non_ignorable)
        << "got:      " << ce_dumper(non_ignorable);

    // 1D78C 0021;	
    // (𝞌) MATHEMATICAL SANS-SERIF BOLD KAPPA SYMBOL	[202E | 0020 | 0005 | FFFF 0261 |]
    uint32_t const ces_shifted[9] = { 0x202E, 0x0000, 0x0020, 0x0000, 0x0005, 0x0000, 0xFFFF, 0x0261, 0x0000 };

    auto const shifted = collate_for_tests(
        cps, cps + 2, boost::text::variable_weighting::shifted);

    EXPECT_EQ(shifted.size(), 9);
    EXPECT_TRUE(boost::algorithm::equal(shifted.begin(), shifted.end(), ces_shifted, ces_shifted + 9))
        << "from:     " << ce_dumper(cps)
        << "expected: " << ce_dumper(ces_shifted)
        << "got:      " << ce_dumper(shifted);
}

TEST(collation, verbatim_131_279)
{
    uint32_t const cps[2] = { 0x1D7B3, 0x0021 };

    // 1D7B3 0021;	
    // (𝞳) MATHEMATICAL SANS-SERIF BOLD ITALIC SMALL KAPPA	[202E 0261 | 0020 0020 | 0005 0002 |]
    uint32_t const ces_non_ignorable[9] = { 0x202E, 0x0261, 0x0000, 0x0020, 0x0020, 0x0000, 0x0005, 0x0002, 0x0000 };

    auto const non_ignorable = collate_for_tests(
        cps, cps + 2, boost::text::variable_weighting::non_ignorable);

    EXPECT_EQ(non_ignorable.size(), 9);
    EXPECT_TRUE(boost::algorithm::equal(non_ignorable.begin(), non_ignorable.end(), ces_non_ignorable, ces_non_ignorable + 9))
        << "from:     " << ce_dumper(cps)
        << "expected: " << ce_dumper(ces_non_ignorable)
        << "got:      " << ce_dumper(non_ignorable);

    // 1D7B3 0021;	
    // (𝞳) MATHEMATICAL SANS-SERIF BOLD ITALIC SMALL KAPPA	[202E | 0020 | 0005 | FFFF 0261 |]
    uint32_t const ces_shifted[9] = { 0x202E, 0x0000, 0x0020, 0x0000, 0x0005, 0x0000, 0xFFFF, 0x0261, 0x0000 };

    auto const shifted = collate_for_tests(
        cps, cps + 2, boost::text::variable_weighting::shifted);

    EXPECT_EQ(shifted.size(), 9);
    EXPECT_TRUE(boost::algorithm::equal(shifted.begin(), shifted.end(), ces_shifted, ces_shifted + 9))
        << "from:     " << ce_dumper(cps)
        << "expected: " << ce_dumper(ces_shifted)
        << "got:      " << ce_dumper(shifted);
}

TEST(collation, verbatim_131_280)
{
    uint32_t const cps[2] = { 0x1D7C6, 0x0021 };

    // 1D7C6 0021;	
    // (𝟆) MATHEMATICAL SANS-SERIF BOLD ITALIC KAPPA SYMBOL	[202E 0261 | 0020 0020 | 0005 0002 |]
    uint32_t const ces_non_ignorable[9] = { 0x202E, 0x0261, 0x0000, 0x0020, 0x0020, 0x0000, 0x0005, 0x0002, 0x0000 };

    auto const non_ignorable = collate_for_tests(
        cps, cps + 2, boost::text::variable_weighting::non_ignorable);

    EXPECT_EQ(non_ignorable.size(), 9);
    EXPECT_TRUE(boost::algorithm::equal(non_ignorable.begin(), non_ignorable.end(), ces_non_ignorable, ces_non_ignorable + 9))
        << "from:     " << ce_dumper(cps)
        << "expected: " << ce_dumper(ces_non_ignorable)
        << "got:      " << ce_dumper(non_ignorable);

    // 1D7C6 0021;	
    // (𝟆) MATHEMATICAL SANS-SERIF BOLD ITALIC KAPPA SYMBOL	[202E | 0020 | 0005 | FFFF 0261 |]
    uint32_t const ces_shifted[9] = { 0x202E, 0x0000, 0x0020, 0x0000, 0x0005, 0x0000, 0xFFFF, 0x0261, 0x0000 };

    auto const shifted = collate_for_tests(
        cps, cps + 2, boost::text::variable_weighting::shifted);

    EXPECT_EQ(shifted.size(), 9);
    EXPECT_TRUE(boost::algorithm::equal(shifted.begin(), shifted.end(), ces_shifted, ces_shifted + 9))
        << "from:     " << ce_dumper(cps)
        << "expected: " << ce_dumper(ces_shifted)
        << "got:      " << ce_dumper(shifted);
}

TEST(collation, verbatim_131_281)
{
    uint32_t const cps[2] = { 0x039A, 0x0021 };

    // 039A 0021;	
    // (Κ) GREEK CAPITAL LETTER KAPPA	[202E 0261 | 0020 0020 | 0008 0002 |]
    uint32_t const ces_non_ignorable[9] = { 0x202E, 0x0261, 0x0000, 0x0020, 0x0020, 0x0000, 0x0008, 0x0002, 0x0000 };

    auto const non_ignorable = collate_for_tests(
        cps, cps + 2, boost::text::variable_weighting::non_ignorable);

    EXPECT_EQ(non_ignorable.size(), 9);
    EXPECT_TRUE(boost::algorithm::equal(non_ignorable.begin(), non_ignorable.end(), ces_non_ignorable, ces_non_ignorable + 9))
        << "from:     " << ce_dumper(cps)
        << "expected: " << ce_dumper(ces_non_ignorable)
        << "got:      " << ce_dumper(non_ignorable);

    // 039A 0021;	
    // (Κ) GREEK CAPITAL LETTER KAPPA	[202E | 0020 | 0008 | FFFF 0261 |]
    uint32_t const ces_shifted[9] = { 0x202E, 0x0000, 0x0020, 0x0000, 0x0008, 0x0000, 0xFFFF, 0x0261, 0x0000 };

    auto const shifted = collate_for_tests(
        cps, cps + 2, boost::text::variable_weighting::shifted);

    EXPECT_EQ(shifted.size(), 9);
    EXPECT_TRUE(boost::algorithm::equal(shifted.begin(), shifted.end(), ces_shifted, ces_shifted + 9))
        << "from:     " << ce_dumper(cps)
        << "expected: " << ce_dumper(ces_shifted)
        << "got:      " << ce_dumper(shifted);
}

TEST(collation, verbatim_131_282)
{
    uint32_t const cps[2] = { 0x1D6B1, 0x0021 };

    // 1D6B1 0021;	
    // (𝚱) MATHEMATICAL BOLD CAPITAL KAPPA	[202E 0261 | 0020 0020 | 000B 0002 |]
    uint32_t const ces_non_ignorable[9] = { 0x202E, 0x0261, 0x0000, 0x0020, 0x0020, 0x0000, 0x000B, 0x0002, 0x0000 };

    auto const non_ignorable = collate_for_tests(
        cps, cps + 2, boost::text::variable_weighting::non_ignorable);

    EXPECT_EQ(non_ignorable.size(), 9);
    EXPECT_TRUE(boost::algorithm::equal(non_ignorable.begin(), non_ignorable.end(), ces_non_ignorable, ces_non_ignorable + 9))
        << "from:     " << ce_dumper(cps)
        << "expected: " << ce_dumper(ces_non_ignorable)
        << "got:      " << ce_dumper(non_ignorable);

    // 1D6B1 0021;	
    // (𝚱) MATHEMATICAL BOLD CAPITAL KAPPA	[202E | 0020 | 000B | FFFF 0261 |]
    uint32_t const ces_shifted[9] = { 0x202E, 0x0000, 0x0020, 0x0000, 0x000B, 0x0000, 0xFFFF, 0x0261, 0x0000 };

    auto const shifted = collate_for_tests(
        cps, cps + 2, boost::text::variable_weighting::shifted);

    EXPECT_EQ(shifted.size(), 9);
    EXPECT_TRUE(boost::algorithm::equal(shifted.begin(), shifted.end(), ces_shifted, ces_shifted + 9))
        << "from:     " << ce_dumper(cps)
        << "expected: " << ce_dumper(ces_shifted)
        << "got:      " << ce_dumper(shifted);
}

TEST(collation, verbatim_131_283)
{
    uint32_t const cps[2] = { 0x1D6EB, 0x0021 };

    // 1D6EB 0021;	
    // (𝛫) MATHEMATICAL ITALIC CAPITAL KAPPA	[202E 0261 | 0020 0020 | 000B 0002 |]
    uint32_t const ces_non_ignorable[9] = { 0x202E, 0x0261, 0x0000, 0x0020, 0x0020, 0x0000, 0x000B, 0x0002, 0x0000 };

    auto const non_ignorable = collate_for_tests(
        cps, cps + 2, boost::text::variable_weighting::non_ignorable);

    EXPECT_EQ(non_ignorable.size(), 9);
    EXPECT_TRUE(boost::algorithm::equal(non_ignorable.begin(), non_ignorable.end(), ces_non_ignorable, ces_non_ignorable + 9))
        << "from:     " << ce_dumper(cps)
        << "expected: " << ce_dumper(ces_non_ignorable)
        << "got:      " << ce_dumper(non_ignorable);

    // 1D6EB 0021;	
    // (𝛫) MATHEMATICAL ITALIC CAPITAL KAPPA	[202E | 0020 | 000B | FFFF 0261 |]
    uint32_t const ces_shifted[9] = { 0x202E, 0x0000, 0x0020, 0x0000, 0x000B, 0x0000, 0xFFFF, 0x0261, 0x0000 };

    auto const shifted = collate_for_tests(
        cps, cps + 2, boost::text::variable_weighting::shifted);

    EXPECT_EQ(shifted.size(), 9);
    EXPECT_TRUE(boost::algorithm::equal(shifted.begin(), shifted.end(), ces_shifted, ces_shifted + 9))
        << "from:     " << ce_dumper(cps)
        << "expected: " << ce_dumper(ces_shifted)
        << "got:      " << ce_dumper(shifted);
}

TEST(collation, verbatim_131_284)
{
    uint32_t const cps[2] = { 0x1D725, 0x0021 };

    // 1D725 0021;	
    // (𝜥) MATHEMATICAL BOLD ITALIC CAPITAL KAPPA	[202E 0261 | 0020 0020 | 000B 0002 |]
    uint32_t const ces_non_ignorable[9] = { 0x202E, 0x0261, 0x0000, 0x0020, 0x0020, 0x0000, 0x000B, 0x0002, 0x0000 };

    auto const non_ignorable = collate_for_tests(
        cps, cps + 2, boost::text::variable_weighting::non_ignorable);

    EXPECT_EQ(non_ignorable.size(), 9);
    EXPECT_TRUE(boost::algorithm::equal(non_ignorable.begin(), non_ignorable.end(), ces_non_ignorable, ces_non_ignorable + 9))
        << "from:     " << ce_dumper(cps)
        << "expected: " << ce_dumper(ces_non_ignorable)
        << "got:      " << ce_dumper(non_ignorable);

    // 1D725 0021;	
    // (𝜥) MATHEMATICAL BOLD ITALIC CAPITAL KAPPA	[202E | 0020 | 000B | FFFF 0261 |]
    uint32_t const ces_shifted[9] = { 0x202E, 0x0000, 0x0020, 0x0000, 0x000B, 0x0000, 0xFFFF, 0x0261, 0x0000 };

    auto const shifted = collate_for_tests(
        cps, cps + 2, boost::text::variable_weighting::shifted);

    EXPECT_EQ(shifted.size(), 9);
    EXPECT_TRUE(boost::algorithm::equal(shifted.begin(), shifted.end(), ces_shifted, ces_shifted + 9))
        << "from:     " << ce_dumper(cps)
        << "expected: " << ce_dumper(ces_shifted)
        << "got:      " << ce_dumper(shifted);
}

TEST(collation, verbatim_131_285)
{
    uint32_t const cps[2] = { 0x1D75F, 0x0021 };

    // 1D75F 0021;	
    // (𝝟) MATHEMATICAL SANS-SERIF BOLD CAPITAL KAPPA	[202E 0261 | 0020 0020 | 000B 0002 |]
    uint32_t const ces_non_ignorable[9] = { 0x202E, 0x0261, 0x0000, 0x0020, 0x0020, 0x0000, 0x000B, 0x0002, 0x0000 };

    auto const non_ignorable = collate_for_tests(
        cps, cps + 2, boost::text::variable_weighting::non_ignorable);

    EXPECT_EQ(non_ignorable.size(), 9);
    EXPECT_TRUE(boost::algorithm::equal(non_ignorable.begin(), non_ignorable.end(), ces_non_ignorable, ces_non_ignorable + 9))
        << "from:     " << ce_dumper(cps)
        << "expected: " << ce_dumper(ces_non_ignorable)
        << "got:      " << ce_dumper(non_ignorable);

    // 1D75F 0021;	
    // (𝝟) MATHEMATICAL SANS-SERIF BOLD CAPITAL KAPPA	[202E | 0020 | 000B | FFFF 0261 |]
    uint32_t const ces_shifted[9] = { 0x202E, 0x0000, 0x0020, 0x0000, 0x000B, 0x0000, 0xFFFF, 0x0261, 0x0000 };

    auto const shifted = collate_for_tests(
        cps, cps + 2, boost::text::variable_weighting::shifted);

    EXPECT_EQ(shifted.size(), 9);
    EXPECT_TRUE(boost::algorithm::equal(shifted.begin(), shifted.end(), ces_shifted, ces_shifted + 9))
        << "from:     " << ce_dumper(cps)
        << "expected: " << ce_dumper(ces_shifted)
        << "got:      " << ce_dumper(shifted);
}

TEST(collation, verbatim_131_286)
{
    uint32_t const cps[2] = { 0x1D799, 0x0021 };

    // 1D799 0021;	
    // (𝞙) MATHEMATICAL SANS-SERIF BOLD ITALIC CAPITAL KAPPA	[202E 0261 | 0020 0020 | 000B 0002 |]
    uint32_t const ces_non_ignorable[9] = { 0x202E, 0x0261, 0x0000, 0x0020, 0x0020, 0x0000, 0x000B, 0x0002, 0x0000 };

    auto const non_ignorable = collate_for_tests(
        cps, cps + 2, boost::text::variable_weighting::non_ignorable);

    EXPECT_EQ(non_ignorable.size(), 9);
    EXPECT_TRUE(boost::algorithm::equal(non_ignorable.begin(), non_ignorable.end(), ces_non_ignorable, ces_non_ignorable + 9))
        << "from:     " << ce_dumper(cps)
        << "expected: " << ce_dumper(ces_non_ignorable)
        << "got:      " << ce_dumper(non_ignorable);

    // 1D799 0021;	
    // (𝞙) MATHEMATICAL SANS-SERIF BOLD ITALIC CAPITAL KAPPA	[202E | 0020 | 000B | FFFF 0261 |]
    uint32_t const ces_shifted[9] = { 0x202E, 0x0000, 0x0020, 0x0000, 0x000B, 0x0000, 0xFFFF, 0x0261, 0x0000 };

    auto const shifted = collate_for_tests(
        cps, cps + 2, boost::text::variable_weighting::shifted);

    EXPECT_EQ(shifted.size(), 9);
    EXPECT_TRUE(boost::algorithm::equal(shifted.begin(), shifted.end(), ces_shifted, ces_shifted + 9))
        << "from:     " << ce_dumper(cps)
        << "expected: " << ce_dumper(ces_shifted)
        << "got:      " << ce_dumper(shifted);
}

TEST(collation, verbatim_131_287)
{
    uint32_t const cps[2] = { 0x03BA, 0x003F };

    // 03BA 003F;	
    // (κ) GREEK SMALL LETTER KAPPA	[202E 0267 | 0020 0020 | 0002 0002 |]
    uint32_t const ces_non_ignorable[9] = { 0x202E, 0x0267, 0x0000, 0x0020, 0x0020, 0x0000, 0x0002, 0x0002, 0x0000 };

    auto const non_ignorable = collate_for_tests(
        cps, cps + 2, boost::text::variable_weighting::non_ignorable);

    EXPECT_EQ(non_ignorable.size(), 9);
    EXPECT_TRUE(boost::algorithm::equal(non_ignorable.begin(), non_ignorable.end(), ces_non_ignorable, ces_non_ignorable + 9))
        << "from:     " << ce_dumper(cps)
        << "expected: " << ce_dumper(ces_non_ignorable)
        << "got:      " << ce_dumper(non_ignorable);

    // 03BA 003F;	
    // (κ) GREEK SMALL LETTER KAPPA	[202E | 0020 | 0002 | FFFF 0267 |]
    uint32_t const ces_shifted[9] = { 0x202E, 0x0000, 0x0020, 0x0000, 0x0002, 0x0000, 0xFFFF, 0x0267, 0x0000 };

    auto const shifted = collate_for_tests(
        cps, cps + 2, boost::text::variable_weighting::shifted);

    EXPECT_EQ(shifted.size(), 9);
    EXPECT_TRUE(boost::algorithm::equal(shifted.begin(), shifted.end(), ces_shifted, ces_shifted + 9))
        << "from:     " << ce_dumper(cps)
        << "expected: " << ce_dumper(ces_shifted)
        << "got:      " << ce_dumper(shifted);
}

TEST(collation, verbatim_131_288)
{
    uint32_t const cps[2] = { 0x03F0, 0x003F };

    // 03F0 003F;	
    // (ϰ) GREEK KAPPA SYMBOL	[202E 0267 | 0020 0020 | 0004 0002 |]
    uint32_t const ces_non_ignorable[9] = { 0x202E, 0x0267, 0x0000, 0x0020, 0x0020, 0x0000, 0x0004, 0x0002, 0x0000 };

    auto const non_ignorable = collate_for_tests(
        cps, cps + 2, boost::text::variable_weighting::non_ignorable);

    EXPECT_EQ(non_ignorable.size(), 9);
    EXPECT_TRUE(boost::algorithm::equal(non_ignorable.begin(), non_ignorable.end(), ces_non_ignorable, ces_non_ignorable + 9))
        << "from:     " << ce_dumper(cps)
        << "expected: " << ce_dumper(ces_non_ignorable)
        << "got:      " << ce_dumper(non_ignorable);

    // 03F0 003F;	
    // (ϰ) GREEK KAPPA SYMBOL	[202E | 0020 | 0004 | FFFF 0267 |]
    uint32_t const ces_shifted[9] = { 0x202E, 0x0000, 0x0020, 0x0000, 0x0004, 0x0000, 0xFFFF, 0x0267, 0x0000 };

    auto const shifted = collate_for_tests(
        cps, cps + 2, boost::text::variable_weighting::shifted);

    EXPECT_EQ(shifted.size(), 9);
    EXPECT_TRUE(boost::algorithm::equal(shifted.begin(), shifted.end(), ces_shifted, ces_shifted + 9))
        << "from:     " << ce_dumper(cps)
        << "expected: " << ce_dumper(ces_shifted)
        << "got:      " << ce_dumper(shifted);
}

TEST(collation, verbatim_131_289)
{
    uint32_t const cps[2] = { 0x1D6CB, 0x003F };

    // 1D6CB 003F;	
    // (𝛋) MATHEMATICAL BOLD SMALL KAPPA	[202E 0267 | 0020 0020 | 0005 0002 |]
    uint32_t const ces_non_ignorable[9] = { 0x202E, 0x0267, 0x0000, 0x0020, 0x0020, 0x0000, 0x0005, 0x0002, 0x0000 };

    auto const non_ignorable = collate_for_tests(
        cps, cps + 2, boost::text::variable_weighting::non_ignorable);

    EXPECT_EQ(non_ignorable.size(), 9);
    EXPECT_TRUE(boost::algorithm::equal(non_ignorable.begin(), non_ignorable.end(), ces_non_ignorable, ces_non_ignorable + 9))
        << "from:     " << ce_dumper(cps)
        << "expected: " << ce_dumper(ces_non_ignorable)
        << "got:      " << ce_dumper(non_ignorable);

    // 1D6CB 003F;	
    // (𝛋) MATHEMATICAL BOLD SMALL KAPPA	[202E | 0020 | 0005 | FFFF 0267 |]
    uint32_t const ces_shifted[9] = { 0x202E, 0x0000, 0x0020, 0x0000, 0x0005, 0x0000, 0xFFFF, 0x0267, 0x0000 };

    auto const shifted = collate_for_tests(
        cps, cps + 2, boost::text::variable_weighting::shifted);

    EXPECT_EQ(shifted.size(), 9);
    EXPECT_TRUE(boost::algorithm::equal(shifted.begin(), shifted.end(), ces_shifted, ces_shifted + 9))
        << "from:     " << ce_dumper(cps)
        << "expected: " << ce_dumper(ces_shifted)
        << "got:      " << ce_dumper(shifted);
}

TEST(collation, verbatim_131_290)
{
    uint32_t const cps[2] = { 0x1D6DE, 0x003F };

    // 1D6DE 003F;	
    // (𝛞) MATHEMATICAL BOLD KAPPA SYMBOL	[202E 0267 | 0020 0020 | 0005 0002 |]
    uint32_t const ces_non_ignorable[9] = { 0x202E, 0x0267, 0x0000, 0x0020, 0x0020, 0x0000, 0x0005, 0x0002, 0x0000 };

    auto const non_ignorable = collate_for_tests(
        cps, cps + 2, boost::text::variable_weighting::non_ignorable);

    EXPECT_EQ(non_ignorable.size(), 9);
    EXPECT_TRUE(boost::algorithm::equal(non_ignorable.begin(), non_ignorable.end(), ces_non_ignorable, ces_non_ignorable + 9))
        << "from:     " << ce_dumper(cps)
        << "expected: " << ce_dumper(ces_non_ignorable)
        << "got:      " << ce_dumper(non_ignorable);

    // 1D6DE 003F;	
    // (𝛞) MATHEMATICAL BOLD KAPPA SYMBOL	[202E | 0020 | 0005 | FFFF 0267 |]
    uint32_t const ces_shifted[9] = { 0x202E, 0x0000, 0x0020, 0x0000, 0x0005, 0x0000, 0xFFFF, 0x0267, 0x0000 };

    auto const shifted = collate_for_tests(
        cps, cps + 2, boost::text::variable_weighting::shifted);

    EXPECT_EQ(shifted.size(), 9);
    EXPECT_TRUE(boost::algorithm::equal(shifted.begin(), shifted.end(), ces_shifted, ces_shifted + 9))
        << "from:     " << ce_dumper(cps)
        << "expected: " << ce_dumper(ces_shifted)
        << "got:      " << ce_dumper(shifted);
}

TEST(collation, verbatim_131_291)
{
    uint32_t const cps[2] = { 0x1D705, 0x003F };

    // 1D705 003F;	
    // (𝜅) MATHEMATICAL ITALIC SMALL KAPPA	[202E 0267 | 0020 0020 | 0005 0002 |]
    uint32_t const ces_non_ignorable[9] = { 0x202E, 0x0267, 0x0000, 0x0020, 0x0020, 0x0000, 0x0005, 0x0002, 0x0000 };

    auto const non_ignorable = collate_for_tests(
        cps, cps + 2, boost::text::variable_weighting::non_ignorable);

    EXPECT_EQ(non_ignorable.size(), 9);
    EXPECT_TRUE(boost::algorithm::equal(non_ignorable.begin(), non_ignorable.end(), ces_non_ignorable, ces_non_ignorable + 9))
        << "from:     " << ce_dumper(cps)
        << "expected: " << ce_dumper(ces_non_ignorable)
        << "got:      " << ce_dumper(non_ignorable);

    // 1D705 003F;	
    // (𝜅) MATHEMATICAL ITALIC SMALL KAPPA	[202E | 0020 | 0005 | FFFF 0267 |]
    uint32_t const ces_shifted[9] = { 0x202E, 0x0000, 0x0020, 0x0000, 0x0005, 0x0000, 0xFFFF, 0x0267, 0x0000 };

    auto const shifted = collate_for_tests(
        cps, cps + 2, boost::text::variable_weighting::shifted);

    EXPECT_EQ(shifted.size(), 9);
    EXPECT_TRUE(boost::algorithm::equal(shifted.begin(), shifted.end(), ces_shifted, ces_shifted + 9))
        << "from:     " << ce_dumper(cps)
        << "expected: " << ce_dumper(ces_shifted)
        << "got:      " << ce_dumper(shifted);
}

TEST(collation, verbatim_131_292)
{
    uint32_t const cps[2] = { 0x1D718, 0x003F };

    // 1D718 003F;	
    // (𝜘) MATHEMATICAL ITALIC KAPPA SYMBOL	[202E 0267 | 0020 0020 | 0005 0002 |]
    uint32_t const ces_non_ignorable[9] = { 0x202E, 0x0267, 0x0000, 0x0020, 0x0020, 0x0000, 0x0005, 0x0002, 0x0000 };

    auto const non_ignorable = collate_for_tests(
        cps, cps + 2, boost::text::variable_weighting::non_ignorable);

    EXPECT_EQ(non_ignorable.size(), 9);
    EXPECT_TRUE(boost::algorithm::equal(non_ignorable.begin(), non_ignorable.end(), ces_non_ignorable, ces_non_ignorable + 9))
        << "from:     " << ce_dumper(cps)
        << "expected: " << ce_dumper(ces_non_ignorable)
        << "got:      " << ce_dumper(non_ignorable);

    // 1D718 003F;	
    // (𝜘) MATHEMATICAL ITALIC KAPPA SYMBOL	[202E | 0020 | 0005 | FFFF 0267 |]
    uint32_t const ces_shifted[9] = { 0x202E, 0x0000, 0x0020, 0x0000, 0x0005, 0x0000, 0xFFFF, 0x0267, 0x0000 };

    auto const shifted = collate_for_tests(
        cps, cps + 2, boost::text::variable_weighting::shifted);

    EXPECT_EQ(shifted.size(), 9);
    EXPECT_TRUE(boost::algorithm::equal(shifted.begin(), shifted.end(), ces_shifted, ces_shifted + 9))
        << "from:     " << ce_dumper(cps)
        << "expected: " << ce_dumper(ces_shifted)
        << "got:      " << ce_dumper(shifted);
}

TEST(collation, verbatim_131_293)
{
    uint32_t const cps[2] = { 0x1D73F, 0x003F };

    // 1D73F 003F;	
    // (𝜿) MATHEMATICAL BOLD ITALIC SMALL KAPPA	[202E 0267 | 0020 0020 | 0005 0002 |]
    uint32_t const ces_non_ignorable[9] = { 0x202E, 0x0267, 0x0000, 0x0020, 0x0020, 0x0000, 0x0005, 0x0002, 0x0000 };

    auto const non_ignorable = collate_for_tests(
        cps, cps + 2, boost::text::variable_weighting::non_ignorable);

    EXPECT_EQ(non_ignorable.size(), 9);
    EXPECT_TRUE(boost::algorithm::equal(non_ignorable.begin(), non_ignorable.end(), ces_non_ignorable, ces_non_ignorable + 9))
        << "from:     " << ce_dumper(cps)
        << "expected: " << ce_dumper(ces_non_ignorable)
        << "got:      " << ce_dumper(non_ignorable);

    // 1D73F 003F;	
    // (𝜿) MATHEMATICAL BOLD ITALIC SMALL KAPPA	[202E | 0020 | 0005 | FFFF 0267 |]
    uint32_t const ces_shifted[9] = { 0x202E, 0x0000, 0x0020, 0x0000, 0x0005, 0x0000, 0xFFFF, 0x0267, 0x0000 };

    auto const shifted = collate_for_tests(
        cps, cps + 2, boost::text::variable_weighting::shifted);

    EXPECT_EQ(shifted.size(), 9);
    EXPECT_TRUE(boost::algorithm::equal(shifted.begin(), shifted.end(), ces_shifted, ces_shifted + 9))
        << "from:     " << ce_dumper(cps)
        << "expected: " << ce_dumper(ces_shifted)
        << "got:      " << ce_dumper(shifted);
}

TEST(collation, verbatim_131_294)
{
    uint32_t const cps[2] = { 0x1D752, 0x003F };

    // 1D752 003F;	
    // (𝝒) MATHEMATICAL BOLD ITALIC KAPPA SYMBOL	[202E 0267 | 0020 0020 | 0005 0002 |]
    uint32_t const ces_non_ignorable[9] = { 0x202E, 0x0267, 0x0000, 0x0020, 0x0020, 0x0000, 0x0005, 0x0002, 0x0000 };

    auto const non_ignorable = collate_for_tests(
        cps, cps + 2, boost::text::variable_weighting::non_ignorable);

    EXPECT_EQ(non_ignorable.size(), 9);
    EXPECT_TRUE(boost::algorithm::equal(non_ignorable.begin(), non_ignorable.end(), ces_non_ignorable, ces_non_ignorable + 9))
        << "from:     " << ce_dumper(cps)
        << "expected: " << ce_dumper(ces_non_ignorable)
        << "got:      " << ce_dumper(non_ignorable);

    // 1D752 003F;	
    // (𝝒) MATHEMATICAL BOLD ITALIC KAPPA SYMBOL	[202E | 0020 | 0005 | FFFF 0267 |]
    uint32_t const ces_shifted[9] = { 0x202E, 0x0000, 0x0020, 0x0000, 0x0005, 0x0000, 0xFFFF, 0x0267, 0x0000 };

    auto const shifted = collate_for_tests(
        cps, cps + 2, boost::text::variable_weighting::shifted);

    EXPECT_EQ(shifted.size(), 9);
    EXPECT_TRUE(boost::algorithm::equal(shifted.begin(), shifted.end(), ces_shifted, ces_shifted + 9))
        << "from:     " << ce_dumper(cps)
        << "expected: " << ce_dumper(ces_shifted)
        << "got:      " << ce_dumper(shifted);
}

TEST(collation, verbatim_131_295)
{
    uint32_t const cps[2] = { 0x1D779, 0x003F };

    // 1D779 003F;	
    // (𝝹) MATHEMATICAL SANS-SERIF BOLD SMALL KAPPA	[202E 0267 | 0020 0020 | 0005 0002 |]
    uint32_t const ces_non_ignorable[9] = { 0x202E, 0x0267, 0x0000, 0x0020, 0x0020, 0x0000, 0x0005, 0x0002, 0x0000 };

    auto const non_ignorable = collate_for_tests(
        cps, cps + 2, boost::text::variable_weighting::non_ignorable);

    EXPECT_EQ(non_ignorable.size(), 9);
    EXPECT_TRUE(boost::algorithm::equal(non_ignorable.begin(), non_ignorable.end(), ces_non_ignorable, ces_non_ignorable + 9))
        << "from:     " << ce_dumper(cps)
        << "expected: " << ce_dumper(ces_non_ignorable)
        << "got:      " << ce_dumper(non_ignorable);

    // 1D779 003F;	
    // (𝝹) MATHEMATICAL SANS-SERIF BOLD SMALL KAPPA	[202E | 0020 | 0005 | FFFF 0267 |]
    uint32_t const ces_shifted[9] = { 0x202E, 0x0000, 0x0020, 0x0000, 0x0005, 0x0000, 0xFFFF, 0x0267, 0x0000 };

    auto const shifted = collate_for_tests(
        cps, cps + 2, boost::text::variable_weighting::shifted);

    EXPECT_EQ(shifted.size(), 9);
    EXPECT_TRUE(boost::algorithm::equal(shifted.begin(), shifted.end(), ces_shifted, ces_shifted + 9))
        << "from:     " << ce_dumper(cps)
        << "expected: " << ce_dumper(ces_shifted)
        << "got:      " << ce_dumper(shifted);
}

TEST(collation, verbatim_131_296)
{
    uint32_t const cps[2] = { 0x1D78C, 0x003F };

    // 1D78C 003F;	
    // (𝞌) MATHEMATICAL SANS-SERIF BOLD KAPPA SYMBOL	[202E 0267 | 0020 0020 | 0005 0002 |]
    uint32_t const ces_non_ignorable[9] = { 0x202E, 0x0267, 0x0000, 0x0020, 0x0020, 0x0000, 0x0005, 0x0002, 0x0000 };

    auto const non_ignorable = collate_for_tests(
        cps, cps + 2, boost::text::variable_weighting::non_ignorable);

    EXPECT_EQ(non_ignorable.size(), 9);
    EXPECT_TRUE(boost::algorithm::equal(non_ignorable.begin(), non_ignorable.end(), ces_non_ignorable, ces_non_ignorable + 9))
        << "from:     " << ce_dumper(cps)
        << "expected: " << ce_dumper(ces_non_ignorable)
        << "got:      " << ce_dumper(non_ignorable);

    // 1D78C 003F;	
    // (𝞌) MATHEMATICAL SANS-SERIF BOLD KAPPA SYMBOL	[202E | 0020 | 0005 | FFFF 0267 |]
    uint32_t const ces_shifted[9] = { 0x202E, 0x0000, 0x0020, 0x0000, 0x0005, 0x0000, 0xFFFF, 0x0267, 0x0000 };

    auto const shifted = collate_for_tests(
        cps, cps + 2, boost::text::variable_weighting::shifted);

    EXPECT_EQ(shifted.size(), 9);
    EXPECT_TRUE(boost::algorithm::equal(shifted.begin(), shifted.end(), ces_shifted, ces_shifted + 9))
        << "from:     " << ce_dumper(cps)
        << "expected: " << ce_dumper(ces_shifted)
        << "got:      " << ce_dumper(shifted);
}

TEST(collation, verbatim_131_297)
{
    uint32_t const cps[2] = { 0x1D7B3, 0x003F };

    // 1D7B3 003F;	
    // (𝞳) MATHEMATICAL SANS-SERIF BOLD ITALIC SMALL KAPPA	[202E 0267 | 0020 0020 | 0005 0002 |]
    uint32_t const ces_non_ignorable[9] = { 0x202E, 0x0267, 0x0000, 0x0020, 0x0020, 0x0000, 0x0005, 0x0002, 0x0000 };

    auto const non_ignorable = collate_for_tests(
        cps, cps + 2, boost::text::variable_weighting::non_ignorable);

    EXPECT_EQ(non_ignorable.size(), 9);
    EXPECT_TRUE(boost::algorithm::equal(non_ignorable.begin(), non_ignorable.end(), ces_non_ignorable, ces_non_ignorable + 9))
        << "from:     " << ce_dumper(cps)
        << "expected: " << ce_dumper(ces_non_ignorable)
        << "got:      " << ce_dumper(non_ignorable);

    // 1D7B3 003F;	
    // (𝞳) MATHEMATICAL SANS-SERIF BOLD ITALIC SMALL KAPPA	[202E | 0020 | 0005 | FFFF 0267 |]
    uint32_t const ces_shifted[9] = { 0x202E, 0x0000, 0x0020, 0x0000, 0x0005, 0x0000, 0xFFFF, 0x0267, 0x0000 };

    auto const shifted = collate_for_tests(
        cps, cps + 2, boost::text::variable_weighting::shifted);

    EXPECT_EQ(shifted.size(), 9);
    EXPECT_TRUE(boost::algorithm::equal(shifted.begin(), shifted.end(), ces_shifted, ces_shifted + 9))
        << "from:     " << ce_dumper(cps)
        << "expected: " << ce_dumper(ces_shifted)
        << "got:      " << ce_dumper(shifted);
}

TEST(collation, verbatim_131_298)
{
    uint32_t const cps[2] = { 0x1D7C6, 0x003F };

    // 1D7C6 003F;	
    // (𝟆) MATHEMATICAL SANS-SERIF BOLD ITALIC KAPPA SYMBOL	[202E 0267 | 0020 0020 | 0005 0002 |]
    uint32_t const ces_non_ignorable[9] = { 0x202E, 0x0267, 0x0000, 0x0020, 0x0020, 0x0000, 0x0005, 0x0002, 0x0000 };

    auto const non_ignorable = collate_for_tests(
        cps, cps + 2, boost::text::variable_weighting::non_ignorable);

    EXPECT_EQ(non_ignorable.size(), 9);
    EXPECT_TRUE(boost::algorithm::equal(non_ignorable.begin(), non_ignorable.end(), ces_non_ignorable, ces_non_ignorable + 9))
        << "from:     " << ce_dumper(cps)
        << "expected: " << ce_dumper(ces_non_ignorable)
        << "got:      " << ce_dumper(non_ignorable);

    // 1D7C6 003F;	
    // (𝟆) MATHEMATICAL SANS-SERIF BOLD ITALIC KAPPA SYMBOL	[202E | 0020 | 0005 | FFFF 0267 |]
    uint32_t const ces_shifted[9] = { 0x202E, 0x0000, 0x0020, 0x0000, 0x0005, 0x0000, 0xFFFF, 0x0267, 0x0000 };

    auto const shifted = collate_for_tests(
        cps, cps + 2, boost::text::variable_weighting::shifted);

    EXPECT_EQ(shifted.size(), 9);
    EXPECT_TRUE(boost::algorithm::equal(shifted.begin(), shifted.end(), ces_shifted, ces_shifted + 9))
        << "from:     " << ce_dumper(cps)
        << "expected: " << ce_dumper(ces_shifted)
        << "got:      " << ce_dumper(shifted);
}

TEST(collation, verbatim_131_299)
{
    uint32_t const cps[2] = { 0x039A, 0x003F };

    // 039A 003F;	
    // (Κ) GREEK CAPITAL LETTER KAPPA	[202E 0267 | 0020 0020 | 0008 0002 |]
    uint32_t const ces_non_ignorable[9] = { 0x202E, 0x0267, 0x0000, 0x0020, 0x0020, 0x0000, 0x0008, 0x0002, 0x0000 };

    auto const non_ignorable = collate_for_tests(
        cps, cps + 2, boost::text::variable_weighting::non_ignorable);

    EXPECT_EQ(non_ignorable.size(), 9);
    EXPECT_TRUE(boost::algorithm::equal(non_ignorable.begin(), non_ignorable.end(), ces_non_ignorable, ces_non_ignorable + 9))
        << "from:     " << ce_dumper(cps)
        << "expected: " << ce_dumper(ces_non_ignorable)
        << "got:      " << ce_dumper(non_ignorable);

    // 039A 003F;	
    // (Κ) GREEK CAPITAL LETTER KAPPA	[202E | 0020 | 0008 | FFFF 0267 |]
    uint32_t const ces_shifted[9] = { 0x202E, 0x0000, 0x0020, 0x0000, 0x0008, 0x0000, 0xFFFF, 0x0267, 0x0000 };

    auto const shifted = collate_for_tests(
        cps, cps + 2, boost::text::variable_weighting::shifted);

    EXPECT_EQ(shifted.size(), 9);
    EXPECT_TRUE(boost::algorithm::equal(shifted.begin(), shifted.end(), ces_shifted, ces_shifted + 9))
        << "from:     " << ce_dumper(cps)
        << "expected: " << ce_dumper(ces_shifted)
        << "got:      " << ce_dumper(shifted);
}

TEST(collation, verbatim_131_300)
{
    uint32_t const cps[2] = { 0x1D6B1, 0x003F };

    // 1D6B1 003F;	
    // (𝚱) MATHEMATICAL BOLD CAPITAL KAPPA	[202E 0267 | 0020 0020 | 000B 0002 |]
    uint32_t const ces_non_ignorable[9] = { 0x202E, 0x0267, 0x0000, 0x0020, 0x0020, 0x0000, 0x000B, 0x0002, 0x0000 };

    auto const non_ignorable = collate_for_tests(
        cps, cps + 2, boost::text::variable_weighting::non_ignorable);

    EXPECT_EQ(non_ignorable.size(), 9);
    EXPECT_TRUE(boost::algorithm::equal(non_ignorable.begin(), non_ignorable.end(), ces_non_ignorable, ces_non_ignorable + 9))
        << "from:     " << ce_dumper(cps)
        << "expected: " << ce_dumper(ces_non_ignorable)
        << "got:      " << ce_dumper(non_ignorable);

    // 1D6B1 003F;	
    // (𝚱) MATHEMATICAL BOLD CAPITAL KAPPA	[202E | 0020 | 000B | FFFF 0267 |]
    uint32_t const ces_shifted[9] = { 0x202E, 0x0000, 0x0020, 0x0000, 0x000B, 0x0000, 0xFFFF, 0x0267, 0x0000 };

    auto const shifted = collate_for_tests(
        cps, cps + 2, boost::text::variable_weighting::shifted);

    EXPECT_EQ(shifted.size(), 9);
    EXPECT_TRUE(boost::algorithm::equal(shifted.begin(), shifted.end(), ces_shifted, ces_shifted + 9))
        << "from:     " << ce_dumper(cps)
        << "expected: " << ce_dumper(ces_shifted)
        << "got:      " << ce_dumper(shifted);
}

TEST(collation, verbatim_131_301)
{
    uint32_t const cps[2] = { 0x1D6EB, 0x003F };

    // 1D6EB 003F;	
    // (𝛫) MATHEMATICAL ITALIC CAPITAL KAPPA	[202E 0267 | 0020 0020 | 000B 0002 |]
    uint32_t const ces_non_ignorable[9] = { 0x202E, 0x0267, 0x0000, 0x0020, 0x0020, 0x0000, 0x000B, 0x0002, 0x0000 };

    auto const non_ignorable = collate_for_tests(
        cps, cps + 2, boost::text::variable_weighting::non_ignorable);

    EXPECT_EQ(non_ignorable.size(), 9);
    EXPECT_TRUE(boost::algorithm::equal(non_ignorable.begin(), non_ignorable.end(), ces_non_ignorable, ces_non_ignorable + 9))
        << "from:     " << ce_dumper(cps)
        << "expected: " << ce_dumper(ces_non_ignorable)
        << "got:      " << ce_dumper(non_ignorable);

    // 1D6EB 003F;	
    // (𝛫) MATHEMATICAL ITALIC CAPITAL KAPPA	[202E | 0020 | 000B | FFFF 0267 |]
    uint32_t const ces_shifted[9] = { 0x202E, 0x0000, 0x0020, 0x0000, 0x000B, 0x0000, 0xFFFF, 0x0267, 0x0000 };

    auto const shifted = collate_for_tests(
        cps, cps + 2, boost::text::variable_weighting::shifted);

    EXPECT_EQ(shifted.size(), 9);
    EXPECT_TRUE(boost::algorithm::equal(shifted.begin(), shifted.end(), ces_shifted, ces_shifted + 9))
        << "from:     " << ce_dumper(cps)
        << "expected: " << ce_dumper(ces_shifted)
        << "got:      " << ce_dumper(shifted);
}

TEST(collation, verbatim_131_302)
{
    uint32_t const cps[2] = { 0x1D725, 0x003F };

    // 1D725 003F;	
    // (𝜥) MATHEMATICAL BOLD ITALIC CAPITAL KAPPA	[202E 0267 | 0020 0020 | 000B 0002 |]
    uint32_t const ces_non_ignorable[9] = { 0x202E, 0x0267, 0x0000, 0x0020, 0x0020, 0x0000, 0x000B, 0x0002, 0x0000 };

    auto const non_ignorable = collate_for_tests(
        cps, cps + 2, boost::text::variable_weighting::non_ignorable);

    EXPECT_EQ(non_ignorable.size(), 9);
    EXPECT_TRUE(boost::algorithm::equal(non_ignorable.begin(), non_ignorable.end(), ces_non_ignorable, ces_non_ignorable + 9))
        << "from:     " << ce_dumper(cps)
        << "expected: " << ce_dumper(ces_non_ignorable)
        << "got:      " << ce_dumper(non_ignorable);

    // 1D725 003F;	
    // (𝜥) MATHEMATICAL BOLD ITALIC CAPITAL KAPPA	[202E | 0020 | 000B | FFFF 0267 |]
    uint32_t const ces_shifted[9] = { 0x202E, 0x0000, 0x0020, 0x0000, 0x000B, 0x0000, 0xFFFF, 0x0267, 0x0000 };

    auto const shifted = collate_for_tests(
        cps, cps + 2, boost::text::variable_weighting::shifted);

    EXPECT_EQ(shifted.size(), 9);
    EXPECT_TRUE(boost::algorithm::equal(shifted.begin(), shifted.end(), ces_shifted, ces_shifted + 9))
        << "from:     " << ce_dumper(cps)
        << "expected: " << ce_dumper(ces_shifted)
        << "got:      " << ce_dumper(shifted);
}

TEST(collation, verbatim_131_303)
{
    uint32_t const cps[2] = { 0x1D75F, 0x003F };

    // 1D75F 003F;	
    // (𝝟) MATHEMATICAL SANS-SERIF BOLD CAPITAL KAPPA	[202E 0267 | 0020 0020 | 000B 0002 |]
    uint32_t const ces_non_ignorable[9] = { 0x202E, 0x0267, 0x0000, 0x0020, 0x0020, 0x0000, 0x000B, 0x0002, 0x0000 };

    auto const non_ignorable = collate_for_tests(
        cps, cps + 2, boost::text::variable_weighting::non_ignorable);

    EXPECT_EQ(non_ignorable.size(), 9);
    EXPECT_TRUE(boost::algorithm::equal(non_ignorable.begin(), non_ignorable.end(), ces_non_ignorable, ces_non_ignorable + 9))
        << "from:     " << ce_dumper(cps)
        << "expected: " << ce_dumper(ces_non_ignorable)
        << "got:      " << ce_dumper(non_ignorable);

    // 1D75F 003F;	
    // (𝝟) MATHEMATICAL SANS-SERIF BOLD CAPITAL KAPPA	[202E | 0020 | 000B | FFFF 0267 |]
    uint32_t const ces_shifted[9] = { 0x202E, 0x0000, 0x0020, 0x0000, 0x000B, 0x0000, 0xFFFF, 0x0267, 0x0000 };

    auto const shifted = collate_for_tests(
        cps, cps + 2, boost::text::variable_weighting::shifted);

    EXPECT_EQ(shifted.size(), 9);
    EXPECT_TRUE(boost::algorithm::equal(shifted.begin(), shifted.end(), ces_shifted, ces_shifted + 9))
        << "from:     " << ce_dumper(cps)
        << "expected: " << ce_dumper(ces_shifted)
        << "got:      " << ce_dumper(shifted);
}

TEST(collation, verbatim_131_304)
{
    uint32_t const cps[2] = { 0x1D799, 0x003F };

    // 1D799 003F;	
    // (𝞙) MATHEMATICAL SANS-SERIF BOLD ITALIC CAPITAL KAPPA	[202E 0267 | 0020 0020 | 000B 0002 |]
    uint32_t const ces_non_ignorable[9] = { 0x202E, 0x0267, 0x0000, 0x0020, 0x0020, 0x0000, 0x000B, 0x0002, 0x0000 };

    auto const non_ignorable = collate_for_tests(
        cps, cps + 2, boost::text::variable_weighting::non_ignorable);

    EXPECT_EQ(non_ignorable.size(), 9);
    EXPECT_TRUE(boost::algorithm::equal(non_ignorable.begin(), non_ignorable.end(), ces_non_ignorable, ces_non_ignorable + 9))
        << "from:     " << ce_dumper(cps)
        << "expected: " << ce_dumper(ces_non_ignorable)
        << "got:      " << ce_dumper(non_ignorable);

    // 1D799 003F;	
    // (𝞙) MATHEMATICAL SANS-SERIF BOLD ITALIC CAPITAL KAPPA	[202E | 0020 | 000B | FFFF 0267 |]
    uint32_t const ces_shifted[9] = { 0x202E, 0x0000, 0x0020, 0x0000, 0x000B, 0x0000, 0xFFFF, 0x0267, 0x0000 };

    auto const shifted = collate_for_tests(
        cps, cps + 2, boost::text::variable_weighting::shifted);

    EXPECT_EQ(shifted.size(), 9);
    EXPECT_TRUE(boost::algorithm::equal(shifted.begin(), shifted.end(), ces_shifted, ces_shifted + 9))
        << "from:     " << ce_dumper(cps)
        << "expected: " << ce_dumper(ces_shifted)
        << "got:      " << ce_dumper(shifted);
}

TEST(collation, verbatim_131_305)
{
    uint32_t const cps[2] = { 0x03BA, 0x0061 };

    // 03BA 0061;	
    // (κ) GREEK SMALL LETTER KAPPA	[202E 1CAD | 0020 0020 | 0002 0002 |]
    uint32_t const ces_non_ignorable[9] = { 0x202E, 0x1CAD, 0x0000, 0x0020, 0x0020, 0x0000, 0x0002, 0x0002, 0x0000 };

    auto const non_ignorable = collate_for_tests(
        cps, cps + 2, boost::text::variable_weighting::non_ignorable);

    EXPECT_EQ(non_ignorable.size(), 9);
    EXPECT_TRUE(boost::algorithm::equal(non_ignorable.begin(), non_ignorable.end(), ces_non_ignorable, ces_non_ignorable + 9))
        << "from:     " << ce_dumper(cps)
        << "expected: " << ce_dumper(ces_non_ignorable)
        << "got:      " << ce_dumper(non_ignorable);

    // 03BA 0061;	
    // (κ) GREEK SMALL LETTER KAPPA	[202E 1CAD | 0020 0020 | 0002 0002 | FFFF FFFF |]
    uint32_t const ces_shifted[12] = { 0x202E, 0x1CAD, 0x0000, 0x0020, 0x0020, 0x0000, 0x0002, 0x0002, 0x0000, 0xFFFF, 0xFFFF, 0x0000 };

    auto const shifted = collate_for_tests(
        cps, cps + 2, boost::text::variable_weighting::shifted);

    EXPECT_EQ(shifted.size(), 12);
    EXPECT_TRUE(boost::algorithm::equal(shifted.begin(), shifted.end(), ces_shifted, ces_shifted + 12))
        << "from:     " << ce_dumper(cps)
        << "expected: " << ce_dumper(ces_shifted)
        << "got:      " << ce_dumper(shifted);
}

TEST(collation, verbatim_131_306)
{
    uint32_t const cps[2] = { 0x03BA, 0x0041 };

    // 03BA 0041;	
    // (κ) GREEK SMALL LETTER KAPPA	[202E 1CAD | 0020 0020 | 0002 0008 |]
    uint32_t const ces_non_ignorable[9] = { 0x202E, 0x1CAD, 0x0000, 0x0020, 0x0020, 0x0000, 0x0002, 0x0008, 0x0000 };

    auto const non_ignorable = collate_for_tests(
        cps, cps + 2, boost::text::variable_weighting::non_ignorable);

    EXPECT_EQ(non_ignorable.size(), 9);
    EXPECT_TRUE(boost::algorithm::equal(non_ignorable.begin(), non_ignorable.end(), ces_non_ignorable, ces_non_ignorable + 9))
        << "from:     " << ce_dumper(cps)
        << "expected: " << ce_dumper(ces_non_ignorable)
        << "got:      " << ce_dumper(non_ignorable);

    // 03BA 0041;	
    // (κ) GREEK SMALL LETTER KAPPA	[202E 1CAD | 0020 0020 | 0002 0008 | FFFF FFFF |]
    uint32_t const ces_shifted[12] = { 0x202E, 0x1CAD, 0x0000, 0x0020, 0x0020, 0x0000, 0x0002, 0x0008, 0x0000, 0xFFFF, 0xFFFF, 0x0000 };

    auto const shifted = collate_for_tests(
        cps, cps + 2, boost::text::variable_weighting::shifted);

    EXPECT_EQ(shifted.size(), 12);
    EXPECT_TRUE(boost::algorithm::equal(shifted.begin(), shifted.end(), ces_shifted, ces_shifted + 12))
        << "from:     " << ce_dumper(cps)
        << "expected: " << ce_dumper(ces_shifted)
        << "got:      " << ce_dumper(shifted);
}

TEST(collation, verbatim_131_307)
{
    uint32_t const cps[2] = { 0x03F0, 0x0061 };

    // 03F0 0061;	
    // (ϰ) GREEK KAPPA SYMBOL	[202E 1CAD | 0020 0020 | 0004 0002 |]
    uint32_t const ces_non_ignorable[9] = { 0x202E, 0x1CAD, 0x0000, 0x0020, 0x0020, 0x0000, 0x0004, 0x0002, 0x0000 };

    auto const non_ignorable = collate_for_tests(
        cps, cps + 2, boost::text::variable_weighting::non_ignorable);

    EXPECT_EQ(non_ignorable.size(), 9);
    EXPECT_TRUE(boost::algorithm::equal(non_ignorable.begin(), non_ignorable.end(), ces_non_ignorable, ces_non_ignorable + 9))
        << "from:     " << ce_dumper(cps)
        << "expected: " << ce_dumper(ces_non_ignorable)
        << "got:      " << ce_dumper(non_ignorable);

    // 03F0 0061;	
    // (ϰ) GREEK KAPPA SYMBOL	[202E 1CAD | 0020 0020 | 0004 0002 | FFFF FFFF |]
    uint32_t const ces_shifted[12] = { 0x202E, 0x1CAD, 0x0000, 0x0020, 0x0020, 0x0000, 0x0004, 0x0002, 0x0000, 0xFFFF, 0xFFFF, 0x0000 };

    auto const shifted = collate_for_tests(
        cps, cps + 2, boost::text::variable_weighting::shifted);

    EXPECT_EQ(shifted.size(), 12);
    EXPECT_TRUE(boost::algorithm::equal(shifted.begin(), shifted.end(), ces_shifted, ces_shifted + 12))
        << "from:     " << ce_dumper(cps)
        << "expected: " << ce_dumper(ces_shifted)
        << "got:      " << ce_dumper(shifted);
}

TEST(collation, verbatim_131_308)
{
    uint32_t const cps[2] = { 0x03F0, 0x0041 };

    // 03F0 0041;	
    // (ϰ) GREEK KAPPA SYMBOL	[202E 1CAD | 0020 0020 | 0004 0008 |]
    uint32_t const ces_non_ignorable[9] = { 0x202E, 0x1CAD, 0x0000, 0x0020, 0x0020, 0x0000, 0x0004, 0x0008, 0x0000 };

    auto const non_ignorable = collate_for_tests(
        cps, cps + 2, boost::text::variable_weighting::non_ignorable);

    EXPECT_EQ(non_ignorable.size(), 9);
    EXPECT_TRUE(boost::algorithm::equal(non_ignorable.begin(), non_ignorable.end(), ces_non_ignorable, ces_non_ignorable + 9))
        << "from:     " << ce_dumper(cps)
        << "expected: " << ce_dumper(ces_non_ignorable)
        << "got:      " << ce_dumper(non_ignorable);

    // 03F0 0041;	
    // (ϰ) GREEK KAPPA SYMBOL	[202E 1CAD | 0020 0020 | 0004 0008 | FFFF FFFF |]
    uint32_t const ces_shifted[12] = { 0x202E, 0x1CAD, 0x0000, 0x0020, 0x0020, 0x0000, 0x0004, 0x0008, 0x0000, 0xFFFF, 0xFFFF, 0x0000 };

    auto const shifted = collate_for_tests(
        cps, cps + 2, boost::text::variable_weighting::shifted);

    EXPECT_EQ(shifted.size(), 12);
    EXPECT_TRUE(boost::algorithm::equal(shifted.begin(), shifted.end(), ces_shifted, ces_shifted + 12))
        << "from:     " << ce_dumper(cps)
        << "expected: " << ce_dumper(ces_shifted)
        << "got:      " << ce_dumper(shifted);
}

TEST(collation, verbatim_131_309)
{
    uint32_t const cps[2] = { 0x1D6CB, 0x0061 };

    // 1D6CB 0061;	
    // (𝛋) MATHEMATICAL BOLD SMALL KAPPA	[202E 1CAD | 0020 0020 | 0005 0002 |]
    uint32_t const ces_non_ignorable[9] = { 0x202E, 0x1CAD, 0x0000, 0x0020, 0x0020, 0x0000, 0x0005, 0x0002, 0x0000 };

    auto const non_ignorable = collate_for_tests(
        cps, cps + 2, boost::text::variable_weighting::non_ignorable);

    EXPECT_EQ(non_ignorable.size(), 9);
    EXPECT_TRUE(boost::algorithm::equal(non_ignorable.begin(), non_ignorable.end(), ces_non_ignorable, ces_non_ignorable + 9))
        << "from:     " << ce_dumper(cps)
        << "expected: " << ce_dumper(ces_non_ignorable)
        << "got:      " << ce_dumper(non_ignorable);

    // 1D6CB 0061;	
    // (𝛋) MATHEMATICAL BOLD SMALL KAPPA	[202E 1CAD | 0020 0020 | 0005 0002 | FFFF FFFF |]
    uint32_t const ces_shifted[12] = { 0x202E, 0x1CAD, 0x0000, 0x0020, 0x0020, 0x0000, 0x0005, 0x0002, 0x0000, 0xFFFF, 0xFFFF, 0x0000 };

    auto const shifted = collate_for_tests(
        cps, cps + 2, boost::text::variable_weighting::shifted);

    EXPECT_EQ(shifted.size(), 12);
    EXPECT_TRUE(boost::algorithm::equal(shifted.begin(), shifted.end(), ces_shifted, ces_shifted + 12))
        << "from:     " << ce_dumper(cps)
        << "expected: " << ce_dumper(ces_shifted)
        << "got:      " << ce_dumper(shifted);
}

TEST(collation, verbatim_131_310)
{
    uint32_t const cps[2] = { 0x1D6DE, 0x0061 };

    // 1D6DE 0061;	
    // (𝛞) MATHEMATICAL BOLD KAPPA SYMBOL	[202E 1CAD | 0020 0020 | 0005 0002 |]
    uint32_t const ces_non_ignorable[9] = { 0x202E, 0x1CAD, 0x0000, 0x0020, 0x0020, 0x0000, 0x0005, 0x0002, 0x0000 };

    auto const non_ignorable = collate_for_tests(
        cps, cps + 2, boost::text::variable_weighting::non_ignorable);

    EXPECT_EQ(non_ignorable.size(), 9);
    EXPECT_TRUE(boost::algorithm::equal(non_ignorable.begin(), non_ignorable.end(), ces_non_ignorable, ces_non_ignorable + 9))
        << "from:     " << ce_dumper(cps)
        << "expected: " << ce_dumper(ces_non_ignorable)
        << "got:      " << ce_dumper(non_ignorable);

    // 1D6DE 0061;	
    // (𝛞) MATHEMATICAL BOLD KAPPA SYMBOL	[202E 1CAD | 0020 0020 | 0005 0002 | FFFF FFFF |]
    uint32_t const ces_shifted[12] = { 0x202E, 0x1CAD, 0x0000, 0x0020, 0x0020, 0x0000, 0x0005, 0x0002, 0x0000, 0xFFFF, 0xFFFF, 0x0000 };

    auto const shifted = collate_for_tests(
        cps, cps + 2, boost::text::variable_weighting::shifted);

    EXPECT_EQ(shifted.size(), 12);
    EXPECT_TRUE(boost::algorithm::equal(shifted.begin(), shifted.end(), ces_shifted, ces_shifted + 12))
        << "from:     " << ce_dumper(cps)
        << "expected: " << ce_dumper(ces_shifted)
        << "got:      " << ce_dumper(shifted);
}

TEST(collation, verbatim_131_311)
{
    uint32_t const cps[2] = { 0x1D705, 0x0061 };

    // 1D705 0061;	
    // (𝜅) MATHEMATICAL ITALIC SMALL KAPPA	[202E 1CAD | 0020 0020 | 0005 0002 |]
    uint32_t const ces_non_ignorable[9] = { 0x202E, 0x1CAD, 0x0000, 0x0020, 0x0020, 0x0000, 0x0005, 0x0002, 0x0000 };

    auto const non_ignorable = collate_for_tests(
        cps, cps + 2, boost::text::variable_weighting::non_ignorable);

    EXPECT_EQ(non_ignorable.size(), 9);
    EXPECT_TRUE(boost::algorithm::equal(non_ignorable.begin(), non_ignorable.end(), ces_non_ignorable, ces_non_ignorable + 9))
        << "from:     " << ce_dumper(cps)
        << "expected: " << ce_dumper(ces_non_ignorable)
        << "got:      " << ce_dumper(non_ignorable);

    // 1D705 0061;	
    // (𝜅) MATHEMATICAL ITALIC SMALL KAPPA	[202E 1CAD | 0020 0020 | 0005 0002 | FFFF FFFF |]
    uint32_t const ces_shifted[12] = { 0x202E, 0x1CAD, 0x0000, 0x0020, 0x0020, 0x0000, 0x0005, 0x0002, 0x0000, 0xFFFF, 0xFFFF, 0x0000 };

    auto const shifted = collate_for_tests(
        cps, cps + 2, boost::text::variable_weighting::shifted);

    EXPECT_EQ(shifted.size(), 12);
    EXPECT_TRUE(boost::algorithm::equal(shifted.begin(), shifted.end(), ces_shifted, ces_shifted + 12))
        << "from:     " << ce_dumper(cps)
        << "expected: " << ce_dumper(ces_shifted)
        << "got:      " << ce_dumper(shifted);
}

TEST(collation, verbatim_131_312)
{
    uint32_t const cps[2] = { 0x1D718, 0x0061 };

    // 1D718 0061;	
    // (𝜘) MATHEMATICAL ITALIC KAPPA SYMBOL	[202E 1CAD | 0020 0020 | 0005 0002 |]
    uint32_t const ces_non_ignorable[9] = { 0x202E, 0x1CAD, 0x0000, 0x0020, 0x0020, 0x0000, 0x0005, 0x0002, 0x0000 };

    auto const non_ignorable = collate_for_tests(
        cps, cps + 2, boost::text::variable_weighting::non_ignorable);

    EXPECT_EQ(non_ignorable.size(), 9);
    EXPECT_TRUE(boost::algorithm::equal(non_ignorable.begin(), non_ignorable.end(), ces_non_ignorable, ces_non_ignorable + 9))
        << "from:     " << ce_dumper(cps)
        << "expected: " << ce_dumper(ces_non_ignorable)
        << "got:      " << ce_dumper(non_ignorable);

    // 1D718 0061;	
    // (𝜘) MATHEMATICAL ITALIC KAPPA SYMBOL	[202E 1CAD | 0020 0020 | 0005 0002 | FFFF FFFF |]
    uint32_t const ces_shifted[12] = { 0x202E, 0x1CAD, 0x0000, 0x0020, 0x0020, 0x0000, 0x0005, 0x0002, 0x0000, 0xFFFF, 0xFFFF, 0x0000 };

    auto const shifted = collate_for_tests(
        cps, cps + 2, boost::text::variable_weighting::shifted);

    EXPECT_EQ(shifted.size(), 12);
    EXPECT_TRUE(boost::algorithm::equal(shifted.begin(), shifted.end(), ces_shifted, ces_shifted + 12))
        << "from:     " << ce_dumper(cps)
        << "expected: " << ce_dumper(ces_shifted)
        << "got:      " << ce_dumper(shifted);
}

TEST(collation, verbatim_131_313)
{
    uint32_t const cps[2] = { 0x1D73F, 0x0061 };

    // 1D73F 0061;	
    // (𝜿) MATHEMATICAL BOLD ITALIC SMALL KAPPA	[202E 1CAD | 0020 0020 | 0005 0002 |]
    uint32_t const ces_non_ignorable[9] = { 0x202E, 0x1CAD, 0x0000, 0x0020, 0x0020, 0x0000, 0x0005, 0x0002, 0x0000 };

    auto const non_ignorable = collate_for_tests(
        cps, cps + 2, boost::text::variable_weighting::non_ignorable);

    EXPECT_EQ(non_ignorable.size(), 9);
    EXPECT_TRUE(boost::algorithm::equal(non_ignorable.begin(), non_ignorable.end(), ces_non_ignorable, ces_non_ignorable + 9))
        << "from:     " << ce_dumper(cps)
        << "expected: " << ce_dumper(ces_non_ignorable)
        << "got:      " << ce_dumper(non_ignorable);

    // 1D73F 0061;	
    // (𝜿) MATHEMATICAL BOLD ITALIC SMALL KAPPA	[202E 1CAD | 0020 0020 | 0005 0002 | FFFF FFFF |]
    uint32_t const ces_shifted[12] = { 0x202E, 0x1CAD, 0x0000, 0x0020, 0x0020, 0x0000, 0x0005, 0x0002, 0x0000, 0xFFFF, 0xFFFF, 0x0000 };

    auto const shifted = collate_for_tests(
        cps, cps + 2, boost::text::variable_weighting::shifted);

    EXPECT_EQ(shifted.size(), 12);
    EXPECT_TRUE(boost::algorithm::equal(shifted.begin(), shifted.end(), ces_shifted, ces_shifted + 12))
        << "from:     " << ce_dumper(cps)
        << "expected: " << ce_dumper(ces_shifted)
        << "got:      " << ce_dumper(shifted);
}

TEST(collation, verbatim_131_314)
{
    uint32_t const cps[2] = { 0x1D752, 0x0061 };

    // 1D752 0061;	
    // (𝝒) MATHEMATICAL BOLD ITALIC KAPPA SYMBOL	[202E 1CAD | 0020 0020 | 0005 0002 |]
    uint32_t const ces_non_ignorable[9] = { 0x202E, 0x1CAD, 0x0000, 0x0020, 0x0020, 0x0000, 0x0005, 0x0002, 0x0000 };

    auto const non_ignorable = collate_for_tests(
        cps, cps + 2, boost::text::variable_weighting::non_ignorable);

    EXPECT_EQ(non_ignorable.size(), 9);
    EXPECT_TRUE(boost::algorithm::equal(non_ignorable.begin(), non_ignorable.end(), ces_non_ignorable, ces_non_ignorable + 9))
        << "from:     " << ce_dumper(cps)
        << "expected: " << ce_dumper(ces_non_ignorable)
        << "got:      " << ce_dumper(non_ignorable);

    // 1D752 0061;	
    // (𝝒) MATHEMATICAL BOLD ITALIC KAPPA SYMBOL	[202E 1CAD | 0020 0020 | 0005 0002 | FFFF FFFF |]
    uint32_t const ces_shifted[12] = { 0x202E, 0x1CAD, 0x0000, 0x0020, 0x0020, 0x0000, 0x0005, 0x0002, 0x0000, 0xFFFF, 0xFFFF, 0x0000 };

    auto const shifted = collate_for_tests(
        cps, cps + 2, boost::text::variable_weighting::shifted);

    EXPECT_EQ(shifted.size(), 12);
    EXPECT_TRUE(boost::algorithm::equal(shifted.begin(), shifted.end(), ces_shifted, ces_shifted + 12))
        << "from:     " << ce_dumper(cps)
        << "expected: " << ce_dumper(ces_shifted)
        << "got:      " << ce_dumper(shifted);
}

TEST(collation, verbatim_131_315)
{
    uint32_t const cps[2] = { 0x1D779, 0x0061 };

    // 1D779 0061;	
    // (𝝹) MATHEMATICAL SANS-SERIF BOLD SMALL KAPPA	[202E 1CAD | 0020 0020 | 0005 0002 |]
    uint32_t const ces_non_ignorable[9] = { 0x202E, 0x1CAD, 0x0000, 0x0020, 0x0020, 0x0000, 0x0005, 0x0002, 0x0000 };

    auto const non_ignorable = collate_for_tests(
        cps, cps + 2, boost::text::variable_weighting::non_ignorable);

    EXPECT_EQ(non_ignorable.size(), 9);
    EXPECT_TRUE(boost::algorithm::equal(non_ignorable.begin(), non_ignorable.end(), ces_non_ignorable, ces_non_ignorable + 9))
        << "from:     " << ce_dumper(cps)
        << "expected: " << ce_dumper(ces_non_ignorable)
        << "got:      " << ce_dumper(non_ignorable);

    // 1D779 0061;	
    // (𝝹) MATHEMATICAL SANS-SERIF BOLD SMALL KAPPA	[202E 1CAD | 0020 0020 | 0005 0002 | FFFF FFFF |]
    uint32_t const ces_shifted[12] = { 0x202E, 0x1CAD, 0x0000, 0x0020, 0x0020, 0x0000, 0x0005, 0x0002, 0x0000, 0xFFFF, 0xFFFF, 0x0000 };

    auto const shifted = collate_for_tests(
        cps, cps + 2, boost::text::variable_weighting::shifted);

    EXPECT_EQ(shifted.size(), 12);
    EXPECT_TRUE(boost::algorithm::equal(shifted.begin(), shifted.end(), ces_shifted, ces_shifted + 12))
        << "from:     " << ce_dumper(cps)
        << "expected: " << ce_dumper(ces_shifted)
        << "got:      " << ce_dumper(shifted);
}

TEST(collation, verbatim_131_316)
{
    uint32_t const cps[2] = { 0x1D78C, 0x0061 };

    // 1D78C 0061;	
    // (𝞌) MATHEMATICAL SANS-SERIF BOLD KAPPA SYMBOL	[202E 1CAD | 0020 0020 | 0005 0002 |]
    uint32_t const ces_non_ignorable[9] = { 0x202E, 0x1CAD, 0x0000, 0x0020, 0x0020, 0x0000, 0x0005, 0x0002, 0x0000 };

    auto const non_ignorable = collate_for_tests(
        cps, cps + 2, boost::text::variable_weighting::non_ignorable);

    EXPECT_EQ(non_ignorable.size(), 9);
    EXPECT_TRUE(boost::algorithm::equal(non_ignorable.begin(), non_ignorable.end(), ces_non_ignorable, ces_non_ignorable + 9))
        << "from:     " << ce_dumper(cps)
        << "expected: " << ce_dumper(ces_non_ignorable)
        << "got:      " << ce_dumper(non_ignorable);

    // 1D78C 0061;	
    // (𝞌) MATHEMATICAL SANS-SERIF BOLD KAPPA SYMBOL	[202E 1CAD | 0020 0020 | 0005 0002 | FFFF FFFF |]
    uint32_t const ces_shifted[12] = { 0x202E, 0x1CAD, 0x0000, 0x0020, 0x0020, 0x0000, 0x0005, 0x0002, 0x0000, 0xFFFF, 0xFFFF, 0x0000 };

    auto const shifted = collate_for_tests(
        cps, cps + 2, boost::text::variable_weighting::shifted);

    EXPECT_EQ(shifted.size(), 12);
    EXPECT_TRUE(boost::algorithm::equal(shifted.begin(), shifted.end(), ces_shifted, ces_shifted + 12))
        << "from:     " << ce_dumper(cps)
        << "expected: " << ce_dumper(ces_shifted)
        << "got:      " << ce_dumper(shifted);
}

TEST(collation, verbatim_131_317)
{
    uint32_t const cps[2] = { 0x1D7B3, 0x0061 };

    // 1D7B3 0061;	
    // (𝞳) MATHEMATICAL SANS-SERIF BOLD ITALIC SMALL KAPPA	[202E 1CAD | 0020 0020 | 0005 0002 |]
    uint32_t const ces_non_ignorable[9] = { 0x202E, 0x1CAD, 0x0000, 0x0020, 0x0020, 0x0000, 0x0005, 0x0002, 0x0000 };

    auto const non_ignorable = collate_for_tests(
        cps, cps + 2, boost::text::variable_weighting::non_ignorable);

    EXPECT_EQ(non_ignorable.size(), 9);
    EXPECT_TRUE(boost::algorithm::equal(non_ignorable.begin(), non_ignorable.end(), ces_non_ignorable, ces_non_ignorable + 9))
        << "from:     " << ce_dumper(cps)
        << "expected: " << ce_dumper(ces_non_ignorable)
        << "got:      " << ce_dumper(non_ignorable);

    // 1D7B3 0061;	
    // (𝞳) MATHEMATICAL SANS-SERIF BOLD ITALIC SMALL KAPPA	[202E 1CAD | 0020 0020 | 0005 0002 | FFFF FFFF |]
    uint32_t const ces_shifted[12] = { 0x202E, 0x1CAD, 0x0000, 0x0020, 0x0020, 0x0000, 0x0005, 0x0002, 0x0000, 0xFFFF, 0xFFFF, 0x0000 };

    auto const shifted = collate_for_tests(
        cps, cps + 2, boost::text::variable_weighting::shifted);

    EXPECT_EQ(shifted.size(), 12);
    EXPECT_TRUE(boost::algorithm::equal(shifted.begin(), shifted.end(), ces_shifted, ces_shifted + 12))
        << "from:     " << ce_dumper(cps)
        << "expected: " << ce_dumper(ces_shifted)
        << "got:      " << ce_dumper(shifted);
}

TEST(collation, verbatim_131_318)
{
    uint32_t const cps[2] = { 0x1D7C6, 0x0061 };

    // 1D7C6 0061;	
    // (𝟆) MATHEMATICAL SANS-SERIF BOLD ITALIC KAPPA SYMBOL	[202E 1CAD | 0020 0020 | 0005 0002 |]
    uint32_t const ces_non_ignorable[9] = { 0x202E, 0x1CAD, 0x0000, 0x0020, 0x0020, 0x0000, 0x0005, 0x0002, 0x0000 };

    auto const non_ignorable = collate_for_tests(
        cps, cps + 2, boost::text::variable_weighting::non_ignorable);

    EXPECT_EQ(non_ignorable.size(), 9);
    EXPECT_TRUE(boost::algorithm::equal(non_ignorable.begin(), non_ignorable.end(), ces_non_ignorable, ces_non_ignorable + 9))
        << "from:     " << ce_dumper(cps)
        << "expected: " << ce_dumper(ces_non_ignorable)
        << "got:      " << ce_dumper(non_ignorable);

    // 1D7C6 0061;	
    // (𝟆) MATHEMATICAL SANS-SERIF BOLD ITALIC KAPPA SYMBOL	[202E 1CAD | 0020 0020 | 0005 0002 | FFFF FFFF |]
    uint32_t const ces_shifted[12] = { 0x202E, 0x1CAD, 0x0000, 0x0020, 0x0020, 0x0000, 0x0005, 0x0002, 0x0000, 0xFFFF, 0xFFFF, 0x0000 };

    auto const shifted = collate_for_tests(
        cps, cps + 2, boost::text::variable_weighting::shifted);

    EXPECT_EQ(shifted.size(), 12);
    EXPECT_TRUE(boost::algorithm::equal(shifted.begin(), shifted.end(), ces_shifted, ces_shifted + 12))
        << "from:     " << ce_dumper(cps)
        << "expected: " << ce_dumper(ces_shifted)
        << "got:      " << ce_dumper(shifted);
}

TEST(collation, verbatim_131_319)
{
    uint32_t const cps[2] = { 0x1D6CB, 0x0041 };

    // 1D6CB 0041;	
    // (𝛋) MATHEMATICAL BOLD SMALL KAPPA	[202E 1CAD | 0020 0020 | 0005 0008 |]
    uint32_t const ces_non_ignorable[9] = { 0x202E, 0x1CAD, 0x0000, 0x0020, 0x0020, 0x0000, 0x0005, 0x0008, 0x0000 };

    auto const non_ignorable = collate_for_tests(
        cps, cps + 2, boost::text::variable_weighting::non_ignorable);

    EXPECT_EQ(non_ignorable.size(), 9);
    EXPECT_TRUE(boost::algorithm::equal(non_ignorable.begin(), non_ignorable.end(), ces_non_ignorable, ces_non_ignorable + 9))
        << "from:     " << ce_dumper(cps)
        << "expected: " << ce_dumper(ces_non_ignorable)
        << "got:      " << ce_dumper(non_ignorable);

    // 1D6CB 0041;	
    // (𝛋) MATHEMATICAL BOLD SMALL KAPPA	[202E 1CAD | 0020 0020 | 0005 0008 | FFFF FFFF |]
    uint32_t const ces_shifted[12] = { 0x202E, 0x1CAD, 0x0000, 0x0020, 0x0020, 0x0000, 0x0005, 0x0008, 0x0000, 0xFFFF, 0xFFFF, 0x0000 };

    auto const shifted = collate_for_tests(
        cps, cps + 2, boost::text::variable_weighting::shifted);

    EXPECT_EQ(shifted.size(), 12);
    EXPECT_TRUE(boost::algorithm::equal(shifted.begin(), shifted.end(), ces_shifted, ces_shifted + 12))
        << "from:     " << ce_dumper(cps)
        << "expected: " << ce_dumper(ces_shifted)
        << "got:      " << ce_dumper(shifted);
}

TEST(collation, verbatim_131_320)
{
    uint32_t const cps[2] = { 0x1D6DE, 0x0041 };

    // 1D6DE 0041;	
    // (𝛞) MATHEMATICAL BOLD KAPPA SYMBOL	[202E 1CAD | 0020 0020 | 0005 0008 |]
    uint32_t const ces_non_ignorable[9] = { 0x202E, 0x1CAD, 0x0000, 0x0020, 0x0020, 0x0000, 0x0005, 0x0008, 0x0000 };

    auto const non_ignorable = collate_for_tests(
        cps, cps + 2, boost::text::variable_weighting::non_ignorable);

    EXPECT_EQ(non_ignorable.size(), 9);
    EXPECT_TRUE(boost::algorithm::equal(non_ignorable.begin(), non_ignorable.end(), ces_non_ignorable, ces_non_ignorable + 9))
        << "from:     " << ce_dumper(cps)
        << "expected: " << ce_dumper(ces_non_ignorable)
        << "got:      " << ce_dumper(non_ignorable);

    // 1D6DE 0041;	
    // (𝛞) MATHEMATICAL BOLD KAPPA SYMBOL	[202E 1CAD | 0020 0020 | 0005 0008 | FFFF FFFF |]
    uint32_t const ces_shifted[12] = { 0x202E, 0x1CAD, 0x0000, 0x0020, 0x0020, 0x0000, 0x0005, 0x0008, 0x0000, 0xFFFF, 0xFFFF, 0x0000 };

    auto const shifted = collate_for_tests(
        cps, cps + 2, boost::text::variable_weighting::shifted);

    EXPECT_EQ(shifted.size(), 12);
    EXPECT_TRUE(boost::algorithm::equal(shifted.begin(), shifted.end(), ces_shifted, ces_shifted + 12))
        << "from:     " << ce_dumper(cps)
        << "expected: " << ce_dumper(ces_shifted)
        << "got:      " << ce_dumper(shifted);
}

TEST(collation, verbatim_131_321)
{
    uint32_t const cps[2] = { 0x1D705, 0x0041 };

    // 1D705 0041;	
    // (𝜅) MATHEMATICAL ITALIC SMALL KAPPA	[202E 1CAD | 0020 0020 | 0005 0008 |]
    uint32_t const ces_non_ignorable[9] = { 0x202E, 0x1CAD, 0x0000, 0x0020, 0x0020, 0x0000, 0x0005, 0x0008, 0x0000 };

    auto const non_ignorable = collate_for_tests(
        cps, cps + 2, boost::text::variable_weighting::non_ignorable);

    EXPECT_EQ(non_ignorable.size(), 9);
    EXPECT_TRUE(boost::algorithm::equal(non_ignorable.begin(), non_ignorable.end(), ces_non_ignorable, ces_non_ignorable + 9))
        << "from:     " << ce_dumper(cps)
        << "expected: " << ce_dumper(ces_non_ignorable)
        << "got:      " << ce_dumper(non_ignorable);

    // 1D705 0041;	
    // (𝜅) MATHEMATICAL ITALIC SMALL KAPPA	[202E 1CAD | 0020 0020 | 0005 0008 | FFFF FFFF |]
    uint32_t const ces_shifted[12] = { 0x202E, 0x1CAD, 0x0000, 0x0020, 0x0020, 0x0000, 0x0005, 0x0008, 0x0000, 0xFFFF, 0xFFFF, 0x0000 };

    auto const shifted = collate_for_tests(
        cps, cps + 2, boost::text::variable_weighting::shifted);

    EXPECT_EQ(shifted.size(), 12);
    EXPECT_TRUE(boost::algorithm::equal(shifted.begin(), shifted.end(), ces_shifted, ces_shifted + 12))
        << "from:     " << ce_dumper(cps)
        << "expected: " << ce_dumper(ces_shifted)
        << "got:      " << ce_dumper(shifted);
}

TEST(collation, verbatim_131_322)
{
    uint32_t const cps[2] = { 0x1D718, 0x0041 };

    // 1D718 0041;	
    // (𝜘) MATHEMATICAL ITALIC KAPPA SYMBOL	[202E 1CAD | 0020 0020 | 0005 0008 |]
    uint32_t const ces_non_ignorable[9] = { 0x202E, 0x1CAD, 0x0000, 0x0020, 0x0020, 0x0000, 0x0005, 0x0008, 0x0000 };

    auto const non_ignorable = collate_for_tests(
        cps, cps + 2, boost::text::variable_weighting::non_ignorable);

    EXPECT_EQ(non_ignorable.size(), 9);
    EXPECT_TRUE(boost::algorithm::equal(non_ignorable.begin(), non_ignorable.end(), ces_non_ignorable, ces_non_ignorable + 9))
        << "from:     " << ce_dumper(cps)
        << "expected: " << ce_dumper(ces_non_ignorable)
        << "got:      " << ce_dumper(non_ignorable);

    // 1D718 0041;	
    // (𝜘) MATHEMATICAL ITALIC KAPPA SYMBOL	[202E 1CAD | 0020 0020 | 0005 0008 | FFFF FFFF |]
    uint32_t const ces_shifted[12] = { 0x202E, 0x1CAD, 0x0000, 0x0020, 0x0020, 0x0000, 0x0005, 0x0008, 0x0000, 0xFFFF, 0xFFFF, 0x0000 };

    auto const shifted = collate_for_tests(
        cps, cps + 2, boost::text::variable_weighting::shifted);

    EXPECT_EQ(shifted.size(), 12);
    EXPECT_TRUE(boost::algorithm::equal(shifted.begin(), shifted.end(), ces_shifted, ces_shifted + 12))
        << "from:     " << ce_dumper(cps)
        << "expected: " << ce_dumper(ces_shifted)
        << "got:      " << ce_dumper(shifted);
}

TEST(collation, verbatim_131_323)
{
    uint32_t const cps[2] = { 0x1D73F, 0x0041 };

    // 1D73F 0041;	
    // (𝜿) MATHEMATICAL BOLD ITALIC SMALL KAPPA	[202E 1CAD | 0020 0020 | 0005 0008 |]
    uint32_t const ces_non_ignorable[9] = { 0x202E, 0x1CAD, 0x0000, 0x0020, 0x0020, 0x0000, 0x0005, 0x0008, 0x0000 };

    auto const non_ignorable = collate_for_tests(
        cps, cps + 2, boost::text::variable_weighting::non_ignorable);

    EXPECT_EQ(non_ignorable.size(), 9);
    EXPECT_TRUE(boost::algorithm::equal(non_ignorable.begin(), non_ignorable.end(), ces_non_ignorable, ces_non_ignorable + 9))
        << "from:     " << ce_dumper(cps)
        << "expected: " << ce_dumper(ces_non_ignorable)
        << "got:      " << ce_dumper(non_ignorable);

    // 1D73F 0041;	
    // (𝜿) MATHEMATICAL BOLD ITALIC SMALL KAPPA	[202E 1CAD | 0020 0020 | 0005 0008 | FFFF FFFF |]
    uint32_t const ces_shifted[12] = { 0x202E, 0x1CAD, 0x0000, 0x0020, 0x0020, 0x0000, 0x0005, 0x0008, 0x0000, 0xFFFF, 0xFFFF, 0x0000 };

    auto const shifted = collate_for_tests(
        cps, cps + 2, boost::text::variable_weighting::shifted);

    EXPECT_EQ(shifted.size(), 12);
    EXPECT_TRUE(boost::algorithm::equal(shifted.begin(), shifted.end(), ces_shifted, ces_shifted + 12))
        << "from:     " << ce_dumper(cps)
        << "expected: " << ce_dumper(ces_shifted)
        << "got:      " << ce_dumper(shifted);
}

TEST(collation, verbatim_131_324)
{
    uint32_t const cps[2] = { 0x1D752, 0x0041 };

    // 1D752 0041;	
    // (𝝒) MATHEMATICAL BOLD ITALIC KAPPA SYMBOL	[202E 1CAD | 0020 0020 | 0005 0008 |]
    uint32_t const ces_non_ignorable[9] = { 0x202E, 0x1CAD, 0x0000, 0x0020, 0x0020, 0x0000, 0x0005, 0x0008, 0x0000 };

    auto const non_ignorable = collate_for_tests(
        cps, cps + 2, boost::text::variable_weighting::non_ignorable);

    EXPECT_EQ(non_ignorable.size(), 9);
    EXPECT_TRUE(boost::algorithm::equal(non_ignorable.begin(), non_ignorable.end(), ces_non_ignorable, ces_non_ignorable + 9))
        << "from:     " << ce_dumper(cps)
        << "expected: " << ce_dumper(ces_non_ignorable)
        << "got:      " << ce_dumper(non_ignorable);

    // 1D752 0041;	
    // (𝝒) MATHEMATICAL BOLD ITALIC KAPPA SYMBOL	[202E 1CAD | 0020 0020 | 0005 0008 | FFFF FFFF |]
    uint32_t const ces_shifted[12] = { 0x202E, 0x1CAD, 0x0000, 0x0020, 0x0020, 0x0000, 0x0005, 0x0008, 0x0000, 0xFFFF, 0xFFFF, 0x0000 };

    auto const shifted = collate_for_tests(
        cps, cps + 2, boost::text::variable_weighting::shifted);

    EXPECT_EQ(shifted.size(), 12);
    EXPECT_TRUE(boost::algorithm::equal(shifted.begin(), shifted.end(), ces_shifted, ces_shifted + 12))
        << "from:     " << ce_dumper(cps)
        << "expected: " << ce_dumper(ces_shifted)
        << "got:      " << ce_dumper(shifted);
}

TEST(collation, verbatim_131_325)
{
    uint32_t const cps[2] = { 0x1D779, 0x0041 };

    // 1D779 0041;	
    // (𝝹) MATHEMATICAL SANS-SERIF BOLD SMALL KAPPA	[202E 1CAD | 0020 0020 | 0005 0008 |]
    uint32_t const ces_non_ignorable[9] = { 0x202E, 0x1CAD, 0x0000, 0x0020, 0x0020, 0x0000, 0x0005, 0x0008, 0x0000 };

    auto const non_ignorable = collate_for_tests(
        cps, cps + 2, boost::text::variable_weighting::non_ignorable);

    EXPECT_EQ(non_ignorable.size(), 9);
    EXPECT_TRUE(boost::algorithm::equal(non_ignorable.begin(), non_ignorable.end(), ces_non_ignorable, ces_non_ignorable + 9))
        << "from:     " << ce_dumper(cps)
        << "expected: " << ce_dumper(ces_non_ignorable)
        << "got:      " << ce_dumper(non_ignorable);

    // 1D779 0041;	
    // (𝝹) MATHEMATICAL SANS-SERIF BOLD SMALL KAPPA	[202E 1CAD | 0020 0020 | 0005 0008 | FFFF FFFF |]
    uint32_t const ces_shifted[12] = { 0x202E, 0x1CAD, 0x0000, 0x0020, 0x0020, 0x0000, 0x0005, 0x0008, 0x0000, 0xFFFF, 0xFFFF, 0x0000 };

    auto const shifted = collate_for_tests(
        cps, cps + 2, boost::text::variable_weighting::shifted);

    EXPECT_EQ(shifted.size(), 12);
    EXPECT_TRUE(boost::algorithm::equal(shifted.begin(), shifted.end(), ces_shifted, ces_shifted + 12))
        << "from:     " << ce_dumper(cps)
        << "expected: " << ce_dumper(ces_shifted)
        << "got:      " << ce_dumper(shifted);
}

TEST(collation, verbatim_131_326)
{
    uint32_t const cps[2] = { 0x1D78C, 0x0041 };

    // 1D78C 0041;	
    // (𝞌) MATHEMATICAL SANS-SERIF BOLD KAPPA SYMBOL	[202E 1CAD | 0020 0020 | 0005 0008 |]
    uint32_t const ces_non_ignorable[9] = { 0x202E, 0x1CAD, 0x0000, 0x0020, 0x0020, 0x0000, 0x0005, 0x0008, 0x0000 };

    auto const non_ignorable = collate_for_tests(
        cps, cps + 2, boost::text::variable_weighting::non_ignorable);

    EXPECT_EQ(non_ignorable.size(), 9);
    EXPECT_TRUE(boost::algorithm::equal(non_ignorable.begin(), non_ignorable.end(), ces_non_ignorable, ces_non_ignorable + 9))
        << "from:     " << ce_dumper(cps)
        << "expected: " << ce_dumper(ces_non_ignorable)
        << "got:      " << ce_dumper(non_ignorable);

    // 1D78C 0041;	
    // (𝞌) MATHEMATICAL SANS-SERIF BOLD KAPPA SYMBOL	[202E 1CAD | 0020 0020 | 0005 0008 | FFFF FFFF |]
    uint32_t const ces_shifted[12] = { 0x202E, 0x1CAD, 0x0000, 0x0020, 0x0020, 0x0000, 0x0005, 0x0008, 0x0000, 0xFFFF, 0xFFFF, 0x0000 };

    auto const shifted = collate_for_tests(
        cps, cps + 2, boost::text::variable_weighting::shifted);

    EXPECT_EQ(shifted.size(), 12);
    EXPECT_TRUE(boost::algorithm::equal(shifted.begin(), shifted.end(), ces_shifted, ces_shifted + 12))
        << "from:     " << ce_dumper(cps)
        << "expected: " << ce_dumper(ces_shifted)
        << "got:      " << ce_dumper(shifted);
}

TEST(collation, verbatim_131_327)
{
    uint32_t const cps[2] = { 0x1D7B3, 0x0041 };

    // 1D7B3 0041;	
    // (𝞳) MATHEMATICAL SANS-SERIF BOLD ITALIC SMALL KAPPA	[202E 1CAD | 0020 0020 | 0005 0008 |]
    uint32_t const ces_non_ignorable[9] = { 0x202E, 0x1CAD, 0x0000, 0x0020, 0x0020, 0x0000, 0x0005, 0x0008, 0x0000 };

    auto const non_ignorable = collate_for_tests(
        cps, cps + 2, boost::text::variable_weighting::non_ignorable);

    EXPECT_EQ(non_ignorable.size(), 9);
    EXPECT_TRUE(boost::algorithm::equal(non_ignorable.begin(), non_ignorable.end(), ces_non_ignorable, ces_non_ignorable + 9))
        << "from:     " << ce_dumper(cps)
        << "expected: " << ce_dumper(ces_non_ignorable)
        << "got:      " << ce_dumper(non_ignorable);

    // 1D7B3 0041;	
    // (𝞳) MATHEMATICAL SANS-SERIF BOLD ITALIC SMALL KAPPA	[202E 1CAD | 0020 0020 | 0005 0008 | FFFF FFFF |]
    uint32_t const ces_shifted[12] = { 0x202E, 0x1CAD, 0x0000, 0x0020, 0x0020, 0x0000, 0x0005, 0x0008, 0x0000, 0xFFFF, 0xFFFF, 0x0000 };

    auto const shifted = collate_for_tests(
        cps, cps + 2, boost::text::variable_weighting::shifted);

    EXPECT_EQ(shifted.size(), 12);
    EXPECT_TRUE(boost::algorithm::equal(shifted.begin(), shifted.end(), ces_shifted, ces_shifted + 12))
        << "from:     " << ce_dumper(cps)
        << "expected: " << ce_dumper(ces_shifted)
        << "got:      " << ce_dumper(shifted);
}

TEST(collation, verbatim_131_328)
{
    uint32_t const cps[2] = { 0x1D7C6, 0x0041 };

    // 1D7C6 0041;	
    // (𝟆) MATHEMATICAL SANS-SERIF BOLD ITALIC KAPPA SYMBOL	[202E 1CAD | 0020 0020 | 0005 0008 |]
    uint32_t const ces_non_ignorable[9] = { 0x202E, 0x1CAD, 0x0000, 0x0020, 0x0020, 0x0000, 0x0005, 0x0008, 0x0000 };

    auto const non_ignorable = collate_for_tests(
        cps, cps + 2, boost::text::variable_weighting::non_ignorable);

    EXPECT_EQ(non_ignorable.size(), 9);
    EXPECT_TRUE(boost::algorithm::equal(non_ignorable.begin(), non_ignorable.end(), ces_non_ignorable, ces_non_ignorable + 9))
        << "from:     " << ce_dumper(cps)
        << "expected: " << ce_dumper(ces_non_ignorable)
        << "got:      " << ce_dumper(non_ignorable);

    // 1D7C6 0041;	
    // (𝟆) MATHEMATICAL SANS-SERIF BOLD ITALIC KAPPA SYMBOL	[202E 1CAD | 0020 0020 | 0005 0008 | FFFF FFFF |]
    uint32_t const ces_shifted[12] = { 0x202E, 0x1CAD, 0x0000, 0x0020, 0x0020, 0x0000, 0x0005, 0x0008, 0x0000, 0xFFFF, 0xFFFF, 0x0000 };

    auto const shifted = collate_for_tests(
        cps, cps + 2, boost::text::variable_weighting::shifted);

    EXPECT_EQ(shifted.size(), 12);
    EXPECT_TRUE(boost::algorithm::equal(shifted.begin(), shifted.end(), ces_shifted, ces_shifted + 12))
        << "from:     " << ce_dumper(cps)
        << "expected: " << ce_dumper(ces_shifted)
        << "got:      " << ce_dumper(shifted);
}

TEST(collation, verbatim_131_329)
{
    uint32_t const cps[2] = { 0x039A, 0x0061 };

    // 039A 0061;	
    // (Κ) GREEK CAPITAL LETTER KAPPA	[202E 1CAD | 0020 0020 | 0008 0002 |]
    uint32_t const ces_non_ignorable[9] = { 0x202E, 0x1CAD, 0x0000, 0x0020, 0x0020, 0x0000, 0x0008, 0x0002, 0x0000 };

    auto const non_ignorable = collate_for_tests(
        cps, cps + 2, boost::text::variable_weighting::non_ignorable);

    EXPECT_EQ(non_ignorable.size(), 9);
    EXPECT_TRUE(boost::algorithm::equal(non_ignorable.begin(), non_ignorable.end(), ces_non_ignorable, ces_non_ignorable + 9))
        << "from:     " << ce_dumper(cps)
        << "expected: " << ce_dumper(ces_non_ignorable)
        << "got:      " << ce_dumper(non_ignorable);

    // 039A 0061;	
    // (Κ) GREEK CAPITAL LETTER KAPPA	[202E 1CAD | 0020 0020 | 0008 0002 | FFFF FFFF |]
    uint32_t const ces_shifted[12] = { 0x202E, 0x1CAD, 0x0000, 0x0020, 0x0020, 0x0000, 0x0008, 0x0002, 0x0000, 0xFFFF, 0xFFFF, 0x0000 };

    auto const shifted = collate_for_tests(
        cps, cps + 2, boost::text::variable_weighting::shifted);

    EXPECT_EQ(shifted.size(), 12);
    EXPECT_TRUE(boost::algorithm::equal(shifted.begin(), shifted.end(), ces_shifted, ces_shifted + 12))
        << "from:     " << ce_dumper(cps)
        << "expected: " << ce_dumper(ces_shifted)
        << "got:      " << ce_dumper(shifted);
}

TEST(collation, verbatim_131_330)
{
    uint32_t const cps[2] = { 0x039A, 0x0041 };

    // 039A 0041;	
    // (Κ) GREEK CAPITAL LETTER KAPPA	[202E 1CAD | 0020 0020 | 0008 0008 |]
    uint32_t const ces_non_ignorable[9] = { 0x202E, 0x1CAD, 0x0000, 0x0020, 0x0020, 0x0000, 0x0008, 0x0008, 0x0000 };

    auto const non_ignorable = collate_for_tests(
        cps, cps + 2, boost::text::variable_weighting::non_ignorable);

    EXPECT_EQ(non_ignorable.size(), 9);
    EXPECT_TRUE(boost::algorithm::equal(non_ignorable.begin(), non_ignorable.end(), ces_non_ignorable, ces_non_ignorable + 9))
        << "from:     " << ce_dumper(cps)
        << "expected: " << ce_dumper(ces_non_ignorable)
        << "got:      " << ce_dumper(non_ignorable);

    // 039A 0041;	
    // (Κ) GREEK CAPITAL LETTER KAPPA	[202E 1CAD | 0020 0020 | 0008 0008 | FFFF FFFF |]
    uint32_t const ces_shifted[12] = { 0x202E, 0x1CAD, 0x0000, 0x0020, 0x0020, 0x0000, 0x0008, 0x0008, 0x0000, 0xFFFF, 0xFFFF, 0x0000 };

    auto const shifted = collate_for_tests(
        cps, cps + 2, boost::text::variable_weighting::shifted);

    EXPECT_EQ(shifted.size(), 12);
    EXPECT_TRUE(boost::algorithm::equal(shifted.begin(), shifted.end(), ces_shifted, ces_shifted + 12))
        << "from:     " << ce_dumper(cps)
        << "expected: " << ce_dumper(ces_shifted)
        << "got:      " << ce_dumper(shifted);
}

TEST(collation, verbatim_131_331)
{
    uint32_t const cps[2] = { 0x1D6B1, 0x0061 };

    // 1D6B1 0061;	
    // (𝚱) MATHEMATICAL BOLD CAPITAL KAPPA	[202E 1CAD | 0020 0020 | 000B 0002 |]
    uint32_t const ces_non_ignorable[9] = { 0x202E, 0x1CAD, 0x0000, 0x0020, 0x0020, 0x0000, 0x000B, 0x0002, 0x0000 };

    auto const non_ignorable = collate_for_tests(
        cps, cps + 2, boost::text::variable_weighting::non_ignorable);

    EXPECT_EQ(non_ignorable.size(), 9);
    EXPECT_TRUE(boost::algorithm::equal(non_ignorable.begin(), non_ignorable.end(), ces_non_ignorable, ces_non_ignorable + 9))
        << "from:     " << ce_dumper(cps)
        << "expected: " << ce_dumper(ces_non_ignorable)
        << "got:      " << ce_dumper(non_ignorable);

    // 1D6B1 0061;	
    // (𝚱) MATHEMATICAL BOLD CAPITAL KAPPA	[202E 1CAD | 0020 0020 | 000B 0002 | FFFF FFFF |]
    uint32_t const ces_shifted[12] = { 0x202E, 0x1CAD, 0x0000, 0x0020, 0x0020, 0x0000, 0x000B, 0x0002, 0x0000, 0xFFFF, 0xFFFF, 0x0000 };

    auto const shifted = collate_for_tests(
        cps, cps + 2, boost::text::variable_weighting::shifted);

    EXPECT_EQ(shifted.size(), 12);
    EXPECT_TRUE(boost::algorithm::equal(shifted.begin(), shifted.end(), ces_shifted, ces_shifted + 12))
        << "from:     " << ce_dumper(cps)
        << "expected: " << ce_dumper(ces_shifted)
        << "got:      " << ce_dumper(shifted);
}

TEST(collation, verbatim_131_332)
{
    uint32_t const cps[2] = { 0x1D6EB, 0x0061 };

    // 1D6EB 0061;	
    // (𝛫) MATHEMATICAL ITALIC CAPITAL KAPPA	[202E 1CAD | 0020 0020 | 000B 0002 |]
    uint32_t const ces_non_ignorable[9] = { 0x202E, 0x1CAD, 0x0000, 0x0020, 0x0020, 0x0000, 0x000B, 0x0002, 0x0000 };

    auto const non_ignorable = collate_for_tests(
        cps, cps + 2, boost::text::variable_weighting::non_ignorable);

    EXPECT_EQ(non_ignorable.size(), 9);
    EXPECT_TRUE(boost::algorithm::equal(non_ignorable.begin(), non_ignorable.end(), ces_non_ignorable, ces_non_ignorable + 9))
        << "from:     " << ce_dumper(cps)
        << "expected: " << ce_dumper(ces_non_ignorable)
        << "got:      " << ce_dumper(non_ignorable);

    // 1D6EB 0061;	
    // (𝛫) MATHEMATICAL ITALIC CAPITAL KAPPA	[202E 1CAD | 0020 0020 | 000B 0002 | FFFF FFFF |]
    uint32_t const ces_shifted[12] = { 0x202E, 0x1CAD, 0x0000, 0x0020, 0x0020, 0x0000, 0x000B, 0x0002, 0x0000, 0xFFFF, 0xFFFF, 0x0000 };

    auto const shifted = collate_for_tests(
        cps, cps + 2, boost::text::variable_weighting::shifted);

    EXPECT_EQ(shifted.size(), 12);
    EXPECT_TRUE(boost::algorithm::equal(shifted.begin(), shifted.end(), ces_shifted, ces_shifted + 12))
        << "from:     " << ce_dumper(cps)
        << "expected: " << ce_dumper(ces_shifted)
        << "got:      " << ce_dumper(shifted);
}

TEST(collation, verbatim_131_333)
{
    uint32_t const cps[2] = { 0x1D725, 0x0061 };

    // 1D725 0061;	
    // (𝜥) MATHEMATICAL BOLD ITALIC CAPITAL KAPPA	[202E 1CAD | 0020 0020 | 000B 0002 |]
    uint32_t const ces_non_ignorable[9] = { 0x202E, 0x1CAD, 0x0000, 0x0020, 0x0020, 0x0000, 0x000B, 0x0002, 0x0000 };

    auto const non_ignorable = collate_for_tests(
        cps, cps + 2, boost::text::variable_weighting::non_ignorable);

    EXPECT_EQ(non_ignorable.size(), 9);
    EXPECT_TRUE(boost::algorithm::equal(non_ignorable.begin(), non_ignorable.end(), ces_non_ignorable, ces_non_ignorable + 9))
        << "from:     " << ce_dumper(cps)
        << "expected: " << ce_dumper(ces_non_ignorable)
        << "got:      " << ce_dumper(non_ignorable);

    // 1D725 0061;	
    // (𝜥) MATHEMATICAL BOLD ITALIC CAPITAL KAPPA	[202E 1CAD | 0020 0020 | 000B 0002 | FFFF FFFF |]
    uint32_t const ces_shifted[12] = { 0x202E, 0x1CAD, 0x0000, 0x0020, 0x0020, 0x0000, 0x000B, 0x0002, 0x0000, 0xFFFF, 0xFFFF, 0x0000 };

    auto const shifted = collate_for_tests(
        cps, cps + 2, boost::text::variable_weighting::shifted);

    EXPECT_EQ(shifted.size(), 12);
    EXPECT_TRUE(boost::algorithm::equal(shifted.begin(), shifted.end(), ces_shifted, ces_shifted + 12))
        << "from:     " << ce_dumper(cps)
        << "expected: " << ce_dumper(ces_shifted)
        << "got:      " << ce_dumper(shifted);
}

TEST(collation, verbatim_131_334)
{
    uint32_t const cps[2] = { 0x1D75F, 0x0061 };

    // 1D75F 0061;	
    // (𝝟) MATHEMATICAL SANS-SERIF BOLD CAPITAL KAPPA	[202E 1CAD | 0020 0020 | 000B 0002 |]
    uint32_t const ces_non_ignorable[9] = { 0x202E, 0x1CAD, 0x0000, 0x0020, 0x0020, 0x0000, 0x000B, 0x0002, 0x0000 };

    auto const non_ignorable = collate_for_tests(
        cps, cps + 2, boost::text::variable_weighting::non_ignorable);

    EXPECT_EQ(non_ignorable.size(), 9);
    EXPECT_TRUE(boost::algorithm::equal(non_ignorable.begin(), non_ignorable.end(), ces_non_ignorable, ces_non_ignorable + 9))
        << "from:     " << ce_dumper(cps)
        << "expected: " << ce_dumper(ces_non_ignorable)
        << "got:      " << ce_dumper(non_ignorable);

    // 1D75F 0061;	
    // (𝝟) MATHEMATICAL SANS-SERIF BOLD CAPITAL KAPPA	[202E 1CAD | 0020 0020 | 000B 0002 | FFFF FFFF |]
    uint32_t const ces_shifted[12] = { 0x202E, 0x1CAD, 0x0000, 0x0020, 0x0020, 0x0000, 0x000B, 0x0002, 0x0000, 0xFFFF, 0xFFFF, 0x0000 };

    auto const shifted = collate_for_tests(
        cps, cps + 2, boost::text::variable_weighting::shifted);

    EXPECT_EQ(shifted.size(), 12);
    EXPECT_TRUE(boost::algorithm::equal(shifted.begin(), shifted.end(), ces_shifted, ces_shifted + 12))
        << "from:     " << ce_dumper(cps)
        << "expected: " << ce_dumper(ces_shifted)
        << "got:      " << ce_dumper(shifted);
}

TEST(collation, verbatim_131_335)
{
    uint32_t const cps[2] = { 0x1D799, 0x0061 };

    // 1D799 0061;	
    // (𝞙) MATHEMATICAL SANS-SERIF BOLD ITALIC CAPITAL KAPPA	[202E 1CAD | 0020 0020 | 000B 0002 |]
    uint32_t const ces_non_ignorable[9] = { 0x202E, 0x1CAD, 0x0000, 0x0020, 0x0020, 0x0000, 0x000B, 0x0002, 0x0000 };

    auto const non_ignorable = collate_for_tests(
        cps, cps + 2, boost::text::variable_weighting::non_ignorable);

    EXPECT_EQ(non_ignorable.size(), 9);
    EXPECT_TRUE(boost::algorithm::equal(non_ignorable.begin(), non_ignorable.end(), ces_non_ignorable, ces_non_ignorable + 9))
        << "from:     " << ce_dumper(cps)
        << "expected: " << ce_dumper(ces_non_ignorable)
        << "got:      " << ce_dumper(non_ignorable);

    // 1D799 0061;	
    // (𝞙) MATHEMATICAL SANS-SERIF BOLD ITALIC CAPITAL KAPPA	[202E 1CAD | 0020 0020 | 000B 0002 | FFFF FFFF |]
    uint32_t const ces_shifted[12] = { 0x202E, 0x1CAD, 0x0000, 0x0020, 0x0020, 0x0000, 0x000B, 0x0002, 0x0000, 0xFFFF, 0xFFFF, 0x0000 };

    auto const shifted = collate_for_tests(
        cps, cps + 2, boost::text::variable_weighting::shifted);

    EXPECT_EQ(shifted.size(), 12);
    EXPECT_TRUE(boost::algorithm::equal(shifted.begin(), shifted.end(), ces_shifted, ces_shifted + 12))
        << "from:     " << ce_dumper(cps)
        << "expected: " << ce_dumper(ces_shifted)
        << "got:      " << ce_dumper(shifted);
}

TEST(collation, verbatim_131_336)
{
    uint32_t const cps[2] = { 0x1D6B1, 0x0041 };

    // 1D6B1 0041;	
    // (𝚱) MATHEMATICAL BOLD CAPITAL KAPPA	[202E 1CAD | 0020 0020 | 000B 0008 |]
    uint32_t const ces_non_ignorable[9] = { 0x202E, 0x1CAD, 0x0000, 0x0020, 0x0020, 0x0000, 0x000B, 0x0008, 0x0000 };

    auto const non_ignorable = collate_for_tests(
        cps, cps + 2, boost::text::variable_weighting::non_ignorable);

    EXPECT_EQ(non_ignorable.size(), 9);
    EXPECT_TRUE(boost::algorithm::equal(non_ignorable.begin(), non_ignorable.end(), ces_non_ignorable, ces_non_ignorable + 9))
        << "from:     " << ce_dumper(cps)
        << "expected: " << ce_dumper(ces_non_ignorable)
        << "got:      " << ce_dumper(non_ignorable);

    // 1D6B1 0041;	
    // (𝚱) MATHEMATICAL BOLD CAPITAL KAPPA	[202E 1CAD | 0020 0020 | 000B 0008 | FFFF FFFF |]
    uint32_t const ces_shifted[12] = { 0x202E, 0x1CAD, 0x0000, 0x0020, 0x0020, 0x0000, 0x000B, 0x0008, 0x0000, 0xFFFF, 0xFFFF, 0x0000 };

    auto const shifted = collate_for_tests(
        cps, cps + 2, boost::text::variable_weighting::shifted);

    EXPECT_EQ(shifted.size(), 12);
    EXPECT_TRUE(boost::algorithm::equal(shifted.begin(), shifted.end(), ces_shifted, ces_shifted + 12))
        << "from:     " << ce_dumper(cps)
        << "expected: " << ce_dumper(ces_shifted)
        << "got:      " << ce_dumper(shifted);
}

TEST(collation, verbatim_131_337)
{
    uint32_t const cps[2] = { 0x1D6EB, 0x0041 };

    // 1D6EB 0041;	
    // (𝛫) MATHEMATICAL ITALIC CAPITAL KAPPA	[202E 1CAD | 0020 0020 | 000B 0008 |]
    uint32_t const ces_non_ignorable[9] = { 0x202E, 0x1CAD, 0x0000, 0x0020, 0x0020, 0x0000, 0x000B, 0x0008, 0x0000 };

    auto const non_ignorable = collate_for_tests(
        cps, cps + 2, boost::text::variable_weighting::non_ignorable);

    EXPECT_EQ(non_ignorable.size(), 9);
    EXPECT_TRUE(boost::algorithm::equal(non_ignorable.begin(), non_ignorable.end(), ces_non_ignorable, ces_non_ignorable + 9))
        << "from:     " << ce_dumper(cps)
        << "expected: " << ce_dumper(ces_non_ignorable)
        << "got:      " << ce_dumper(non_ignorable);

    // 1D6EB 0041;	
    // (𝛫) MATHEMATICAL ITALIC CAPITAL KAPPA	[202E 1CAD | 0020 0020 | 000B 0008 | FFFF FFFF |]
    uint32_t const ces_shifted[12] = { 0x202E, 0x1CAD, 0x0000, 0x0020, 0x0020, 0x0000, 0x000B, 0x0008, 0x0000, 0xFFFF, 0xFFFF, 0x0000 };

    auto const shifted = collate_for_tests(
        cps, cps + 2, boost::text::variable_weighting::shifted);

    EXPECT_EQ(shifted.size(), 12);
    EXPECT_TRUE(boost::algorithm::equal(shifted.begin(), shifted.end(), ces_shifted, ces_shifted + 12))
        << "from:     " << ce_dumper(cps)
        << "expected: " << ce_dumper(ces_shifted)
        << "got:      " << ce_dumper(shifted);
}

TEST(collation, verbatim_131_338)
{
    uint32_t const cps[2] = { 0x1D725, 0x0041 };

    // 1D725 0041;	
    // (𝜥) MATHEMATICAL BOLD ITALIC CAPITAL KAPPA	[202E 1CAD | 0020 0020 | 000B 0008 |]
    uint32_t const ces_non_ignorable[9] = { 0x202E, 0x1CAD, 0x0000, 0x0020, 0x0020, 0x0000, 0x000B, 0x0008, 0x0000 };

    auto const non_ignorable = collate_for_tests(
        cps, cps + 2, boost::text::variable_weighting::non_ignorable);

    EXPECT_EQ(non_ignorable.size(), 9);
    EXPECT_TRUE(boost::algorithm::equal(non_ignorable.begin(), non_ignorable.end(), ces_non_ignorable, ces_non_ignorable + 9))
        << "from:     " << ce_dumper(cps)
        << "expected: " << ce_dumper(ces_non_ignorable)
        << "got:      " << ce_dumper(non_ignorable);

    // 1D725 0041;	
    // (𝜥) MATHEMATICAL BOLD ITALIC CAPITAL KAPPA	[202E 1CAD | 0020 0020 | 000B 0008 | FFFF FFFF |]
    uint32_t const ces_shifted[12] = { 0x202E, 0x1CAD, 0x0000, 0x0020, 0x0020, 0x0000, 0x000B, 0x0008, 0x0000, 0xFFFF, 0xFFFF, 0x0000 };

    auto const shifted = collate_for_tests(
        cps, cps + 2, boost::text::variable_weighting::shifted);

    EXPECT_EQ(shifted.size(), 12);
    EXPECT_TRUE(boost::algorithm::equal(shifted.begin(), shifted.end(), ces_shifted, ces_shifted + 12))
        << "from:     " << ce_dumper(cps)
        << "expected: " << ce_dumper(ces_shifted)
        << "got:      " << ce_dumper(shifted);
}

TEST(collation, verbatim_131_339)
{
    uint32_t const cps[2] = { 0x1D75F, 0x0041 };

    // 1D75F 0041;	
    // (𝝟) MATHEMATICAL SANS-SERIF BOLD CAPITAL KAPPA	[202E 1CAD | 0020 0020 | 000B 0008 |]
    uint32_t const ces_non_ignorable[9] = { 0x202E, 0x1CAD, 0x0000, 0x0020, 0x0020, 0x0000, 0x000B, 0x0008, 0x0000 };

    auto const non_ignorable = collate_for_tests(
        cps, cps + 2, boost::text::variable_weighting::non_ignorable);

    EXPECT_EQ(non_ignorable.size(), 9);
    EXPECT_TRUE(boost::algorithm::equal(non_ignorable.begin(), non_ignorable.end(), ces_non_ignorable, ces_non_ignorable + 9))
        << "from:     " << ce_dumper(cps)
        << "expected: " << ce_dumper(ces_non_ignorable)
        << "got:      " << ce_dumper(non_ignorable);

    // 1D75F 0041;	
    // (𝝟) MATHEMATICAL SANS-SERIF BOLD CAPITAL KAPPA	[202E 1CAD | 0020 0020 | 000B 0008 | FFFF FFFF |]
    uint32_t const ces_shifted[12] = { 0x202E, 0x1CAD, 0x0000, 0x0020, 0x0020, 0x0000, 0x000B, 0x0008, 0x0000, 0xFFFF, 0xFFFF, 0x0000 };

    auto const shifted = collate_for_tests(
        cps, cps + 2, boost::text::variable_weighting::shifted);

    EXPECT_EQ(shifted.size(), 12);
    EXPECT_TRUE(boost::algorithm::equal(shifted.begin(), shifted.end(), ces_shifted, ces_shifted + 12))
        << "from:     " << ce_dumper(cps)
        << "expected: " << ce_dumper(ces_shifted)
        << "got:      " << ce_dumper(shifted);
}

TEST(collation, verbatim_131_340)
{
    uint32_t const cps[2] = { 0x1D799, 0x0041 };

    // 1D799 0041;	
    // (𝞙) MATHEMATICAL SANS-SERIF BOLD ITALIC CAPITAL KAPPA	[202E 1CAD | 0020 0020 | 000B 0008 |]
    uint32_t const ces_non_ignorable[9] = { 0x202E, 0x1CAD, 0x0000, 0x0020, 0x0020, 0x0000, 0x000B, 0x0008, 0x0000 };

    auto const non_ignorable = collate_for_tests(
        cps, cps + 2, boost::text::variable_weighting::non_ignorable);

    EXPECT_EQ(non_ignorable.size(), 9);
    EXPECT_TRUE(boost::algorithm::equal(non_ignorable.begin(), non_ignorable.end(), ces_non_ignorable, ces_non_ignorable + 9))
        << "from:     " << ce_dumper(cps)
        << "expected: " << ce_dumper(ces_non_ignorable)
        << "got:      " << ce_dumper(non_ignorable);

    // 1D799 0041;	
    // (𝞙) MATHEMATICAL SANS-SERIF BOLD ITALIC CAPITAL KAPPA	[202E 1CAD | 0020 0020 | 000B 0008 | FFFF FFFF |]
    uint32_t const ces_shifted[12] = { 0x202E, 0x1CAD, 0x0000, 0x0020, 0x0020, 0x0000, 0x000B, 0x0008, 0x0000, 0xFFFF, 0xFFFF, 0x0000 };

    auto const shifted = collate_for_tests(
        cps, cps + 2, boost::text::variable_weighting::shifted);

    EXPECT_EQ(shifted.size(), 12);
    EXPECT_TRUE(boost::algorithm::equal(shifted.begin(), shifted.end(), ces_shifted, ces_shifted + 12))
        << "from:     " << ce_dumper(cps)
        << "expected: " << ce_dumper(ces_shifted)
        << "got:      " << ce_dumper(shifted);
}

TEST(collation, verbatim_131_341)
{
    uint32_t const cps[2] = { 0x03BA, 0x0062 };

    // 03BA 0062;	
    // (κ) GREEK SMALL LETTER KAPPA	[202E 1CC6 | 0020 0020 | 0002 0002 |]
    uint32_t const ces_non_ignorable[9] = { 0x202E, 0x1CC6, 0x0000, 0x0020, 0x0020, 0x0000, 0x0002, 0x0002, 0x0000 };

    auto const non_ignorable = collate_for_tests(
        cps, cps + 2, boost::text::variable_weighting::non_ignorable);

    EXPECT_EQ(non_ignorable.size(), 9);
    EXPECT_TRUE(boost::algorithm::equal(non_ignorable.begin(), non_ignorable.end(), ces_non_ignorable, ces_non_ignorable + 9))
        << "from:     " << ce_dumper(cps)
        << "expected: " << ce_dumper(ces_non_ignorable)
        << "got:      " << ce_dumper(non_ignorable);

    // 03BA 0062;	
    // (κ) GREEK SMALL LETTER KAPPA	[202E 1CC6 | 0020 0020 | 0002 0002 | FFFF FFFF |]
    uint32_t const ces_shifted[12] = { 0x202E, 0x1CC6, 0x0000, 0x0020, 0x0020, 0x0000, 0x0002, 0x0002, 0x0000, 0xFFFF, 0xFFFF, 0x0000 };

    auto const shifted = collate_for_tests(
        cps, cps + 2, boost::text::variable_weighting::shifted);

    EXPECT_EQ(shifted.size(), 12);
    EXPECT_TRUE(boost::algorithm::equal(shifted.begin(), shifted.end(), ces_shifted, ces_shifted + 12))
        << "from:     " << ce_dumper(cps)
        << "expected: " << ce_dumper(ces_shifted)
        << "got:      " << ce_dumper(shifted);
}

TEST(collation, verbatim_131_342)
{
    uint32_t const cps[2] = { 0x03F0, 0x0062 };

    // 03F0 0062;	
    // (ϰ) GREEK KAPPA SYMBOL	[202E 1CC6 | 0020 0020 | 0004 0002 |]
    uint32_t const ces_non_ignorable[9] = { 0x202E, 0x1CC6, 0x0000, 0x0020, 0x0020, 0x0000, 0x0004, 0x0002, 0x0000 };

    auto const non_ignorable = collate_for_tests(
        cps, cps + 2, boost::text::variable_weighting::non_ignorable);

    EXPECT_EQ(non_ignorable.size(), 9);
    EXPECT_TRUE(boost::algorithm::equal(non_ignorable.begin(), non_ignorable.end(), ces_non_ignorable, ces_non_ignorable + 9))
        << "from:     " << ce_dumper(cps)
        << "expected: " << ce_dumper(ces_non_ignorable)
        << "got:      " << ce_dumper(non_ignorable);

    // 03F0 0062;	
    // (ϰ) GREEK KAPPA SYMBOL	[202E 1CC6 | 0020 0020 | 0004 0002 | FFFF FFFF |]
    uint32_t const ces_shifted[12] = { 0x202E, 0x1CC6, 0x0000, 0x0020, 0x0020, 0x0000, 0x0004, 0x0002, 0x0000, 0xFFFF, 0xFFFF, 0x0000 };

    auto const shifted = collate_for_tests(
        cps, cps + 2, boost::text::variable_weighting::shifted);

    EXPECT_EQ(shifted.size(), 12);
    EXPECT_TRUE(boost::algorithm::equal(shifted.begin(), shifted.end(), ces_shifted, ces_shifted + 12))
        << "from:     " << ce_dumper(cps)
        << "expected: " << ce_dumper(ces_shifted)
        << "got:      " << ce_dumper(shifted);
}

TEST(collation, verbatim_131_343)
{
    uint32_t const cps[2] = { 0x1D6CB, 0x0062 };

    // 1D6CB 0062;	
    // (𝛋) MATHEMATICAL BOLD SMALL KAPPA	[202E 1CC6 | 0020 0020 | 0005 0002 |]
    uint32_t const ces_non_ignorable[9] = { 0x202E, 0x1CC6, 0x0000, 0x0020, 0x0020, 0x0000, 0x0005, 0x0002, 0x0000 };

    auto const non_ignorable = collate_for_tests(
        cps, cps + 2, boost::text::variable_weighting::non_ignorable);

    EXPECT_EQ(non_ignorable.size(), 9);
    EXPECT_TRUE(boost::algorithm::equal(non_ignorable.begin(), non_ignorable.end(), ces_non_ignorable, ces_non_ignorable + 9))
        << "from:     " << ce_dumper(cps)
        << "expected: " << ce_dumper(ces_non_ignorable)
        << "got:      " << ce_dumper(non_ignorable);

    // 1D6CB 0062;	
    // (𝛋) MATHEMATICAL BOLD SMALL KAPPA	[202E 1CC6 | 0020 0020 | 0005 0002 | FFFF FFFF |]
    uint32_t const ces_shifted[12] = { 0x202E, 0x1CC6, 0x0000, 0x0020, 0x0020, 0x0000, 0x0005, 0x0002, 0x0000, 0xFFFF, 0xFFFF, 0x0000 };

    auto const shifted = collate_for_tests(
        cps, cps + 2, boost::text::variable_weighting::shifted);

    EXPECT_EQ(shifted.size(), 12);
    EXPECT_TRUE(boost::algorithm::equal(shifted.begin(), shifted.end(), ces_shifted, ces_shifted + 12))
        << "from:     " << ce_dumper(cps)
        << "expected: " << ce_dumper(ces_shifted)
        << "got:      " << ce_dumper(shifted);
}

TEST(collation, verbatim_131_344)
{
    uint32_t const cps[2] = { 0x1D6DE, 0x0062 };

    // 1D6DE 0062;	
    // (𝛞) MATHEMATICAL BOLD KAPPA SYMBOL	[202E 1CC6 | 0020 0020 | 0005 0002 |]
    uint32_t const ces_non_ignorable[9] = { 0x202E, 0x1CC6, 0x0000, 0x0020, 0x0020, 0x0000, 0x0005, 0x0002, 0x0000 };

    auto const non_ignorable = collate_for_tests(
        cps, cps + 2, boost::text::variable_weighting::non_ignorable);

    EXPECT_EQ(non_ignorable.size(), 9);
    EXPECT_TRUE(boost::algorithm::equal(non_ignorable.begin(), non_ignorable.end(), ces_non_ignorable, ces_non_ignorable + 9))
        << "from:     " << ce_dumper(cps)
        << "expected: " << ce_dumper(ces_non_ignorable)
        << "got:      " << ce_dumper(non_ignorable);

    // 1D6DE 0062;	
    // (𝛞) MATHEMATICAL BOLD KAPPA SYMBOL	[202E 1CC6 | 0020 0020 | 0005 0002 | FFFF FFFF |]
    uint32_t const ces_shifted[12] = { 0x202E, 0x1CC6, 0x0000, 0x0020, 0x0020, 0x0000, 0x0005, 0x0002, 0x0000, 0xFFFF, 0xFFFF, 0x0000 };

    auto const shifted = collate_for_tests(
        cps, cps + 2, boost::text::variable_weighting::shifted);

    EXPECT_EQ(shifted.size(), 12);
    EXPECT_TRUE(boost::algorithm::equal(shifted.begin(), shifted.end(), ces_shifted, ces_shifted + 12))
        << "from:     " << ce_dumper(cps)
        << "expected: " << ce_dumper(ces_shifted)
        << "got:      " << ce_dumper(shifted);
}

TEST(collation, verbatim_131_345)
{
    uint32_t const cps[2] = { 0x1D705, 0x0062 };

    // 1D705 0062;	
    // (𝜅) MATHEMATICAL ITALIC SMALL KAPPA	[202E 1CC6 | 0020 0020 | 0005 0002 |]
    uint32_t const ces_non_ignorable[9] = { 0x202E, 0x1CC6, 0x0000, 0x0020, 0x0020, 0x0000, 0x0005, 0x0002, 0x0000 };

    auto const non_ignorable = collate_for_tests(
        cps, cps + 2, boost::text::variable_weighting::non_ignorable);

    EXPECT_EQ(non_ignorable.size(), 9);
    EXPECT_TRUE(boost::algorithm::equal(non_ignorable.begin(), non_ignorable.end(), ces_non_ignorable, ces_non_ignorable + 9))
        << "from:     " << ce_dumper(cps)
        << "expected: " << ce_dumper(ces_non_ignorable)
        << "got:      " << ce_dumper(non_ignorable);

    // 1D705 0062;	
    // (𝜅) MATHEMATICAL ITALIC SMALL KAPPA	[202E 1CC6 | 0020 0020 | 0005 0002 | FFFF FFFF |]
    uint32_t const ces_shifted[12] = { 0x202E, 0x1CC6, 0x0000, 0x0020, 0x0020, 0x0000, 0x0005, 0x0002, 0x0000, 0xFFFF, 0xFFFF, 0x0000 };

    auto const shifted = collate_for_tests(
        cps, cps + 2, boost::text::variable_weighting::shifted);

    EXPECT_EQ(shifted.size(), 12);
    EXPECT_TRUE(boost::algorithm::equal(shifted.begin(), shifted.end(), ces_shifted, ces_shifted + 12))
        << "from:     " << ce_dumper(cps)
        << "expected: " << ce_dumper(ces_shifted)
        << "got:      " << ce_dumper(shifted);
}

TEST(collation, verbatim_131_346)
{
    uint32_t const cps[2] = { 0x1D718, 0x0062 };

    // 1D718 0062;	
    // (𝜘) MATHEMATICAL ITALIC KAPPA SYMBOL	[202E 1CC6 | 0020 0020 | 0005 0002 |]
    uint32_t const ces_non_ignorable[9] = { 0x202E, 0x1CC6, 0x0000, 0x0020, 0x0020, 0x0000, 0x0005, 0x0002, 0x0000 };

    auto const non_ignorable = collate_for_tests(
        cps, cps + 2, boost::text::variable_weighting::non_ignorable);

    EXPECT_EQ(non_ignorable.size(), 9);
    EXPECT_TRUE(boost::algorithm::equal(non_ignorable.begin(), non_ignorable.end(), ces_non_ignorable, ces_non_ignorable + 9))
        << "from:     " << ce_dumper(cps)
        << "expected: " << ce_dumper(ces_non_ignorable)
        << "got:      " << ce_dumper(non_ignorable);

    // 1D718 0062;	
    // (𝜘) MATHEMATICAL ITALIC KAPPA SYMBOL	[202E 1CC6 | 0020 0020 | 0005 0002 | FFFF FFFF |]
    uint32_t const ces_shifted[12] = { 0x202E, 0x1CC6, 0x0000, 0x0020, 0x0020, 0x0000, 0x0005, 0x0002, 0x0000, 0xFFFF, 0xFFFF, 0x0000 };

    auto const shifted = collate_for_tests(
        cps, cps + 2, boost::text::variable_weighting::shifted);

    EXPECT_EQ(shifted.size(), 12);
    EXPECT_TRUE(boost::algorithm::equal(shifted.begin(), shifted.end(), ces_shifted, ces_shifted + 12))
        << "from:     " << ce_dumper(cps)
        << "expected: " << ce_dumper(ces_shifted)
        << "got:      " << ce_dumper(shifted);
}

TEST(collation, verbatim_131_347)
{
    uint32_t const cps[2] = { 0x1D73F, 0x0062 };

    // 1D73F 0062;	
    // (𝜿) MATHEMATICAL BOLD ITALIC SMALL KAPPA	[202E 1CC6 | 0020 0020 | 0005 0002 |]
    uint32_t const ces_non_ignorable[9] = { 0x202E, 0x1CC6, 0x0000, 0x0020, 0x0020, 0x0000, 0x0005, 0x0002, 0x0000 };

    auto const non_ignorable = collate_for_tests(
        cps, cps + 2, boost::text::variable_weighting::non_ignorable);

    EXPECT_EQ(non_ignorable.size(), 9);
    EXPECT_TRUE(boost::algorithm::equal(non_ignorable.begin(), non_ignorable.end(), ces_non_ignorable, ces_non_ignorable + 9))
        << "from:     " << ce_dumper(cps)
        << "expected: " << ce_dumper(ces_non_ignorable)
        << "got:      " << ce_dumper(non_ignorable);

    // 1D73F 0062;	
    // (𝜿) MATHEMATICAL BOLD ITALIC SMALL KAPPA	[202E 1CC6 | 0020 0020 | 0005 0002 | FFFF FFFF |]
    uint32_t const ces_shifted[12] = { 0x202E, 0x1CC6, 0x0000, 0x0020, 0x0020, 0x0000, 0x0005, 0x0002, 0x0000, 0xFFFF, 0xFFFF, 0x0000 };

    auto const shifted = collate_for_tests(
        cps, cps + 2, boost::text::variable_weighting::shifted);

    EXPECT_EQ(shifted.size(), 12);
    EXPECT_TRUE(boost::algorithm::equal(shifted.begin(), shifted.end(), ces_shifted, ces_shifted + 12))
        << "from:     " << ce_dumper(cps)
        << "expected: " << ce_dumper(ces_shifted)
        << "got:      " << ce_dumper(shifted);
}

TEST(collation, verbatim_131_348)
{
    uint32_t const cps[2] = { 0x1D752, 0x0062 };

    // 1D752 0062;	
    // (𝝒) MATHEMATICAL BOLD ITALIC KAPPA SYMBOL	[202E 1CC6 | 0020 0020 | 0005 0002 |]
    uint32_t const ces_non_ignorable[9] = { 0x202E, 0x1CC6, 0x0000, 0x0020, 0x0020, 0x0000, 0x0005, 0x0002, 0x0000 };

    auto const non_ignorable = collate_for_tests(
        cps, cps + 2, boost::text::variable_weighting::non_ignorable);

    EXPECT_EQ(non_ignorable.size(), 9);
    EXPECT_TRUE(boost::algorithm::equal(non_ignorable.begin(), non_ignorable.end(), ces_non_ignorable, ces_non_ignorable + 9))
        << "from:     " << ce_dumper(cps)
        << "expected: " << ce_dumper(ces_non_ignorable)
        << "got:      " << ce_dumper(non_ignorable);

    // 1D752 0062;	
    // (𝝒) MATHEMATICAL BOLD ITALIC KAPPA SYMBOL	[202E 1CC6 | 0020 0020 | 0005 0002 | FFFF FFFF |]
    uint32_t const ces_shifted[12] = { 0x202E, 0x1CC6, 0x0000, 0x0020, 0x0020, 0x0000, 0x0005, 0x0002, 0x0000, 0xFFFF, 0xFFFF, 0x0000 };

    auto const shifted = collate_for_tests(
        cps, cps + 2, boost::text::variable_weighting::shifted);

    EXPECT_EQ(shifted.size(), 12);
    EXPECT_TRUE(boost::algorithm::equal(shifted.begin(), shifted.end(), ces_shifted, ces_shifted + 12))
        << "from:     " << ce_dumper(cps)
        << "expected: " << ce_dumper(ces_shifted)
        << "got:      " << ce_dumper(shifted);
}

TEST(collation, verbatim_131_349)
{
    uint32_t const cps[2] = { 0x1D779, 0x0062 };

    // 1D779 0062;	
    // (𝝹) MATHEMATICAL SANS-SERIF BOLD SMALL KAPPA	[202E 1CC6 | 0020 0020 | 0005 0002 |]
    uint32_t const ces_non_ignorable[9] = { 0x202E, 0x1CC6, 0x0000, 0x0020, 0x0020, 0x0000, 0x0005, 0x0002, 0x0000 };

    auto const non_ignorable = collate_for_tests(
        cps, cps + 2, boost::text::variable_weighting::non_ignorable);

    EXPECT_EQ(non_ignorable.size(), 9);
    EXPECT_TRUE(boost::algorithm::equal(non_ignorable.begin(), non_ignorable.end(), ces_non_ignorable, ces_non_ignorable + 9))
        << "from:     " << ce_dumper(cps)
        << "expected: " << ce_dumper(ces_non_ignorable)
        << "got:      " << ce_dumper(non_ignorable);

    // 1D779 0062;	
    // (𝝹) MATHEMATICAL SANS-SERIF BOLD SMALL KAPPA	[202E 1CC6 | 0020 0020 | 0005 0002 | FFFF FFFF |]
    uint32_t const ces_shifted[12] = { 0x202E, 0x1CC6, 0x0000, 0x0020, 0x0020, 0x0000, 0x0005, 0x0002, 0x0000, 0xFFFF, 0xFFFF, 0x0000 };

    auto const shifted = collate_for_tests(
        cps, cps + 2, boost::text::variable_weighting::shifted);

    EXPECT_EQ(shifted.size(), 12);
    EXPECT_TRUE(boost::algorithm::equal(shifted.begin(), shifted.end(), ces_shifted, ces_shifted + 12))
        << "from:     " << ce_dumper(cps)
        << "expected: " << ce_dumper(ces_shifted)
        << "got:      " << ce_dumper(shifted);
}

TEST(collation, verbatim_131_350)
{
    uint32_t const cps[2] = { 0x1D78C, 0x0062 };

    // 1D78C 0062;	
    // (𝞌) MATHEMATICAL SANS-SERIF BOLD KAPPA SYMBOL	[202E 1CC6 | 0020 0020 | 0005 0002 |]
    uint32_t const ces_non_ignorable[9] = { 0x202E, 0x1CC6, 0x0000, 0x0020, 0x0020, 0x0000, 0x0005, 0x0002, 0x0000 };

    auto const non_ignorable = collate_for_tests(
        cps, cps + 2, boost::text::variable_weighting::non_ignorable);

    EXPECT_EQ(non_ignorable.size(), 9);
    EXPECT_TRUE(boost::algorithm::equal(non_ignorable.begin(), non_ignorable.end(), ces_non_ignorable, ces_non_ignorable + 9))
        << "from:     " << ce_dumper(cps)
        << "expected: " << ce_dumper(ces_non_ignorable)
        << "got:      " << ce_dumper(non_ignorable);

    // 1D78C 0062;	
    // (𝞌) MATHEMATICAL SANS-SERIF BOLD KAPPA SYMBOL	[202E 1CC6 | 0020 0020 | 0005 0002 | FFFF FFFF |]
    uint32_t const ces_shifted[12] = { 0x202E, 0x1CC6, 0x0000, 0x0020, 0x0020, 0x0000, 0x0005, 0x0002, 0x0000, 0xFFFF, 0xFFFF, 0x0000 };

    auto const shifted = collate_for_tests(
        cps, cps + 2, boost::text::variable_weighting::shifted);

    EXPECT_EQ(shifted.size(), 12);
    EXPECT_TRUE(boost::algorithm::equal(shifted.begin(), shifted.end(), ces_shifted, ces_shifted + 12))
        << "from:     " << ce_dumper(cps)
        << "expected: " << ce_dumper(ces_shifted)
        << "got:      " << ce_dumper(shifted);
}

TEST(collation, verbatim_131_351)
{
    uint32_t const cps[2] = { 0x1D7B3, 0x0062 };

    // 1D7B3 0062;	
    // (𝞳) MATHEMATICAL SANS-SERIF BOLD ITALIC SMALL KAPPA	[202E 1CC6 | 0020 0020 | 0005 0002 |]
    uint32_t const ces_non_ignorable[9] = { 0x202E, 0x1CC6, 0x0000, 0x0020, 0x0020, 0x0000, 0x0005, 0x0002, 0x0000 };

    auto const non_ignorable = collate_for_tests(
        cps, cps + 2, boost::text::variable_weighting::non_ignorable);

    EXPECT_EQ(non_ignorable.size(), 9);
    EXPECT_TRUE(boost::algorithm::equal(non_ignorable.begin(), non_ignorable.end(), ces_non_ignorable, ces_non_ignorable + 9))
        << "from:     " << ce_dumper(cps)
        << "expected: " << ce_dumper(ces_non_ignorable)
        << "got:      " << ce_dumper(non_ignorable);

    // 1D7B3 0062;	
    // (𝞳) MATHEMATICAL SANS-SERIF BOLD ITALIC SMALL KAPPA	[202E 1CC6 | 0020 0020 | 0005 0002 | FFFF FFFF |]
    uint32_t const ces_shifted[12] = { 0x202E, 0x1CC6, 0x0000, 0x0020, 0x0020, 0x0000, 0x0005, 0x0002, 0x0000, 0xFFFF, 0xFFFF, 0x0000 };

    auto const shifted = collate_for_tests(
        cps, cps + 2, boost::text::variable_weighting::shifted);

    EXPECT_EQ(shifted.size(), 12);
    EXPECT_TRUE(boost::algorithm::equal(shifted.begin(), shifted.end(), ces_shifted, ces_shifted + 12))
        << "from:     " << ce_dumper(cps)
        << "expected: " << ce_dumper(ces_shifted)
        << "got:      " << ce_dumper(shifted);
}

TEST(collation, verbatim_131_352)
{
    uint32_t const cps[2] = { 0x1D7C6, 0x0062 };

    // 1D7C6 0062;	
    // (𝟆) MATHEMATICAL SANS-SERIF BOLD ITALIC KAPPA SYMBOL	[202E 1CC6 | 0020 0020 | 0005 0002 |]
    uint32_t const ces_non_ignorable[9] = { 0x202E, 0x1CC6, 0x0000, 0x0020, 0x0020, 0x0000, 0x0005, 0x0002, 0x0000 };

    auto const non_ignorable = collate_for_tests(
        cps, cps + 2, boost::text::variable_weighting::non_ignorable);

    EXPECT_EQ(non_ignorable.size(), 9);
    EXPECT_TRUE(boost::algorithm::equal(non_ignorable.begin(), non_ignorable.end(), ces_non_ignorable, ces_non_ignorable + 9))
        << "from:     " << ce_dumper(cps)
        << "expected: " << ce_dumper(ces_non_ignorable)
        << "got:      " << ce_dumper(non_ignorable);

    // 1D7C6 0062;	
    // (𝟆) MATHEMATICAL SANS-SERIF BOLD ITALIC KAPPA SYMBOL	[202E 1CC6 | 0020 0020 | 0005 0002 | FFFF FFFF |]
    uint32_t const ces_shifted[12] = { 0x202E, 0x1CC6, 0x0000, 0x0020, 0x0020, 0x0000, 0x0005, 0x0002, 0x0000, 0xFFFF, 0xFFFF, 0x0000 };

    auto const shifted = collate_for_tests(
        cps, cps + 2, boost::text::variable_weighting::shifted);

    EXPECT_EQ(shifted.size(), 12);
    EXPECT_TRUE(boost::algorithm::equal(shifted.begin(), shifted.end(), ces_shifted, ces_shifted + 12))
        << "from:     " << ce_dumper(cps)
        << "expected: " << ce_dumper(ces_shifted)
        << "got:      " << ce_dumper(shifted);
}

TEST(collation, verbatim_131_353)
{
    uint32_t const cps[2] = { 0x039A, 0x0062 };

    // 039A 0062;	
    // (Κ) GREEK CAPITAL LETTER KAPPA	[202E 1CC6 | 0020 0020 | 0008 0002 |]
    uint32_t const ces_non_ignorable[9] = { 0x202E, 0x1CC6, 0x0000, 0x0020, 0x0020, 0x0000, 0x0008, 0x0002, 0x0000 };

    auto const non_ignorable = collate_for_tests(
        cps, cps + 2, boost::text::variable_weighting::non_ignorable);

    EXPECT_EQ(non_ignorable.size(), 9);
    EXPECT_TRUE(boost::algorithm::equal(non_ignorable.begin(), non_ignorable.end(), ces_non_ignorable, ces_non_ignorable + 9))
        << "from:     " << ce_dumper(cps)
        << "expected: " << ce_dumper(ces_non_ignorable)
        << "got:      " << ce_dumper(non_ignorable);

    // 039A 0062;	
    // (Κ) GREEK CAPITAL LETTER KAPPA	[202E 1CC6 | 0020 0020 | 0008 0002 | FFFF FFFF |]
    uint32_t const ces_shifted[12] = { 0x202E, 0x1CC6, 0x0000, 0x0020, 0x0020, 0x0000, 0x0008, 0x0002, 0x0000, 0xFFFF, 0xFFFF, 0x0000 };

    auto const shifted = collate_for_tests(
        cps, cps + 2, boost::text::variable_weighting::shifted);

    EXPECT_EQ(shifted.size(), 12);
    EXPECT_TRUE(boost::algorithm::equal(shifted.begin(), shifted.end(), ces_shifted, ces_shifted + 12))
        << "from:     " << ce_dumper(cps)
        << "expected: " << ce_dumper(ces_shifted)
        << "got:      " << ce_dumper(shifted);
}

TEST(collation, verbatim_131_354)
{
    uint32_t const cps[2] = { 0x1D6B1, 0x0062 };

    // 1D6B1 0062;	
    // (𝚱) MATHEMATICAL BOLD CAPITAL KAPPA	[202E 1CC6 | 0020 0020 | 000B 0002 |]
    uint32_t const ces_non_ignorable[9] = { 0x202E, 0x1CC6, 0x0000, 0x0020, 0x0020, 0x0000, 0x000B, 0x0002, 0x0000 };

    auto const non_ignorable = collate_for_tests(
        cps, cps + 2, boost::text::variable_weighting::non_ignorable);

    EXPECT_EQ(non_ignorable.size(), 9);
    EXPECT_TRUE(boost::algorithm::equal(non_ignorable.begin(), non_ignorable.end(), ces_non_ignorable, ces_non_ignorable + 9))
        << "from:     " << ce_dumper(cps)
        << "expected: " << ce_dumper(ces_non_ignorable)
        << "got:      " << ce_dumper(non_ignorable);

    // 1D6B1 0062;	
    // (𝚱) MATHEMATICAL BOLD CAPITAL KAPPA	[202E 1CC6 | 0020 0020 | 000B 0002 | FFFF FFFF |]
    uint32_t const ces_shifted[12] = { 0x202E, 0x1CC6, 0x0000, 0x0020, 0x0020, 0x0000, 0x000B, 0x0002, 0x0000, 0xFFFF, 0xFFFF, 0x0000 };

    auto const shifted = collate_for_tests(
        cps, cps + 2, boost::text::variable_weighting::shifted);

    EXPECT_EQ(shifted.size(), 12);
    EXPECT_TRUE(boost::algorithm::equal(shifted.begin(), shifted.end(), ces_shifted, ces_shifted + 12))
        << "from:     " << ce_dumper(cps)
        << "expected: " << ce_dumper(ces_shifted)
        << "got:      " << ce_dumper(shifted);
}

TEST(collation, verbatim_131_355)
{
    uint32_t const cps[2] = { 0x1D6EB, 0x0062 };

    // 1D6EB 0062;	
    // (𝛫) MATHEMATICAL ITALIC CAPITAL KAPPA	[202E 1CC6 | 0020 0020 | 000B 0002 |]
    uint32_t const ces_non_ignorable[9] = { 0x202E, 0x1CC6, 0x0000, 0x0020, 0x0020, 0x0000, 0x000B, 0x0002, 0x0000 };

    auto const non_ignorable = collate_for_tests(
        cps, cps + 2, boost::text::variable_weighting::non_ignorable);

    EXPECT_EQ(non_ignorable.size(), 9);
    EXPECT_TRUE(boost::algorithm::equal(non_ignorable.begin(), non_ignorable.end(), ces_non_ignorable, ces_non_ignorable + 9))
        << "from:     " << ce_dumper(cps)
        << "expected: " << ce_dumper(ces_non_ignorable)
        << "got:      " << ce_dumper(non_ignorable);

    // 1D6EB 0062;	
    // (𝛫) MATHEMATICAL ITALIC CAPITAL KAPPA	[202E 1CC6 | 0020 0020 | 000B 0002 | FFFF FFFF |]
    uint32_t const ces_shifted[12] = { 0x202E, 0x1CC6, 0x0000, 0x0020, 0x0020, 0x0000, 0x000B, 0x0002, 0x0000, 0xFFFF, 0xFFFF, 0x0000 };

    auto const shifted = collate_for_tests(
        cps, cps + 2, boost::text::variable_weighting::shifted);

    EXPECT_EQ(shifted.size(), 12);
    EXPECT_TRUE(boost::algorithm::equal(shifted.begin(), shifted.end(), ces_shifted, ces_shifted + 12))
        << "from:     " << ce_dumper(cps)
        << "expected: " << ce_dumper(ces_shifted)
        << "got:      " << ce_dumper(shifted);
}

TEST(collation, verbatim_131_356)
{
    uint32_t const cps[2] = { 0x1D725, 0x0062 };

    // 1D725 0062;	
    // (𝜥) MATHEMATICAL BOLD ITALIC CAPITAL KAPPA	[202E 1CC6 | 0020 0020 | 000B 0002 |]
    uint32_t const ces_non_ignorable[9] = { 0x202E, 0x1CC6, 0x0000, 0x0020, 0x0020, 0x0000, 0x000B, 0x0002, 0x0000 };

    auto const non_ignorable = collate_for_tests(
        cps, cps + 2, boost::text::variable_weighting::non_ignorable);

    EXPECT_EQ(non_ignorable.size(), 9);
    EXPECT_TRUE(boost::algorithm::equal(non_ignorable.begin(), non_ignorable.end(), ces_non_ignorable, ces_non_ignorable + 9))
        << "from:     " << ce_dumper(cps)
        << "expected: " << ce_dumper(ces_non_ignorable)
        << "got:      " << ce_dumper(non_ignorable);

    // 1D725 0062;	
    // (𝜥) MATHEMATICAL BOLD ITALIC CAPITAL KAPPA	[202E 1CC6 | 0020 0020 | 000B 0002 | FFFF FFFF |]
    uint32_t const ces_shifted[12] = { 0x202E, 0x1CC6, 0x0000, 0x0020, 0x0020, 0x0000, 0x000B, 0x0002, 0x0000, 0xFFFF, 0xFFFF, 0x0000 };

    auto const shifted = collate_for_tests(
        cps, cps + 2, boost::text::variable_weighting::shifted);

    EXPECT_EQ(shifted.size(), 12);
    EXPECT_TRUE(boost::algorithm::equal(shifted.begin(), shifted.end(), ces_shifted, ces_shifted + 12))
        << "from:     " << ce_dumper(cps)
        << "expected: " << ce_dumper(ces_shifted)
        << "got:      " << ce_dumper(shifted);
}

TEST(collation, verbatim_131_357)
{
    uint32_t const cps[2] = { 0x1D75F, 0x0062 };

    // 1D75F 0062;	
    // (𝝟) MATHEMATICAL SANS-SERIF BOLD CAPITAL KAPPA	[202E 1CC6 | 0020 0020 | 000B 0002 |]
    uint32_t const ces_non_ignorable[9] = { 0x202E, 0x1CC6, 0x0000, 0x0020, 0x0020, 0x0000, 0x000B, 0x0002, 0x0000 };

    auto const non_ignorable = collate_for_tests(
        cps, cps + 2, boost::text::variable_weighting::non_ignorable);

    EXPECT_EQ(non_ignorable.size(), 9);
    EXPECT_TRUE(boost::algorithm::equal(non_ignorable.begin(), non_ignorable.end(), ces_non_ignorable, ces_non_ignorable + 9))
        << "from:     " << ce_dumper(cps)
        << "expected: " << ce_dumper(ces_non_ignorable)
        << "got:      " << ce_dumper(non_ignorable);

    // 1D75F 0062;	
    // (𝝟) MATHEMATICAL SANS-SERIF BOLD CAPITAL KAPPA	[202E 1CC6 | 0020 0020 | 000B 0002 | FFFF FFFF |]
    uint32_t const ces_shifted[12] = { 0x202E, 0x1CC6, 0x0000, 0x0020, 0x0020, 0x0000, 0x000B, 0x0002, 0x0000, 0xFFFF, 0xFFFF, 0x0000 };

    auto const shifted = collate_for_tests(
        cps, cps + 2, boost::text::variable_weighting::shifted);

    EXPECT_EQ(shifted.size(), 12);
    EXPECT_TRUE(boost::algorithm::equal(shifted.begin(), shifted.end(), ces_shifted, ces_shifted + 12))
        << "from:     " << ce_dumper(cps)
        << "expected: " << ce_dumper(ces_shifted)
        << "got:      " << ce_dumper(shifted);
}

TEST(collation, verbatim_131_358)
{
    uint32_t const cps[2] = { 0x1D799, 0x0062 };

    // 1D799 0062;	
    // (𝞙) MATHEMATICAL SANS-SERIF BOLD ITALIC CAPITAL KAPPA	[202E 1CC6 | 0020 0020 | 000B 0002 |]
    uint32_t const ces_non_ignorable[9] = { 0x202E, 0x1CC6, 0x0000, 0x0020, 0x0020, 0x0000, 0x000B, 0x0002, 0x0000 };

    auto const non_ignorable = collate_for_tests(
        cps, cps + 2, boost::text::variable_weighting::non_ignorable);

    EXPECT_EQ(non_ignorable.size(), 9);
    EXPECT_TRUE(boost::algorithm::equal(non_ignorable.begin(), non_ignorable.end(), ces_non_ignorable, ces_non_ignorable + 9))
        << "from:     " << ce_dumper(cps)
        << "expected: " << ce_dumper(ces_non_ignorable)
        << "got:      " << ce_dumper(non_ignorable);

    // 1D799 0062;	
    // (𝞙) MATHEMATICAL SANS-SERIF BOLD ITALIC CAPITAL KAPPA	[202E 1CC6 | 0020 0020 | 000B 0002 | FFFF FFFF |]
    uint32_t const ces_shifted[12] = { 0x202E, 0x1CC6, 0x0000, 0x0020, 0x0020, 0x0000, 0x000B, 0x0002, 0x0000, 0xFFFF, 0xFFFF, 0x0000 };

    auto const shifted = collate_for_tests(
        cps, cps + 2, boost::text::variable_weighting::shifted);

    EXPECT_EQ(shifted.size(), 12);
    EXPECT_TRUE(boost::algorithm::equal(shifted.begin(), shifted.end(), ces_shifted, ces_shifted + 12))
        << "from:     " << ce_dumper(cps)
        << "expected: " << ce_dumper(ces_shifted)
        << "got:      " << ce_dumper(shifted);
}

TEST(collation, verbatim_131_359)
{
    uint32_t const cps[2] = { 0x03D7, 0x0021 };

    // 03D7 0021;	
    // (ϗ) GREEK KAI SYMBOL	[202E 201F 202C 0261 | 0020 0020 0020 0020 | 0004 0004 0004 0002 |]
    uint32_t const ces_non_ignorable[15] = { 0x202E, 0x201F, 0x202C, 0x0261, 0x0000, 0x0020, 0x0020, 0x0020, 0x0020, 0x0000, 0x0004, 0x0004, 0x0004, 0x0002, 0x0000 };

    auto const non_ignorable = collate_for_tests(
        cps, cps + 2, boost::text::variable_weighting::non_ignorable);

    EXPECT_EQ(non_ignorable.size(), 15);
    EXPECT_TRUE(boost::algorithm::equal(non_ignorable.begin(), non_ignorable.end(), ces_non_ignorable, ces_non_ignorable + 15))
        << "from:     " << ce_dumper(cps)
        << "expected: " << ce_dumper(ces_non_ignorable)
        << "got:      " << ce_dumper(non_ignorable);

    // 03D7 0021;	
    // (ϗ) GREEK KAI SYMBOL	[202E 201F 202C | 0020 0020 0020 | 0004 0004 0004 | FFFF FFFF FFFF 0261 |]
    uint32_t const ces_shifted[17] = { 0x202E, 0x201F, 0x202C, 0x0000, 0x0020, 0x0020, 0x0020, 0x0000, 0x0004, 0x0004, 0x0004, 0x0000, 0xFFFF, 0xFFFF, 0xFFFF, 0x0261, 0x0000 };

    auto const shifted = collate_for_tests(
        cps, cps + 2, boost::text::variable_weighting::shifted);

    EXPECT_EQ(shifted.size(), 17);
    EXPECT_TRUE(boost::algorithm::equal(shifted.begin(), shifted.end(), ces_shifted, ces_shifted + 17))
        << "from:     " << ce_dumper(cps)
        << "expected: " << ce_dumper(ces_shifted)
        << "got:      " << ce_dumper(shifted);
}

TEST(collation, verbatim_131_360)
{
    uint32_t const cps[2] = { 0x03CF, 0x0021 };

    // 03CF 0021;	
    // (Ϗ) GREEK CAPITAL KAI SYMBOL	[202E 201F 202C 0261 | 0020 0020 0020 0020 | 000A 0004 0004 0002 |]
    uint32_t const ces_non_ignorable[15] = { 0x202E, 0x201F, 0x202C, 0x0261, 0x0000, 0x0020, 0x0020, 0x0020, 0x0020, 0x0000, 0x000A, 0x0004, 0x0004, 0x0002, 0x0000 };

    auto const non_ignorable = collate_for_tests(
        cps, cps + 2, boost::text::variable_weighting::non_ignorable);

    EXPECT_EQ(non_ignorable.size(), 15);
    EXPECT_TRUE(boost::algorithm::equal(non_ignorable.begin(), non_ignorable.end(), ces_non_ignorable, ces_non_ignorable + 15))
        << "from:     " << ce_dumper(cps)
        << "expected: " << ce_dumper(ces_non_ignorable)
        << "got:      " << ce_dumper(non_ignorable);

    // 03CF 0021;	
    // (Ϗ) GREEK CAPITAL KAI SYMBOL	[202E 201F 202C | 0020 0020 0020 | 000A 0004 0004 | FFFF FFFF FFFF 0261 |]
    uint32_t const ces_shifted[17] = { 0x202E, 0x201F, 0x202C, 0x0000, 0x0020, 0x0020, 0x0020, 0x0000, 0x000A, 0x0004, 0x0004, 0x0000, 0xFFFF, 0xFFFF, 0xFFFF, 0x0261, 0x0000 };

    auto const shifted = collate_for_tests(
        cps, cps + 2, boost::text::variable_weighting::shifted);

    EXPECT_EQ(shifted.size(), 17);
    EXPECT_TRUE(boost::algorithm::equal(shifted.begin(), shifted.end(), ces_shifted, ces_shifted + 17))
        << "from:     " << ce_dumper(cps)
        << "expected: " << ce_dumper(ces_shifted)
        << "got:      " << ce_dumper(shifted);
}

TEST(collation, verbatim_131_361)
{
    uint32_t const cps[2] = { 0x03D7, 0x003F };

    // 03D7 003F;	
    // (ϗ) GREEK KAI SYMBOL	[202E 201F 202C 0267 | 0020 0020 0020 0020 | 0004 0004 0004 0002 |]
    uint32_t const ces_non_ignorable[15] = { 0x202E, 0x201F, 0x202C, 0x0267, 0x0000, 0x0020, 0x0020, 0x0020, 0x0020, 0x0000, 0x0004, 0x0004, 0x0004, 0x0002, 0x0000 };

    auto const non_ignorable = collate_for_tests(
        cps, cps + 2, boost::text::variable_weighting::non_ignorable);

    EXPECT_EQ(non_ignorable.size(), 15);
    EXPECT_TRUE(boost::algorithm::equal(non_ignorable.begin(), non_ignorable.end(), ces_non_ignorable, ces_non_ignorable + 15))
        << "from:     " << ce_dumper(cps)
        << "expected: " << ce_dumper(ces_non_ignorable)
        << "got:      " << ce_dumper(non_ignorable);

    // 03D7 003F;	
    // (ϗ) GREEK KAI SYMBOL	[202E 201F 202C | 0020 0020 0020 | 0004 0004 0004 | FFFF FFFF FFFF 0267 |]
    uint32_t const ces_shifted[17] = { 0x202E, 0x201F, 0x202C, 0x0000, 0x0020, 0x0020, 0x0020, 0x0000, 0x0004, 0x0004, 0x0004, 0x0000, 0xFFFF, 0xFFFF, 0xFFFF, 0x0267, 0x0000 };

    auto const shifted = collate_for_tests(
        cps, cps + 2, boost::text::variable_weighting::shifted);

    EXPECT_EQ(shifted.size(), 17);
    EXPECT_TRUE(boost::algorithm::equal(shifted.begin(), shifted.end(), ces_shifted, ces_shifted + 17))
        << "from:     " << ce_dumper(cps)
        << "expected: " << ce_dumper(ces_shifted)
        << "got:      " << ce_dumper(shifted);
}

TEST(collation, verbatim_131_362)
{
    uint32_t const cps[2] = { 0x03CF, 0x003F };

    // 03CF 003F;	
    // (Ϗ) GREEK CAPITAL KAI SYMBOL	[202E 201F 202C 0267 | 0020 0020 0020 0020 | 000A 0004 0004 0002 |]
    uint32_t const ces_non_ignorable[15] = { 0x202E, 0x201F, 0x202C, 0x0267, 0x0000, 0x0020, 0x0020, 0x0020, 0x0020, 0x0000, 0x000A, 0x0004, 0x0004, 0x0002, 0x0000 };

    auto const non_ignorable = collate_for_tests(
        cps, cps + 2, boost::text::variable_weighting::non_ignorable);

    EXPECT_EQ(non_ignorable.size(), 15);
    EXPECT_TRUE(boost::algorithm::equal(non_ignorable.begin(), non_ignorable.end(), ces_non_ignorable, ces_non_ignorable + 15))
        << "from:     " << ce_dumper(cps)
        << "expected: " << ce_dumper(ces_non_ignorable)
        << "got:      " << ce_dumper(non_ignorable);

    // 03CF 003F;	
    // (Ϗ) GREEK CAPITAL KAI SYMBOL	[202E 201F 202C | 0020 0020 0020 | 000A 0004 0004 | FFFF FFFF FFFF 0267 |]
    uint32_t const ces_shifted[17] = { 0x202E, 0x201F, 0x202C, 0x0000, 0x0020, 0x0020, 0x0020, 0x0000, 0x000A, 0x0004, 0x0004, 0x0000, 0xFFFF, 0xFFFF, 0xFFFF, 0x0267, 0x0000 };

    auto const shifted = collate_for_tests(
        cps, cps + 2, boost::text::variable_weighting::shifted);

    EXPECT_EQ(shifted.size(), 17);
    EXPECT_TRUE(boost::algorithm::equal(shifted.begin(), shifted.end(), ces_shifted, ces_shifted + 17))
        << "from:     " << ce_dumper(cps)
        << "expected: " << ce_dumper(ces_shifted)
        << "got:      " << ce_dumper(shifted);
}

TEST(collation, verbatim_131_363)
{
    uint32_t const cps[2] = { 0x03D7, 0x0061 };

    // 03D7 0061;	
    // (ϗ) GREEK KAI SYMBOL	[202E 201F 202C 1CAD | 0020 0020 0020 0020 | 0004 0004 0004 0002 |]
    uint32_t const ces_non_ignorable[15] = { 0x202E, 0x201F, 0x202C, 0x1CAD, 0x0000, 0x0020, 0x0020, 0x0020, 0x0020, 0x0000, 0x0004, 0x0004, 0x0004, 0x0002, 0x0000 };

    auto const non_ignorable = collate_for_tests(
        cps, cps + 2, boost::text::variable_weighting::non_ignorable);

    EXPECT_EQ(non_ignorable.size(), 15);
    EXPECT_TRUE(boost::algorithm::equal(non_ignorable.begin(), non_ignorable.end(), ces_non_ignorable, ces_non_ignorable + 15))
        << "from:     " << ce_dumper(cps)
        << "expected: " << ce_dumper(ces_non_ignorable)
        << "got:      " << ce_dumper(non_ignorable);

    // 03D7 0061;	
    // (ϗ) GREEK KAI SYMBOL	[202E 201F 202C 1CAD | 0020 0020 0020 0020 | 0004 0004 0004 0002 | FFFF FFFF FFFF FFFF |]
    uint32_t const ces_shifted[20] = { 0x202E, 0x201F, 0x202C, 0x1CAD, 0x0000, 0x0020, 0x0020, 0x0020, 0x0020, 0x0000, 0x0004, 0x0004, 0x0004, 0x0002, 0x0000, 0xFFFF, 0xFFFF, 0xFFFF, 0xFFFF, 0x0000 };

    auto const shifted = collate_for_tests(
        cps, cps + 2, boost::text::variable_weighting::shifted);

    EXPECT_EQ(shifted.size(), 20);
    EXPECT_TRUE(boost::algorithm::equal(shifted.begin(), shifted.end(), ces_shifted, ces_shifted + 20))
        << "from:     " << ce_dumper(cps)
        << "expected: " << ce_dumper(ces_shifted)
        << "got:      " << ce_dumper(shifted);
}

TEST(collation, verbatim_131_364)
{
    uint32_t const cps[2] = { 0x03D7, 0x0041 };

    // 03D7 0041;	
    // (ϗ) GREEK KAI SYMBOL	[202E 201F 202C 1CAD | 0020 0020 0020 0020 | 0004 0004 0004 0008 |]
    uint32_t const ces_non_ignorable[15] = { 0x202E, 0x201F, 0x202C, 0x1CAD, 0x0000, 0x0020, 0x0020, 0x0020, 0x0020, 0x0000, 0x0004, 0x0004, 0x0004, 0x0008, 0x0000 };

    auto const non_ignorable = collate_for_tests(
        cps, cps + 2, boost::text::variable_weighting::non_ignorable);

    EXPECT_EQ(non_ignorable.size(), 15);
    EXPECT_TRUE(boost::algorithm::equal(non_ignorable.begin(), non_ignorable.end(), ces_non_ignorable, ces_non_ignorable + 15))
        << "from:     " << ce_dumper(cps)
        << "expected: " << ce_dumper(ces_non_ignorable)
        << "got:      " << ce_dumper(non_ignorable);

    // 03D7 0041;	
    // (ϗ) GREEK KAI SYMBOL	[202E 201F 202C 1CAD | 0020 0020 0020 0020 | 0004 0004 0004 0008 | FFFF FFFF FFFF FFFF |]
    uint32_t const ces_shifted[20] = { 0x202E, 0x201F, 0x202C, 0x1CAD, 0x0000, 0x0020, 0x0020, 0x0020, 0x0020, 0x0000, 0x0004, 0x0004, 0x0004, 0x0008, 0x0000, 0xFFFF, 0xFFFF, 0xFFFF, 0xFFFF, 0x0000 };

    auto const shifted = collate_for_tests(
        cps, cps + 2, boost::text::variable_weighting::shifted);

    EXPECT_EQ(shifted.size(), 20);
    EXPECT_TRUE(boost::algorithm::equal(shifted.begin(), shifted.end(), ces_shifted, ces_shifted + 20))
        << "from:     " << ce_dumper(cps)
        << "expected: " << ce_dumper(ces_shifted)
        << "got:      " << ce_dumper(shifted);
}

TEST(collation, verbatim_131_365)
{
    uint32_t const cps[2] = { 0x03CF, 0x0061 };

    // 03CF 0061;	
    // (Ϗ) GREEK CAPITAL KAI SYMBOL	[202E 201F 202C 1CAD | 0020 0020 0020 0020 | 000A 0004 0004 0002 |]
    uint32_t const ces_non_ignorable[15] = { 0x202E, 0x201F, 0x202C, 0x1CAD, 0x0000, 0x0020, 0x0020, 0x0020, 0x0020, 0x0000, 0x000A, 0x0004, 0x0004, 0x0002, 0x0000 };

    auto const non_ignorable = collate_for_tests(
        cps, cps + 2, boost::text::variable_weighting::non_ignorable);

    EXPECT_EQ(non_ignorable.size(), 15);
    EXPECT_TRUE(boost::algorithm::equal(non_ignorable.begin(), non_ignorable.end(), ces_non_ignorable, ces_non_ignorable + 15))
        << "from:     " << ce_dumper(cps)
        << "expected: " << ce_dumper(ces_non_ignorable)
        << "got:      " << ce_dumper(non_ignorable);

    // 03CF 0061;	
    // (Ϗ) GREEK CAPITAL KAI SYMBOL	[202E 201F 202C 1CAD | 0020 0020 0020 0020 | 000A 0004 0004 0002 | FFFF FFFF FFFF FFFF |]
    uint32_t const ces_shifted[20] = { 0x202E, 0x201F, 0x202C, 0x1CAD, 0x0000, 0x0020, 0x0020, 0x0020, 0x0020, 0x0000, 0x000A, 0x0004, 0x0004, 0x0002, 0x0000, 0xFFFF, 0xFFFF, 0xFFFF, 0xFFFF, 0x0000 };

    auto const shifted = collate_for_tests(
        cps, cps + 2, boost::text::variable_weighting::shifted);

    EXPECT_EQ(shifted.size(), 20);
    EXPECT_TRUE(boost::algorithm::equal(shifted.begin(), shifted.end(), ces_shifted, ces_shifted + 20))
        << "from:     " << ce_dumper(cps)
        << "expected: " << ce_dumper(ces_shifted)
        << "got:      " << ce_dumper(shifted);
}

TEST(collation, verbatim_131_366)
{
    uint32_t const cps[2] = { 0x03CF, 0x0041 };

    // 03CF 0041;	
    // (Ϗ) GREEK CAPITAL KAI SYMBOL	[202E 201F 202C 1CAD | 0020 0020 0020 0020 | 000A 0004 0004 0008 |]
    uint32_t const ces_non_ignorable[15] = { 0x202E, 0x201F, 0x202C, 0x1CAD, 0x0000, 0x0020, 0x0020, 0x0020, 0x0020, 0x0000, 0x000A, 0x0004, 0x0004, 0x0008, 0x0000 };

    auto const non_ignorable = collate_for_tests(
        cps, cps + 2, boost::text::variable_weighting::non_ignorable);

    EXPECT_EQ(non_ignorable.size(), 15);
    EXPECT_TRUE(boost::algorithm::equal(non_ignorable.begin(), non_ignorable.end(), ces_non_ignorable, ces_non_ignorable + 15))
        << "from:     " << ce_dumper(cps)
        << "expected: " << ce_dumper(ces_non_ignorable)
        << "got:      " << ce_dumper(non_ignorable);

    // 03CF 0041;	
    // (Ϗ) GREEK CAPITAL KAI SYMBOL	[202E 201F 202C 1CAD | 0020 0020 0020 0020 | 000A 0004 0004 0008 | FFFF FFFF FFFF FFFF |]
    uint32_t const ces_shifted[20] = { 0x202E, 0x201F, 0x202C, 0x1CAD, 0x0000, 0x0020, 0x0020, 0x0020, 0x0020, 0x0000, 0x000A, 0x0004, 0x0004, 0x0008, 0x0000, 0xFFFF, 0xFFFF, 0xFFFF, 0xFFFF, 0x0000 };

    auto const shifted = collate_for_tests(
        cps, cps + 2, boost::text::variable_weighting::shifted);

    EXPECT_EQ(shifted.size(), 20);
    EXPECT_TRUE(boost::algorithm::equal(shifted.begin(), shifted.end(), ces_shifted, ces_shifted + 20))
        << "from:     " << ce_dumper(cps)
        << "expected: " << ce_dumper(ces_shifted)
        << "got:      " << ce_dumper(shifted);
}

TEST(collation, verbatim_131_367)
{
    uint32_t const cps[2] = { 0x03D7, 0x0062 };

    // 03D7 0062;	
    // (ϗ) GREEK KAI SYMBOL	[202E 201F 202C 1CC6 | 0020 0020 0020 0020 | 0004 0004 0004 0002 |]
    uint32_t const ces_non_ignorable[15] = { 0x202E, 0x201F, 0x202C, 0x1CC6, 0x0000, 0x0020, 0x0020, 0x0020, 0x0020, 0x0000, 0x0004, 0x0004, 0x0004, 0x0002, 0x0000 };

    auto const non_ignorable = collate_for_tests(
        cps, cps + 2, boost::text::variable_weighting::non_ignorable);

    EXPECT_EQ(non_ignorable.size(), 15);
    EXPECT_TRUE(boost::algorithm::equal(non_ignorable.begin(), non_ignorable.end(), ces_non_ignorable, ces_non_ignorable + 15))
        << "from:     " << ce_dumper(cps)
        << "expected: " << ce_dumper(ces_non_ignorable)
        << "got:      " << ce_dumper(non_ignorable);

    // 03D7 0062;	
    // (ϗ) GREEK KAI SYMBOL	[202E 201F 202C 1CC6 | 0020 0020 0020 0020 | 0004 0004 0004 0002 | FFFF FFFF FFFF FFFF |]
    uint32_t const ces_shifted[20] = { 0x202E, 0x201F, 0x202C, 0x1CC6, 0x0000, 0x0020, 0x0020, 0x0020, 0x0020, 0x0000, 0x0004, 0x0004, 0x0004, 0x0002, 0x0000, 0xFFFF, 0xFFFF, 0xFFFF, 0xFFFF, 0x0000 };

    auto const shifted = collate_for_tests(
        cps, cps + 2, boost::text::variable_weighting::shifted);

    EXPECT_EQ(shifted.size(), 20);
    EXPECT_TRUE(boost::algorithm::equal(shifted.begin(), shifted.end(), ces_shifted, ces_shifted + 20))
        << "from:     " << ce_dumper(cps)
        << "expected: " << ce_dumper(ces_shifted)
        << "got:      " << ce_dumper(shifted);
}

TEST(collation, verbatim_131_368)
{
    uint32_t const cps[2] = { 0x03CF, 0x0062 };

    // 03CF 0062;	
    // (Ϗ) GREEK CAPITAL KAI SYMBOL	[202E 201F 202C 1CC6 | 0020 0020 0020 0020 | 000A 0004 0004 0002 |]
    uint32_t const ces_non_ignorable[15] = { 0x202E, 0x201F, 0x202C, 0x1CC6, 0x0000, 0x0020, 0x0020, 0x0020, 0x0020, 0x0000, 0x000A, 0x0004, 0x0004, 0x0002, 0x0000 };

    auto const non_ignorable = collate_for_tests(
        cps, cps + 2, boost::text::variable_weighting::non_ignorable);

    EXPECT_EQ(non_ignorable.size(), 15);
    EXPECT_TRUE(boost::algorithm::equal(non_ignorable.begin(), non_ignorable.end(), ces_non_ignorable, ces_non_ignorable + 15))
        << "from:     " << ce_dumper(cps)
        << "expected: " << ce_dumper(ces_non_ignorable)
        << "got:      " << ce_dumper(non_ignorable);

    // 03CF 0062;	
    // (Ϗ) GREEK CAPITAL KAI SYMBOL	[202E 201F 202C 1CC6 | 0020 0020 0020 0020 | 000A 0004 0004 0002 | FFFF FFFF FFFF FFFF |]
    uint32_t const ces_shifted[20] = { 0x202E, 0x201F, 0x202C, 0x1CC6, 0x0000, 0x0020, 0x0020, 0x0020, 0x0020, 0x0000, 0x000A, 0x0004, 0x0004, 0x0002, 0x0000, 0xFFFF, 0xFFFF, 0xFFFF, 0xFFFF, 0x0000 };

    auto const shifted = collate_for_tests(
        cps, cps + 2, boost::text::variable_weighting::shifted);

    EXPECT_EQ(shifted.size(), 20);
    EXPECT_TRUE(boost::algorithm::equal(shifted.begin(), shifted.end(), ces_shifted, ces_shifted + 20))
        << "from:     " << ce_dumper(cps)
        << "expected: " << ce_dumper(ces_shifted)
        << "got:      " << ce_dumper(shifted);
}

TEST(collation, verbatim_131_369)
{
    uint32_t const cps[2] = { 0x03BB, 0x0021 };

    // 03BB 0021;	
    // (λ) GREEK SMALL LETTER LAMDA	[202F 0261 | 0020 0020 | 0002 0002 |]
    uint32_t const ces_non_ignorable[9] = { 0x202F, 0x0261, 0x0000, 0x0020, 0x0020, 0x0000, 0x0002, 0x0002, 0x0000 };

    auto const non_ignorable = collate_for_tests(
        cps, cps + 2, boost::text::variable_weighting::non_ignorable);

    EXPECT_EQ(non_ignorable.size(), 9);
    EXPECT_TRUE(boost::algorithm::equal(non_ignorable.begin(), non_ignorable.end(), ces_non_ignorable, ces_non_ignorable + 9))
        << "from:     " << ce_dumper(cps)
        << "expected: " << ce_dumper(ces_non_ignorable)
        << "got:      " << ce_dumper(non_ignorable);

    // 03BB 0021;	
    // (λ) GREEK SMALL LETTER LAMDA	[202F | 0020 | 0002 | FFFF 0261 |]
    uint32_t const ces_shifted[9] = { 0x202F, 0x0000, 0x0020, 0x0000, 0x0002, 0x0000, 0xFFFF, 0x0261, 0x0000 };

    auto const shifted = collate_for_tests(
        cps, cps + 2, boost::text::variable_weighting::shifted);

    EXPECT_EQ(shifted.size(), 9);
    EXPECT_TRUE(boost::algorithm::equal(shifted.begin(), shifted.end(), ces_shifted, ces_shifted + 9))
        << "from:     " << ce_dumper(cps)
        << "expected: " << ce_dumper(ces_shifted)
        << "got:      " << ce_dumper(shifted);
}

TEST(collation, verbatim_131_370)
{
    uint32_t const cps[2] = { 0x1D6CC, 0x0021 };

    // 1D6CC 0021;	
    // (𝛌) MATHEMATICAL BOLD SMALL LAMDA	[202F 0261 | 0020 0020 | 0005 0002 |]
    uint32_t const ces_non_ignorable[9] = { 0x202F, 0x0261, 0x0000, 0x0020, 0x0020, 0x0000, 0x0005, 0x0002, 0x0000 };

    auto const non_ignorable = collate_for_tests(
        cps, cps + 2, boost::text::variable_weighting::non_ignorable);

    EXPECT_EQ(non_ignorable.size(), 9);
    EXPECT_TRUE(boost::algorithm::equal(non_ignorable.begin(), non_ignorable.end(), ces_non_ignorable, ces_non_ignorable + 9))
        << "from:     " << ce_dumper(cps)
        << "expected: " << ce_dumper(ces_non_ignorable)
        << "got:      " << ce_dumper(non_ignorable);

    // 1D6CC 0021;	
    // (𝛌) MATHEMATICAL BOLD SMALL LAMDA	[202F | 0020 | 0005 | FFFF 0261 |]
    uint32_t const ces_shifted[9] = { 0x202F, 0x0000, 0x0020, 0x0000, 0x0005, 0x0000, 0xFFFF, 0x0261, 0x0000 };

    auto const shifted = collate_for_tests(
        cps, cps + 2, boost::text::variable_weighting::shifted);

    EXPECT_EQ(shifted.size(), 9);
    EXPECT_TRUE(boost::algorithm::equal(shifted.begin(), shifted.end(), ces_shifted, ces_shifted + 9))
        << "from:     " << ce_dumper(cps)
        << "expected: " << ce_dumper(ces_shifted)
        << "got:      " << ce_dumper(shifted);
}

TEST(collation, verbatim_131_371)
{
    uint32_t const cps[2] = { 0x1D706, 0x0021 };

    // 1D706 0021;	
    // (𝜆) MATHEMATICAL ITALIC SMALL LAMDA	[202F 0261 | 0020 0020 | 0005 0002 |]
    uint32_t const ces_non_ignorable[9] = { 0x202F, 0x0261, 0x0000, 0x0020, 0x0020, 0x0000, 0x0005, 0x0002, 0x0000 };

    auto const non_ignorable = collate_for_tests(
        cps, cps + 2, boost::text::variable_weighting::non_ignorable);

    EXPECT_EQ(non_ignorable.size(), 9);
    EXPECT_TRUE(boost::algorithm::equal(non_ignorable.begin(), non_ignorable.end(), ces_non_ignorable, ces_non_ignorable + 9))
        << "from:     " << ce_dumper(cps)
        << "expected: " << ce_dumper(ces_non_ignorable)
        << "got:      " << ce_dumper(non_ignorable);

    // 1D706 0021;	
    // (𝜆) MATHEMATICAL ITALIC SMALL LAMDA	[202F | 0020 | 0005 | FFFF 0261 |]
    uint32_t const ces_shifted[9] = { 0x202F, 0x0000, 0x0020, 0x0000, 0x0005, 0x0000, 0xFFFF, 0x0261, 0x0000 };

    auto const shifted = collate_for_tests(
        cps, cps + 2, boost::text::variable_weighting::shifted);

    EXPECT_EQ(shifted.size(), 9);
    EXPECT_TRUE(boost::algorithm::equal(shifted.begin(), shifted.end(), ces_shifted, ces_shifted + 9))
        << "from:     " << ce_dumper(cps)
        << "expected: " << ce_dumper(ces_shifted)
        << "got:      " << ce_dumper(shifted);
}

TEST(collation, verbatim_131_372)
{
    uint32_t const cps[2] = { 0x1D740, 0x0021 };

    // 1D740 0021;	
    // (𝝀) MATHEMATICAL BOLD ITALIC SMALL LAMDA	[202F 0261 | 0020 0020 | 0005 0002 |]
    uint32_t const ces_non_ignorable[9] = { 0x202F, 0x0261, 0x0000, 0x0020, 0x0020, 0x0000, 0x0005, 0x0002, 0x0000 };

    auto const non_ignorable = collate_for_tests(
        cps, cps + 2, boost::text::variable_weighting::non_ignorable);

    EXPECT_EQ(non_ignorable.size(), 9);
    EXPECT_TRUE(boost::algorithm::equal(non_ignorable.begin(), non_ignorable.end(), ces_non_ignorable, ces_non_ignorable + 9))
        << "from:     " << ce_dumper(cps)
        << "expected: " << ce_dumper(ces_non_ignorable)
        << "got:      " << ce_dumper(non_ignorable);

    // 1D740 0021;	
    // (𝝀) MATHEMATICAL BOLD ITALIC SMALL LAMDA	[202F | 0020 | 0005 | FFFF 0261 |]
    uint32_t const ces_shifted[9] = { 0x202F, 0x0000, 0x0020, 0x0000, 0x0005, 0x0000, 0xFFFF, 0x0261, 0x0000 };

    auto const shifted = collate_for_tests(
        cps, cps + 2, boost::text::variable_weighting::shifted);

    EXPECT_EQ(shifted.size(), 9);
    EXPECT_TRUE(boost::algorithm::equal(shifted.begin(), shifted.end(), ces_shifted, ces_shifted + 9))
        << "from:     " << ce_dumper(cps)
        << "expected: " << ce_dumper(ces_shifted)
        << "got:      " << ce_dumper(shifted);
}

TEST(collation, verbatim_131_373)
{
    uint32_t const cps[2] = { 0x1D77A, 0x0021 };

    // 1D77A 0021;	
    // (𝝺) MATHEMATICAL SANS-SERIF BOLD SMALL LAMDA	[202F 0261 | 0020 0020 | 0005 0002 |]
    uint32_t const ces_non_ignorable[9] = { 0x202F, 0x0261, 0x0000, 0x0020, 0x0020, 0x0000, 0x0005, 0x0002, 0x0000 };

    auto const non_ignorable = collate_for_tests(
        cps, cps + 2, boost::text::variable_weighting::non_ignorable);

    EXPECT_EQ(non_ignorable.size(), 9);
    EXPECT_TRUE(boost::algorithm::equal(non_ignorable.begin(), non_ignorable.end(), ces_non_ignorable, ces_non_ignorable + 9))
        << "from:     " << ce_dumper(cps)
        << "expected: " << ce_dumper(ces_non_ignorable)
        << "got:      " << ce_dumper(non_ignorable);

    // 1D77A 0021;	
    // (𝝺) MATHEMATICAL SANS-SERIF BOLD SMALL LAMDA	[202F | 0020 | 0005 | FFFF 0261 |]
    uint32_t const ces_shifted[9] = { 0x202F, 0x0000, 0x0020, 0x0000, 0x0005, 0x0000, 0xFFFF, 0x0261, 0x0000 };

    auto const shifted = collate_for_tests(
        cps, cps + 2, boost::text::variable_weighting::shifted);

    EXPECT_EQ(shifted.size(), 9);
    EXPECT_TRUE(boost::algorithm::equal(shifted.begin(), shifted.end(), ces_shifted, ces_shifted + 9))
        << "from:     " << ce_dumper(cps)
        << "expected: " << ce_dumper(ces_shifted)
        << "got:      " << ce_dumper(shifted);
}

TEST(collation, verbatim_131_374)
{
    uint32_t const cps[2] = { 0x1D7B4, 0x0021 };

    // 1D7B4 0021;	
    // (𝞴) MATHEMATICAL SANS-SERIF BOLD ITALIC SMALL LAMDA	[202F 0261 | 0020 0020 | 0005 0002 |]
    uint32_t const ces_non_ignorable[9] = { 0x202F, 0x0261, 0x0000, 0x0020, 0x0020, 0x0000, 0x0005, 0x0002, 0x0000 };

    auto const non_ignorable = collate_for_tests(
        cps, cps + 2, boost::text::variable_weighting::non_ignorable);

    EXPECT_EQ(non_ignorable.size(), 9);
    EXPECT_TRUE(boost::algorithm::equal(non_ignorable.begin(), non_ignorable.end(), ces_non_ignorable, ces_non_ignorable + 9))
        << "from:     " << ce_dumper(cps)
        << "expected: " << ce_dumper(ces_non_ignorable)
        << "got:      " << ce_dumper(non_ignorable);

    // 1D7B4 0021;	
    // (𝞴) MATHEMATICAL SANS-SERIF BOLD ITALIC SMALL LAMDA	[202F | 0020 | 0005 | FFFF 0261 |]
    uint32_t const ces_shifted[9] = { 0x202F, 0x0000, 0x0020, 0x0000, 0x0005, 0x0000, 0xFFFF, 0x0261, 0x0000 };

    auto const shifted = collate_for_tests(
        cps, cps + 2, boost::text::variable_weighting::shifted);

    EXPECT_EQ(shifted.size(), 9);
    EXPECT_TRUE(boost::algorithm::equal(shifted.begin(), shifted.end(), ces_shifted, ces_shifted + 9))
        << "from:     " << ce_dumper(cps)
        << "expected: " << ce_dumper(ces_shifted)
        << "got:      " << ce_dumper(shifted);
}

TEST(collation, verbatim_131_375)
{
    uint32_t const cps[2] = { 0x039B, 0x0021 };

    // 039B 0021;	
    // (Λ) GREEK CAPITAL LETTER LAMDA	[202F 0261 | 0020 0020 | 0008 0002 |]
    uint32_t const ces_non_ignorable[9] = { 0x202F, 0x0261, 0x0000, 0x0020, 0x0020, 0x0000, 0x0008, 0x0002, 0x0000 };

    auto const non_ignorable = collate_for_tests(
        cps, cps + 2, boost::text::variable_weighting::non_ignorable);

    EXPECT_EQ(non_ignorable.size(), 9);
    EXPECT_TRUE(boost::algorithm::equal(non_ignorable.begin(), non_ignorable.end(), ces_non_ignorable, ces_non_ignorable + 9))
        << "from:     " << ce_dumper(cps)
        << "expected: " << ce_dumper(ces_non_ignorable)
        << "got:      " << ce_dumper(non_ignorable);

    // 039B 0021;	
    // (Λ) GREEK CAPITAL LETTER LAMDA	[202F | 0020 | 0008 | FFFF 0261 |]
    uint32_t const ces_shifted[9] = { 0x202F, 0x0000, 0x0020, 0x0000, 0x0008, 0x0000, 0xFFFF, 0x0261, 0x0000 };

    auto const shifted = collate_for_tests(
        cps, cps + 2, boost::text::variable_weighting::shifted);

    EXPECT_EQ(shifted.size(), 9);
    EXPECT_TRUE(boost::algorithm::equal(shifted.begin(), shifted.end(), ces_shifted, ces_shifted + 9))
        << "from:     " << ce_dumper(cps)
        << "expected: " << ce_dumper(ces_shifted)
        << "got:      " << ce_dumper(shifted);
}

TEST(collation, verbatim_131_376)
{
    uint32_t const cps[2] = { 0x1D6B2, 0x0021 };

    // 1D6B2 0021;	
    // (𝚲) MATHEMATICAL BOLD CAPITAL LAMDA	[202F 0261 | 0020 0020 | 000B 0002 |]
    uint32_t const ces_non_ignorable[9] = { 0x202F, 0x0261, 0x0000, 0x0020, 0x0020, 0x0000, 0x000B, 0x0002, 0x0000 };

    auto const non_ignorable = collate_for_tests(
        cps, cps + 2, boost::text::variable_weighting::non_ignorable);

    EXPECT_EQ(non_ignorable.size(), 9);
    EXPECT_TRUE(boost::algorithm::equal(non_ignorable.begin(), non_ignorable.end(), ces_non_ignorable, ces_non_ignorable + 9))
        << "from:     " << ce_dumper(cps)
        << "expected: " << ce_dumper(ces_non_ignorable)
        << "got:      " << ce_dumper(non_ignorable);

    // 1D6B2 0021;	
    // (𝚲) MATHEMATICAL BOLD CAPITAL LAMDA	[202F | 0020 | 000B | FFFF 0261 |]
    uint32_t const ces_shifted[9] = { 0x202F, 0x0000, 0x0020, 0x0000, 0x000B, 0x0000, 0xFFFF, 0x0261, 0x0000 };

    auto const shifted = collate_for_tests(
        cps, cps + 2, boost::text::variable_weighting::shifted);

    EXPECT_EQ(shifted.size(), 9);
    EXPECT_TRUE(boost::algorithm::equal(shifted.begin(), shifted.end(), ces_shifted, ces_shifted + 9))
        << "from:     " << ce_dumper(cps)
        << "expected: " << ce_dumper(ces_shifted)
        << "got:      " << ce_dumper(shifted);
}

TEST(collation, verbatim_131_377)
{
    uint32_t const cps[2] = { 0x1D6EC, 0x0021 };

    // 1D6EC 0021;	
    // (𝛬) MATHEMATICAL ITALIC CAPITAL LAMDA	[202F 0261 | 0020 0020 | 000B 0002 |]
    uint32_t const ces_non_ignorable[9] = { 0x202F, 0x0261, 0x0000, 0x0020, 0x0020, 0x0000, 0x000B, 0x0002, 0x0000 };

    auto const non_ignorable = collate_for_tests(
        cps, cps + 2, boost::text::variable_weighting::non_ignorable);

    EXPECT_EQ(non_ignorable.size(), 9);
    EXPECT_TRUE(boost::algorithm::equal(non_ignorable.begin(), non_ignorable.end(), ces_non_ignorable, ces_non_ignorable + 9))
        << "from:     " << ce_dumper(cps)
        << "expected: " << ce_dumper(ces_non_ignorable)
        << "got:      " << ce_dumper(non_ignorable);

    // 1D6EC 0021;	
    // (𝛬) MATHEMATICAL ITALIC CAPITAL LAMDA	[202F | 0020 | 000B | FFFF 0261 |]
    uint32_t const ces_shifted[9] = { 0x202F, 0x0000, 0x0020, 0x0000, 0x000B, 0x0000, 0xFFFF, 0x0261, 0x0000 };

    auto const shifted = collate_for_tests(
        cps, cps + 2, boost::text::variable_weighting::shifted);

    EXPECT_EQ(shifted.size(), 9);
    EXPECT_TRUE(boost::algorithm::equal(shifted.begin(), shifted.end(), ces_shifted, ces_shifted + 9))
        << "from:     " << ce_dumper(cps)
        << "expected: " << ce_dumper(ces_shifted)
        << "got:      " << ce_dumper(shifted);
}

TEST(collation, verbatim_131_378)
{
    uint32_t const cps[2] = { 0x1D726, 0x0021 };

    // 1D726 0021;	
    // (𝜦) MATHEMATICAL BOLD ITALIC CAPITAL LAMDA	[202F 0261 | 0020 0020 | 000B 0002 |]
    uint32_t const ces_non_ignorable[9] = { 0x202F, 0x0261, 0x0000, 0x0020, 0x0020, 0x0000, 0x000B, 0x0002, 0x0000 };

    auto const non_ignorable = collate_for_tests(
        cps, cps + 2, boost::text::variable_weighting::non_ignorable);

    EXPECT_EQ(non_ignorable.size(), 9);
    EXPECT_TRUE(boost::algorithm::equal(non_ignorable.begin(), non_ignorable.end(), ces_non_ignorable, ces_non_ignorable + 9))
        << "from:     " << ce_dumper(cps)
        << "expected: " << ce_dumper(ces_non_ignorable)
        << "got:      " << ce_dumper(non_ignorable);

    // 1D726 0021;	
    // (𝜦) MATHEMATICAL BOLD ITALIC CAPITAL LAMDA	[202F | 0020 | 000B | FFFF 0261 |]
    uint32_t const ces_shifted[9] = { 0x202F, 0x0000, 0x0020, 0x0000, 0x000B, 0x0000, 0xFFFF, 0x0261, 0x0000 };

    auto const shifted = collate_for_tests(
        cps, cps + 2, boost::text::variable_weighting::shifted);

    EXPECT_EQ(shifted.size(), 9);
    EXPECT_TRUE(boost::algorithm::equal(shifted.begin(), shifted.end(), ces_shifted, ces_shifted + 9))
        << "from:     " << ce_dumper(cps)
        << "expected: " << ce_dumper(ces_shifted)
        << "got:      " << ce_dumper(shifted);
}

TEST(collation, verbatim_131_379)
{
    uint32_t const cps[2] = { 0x1D760, 0x0021 };

    // 1D760 0021;	
    // (𝝠) MATHEMATICAL SANS-SERIF BOLD CAPITAL LAMDA	[202F 0261 | 0020 0020 | 000B 0002 |]
    uint32_t const ces_non_ignorable[9] = { 0x202F, 0x0261, 0x0000, 0x0020, 0x0020, 0x0000, 0x000B, 0x0002, 0x0000 };

    auto const non_ignorable = collate_for_tests(
        cps, cps + 2, boost::text::variable_weighting::non_ignorable);

    EXPECT_EQ(non_ignorable.size(), 9);
    EXPECT_TRUE(boost::algorithm::equal(non_ignorable.begin(), non_ignorable.end(), ces_non_ignorable, ces_non_ignorable + 9))
        << "from:     " << ce_dumper(cps)
        << "expected: " << ce_dumper(ces_non_ignorable)
        << "got:      " << ce_dumper(non_ignorable);

    // 1D760 0021;	
    // (𝝠) MATHEMATICAL SANS-SERIF BOLD CAPITAL LAMDA	[202F | 0020 | 000B | FFFF 0261 |]
    uint32_t const ces_shifted[9] = { 0x202F, 0x0000, 0x0020, 0x0000, 0x000B, 0x0000, 0xFFFF, 0x0261, 0x0000 };

    auto const shifted = collate_for_tests(
        cps, cps + 2, boost::text::variable_weighting::shifted);

    EXPECT_EQ(shifted.size(), 9);
    EXPECT_TRUE(boost::algorithm::equal(shifted.begin(), shifted.end(), ces_shifted, ces_shifted + 9))
        << "from:     " << ce_dumper(cps)
        << "expected: " << ce_dumper(ces_shifted)
        << "got:      " << ce_dumper(shifted);
}

TEST(collation, verbatim_131_380)
{
    uint32_t const cps[2] = { 0x1D79A, 0x0021 };

    // 1D79A 0021;	
    // (𝞚) MATHEMATICAL SANS-SERIF BOLD ITALIC CAPITAL LAMDA	[202F 0261 | 0020 0020 | 000B 0002 |]
    uint32_t const ces_non_ignorable[9] = { 0x202F, 0x0261, 0x0000, 0x0020, 0x0020, 0x0000, 0x000B, 0x0002, 0x0000 };

    auto const non_ignorable = collate_for_tests(
        cps, cps + 2, boost::text::variable_weighting::non_ignorable);

    EXPECT_EQ(non_ignorable.size(), 9);
    EXPECT_TRUE(boost::algorithm::equal(non_ignorable.begin(), non_ignorable.end(), ces_non_ignorable, ces_non_ignorable + 9))
        << "from:     " << ce_dumper(cps)
        << "expected: " << ce_dumper(ces_non_ignorable)
        << "got:      " << ce_dumper(non_ignorable);

    // 1D79A 0021;	
    // (𝞚) MATHEMATICAL SANS-SERIF BOLD ITALIC CAPITAL LAMDA	[202F | 0020 | 000B | FFFF 0261 |]
    uint32_t const ces_shifted[9] = { 0x202F, 0x0000, 0x0020, 0x0000, 0x000B, 0x0000, 0xFFFF, 0x0261, 0x0000 };

    auto const shifted = collate_for_tests(
        cps, cps + 2, boost::text::variable_weighting::shifted);

    EXPECT_EQ(shifted.size(), 9);
    EXPECT_TRUE(boost::algorithm::equal(shifted.begin(), shifted.end(), ces_shifted, ces_shifted + 9))
        << "from:     " << ce_dumper(cps)
        << "expected: " << ce_dumper(ces_shifted)
        << "got:      " << ce_dumper(shifted);
}

TEST(collation, verbatim_131_381)
{
    uint32_t const cps[2] = { 0x03BB, 0x003F };

    // 03BB 003F;	
    // (λ) GREEK SMALL LETTER LAMDA	[202F 0267 | 0020 0020 | 0002 0002 |]
    uint32_t const ces_non_ignorable[9] = { 0x202F, 0x0267, 0x0000, 0x0020, 0x0020, 0x0000, 0x0002, 0x0002, 0x0000 };

    auto const non_ignorable = collate_for_tests(
        cps, cps + 2, boost::text::variable_weighting::non_ignorable);

    EXPECT_EQ(non_ignorable.size(), 9);
    EXPECT_TRUE(boost::algorithm::equal(non_ignorable.begin(), non_ignorable.end(), ces_non_ignorable, ces_non_ignorable + 9))
        << "from:     " << ce_dumper(cps)
        << "expected: " << ce_dumper(ces_non_ignorable)
        << "got:      " << ce_dumper(non_ignorable);

    // 03BB 003F;	
    // (λ) GREEK SMALL LETTER LAMDA	[202F | 0020 | 0002 | FFFF 0267 |]
    uint32_t const ces_shifted[9] = { 0x202F, 0x0000, 0x0020, 0x0000, 0x0002, 0x0000, 0xFFFF, 0x0267, 0x0000 };

    auto const shifted = collate_for_tests(
        cps, cps + 2, boost::text::variable_weighting::shifted);

    EXPECT_EQ(shifted.size(), 9);
    EXPECT_TRUE(boost::algorithm::equal(shifted.begin(), shifted.end(), ces_shifted, ces_shifted + 9))
        << "from:     " << ce_dumper(cps)
        << "expected: " << ce_dumper(ces_shifted)
        << "got:      " << ce_dumper(shifted);
}

TEST(collation, verbatim_131_382)
{
    uint32_t const cps[2] = { 0x1D6CC, 0x003F };

    // 1D6CC 003F;	
    // (𝛌) MATHEMATICAL BOLD SMALL LAMDA	[202F 0267 | 0020 0020 | 0005 0002 |]
    uint32_t const ces_non_ignorable[9] = { 0x202F, 0x0267, 0x0000, 0x0020, 0x0020, 0x0000, 0x0005, 0x0002, 0x0000 };

    auto const non_ignorable = collate_for_tests(
        cps, cps + 2, boost::text::variable_weighting::non_ignorable);

    EXPECT_EQ(non_ignorable.size(), 9);
    EXPECT_TRUE(boost::algorithm::equal(non_ignorable.begin(), non_ignorable.end(), ces_non_ignorable, ces_non_ignorable + 9))
        << "from:     " << ce_dumper(cps)
        << "expected: " << ce_dumper(ces_non_ignorable)
        << "got:      " << ce_dumper(non_ignorable);

    // 1D6CC 003F;	
    // (𝛌) MATHEMATICAL BOLD SMALL LAMDA	[202F | 0020 | 0005 | FFFF 0267 |]
    uint32_t const ces_shifted[9] = { 0x202F, 0x0000, 0x0020, 0x0000, 0x0005, 0x0000, 0xFFFF, 0x0267, 0x0000 };

    auto const shifted = collate_for_tests(
        cps, cps + 2, boost::text::variable_weighting::shifted);

    EXPECT_EQ(shifted.size(), 9);
    EXPECT_TRUE(boost::algorithm::equal(shifted.begin(), shifted.end(), ces_shifted, ces_shifted + 9))
        << "from:     " << ce_dumper(cps)
        << "expected: " << ce_dumper(ces_shifted)
        << "got:      " << ce_dumper(shifted);
}

TEST(collation, verbatim_131_383)
{
    uint32_t const cps[2] = { 0x1D706, 0x003F };

    // 1D706 003F;	
    // (𝜆) MATHEMATICAL ITALIC SMALL LAMDA	[202F 0267 | 0020 0020 | 0005 0002 |]
    uint32_t const ces_non_ignorable[9] = { 0x202F, 0x0267, 0x0000, 0x0020, 0x0020, 0x0000, 0x0005, 0x0002, 0x0000 };

    auto const non_ignorable = collate_for_tests(
        cps, cps + 2, boost::text::variable_weighting::non_ignorable);

    EXPECT_EQ(non_ignorable.size(), 9);
    EXPECT_TRUE(boost::algorithm::equal(non_ignorable.begin(), non_ignorable.end(), ces_non_ignorable, ces_non_ignorable + 9))
        << "from:     " << ce_dumper(cps)
        << "expected: " << ce_dumper(ces_non_ignorable)
        << "got:      " << ce_dumper(non_ignorable);

    // 1D706 003F;	
    // (𝜆) MATHEMATICAL ITALIC SMALL LAMDA	[202F | 0020 | 0005 | FFFF 0267 |]
    uint32_t const ces_shifted[9] = { 0x202F, 0x0000, 0x0020, 0x0000, 0x0005, 0x0000, 0xFFFF, 0x0267, 0x0000 };

    auto const shifted = collate_for_tests(
        cps, cps + 2, boost::text::variable_weighting::shifted);

    EXPECT_EQ(shifted.size(), 9);
    EXPECT_TRUE(boost::algorithm::equal(shifted.begin(), shifted.end(), ces_shifted, ces_shifted + 9))
        << "from:     " << ce_dumper(cps)
        << "expected: " << ce_dumper(ces_shifted)
        << "got:      " << ce_dumper(shifted);
}

TEST(collation, verbatim_131_384)
{
    uint32_t const cps[2] = { 0x1D740, 0x003F };

    // 1D740 003F;	
    // (𝝀) MATHEMATICAL BOLD ITALIC SMALL LAMDA	[202F 0267 | 0020 0020 | 0005 0002 |]
    uint32_t const ces_non_ignorable[9] = { 0x202F, 0x0267, 0x0000, 0x0020, 0x0020, 0x0000, 0x0005, 0x0002, 0x0000 };

    auto const non_ignorable = collate_for_tests(
        cps, cps + 2, boost::text::variable_weighting::non_ignorable);

    EXPECT_EQ(non_ignorable.size(), 9);
    EXPECT_TRUE(boost::algorithm::equal(non_ignorable.begin(), non_ignorable.end(), ces_non_ignorable, ces_non_ignorable + 9))
        << "from:     " << ce_dumper(cps)
        << "expected: " << ce_dumper(ces_non_ignorable)
        << "got:      " << ce_dumper(non_ignorable);

    // 1D740 003F;	
    // (𝝀) MATHEMATICAL BOLD ITALIC SMALL LAMDA	[202F | 0020 | 0005 | FFFF 0267 |]
    uint32_t const ces_shifted[9] = { 0x202F, 0x0000, 0x0020, 0x0000, 0x0005, 0x0000, 0xFFFF, 0x0267, 0x0000 };

    auto const shifted = collate_for_tests(
        cps, cps + 2, boost::text::variable_weighting::shifted);

    EXPECT_EQ(shifted.size(), 9);
    EXPECT_TRUE(boost::algorithm::equal(shifted.begin(), shifted.end(), ces_shifted, ces_shifted + 9))
        << "from:     " << ce_dumper(cps)
        << "expected: " << ce_dumper(ces_shifted)
        << "got:      " << ce_dumper(shifted);
}

TEST(collation, verbatim_131_385)
{
    uint32_t const cps[2] = { 0x1D77A, 0x003F };

    // 1D77A 003F;	
    // (𝝺) MATHEMATICAL SANS-SERIF BOLD SMALL LAMDA	[202F 0267 | 0020 0020 | 0005 0002 |]
    uint32_t const ces_non_ignorable[9] = { 0x202F, 0x0267, 0x0000, 0x0020, 0x0020, 0x0000, 0x0005, 0x0002, 0x0000 };

    auto const non_ignorable = collate_for_tests(
        cps, cps + 2, boost::text::variable_weighting::non_ignorable);

    EXPECT_EQ(non_ignorable.size(), 9);
    EXPECT_TRUE(boost::algorithm::equal(non_ignorable.begin(), non_ignorable.end(), ces_non_ignorable, ces_non_ignorable + 9))
        << "from:     " << ce_dumper(cps)
        << "expected: " << ce_dumper(ces_non_ignorable)
        << "got:      " << ce_dumper(non_ignorable);

    // 1D77A 003F;	
    // (𝝺) MATHEMATICAL SANS-SERIF BOLD SMALL LAMDA	[202F | 0020 | 0005 | FFFF 0267 |]
    uint32_t const ces_shifted[9] = { 0x202F, 0x0000, 0x0020, 0x0000, 0x0005, 0x0000, 0xFFFF, 0x0267, 0x0000 };

    auto const shifted = collate_for_tests(
        cps, cps + 2, boost::text::variable_weighting::shifted);

    EXPECT_EQ(shifted.size(), 9);
    EXPECT_TRUE(boost::algorithm::equal(shifted.begin(), shifted.end(), ces_shifted, ces_shifted + 9))
        << "from:     " << ce_dumper(cps)
        << "expected: " << ce_dumper(ces_shifted)
        << "got:      " << ce_dumper(shifted);
}

TEST(collation, verbatim_131_386)
{
    uint32_t const cps[2] = { 0x1D7B4, 0x003F };

    // 1D7B4 003F;	
    // (𝞴) MATHEMATICAL SANS-SERIF BOLD ITALIC SMALL LAMDA	[202F 0267 | 0020 0020 | 0005 0002 |]
    uint32_t const ces_non_ignorable[9] = { 0x202F, 0x0267, 0x0000, 0x0020, 0x0020, 0x0000, 0x0005, 0x0002, 0x0000 };

    auto const non_ignorable = collate_for_tests(
        cps, cps + 2, boost::text::variable_weighting::non_ignorable);

    EXPECT_EQ(non_ignorable.size(), 9);
    EXPECT_TRUE(boost::algorithm::equal(non_ignorable.begin(), non_ignorable.end(), ces_non_ignorable, ces_non_ignorable + 9))
        << "from:     " << ce_dumper(cps)
        << "expected: " << ce_dumper(ces_non_ignorable)
        << "got:      " << ce_dumper(non_ignorable);

    // 1D7B4 003F;	
    // (𝞴) MATHEMATICAL SANS-SERIF BOLD ITALIC SMALL LAMDA	[202F | 0020 | 0005 | FFFF 0267 |]
    uint32_t const ces_shifted[9] = { 0x202F, 0x0000, 0x0020, 0x0000, 0x0005, 0x0000, 0xFFFF, 0x0267, 0x0000 };

    auto const shifted = collate_for_tests(
        cps, cps + 2, boost::text::variable_weighting::shifted);

    EXPECT_EQ(shifted.size(), 9);
    EXPECT_TRUE(boost::algorithm::equal(shifted.begin(), shifted.end(), ces_shifted, ces_shifted + 9))
        << "from:     " << ce_dumper(cps)
        << "expected: " << ce_dumper(ces_shifted)
        << "got:      " << ce_dumper(shifted);
}

TEST(collation, verbatim_131_387)
{
    uint32_t const cps[2] = { 0x039B, 0x003F };

    // 039B 003F;	
    // (Λ) GREEK CAPITAL LETTER LAMDA	[202F 0267 | 0020 0020 | 0008 0002 |]
    uint32_t const ces_non_ignorable[9] = { 0x202F, 0x0267, 0x0000, 0x0020, 0x0020, 0x0000, 0x0008, 0x0002, 0x0000 };

    auto const non_ignorable = collate_for_tests(
        cps, cps + 2, boost::text::variable_weighting::non_ignorable);

    EXPECT_EQ(non_ignorable.size(), 9);
    EXPECT_TRUE(boost::algorithm::equal(non_ignorable.begin(), non_ignorable.end(), ces_non_ignorable, ces_non_ignorable + 9))
        << "from:     " << ce_dumper(cps)
        << "expected: " << ce_dumper(ces_non_ignorable)
        << "got:      " << ce_dumper(non_ignorable);

    // 039B 003F;	
    // (Λ) GREEK CAPITAL LETTER LAMDA	[202F | 0020 | 0008 | FFFF 0267 |]
    uint32_t const ces_shifted[9] = { 0x202F, 0x0000, 0x0020, 0x0000, 0x0008, 0x0000, 0xFFFF, 0x0267, 0x0000 };

    auto const shifted = collate_for_tests(
        cps, cps + 2, boost::text::variable_weighting::shifted);

    EXPECT_EQ(shifted.size(), 9);
    EXPECT_TRUE(boost::algorithm::equal(shifted.begin(), shifted.end(), ces_shifted, ces_shifted + 9))
        << "from:     " << ce_dumper(cps)
        << "expected: " << ce_dumper(ces_shifted)
        << "got:      " << ce_dumper(shifted);
}

TEST(collation, verbatim_131_388)
{
    uint32_t const cps[2] = { 0x1D6B2, 0x003F };

    // 1D6B2 003F;	
    // (𝚲) MATHEMATICAL BOLD CAPITAL LAMDA	[202F 0267 | 0020 0020 | 000B 0002 |]
    uint32_t const ces_non_ignorable[9] = { 0x202F, 0x0267, 0x0000, 0x0020, 0x0020, 0x0000, 0x000B, 0x0002, 0x0000 };

    auto const non_ignorable = collate_for_tests(
        cps, cps + 2, boost::text::variable_weighting::non_ignorable);

    EXPECT_EQ(non_ignorable.size(), 9);
    EXPECT_TRUE(boost::algorithm::equal(non_ignorable.begin(), non_ignorable.end(), ces_non_ignorable, ces_non_ignorable + 9))
        << "from:     " << ce_dumper(cps)
        << "expected: " << ce_dumper(ces_non_ignorable)
        << "got:      " << ce_dumper(non_ignorable);

    // 1D6B2 003F;	
    // (𝚲) MATHEMATICAL BOLD CAPITAL LAMDA	[202F | 0020 | 000B | FFFF 0267 |]
    uint32_t const ces_shifted[9] = { 0x202F, 0x0000, 0x0020, 0x0000, 0x000B, 0x0000, 0xFFFF, 0x0267, 0x0000 };

    auto const shifted = collate_for_tests(
        cps, cps + 2, boost::text::variable_weighting::shifted);

    EXPECT_EQ(shifted.size(), 9);
    EXPECT_TRUE(boost::algorithm::equal(shifted.begin(), shifted.end(), ces_shifted, ces_shifted + 9))
        << "from:     " << ce_dumper(cps)
        << "expected: " << ce_dumper(ces_shifted)
        << "got:      " << ce_dumper(shifted);
}

TEST(collation, verbatim_131_389)
{
    uint32_t const cps[2] = { 0x1D6EC, 0x003F };

    // 1D6EC 003F;	
    // (𝛬) MATHEMATICAL ITALIC CAPITAL LAMDA	[202F 0267 | 0020 0020 | 000B 0002 |]
    uint32_t const ces_non_ignorable[9] = { 0x202F, 0x0267, 0x0000, 0x0020, 0x0020, 0x0000, 0x000B, 0x0002, 0x0000 };

    auto const non_ignorable = collate_for_tests(
        cps, cps + 2, boost::text::variable_weighting::non_ignorable);

    EXPECT_EQ(non_ignorable.size(), 9);
    EXPECT_TRUE(boost::algorithm::equal(non_ignorable.begin(), non_ignorable.end(), ces_non_ignorable, ces_non_ignorable + 9))
        << "from:     " << ce_dumper(cps)
        << "expected: " << ce_dumper(ces_non_ignorable)
        << "got:      " << ce_dumper(non_ignorable);

    // 1D6EC 003F;	
    // (𝛬) MATHEMATICAL ITALIC CAPITAL LAMDA	[202F | 0020 | 000B | FFFF 0267 |]
    uint32_t const ces_shifted[9] = { 0x202F, 0x0000, 0x0020, 0x0000, 0x000B, 0x0000, 0xFFFF, 0x0267, 0x0000 };

    auto const shifted = collate_for_tests(
        cps, cps + 2, boost::text::variable_weighting::shifted);

    EXPECT_EQ(shifted.size(), 9);
    EXPECT_TRUE(boost::algorithm::equal(shifted.begin(), shifted.end(), ces_shifted, ces_shifted + 9))
        << "from:     " << ce_dumper(cps)
        << "expected: " << ce_dumper(ces_shifted)
        << "got:      " << ce_dumper(shifted);
}

TEST(collation, verbatim_131_390)
{
    uint32_t const cps[2] = { 0x1D726, 0x003F };

    // 1D726 003F;	
    // (𝜦) MATHEMATICAL BOLD ITALIC CAPITAL LAMDA	[202F 0267 | 0020 0020 | 000B 0002 |]
    uint32_t const ces_non_ignorable[9] = { 0x202F, 0x0267, 0x0000, 0x0020, 0x0020, 0x0000, 0x000B, 0x0002, 0x0000 };

    auto const non_ignorable = collate_for_tests(
        cps, cps + 2, boost::text::variable_weighting::non_ignorable);

    EXPECT_EQ(non_ignorable.size(), 9);
    EXPECT_TRUE(boost::algorithm::equal(non_ignorable.begin(), non_ignorable.end(), ces_non_ignorable, ces_non_ignorable + 9))
        << "from:     " << ce_dumper(cps)
        << "expected: " << ce_dumper(ces_non_ignorable)
        << "got:      " << ce_dumper(non_ignorable);

    // 1D726 003F;	
    // (𝜦) MATHEMATICAL BOLD ITALIC CAPITAL LAMDA	[202F | 0020 | 000B | FFFF 0267 |]
    uint32_t const ces_shifted[9] = { 0x202F, 0x0000, 0x0020, 0x0000, 0x000B, 0x0000, 0xFFFF, 0x0267, 0x0000 };

    auto const shifted = collate_for_tests(
        cps, cps + 2, boost::text::variable_weighting::shifted);

    EXPECT_EQ(shifted.size(), 9);
    EXPECT_TRUE(boost::algorithm::equal(shifted.begin(), shifted.end(), ces_shifted, ces_shifted + 9))
        << "from:     " << ce_dumper(cps)
        << "expected: " << ce_dumper(ces_shifted)
        << "got:      " << ce_dumper(shifted);
}

TEST(collation, verbatim_131_391)
{
    uint32_t const cps[2] = { 0x1D760, 0x003F };

    // 1D760 003F;	
    // (𝝠) MATHEMATICAL SANS-SERIF BOLD CAPITAL LAMDA	[202F 0267 | 0020 0020 | 000B 0002 |]
    uint32_t const ces_non_ignorable[9] = { 0x202F, 0x0267, 0x0000, 0x0020, 0x0020, 0x0000, 0x000B, 0x0002, 0x0000 };

    auto const non_ignorable = collate_for_tests(
        cps, cps + 2, boost::text::variable_weighting::non_ignorable);

    EXPECT_EQ(non_ignorable.size(), 9);
    EXPECT_TRUE(boost::algorithm::equal(non_ignorable.begin(), non_ignorable.end(), ces_non_ignorable, ces_non_ignorable + 9))
        << "from:     " << ce_dumper(cps)
        << "expected: " << ce_dumper(ces_non_ignorable)
        << "got:      " << ce_dumper(non_ignorable);

    // 1D760 003F;	
    // (𝝠) MATHEMATICAL SANS-SERIF BOLD CAPITAL LAMDA	[202F | 0020 | 000B | FFFF 0267 |]
    uint32_t const ces_shifted[9] = { 0x202F, 0x0000, 0x0020, 0x0000, 0x000B, 0x0000, 0xFFFF, 0x0267, 0x0000 };

    auto const shifted = collate_for_tests(
        cps, cps + 2, boost::text::variable_weighting::shifted);

    EXPECT_EQ(shifted.size(), 9);
    EXPECT_TRUE(boost::algorithm::equal(shifted.begin(), shifted.end(), ces_shifted, ces_shifted + 9))
        << "from:     " << ce_dumper(cps)
        << "expected: " << ce_dumper(ces_shifted)
        << "got:      " << ce_dumper(shifted);
}

TEST(collation, verbatim_131_392)
{
    uint32_t const cps[2] = { 0x1D79A, 0x003F };

    // 1D79A 003F;	
    // (𝞚) MATHEMATICAL SANS-SERIF BOLD ITALIC CAPITAL LAMDA	[202F 0267 | 0020 0020 | 000B 0002 |]
    uint32_t const ces_non_ignorable[9] = { 0x202F, 0x0267, 0x0000, 0x0020, 0x0020, 0x0000, 0x000B, 0x0002, 0x0000 };

    auto const non_ignorable = collate_for_tests(
        cps, cps + 2, boost::text::variable_weighting::non_ignorable);

    EXPECT_EQ(non_ignorable.size(), 9);
    EXPECT_TRUE(boost::algorithm::equal(non_ignorable.begin(), non_ignorable.end(), ces_non_ignorable, ces_non_ignorable + 9))
        << "from:     " << ce_dumper(cps)
        << "expected: " << ce_dumper(ces_non_ignorable)
        << "got:      " << ce_dumper(non_ignorable);

    // 1D79A 003F;	
    // (𝞚) MATHEMATICAL SANS-SERIF BOLD ITALIC CAPITAL LAMDA	[202F | 0020 | 000B | FFFF 0267 |]
    uint32_t const ces_shifted[9] = { 0x202F, 0x0000, 0x0020, 0x0000, 0x000B, 0x0000, 0xFFFF, 0x0267, 0x0000 };

    auto const shifted = collate_for_tests(
        cps, cps + 2, boost::text::variable_weighting::shifted);

    EXPECT_EQ(shifted.size(), 9);
    EXPECT_TRUE(boost::algorithm::equal(shifted.begin(), shifted.end(), ces_shifted, ces_shifted + 9))
        << "from:     " << ce_dumper(cps)
        << "expected: " << ce_dumper(ces_shifted)
        << "got:      " << ce_dumper(shifted);
}

TEST(collation, verbatim_131_393)
{
    uint32_t const cps[2] = { 0x03BB, 0x0061 };

    // 03BB 0061;	
    // (λ) GREEK SMALL LETTER LAMDA	[202F 1CAD | 0020 0020 | 0002 0002 |]
    uint32_t const ces_non_ignorable[9] = { 0x202F, 0x1CAD, 0x0000, 0x0020, 0x0020, 0x0000, 0x0002, 0x0002, 0x0000 };

    auto const non_ignorable = collate_for_tests(
        cps, cps + 2, boost::text::variable_weighting::non_ignorable);

    EXPECT_EQ(non_ignorable.size(), 9);
    EXPECT_TRUE(boost::algorithm::equal(non_ignorable.begin(), non_ignorable.end(), ces_non_ignorable, ces_non_ignorable + 9))
        << "from:     " << ce_dumper(cps)
        << "expected: " << ce_dumper(ces_non_ignorable)
        << "got:      " << ce_dumper(non_ignorable);

    // 03BB 0061;	
    // (λ) GREEK SMALL LETTER LAMDA	[202F 1CAD | 0020 0020 | 0002 0002 | FFFF FFFF |]
    uint32_t const ces_shifted[12] = { 0x202F, 0x1CAD, 0x0000, 0x0020, 0x0020, 0x0000, 0x0002, 0x0002, 0x0000, 0xFFFF, 0xFFFF, 0x0000 };

    auto const shifted = collate_for_tests(
        cps, cps + 2, boost::text::variable_weighting::shifted);

    EXPECT_EQ(shifted.size(), 12);
    EXPECT_TRUE(boost::algorithm::equal(shifted.begin(), shifted.end(), ces_shifted, ces_shifted + 12))
        << "from:     " << ce_dumper(cps)
        << "expected: " << ce_dumper(ces_shifted)
        << "got:      " << ce_dumper(shifted);
}

TEST(collation, verbatim_131_394)
{
    uint32_t const cps[2] = { 0x03BB, 0x0041 };

    // 03BB 0041;	
    // (λ) GREEK SMALL LETTER LAMDA	[202F 1CAD | 0020 0020 | 0002 0008 |]
    uint32_t const ces_non_ignorable[9] = { 0x202F, 0x1CAD, 0x0000, 0x0020, 0x0020, 0x0000, 0x0002, 0x0008, 0x0000 };

    auto const non_ignorable = collate_for_tests(
        cps, cps + 2, boost::text::variable_weighting::non_ignorable);

    EXPECT_EQ(non_ignorable.size(), 9);
    EXPECT_TRUE(boost::algorithm::equal(non_ignorable.begin(), non_ignorable.end(), ces_non_ignorable, ces_non_ignorable + 9))
        << "from:     " << ce_dumper(cps)
        << "expected: " << ce_dumper(ces_non_ignorable)
        << "got:      " << ce_dumper(non_ignorable);

    // 03BB 0041;	
    // (λ) GREEK SMALL LETTER LAMDA	[202F 1CAD | 0020 0020 | 0002 0008 | FFFF FFFF |]
    uint32_t const ces_shifted[12] = { 0x202F, 0x1CAD, 0x0000, 0x0020, 0x0020, 0x0000, 0x0002, 0x0008, 0x0000, 0xFFFF, 0xFFFF, 0x0000 };

    auto const shifted = collate_for_tests(
        cps, cps + 2, boost::text::variable_weighting::shifted);

    EXPECT_EQ(shifted.size(), 12);
    EXPECT_TRUE(boost::algorithm::equal(shifted.begin(), shifted.end(), ces_shifted, ces_shifted + 12))
        << "from:     " << ce_dumper(cps)
        << "expected: " << ce_dumper(ces_shifted)
        << "got:      " << ce_dumper(shifted);
}

TEST(collation, verbatim_131_395)
{
    uint32_t const cps[2] = { 0x1D6CC, 0x0061 };

    // 1D6CC 0061;	
    // (𝛌) MATHEMATICAL BOLD SMALL LAMDA	[202F 1CAD | 0020 0020 | 0005 0002 |]
    uint32_t const ces_non_ignorable[9] = { 0x202F, 0x1CAD, 0x0000, 0x0020, 0x0020, 0x0000, 0x0005, 0x0002, 0x0000 };

    auto const non_ignorable = collate_for_tests(
        cps, cps + 2, boost::text::variable_weighting::non_ignorable);

    EXPECT_EQ(non_ignorable.size(), 9);
    EXPECT_TRUE(boost::algorithm::equal(non_ignorable.begin(), non_ignorable.end(), ces_non_ignorable, ces_non_ignorable + 9))
        << "from:     " << ce_dumper(cps)
        << "expected: " << ce_dumper(ces_non_ignorable)
        << "got:      " << ce_dumper(non_ignorable);

    // 1D6CC 0061;	
    // (𝛌) MATHEMATICAL BOLD SMALL LAMDA	[202F 1CAD | 0020 0020 | 0005 0002 | FFFF FFFF |]
    uint32_t const ces_shifted[12] = { 0x202F, 0x1CAD, 0x0000, 0x0020, 0x0020, 0x0000, 0x0005, 0x0002, 0x0000, 0xFFFF, 0xFFFF, 0x0000 };

    auto const shifted = collate_for_tests(
        cps, cps + 2, boost::text::variable_weighting::shifted);

    EXPECT_EQ(shifted.size(), 12);
    EXPECT_TRUE(boost::algorithm::equal(shifted.begin(), shifted.end(), ces_shifted, ces_shifted + 12))
        << "from:     " << ce_dumper(cps)
        << "expected: " << ce_dumper(ces_shifted)
        << "got:      " << ce_dumper(shifted);
}

TEST(collation, verbatim_131_396)
{
    uint32_t const cps[2] = { 0x1D706, 0x0061 };

    // 1D706 0061;	
    // (𝜆) MATHEMATICAL ITALIC SMALL LAMDA	[202F 1CAD | 0020 0020 | 0005 0002 |]
    uint32_t const ces_non_ignorable[9] = { 0x202F, 0x1CAD, 0x0000, 0x0020, 0x0020, 0x0000, 0x0005, 0x0002, 0x0000 };

    auto const non_ignorable = collate_for_tests(
        cps, cps + 2, boost::text::variable_weighting::non_ignorable);

    EXPECT_EQ(non_ignorable.size(), 9);
    EXPECT_TRUE(boost::algorithm::equal(non_ignorable.begin(), non_ignorable.end(), ces_non_ignorable, ces_non_ignorable + 9))
        << "from:     " << ce_dumper(cps)
        << "expected: " << ce_dumper(ces_non_ignorable)
        << "got:      " << ce_dumper(non_ignorable);

    // 1D706 0061;	
    // (𝜆) MATHEMATICAL ITALIC SMALL LAMDA	[202F 1CAD | 0020 0020 | 0005 0002 | FFFF FFFF |]
    uint32_t const ces_shifted[12] = { 0x202F, 0x1CAD, 0x0000, 0x0020, 0x0020, 0x0000, 0x0005, 0x0002, 0x0000, 0xFFFF, 0xFFFF, 0x0000 };

    auto const shifted = collate_for_tests(
        cps, cps + 2, boost::text::variable_weighting::shifted);

    EXPECT_EQ(shifted.size(), 12);
    EXPECT_TRUE(boost::algorithm::equal(shifted.begin(), shifted.end(), ces_shifted, ces_shifted + 12))
        << "from:     " << ce_dumper(cps)
        << "expected: " << ce_dumper(ces_shifted)
        << "got:      " << ce_dumper(shifted);
}

TEST(collation, verbatim_131_397)
{
    uint32_t const cps[2] = { 0x1D740, 0x0061 };

    // 1D740 0061;	
    // (𝝀) MATHEMATICAL BOLD ITALIC SMALL LAMDA	[202F 1CAD | 0020 0020 | 0005 0002 |]
    uint32_t const ces_non_ignorable[9] = { 0x202F, 0x1CAD, 0x0000, 0x0020, 0x0020, 0x0000, 0x0005, 0x0002, 0x0000 };

    auto const non_ignorable = collate_for_tests(
        cps, cps + 2, boost::text::variable_weighting::non_ignorable);

    EXPECT_EQ(non_ignorable.size(), 9);
    EXPECT_TRUE(boost::algorithm::equal(non_ignorable.begin(), non_ignorable.end(), ces_non_ignorable, ces_non_ignorable + 9))
        << "from:     " << ce_dumper(cps)
        << "expected: " << ce_dumper(ces_non_ignorable)
        << "got:      " << ce_dumper(non_ignorable);

    // 1D740 0061;	
    // (𝝀) MATHEMATICAL BOLD ITALIC SMALL LAMDA	[202F 1CAD | 0020 0020 | 0005 0002 | FFFF FFFF |]
    uint32_t const ces_shifted[12] = { 0x202F, 0x1CAD, 0x0000, 0x0020, 0x0020, 0x0000, 0x0005, 0x0002, 0x0000, 0xFFFF, 0xFFFF, 0x0000 };

    auto const shifted = collate_for_tests(
        cps, cps + 2, boost::text::variable_weighting::shifted);

    EXPECT_EQ(shifted.size(), 12);
    EXPECT_TRUE(boost::algorithm::equal(shifted.begin(), shifted.end(), ces_shifted, ces_shifted + 12))
        << "from:     " << ce_dumper(cps)
        << "expected: " << ce_dumper(ces_shifted)
        << "got:      " << ce_dumper(shifted);
}

TEST(collation, verbatim_131_398)
{
    uint32_t const cps[2] = { 0x1D77A, 0x0061 };

    // 1D77A 0061;	
    // (𝝺) MATHEMATICAL SANS-SERIF BOLD SMALL LAMDA	[202F 1CAD | 0020 0020 | 0005 0002 |]
    uint32_t const ces_non_ignorable[9] = { 0x202F, 0x1CAD, 0x0000, 0x0020, 0x0020, 0x0000, 0x0005, 0x0002, 0x0000 };

    auto const non_ignorable = collate_for_tests(
        cps, cps + 2, boost::text::variable_weighting::non_ignorable);

    EXPECT_EQ(non_ignorable.size(), 9);
    EXPECT_TRUE(boost::algorithm::equal(non_ignorable.begin(), non_ignorable.end(), ces_non_ignorable, ces_non_ignorable + 9))
        << "from:     " << ce_dumper(cps)
        << "expected: " << ce_dumper(ces_non_ignorable)
        << "got:      " << ce_dumper(non_ignorable);

    // 1D77A 0061;	
    // (𝝺) MATHEMATICAL SANS-SERIF BOLD SMALL LAMDA	[202F 1CAD | 0020 0020 | 0005 0002 | FFFF FFFF |]
    uint32_t const ces_shifted[12] = { 0x202F, 0x1CAD, 0x0000, 0x0020, 0x0020, 0x0000, 0x0005, 0x0002, 0x0000, 0xFFFF, 0xFFFF, 0x0000 };

    auto const shifted = collate_for_tests(
        cps, cps + 2, boost::text::variable_weighting::shifted);

    EXPECT_EQ(shifted.size(), 12);
    EXPECT_TRUE(boost::algorithm::equal(shifted.begin(), shifted.end(), ces_shifted, ces_shifted + 12))
        << "from:     " << ce_dumper(cps)
        << "expected: " << ce_dumper(ces_shifted)
        << "got:      " << ce_dumper(shifted);
}

TEST(collation, verbatim_131_399)
{
    uint32_t const cps[2] = { 0x1D7B4, 0x0061 };

    // 1D7B4 0061;	
    // (𝞴) MATHEMATICAL SANS-SERIF BOLD ITALIC SMALL LAMDA	[202F 1CAD | 0020 0020 | 0005 0002 |]
    uint32_t const ces_non_ignorable[9] = { 0x202F, 0x1CAD, 0x0000, 0x0020, 0x0020, 0x0000, 0x0005, 0x0002, 0x0000 };

    auto const non_ignorable = collate_for_tests(
        cps, cps + 2, boost::text::variable_weighting::non_ignorable);

    EXPECT_EQ(non_ignorable.size(), 9);
    EXPECT_TRUE(boost::algorithm::equal(non_ignorable.begin(), non_ignorable.end(), ces_non_ignorable, ces_non_ignorable + 9))
        << "from:     " << ce_dumper(cps)
        << "expected: " << ce_dumper(ces_non_ignorable)
        << "got:      " << ce_dumper(non_ignorable);

    // 1D7B4 0061;	
    // (𝞴) MATHEMATICAL SANS-SERIF BOLD ITALIC SMALL LAMDA	[202F 1CAD | 0020 0020 | 0005 0002 | FFFF FFFF |]
    uint32_t const ces_shifted[12] = { 0x202F, 0x1CAD, 0x0000, 0x0020, 0x0020, 0x0000, 0x0005, 0x0002, 0x0000, 0xFFFF, 0xFFFF, 0x0000 };

    auto const shifted = collate_for_tests(
        cps, cps + 2, boost::text::variable_weighting::shifted);

    EXPECT_EQ(shifted.size(), 12);
    EXPECT_TRUE(boost::algorithm::equal(shifted.begin(), shifted.end(), ces_shifted, ces_shifted + 12))
        << "from:     " << ce_dumper(cps)
        << "expected: " << ce_dumper(ces_shifted)
        << "got:      " << ce_dumper(shifted);
}

TEST(collation, verbatim_131_400)
{
    uint32_t const cps[2] = { 0x1D6CC, 0x0041 };

    // 1D6CC 0041;	
    // (𝛌) MATHEMATICAL BOLD SMALL LAMDA	[202F 1CAD | 0020 0020 | 0005 0008 |]
    uint32_t const ces_non_ignorable[9] = { 0x202F, 0x1CAD, 0x0000, 0x0020, 0x0020, 0x0000, 0x0005, 0x0008, 0x0000 };

    auto const non_ignorable = collate_for_tests(
        cps, cps + 2, boost::text::variable_weighting::non_ignorable);

    EXPECT_EQ(non_ignorable.size(), 9);
    EXPECT_TRUE(boost::algorithm::equal(non_ignorable.begin(), non_ignorable.end(), ces_non_ignorable, ces_non_ignorable + 9))
        << "from:     " << ce_dumper(cps)
        << "expected: " << ce_dumper(ces_non_ignorable)
        << "got:      " << ce_dumper(non_ignorable);

    // 1D6CC 0041;	
    // (𝛌) MATHEMATICAL BOLD SMALL LAMDA	[202F 1CAD | 0020 0020 | 0005 0008 | FFFF FFFF |]
    uint32_t const ces_shifted[12] = { 0x202F, 0x1CAD, 0x0000, 0x0020, 0x0020, 0x0000, 0x0005, 0x0008, 0x0000, 0xFFFF, 0xFFFF, 0x0000 };

    auto const shifted = collate_for_tests(
        cps, cps + 2, boost::text::variable_weighting::shifted);

    EXPECT_EQ(shifted.size(), 12);
    EXPECT_TRUE(boost::algorithm::equal(shifted.begin(), shifted.end(), ces_shifted, ces_shifted + 12))
        << "from:     " << ce_dumper(cps)
        << "expected: " << ce_dumper(ces_shifted)
        << "got:      " << ce_dumper(shifted);
}

TEST(collation, verbatim_131_401)
{
    uint32_t const cps[2] = { 0x1D706, 0x0041 };

    // 1D706 0041;	
    // (𝜆) MATHEMATICAL ITALIC SMALL LAMDA	[202F 1CAD | 0020 0020 | 0005 0008 |]
    uint32_t const ces_non_ignorable[9] = { 0x202F, 0x1CAD, 0x0000, 0x0020, 0x0020, 0x0000, 0x0005, 0x0008, 0x0000 };

    auto const non_ignorable = collate_for_tests(
        cps, cps + 2, boost::text::variable_weighting::non_ignorable);

    EXPECT_EQ(non_ignorable.size(), 9);
    EXPECT_TRUE(boost::algorithm::equal(non_ignorable.begin(), non_ignorable.end(), ces_non_ignorable, ces_non_ignorable + 9))
        << "from:     " << ce_dumper(cps)
        << "expected: " << ce_dumper(ces_non_ignorable)
        << "got:      " << ce_dumper(non_ignorable);

    // 1D706 0041;	
    // (𝜆) MATHEMATICAL ITALIC SMALL LAMDA	[202F 1CAD | 0020 0020 | 0005 0008 | FFFF FFFF |]
    uint32_t const ces_shifted[12] = { 0x202F, 0x1CAD, 0x0000, 0x0020, 0x0020, 0x0000, 0x0005, 0x0008, 0x0000, 0xFFFF, 0xFFFF, 0x0000 };

    auto const shifted = collate_for_tests(
        cps, cps + 2, boost::text::variable_weighting::shifted);

    EXPECT_EQ(shifted.size(), 12);
    EXPECT_TRUE(boost::algorithm::equal(shifted.begin(), shifted.end(), ces_shifted, ces_shifted + 12))
        << "from:     " << ce_dumper(cps)
        << "expected: " << ce_dumper(ces_shifted)
        << "got:      " << ce_dumper(shifted);
}

TEST(collation, verbatim_131_402)
{
    uint32_t const cps[2] = { 0x1D740, 0x0041 };

    // 1D740 0041;	
    // (𝝀) MATHEMATICAL BOLD ITALIC SMALL LAMDA	[202F 1CAD | 0020 0020 | 0005 0008 |]
    uint32_t const ces_non_ignorable[9] = { 0x202F, 0x1CAD, 0x0000, 0x0020, 0x0020, 0x0000, 0x0005, 0x0008, 0x0000 };

    auto const non_ignorable = collate_for_tests(
        cps, cps + 2, boost::text::variable_weighting::non_ignorable);

    EXPECT_EQ(non_ignorable.size(), 9);
    EXPECT_TRUE(boost::algorithm::equal(non_ignorable.begin(), non_ignorable.end(), ces_non_ignorable, ces_non_ignorable + 9))
        << "from:     " << ce_dumper(cps)
        << "expected: " << ce_dumper(ces_non_ignorable)
        << "got:      " << ce_dumper(non_ignorable);

    // 1D740 0041;	
    // (𝝀) MATHEMATICAL BOLD ITALIC SMALL LAMDA	[202F 1CAD | 0020 0020 | 0005 0008 | FFFF FFFF |]
    uint32_t const ces_shifted[12] = { 0x202F, 0x1CAD, 0x0000, 0x0020, 0x0020, 0x0000, 0x0005, 0x0008, 0x0000, 0xFFFF, 0xFFFF, 0x0000 };

    auto const shifted = collate_for_tests(
        cps, cps + 2, boost::text::variable_weighting::shifted);

    EXPECT_EQ(shifted.size(), 12);
    EXPECT_TRUE(boost::algorithm::equal(shifted.begin(), shifted.end(), ces_shifted, ces_shifted + 12))
        << "from:     " << ce_dumper(cps)
        << "expected: " << ce_dumper(ces_shifted)
        << "got:      " << ce_dumper(shifted);
}

TEST(collation, verbatim_131_403)
{
    uint32_t const cps[2] = { 0x1D77A, 0x0041 };

    // 1D77A 0041;	
    // (𝝺) MATHEMATICAL SANS-SERIF BOLD SMALL LAMDA	[202F 1CAD | 0020 0020 | 0005 0008 |]
    uint32_t const ces_non_ignorable[9] = { 0x202F, 0x1CAD, 0x0000, 0x0020, 0x0020, 0x0000, 0x0005, 0x0008, 0x0000 };

    auto const non_ignorable = collate_for_tests(
        cps, cps + 2, boost::text::variable_weighting::non_ignorable);

    EXPECT_EQ(non_ignorable.size(), 9);
    EXPECT_TRUE(boost::algorithm::equal(non_ignorable.begin(), non_ignorable.end(), ces_non_ignorable, ces_non_ignorable + 9))
        << "from:     " << ce_dumper(cps)
        << "expected: " << ce_dumper(ces_non_ignorable)
        << "got:      " << ce_dumper(non_ignorable);

    // 1D77A 0041;	
    // (𝝺) MATHEMATICAL SANS-SERIF BOLD SMALL LAMDA	[202F 1CAD | 0020 0020 | 0005 0008 | FFFF FFFF |]
    uint32_t const ces_shifted[12] = { 0x202F, 0x1CAD, 0x0000, 0x0020, 0x0020, 0x0000, 0x0005, 0x0008, 0x0000, 0xFFFF, 0xFFFF, 0x0000 };

    auto const shifted = collate_for_tests(
        cps, cps + 2, boost::text::variable_weighting::shifted);

    EXPECT_EQ(shifted.size(), 12);
    EXPECT_TRUE(boost::algorithm::equal(shifted.begin(), shifted.end(), ces_shifted, ces_shifted + 12))
        << "from:     " << ce_dumper(cps)
        << "expected: " << ce_dumper(ces_shifted)
        << "got:      " << ce_dumper(shifted);
}

TEST(collation, verbatim_131_404)
{
    uint32_t const cps[2] = { 0x1D7B4, 0x0041 };

    // 1D7B4 0041;	
    // (𝞴) MATHEMATICAL SANS-SERIF BOLD ITALIC SMALL LAMDA	[202F 1CAD | 0020 0020 | 0005 0008 |]
    uint32_t const ces_non_ignorable[9] = { 0x202F, 0x1CAD, 0x0000, 0x0020, 0x0020, 0x0000, 0x0005, 0x0008, 0x0000 };

    auto const non_ignorable = collate_for_tests(
        cps, cps + 2, boost::text::variable_weighting::non_ignorable);

    EXPECT_EQ(non_ignorable.size(), 9);
    EXPECT_TRUE(boost::algorithm::equal(non_ignorable.begin(), non_ignorable.end(), ces_non_ignorable, ces_non_ignorable + 9))
        << "from:     " << ce_dumper(cps)
        << "expected: " << ce_dumper(ces_non_ignorable)
        << "got:      " << ce_dumper(non_ignorable);

    // 1D7B4 0041;	
    // (𝞴) MATHEMATICAL SANS-SERIF BOLD ITALIC SMALL LAMDA	[202F 1CAD | 0020 0020 | 0005 0008 | FFFF FFFF |]
    uint32_t const ces_shifted[12] = { 0x202F, 0x1CAD, 0x0000, 0x0020, 0x0020, 0x0000, 0x0005, 0x0008, 0x0000, 0xFFFF, 0xFFFF, 0x0000 };

    auto const shifted = collate_for_tests(
        cps, cps + 2, boost::text::variable_weighting::shifted);

    EXPECT_EQ(shifted.size(), 12);
    EXPECT_TRUE(boost::algorithm::equal(shifted.begin(), shifted.end(), ces_shifted, ces_shifted + 12))
        << "from:     " << ce_dumper(cps)
        << "expected: " << ce_dumper(ces_shifted)
        << "got:      " << ce_dumper(shifted);
}

TEST(collation, verbatim_131_405)
{
    uint32_t const cps[2] = { 0x039B, 0x0061 };

    // 039B 0061;	
    // (Λ) GREEK CAPITAL LETTER LAMDA	[202F 1CAD | 0020 0020 | 0008 0002 |]
    uint32_t const ces_non_ignorable[9] = { 0x202F, 0x1CAD, 0x0000, 0x0020, 0x0020, 0x0000, 0x0008, 0x0002, 0x0000 };

    auto const non_ignorable = collate_for_tests(
        cps, cps + 2, boost::text::variable_weighting::non_ignorable);

    EXPECT_EQ(non_ignorable.size(), 9);
    EXPECT_TRUE(boost::algorithm::equal(non_ignorable.begin(), non_ignorable.end(), ces_non_ignorable, ces_non_ignorable + 9))
        << "from:     " << ce_dumper(cps)
        << "expected: " << ce_dumper(ces_non_ignorable)
        << "got:      " << ce_dumper(non_ignorable);

    // 039B 0061;	
    // (Λ) GREEK CAPITAL LETTER LAMDA	[202F 1CAD | 0020 0020 | 0008 0002 | FFFF FFFF |]
    uint32_t const ces_shifted[12] = { 0x202F, 0x1CAD, 0x0000, 0x0020, 0x0020, 0x0000, 0x0008, 0x0002, 0x0000, 0xFFFF, 0xFFFF, 0x0000 };

    auto const shifted = collate_for_tests(
        cps, cps + 2, boost::text::variable_weighting::shifted);

    EXPECT_EQ(shifted.size(), 12);
    EXPECT_TRUE(boost::algorithm::equal(shifted.begin(), shifted.end(), ces_shifted, ces_shifted + 12))
        << "from:     " << ce_dumper(cps)
        << "expected: " << ce_dumper(ces_shifted)
        << "got:      " << ce_dumper(shifted);
}

TEST(collation, verbatim_131_406)
{
    uint32_t const cps[2] = { 0x039B, 0x0041 };

    // 039B 0041;	
    // (Λ) GREEK CAPITAL LETTER LAMDA	[202F 1CAD | 0020 0020 | 0008 0008 |]
    uint32_t const ces_non_ignorable[9] = { 0x202F, 0x1CAD, 0x0000, 0x0020, 0x0020, 0x0000, 0x0008, 0x0008, 0x0000 };

    auto const non_ignorable = collate_for_tests(
        cps, cps + 2, boost::text::variable_weighting::non_ignorable);

    EXPECT_EQ(non_ignorable.size(), 9);
    EXPECT_TRUE(boost::algorithm::equal(non_ignorable.begin(), non_ignorable.end(), ces_non_ignorable, ces_non_ignorable + 9))
        << "from:     " << ce_dumper(cps)
        << "expected: " << ce_dumper(ces_non_ignorable)
        << "got:      " << ce_dumper(non_ignorable);

    // 039B 0041;	
    // (Λ) GREEK CAPITAL LETTER LAMDA	[202F 1CAD | 0020 0020 | 0008 0008 | FFFF FFFF |]
    uint32_t const ces_shifted[12] = { 0x202F, 0x1CAD, 0x0000, 0x0020, 0x0020, 0x0000, 0x0008, 0x0008, 0x0000, 0xFFFF, 0xFFFF, 0x0000 };

    auto const shifted = collate_for_tests(
        cps, cps + 2, boost::text::variable_weighting::shifted);

    EXPECT_EQ(shifted.size(), 12);
    EXPECT_TRUE(boost::algorithm::equal(shifted.begin(), shifted.end(), ces_shifted, ces_shifted + 12))
        << "from:     " << ce_dumper(cps)
        << "expected: " << ce_dumper(ces_shifted)
        << "got:      " << ce_dumper(shifted);
}

TEST(collation, verbatim_131_407)
{
    uint32_t const cps[2] = { 0x1D6B2, 0x0061 };

    // 1D6B2 0061;	
    // (𝚲) MATHEMATICAL BOLD CAPITAL LAMDA	[202F 1CAD | 0020 0020 | 000B 0002 |]
    uint32_t const ces_non_ignorable[9] = { 0x202F, 0x1CAD, 0x0000, 0x0020, 0x0020, 0x0000, 0x000B, 0x0002, 0x0000 };

    auto const non_ignorable = collate_for_tests(
        cps, cps + 2, boost::text::variable_weighting::non_ignorable);

    EXPECT_EQ(non_ignorable.size(), 9);
    EXPECT_TRUE(boost::algorithm::equal(non_ignorable.begin(), non_ignorable.end(), ces_non_ignorable, ces_non_ignorable + 9))
        << "from:     " << ce_dumper(cps)
        << "expected: " << ce_dumper(ces_non_ignorable)
        << "got:      " << ce_dumper(non_ignorable);

    // 1D6B2 0061;	
    // (𝚲) MATHEMATICAL BOLD CAPITAL LAMDA	[202F 1CAD | 0020 0020 | 000B 0002 | FFFF FFFF |]
    uint32_t const ces_shifted[12] = { 0x202F, 0x1CAD, 0x0000, 0x0020, 0x0020, 0x0000, 0x000B, 0x0002, 0x0000, 0xFFFF, 0xFFFF, 0x0000 };

    auto const shifted = collate_for_tests(
        cps, cps + 2, boost::text::variable_weighting::shifted);

    EXPECT_EQ(shifted.size(), 12);
    EXPECT_TRUE(boost::algorithm::equal(shifted.begin(), shifted.end(), ces_shifted, ces_shifted + 12))
        << "from:     " << ce_dumper(cps)
        << "expected: " << ce_dumper(ces_shifted)
        << "got:      " << ce_dumper(shifted);
}

TEST(collation, verbatim_131_408)
{
    uint32_t const cps[2] = { 0x1D6EC, 0x0061 };

    // 1D6EC 0061;	
    // (𝛬) MATHEMATICAL ITALIC CAPITAL LAMDA	[202F 1CAD | 0020 0020 | 000B 0002 |]
    uint32_t const ces_non_ignorable[9] = { 0x202F, 0x1CAD, 0x0000, 0x0020, 0x0020, 0x0000, 0x000B, 0x0002, 0x0000 };

    auto const non_ignorable = collate_for_tests(
        cps, cps + 2, boost::text::variable_weighting::non_ignorable);

    EXPECT_EQ(non_ignorable.size(), 9);
    EXPECT_TRUE(boost::algorithm::equal(non_ignorable.begin(), non_ignorable.end(), ces_non_ignorable, ces_non_ignorable + 9))
        << "from:     " << ce_dumper(cps)
        << "expected: " << ce_dumper(ces_non_ignorable)
        << "got:      " << ce_dumper(non_ignorable);

    // 1D6EC 0061;	
    // (𝛬) MATHEMATICAL ITALIC CAPITAL LAMDA	[202F 1CAD | 0020 0020 | 000B 0002 | FFFF FFFF |]
    uint32_t const ces_shifted[12] = { 0x202F, 0x1CAD, 0x0000, 0x0020, 0x0020, 0x0000, 0x000B, 0x0002, 0x0000, 0xFFFF, 0xFFFF, 0x0000 };

    auto const shifted = collate_for_tests(
        cps, cps + 2, boost::text::variable_weighting::shifted);

    EXPECT_EQ(shifted.size(), 12);
    EXPECT_TRUE(boost::algorithm::equal(shifted.begin(), shifted.end(), ces_shifted, ces_shifted + 12))
        << "from:     " << ce_dumper(cps)
        << "expected: " << ce_dumper(ces_shifted)
        << "got:      " << ce_dumper(shifted);
}

TEST(collation, verbatim_131_409)
{
    uint32_t const cps[2] = { 0x1D726, 0x0061 };

    // 1D726 0061;	
    // (𝜦) MATHEMATICAL BOLD ITALIC CAPITAL LAMDA	[202F 1CAD | 0020 0020 | 000B 0002 |]
    uint32_t const ces_non_ignorable[9] = { 0x202F, 0x1CAD, 0x0000, 0x0020, 0x0020, 0x0000, 0x000B, 0x0002, 0x0000 };

    auto const non_ignorable = collate_for_tests(
        cps, cps + 2, boost::text::variable_weighting::non_ignorable);

    EXPECT_EQ(non_ignorable.size(), 9);
    EXPECT_TRUE(boost::algorithm::equal(non_ignorable.begin(), non_ignorable.end(), ces_non_ignorable, ces_non_ignorable + 9))
        << "from:     " << ce_dumper(cps)
        << "expected: " << ce_dumper(ces_non_ignorable)
        << "got:      " << ce_dumper(non_ignorable);

    // 1D726 0061;	
    // (𝜦) MATHEMATICAL BOLD ITALIC CAPITAL LAMDA	[202F 1CAD | 0020 0020 | 000B 0002 | FFFF FFFF |]
    uint32_t const ces_shifted[12] = { 0x202F, 0x1CAD, 0x0000, 0x0020, 0x0020, 0x0000, 0x000B, 0x0002, 0x0000, 0xFFFF, 0xFFFF, 0x0000 };

    auto const shifted = collate_for_tests(
        cps, cps + 2, boost::text::variable_weighting::shifted);

    EXPECT_EQ(shifted.size(), 12);
    EXPECT_TRUE(boost::algorithm::equal(shifted.begin(), shifted.end(), ces_shifted, ces_shifted + 12))
        << "from:     " << ce_dumper(cps)
        << "expected: " << ce_dumper(ces_shifted)
        << "got:      " << ce_dumper(shifted);
}

TEST(collation, verbatim_131_410)
{
    uint32_t const cps[2] = { 0x1D760, 0x0061 };

    // 1D760 0061;	
    // (𝝠) MATHEMATICAL SANS-SERIF BOLD CAPITAL LAMDA	[202F 1CAD | 0020 0020 | 000B 0002 |]
    uint32_t const ces_non_ignorable[9] = { 0x202F, 0x1CAD, 0x0000, 0x0020, 0x0020, 0x0000, 0x000B, 0x0002, 0x0000 };

    auto const non_ignorable = collate_for_tests(
        cps, cps + 2, boost::text::variable_weighting::non_ignorable);

    EXPECT_EQ(non_ignorable.size(), 9);
    EXPECT_TRUE(boost::algorithm::equal(non_ignorable.begin(), non_ignorable.end(), ces_non_ignorable, ces_non_ignorable + 9))
        << "from:     " << ce_dumper(cps)
        << "expected: " << ce_dumper(ces_non_ignorable)
        << "got:      " << ce_dumper(non_ignorable);

    // 1D760 0061;	
    // (𝝠) MATHEMATICAL SANS-SERIF BOLD CAPITAL LAMDA	[202F 1CAD | 0020 0020 | 000B 0002 | FFFF FFFF |]
    uint32_t const ces_shifted[12] = { 0x202F, 0x1CAD, 0x0000, 0x0020, 0x0020, 0x0000, 0x000B, 0x0002, 0x0000, 0xFFFF, 0xFFFF, 0x0000 };

    auto const shifted = collate_for_tests(
        cps, cps + 2, boost::text::variable_weighting::shifted);

    EXPECT_EQ(shifted.size(), 12);
    EXPECT_TRUE(boost::algorithm::equal(shifted.begin(), shifted.end(), ces_shifted, ces_shifted + 12))
        << "from:     " << ce_dumper(cps)
        << "expected: " << ce_dumper(ces_shifted)
        << "got:      " << ce_dumper(shifted);
}

TEST(collation, verbatim_131_411)
{
    uint32_t const cps[2] = { 0x1D79A, 0x0061 };

    // 1D79A 0061;	
    // (𝞚) MATHEMATICAL SANS-SERIF BOLD ITALIC CAPITAL LAMDA	[202F 1CAD | 0020 0020 | 000B 0002 |]
    uint32_t const ces_non_ignorable[9] = { 0x202F, 0x1CAD, 0x0000, 0x0020, 0x0020, 0x0000, 0x000B, 0x0002, 0x0000 };

    auto const non_ignorable = collate_for_tests(
        cps, cps + 2, boost::text::variable_weighting::non_ignorable);

    EXPECT_EQ(non_ignorable.size(), 9);
    EXPECT_TRUE(boost::algorithm::equal(non_ignorable.begin(), non_ignorable.end(), ces_non_ignorable, ces_non_ignorable + 9))
        << "from:     " << ce_dumper(cps)
        << "expected: " << ce_dumper(ces_non_ignorable)
        << "got:      " << ce_dumper(non_ignorable);

    // 1D79A 0061;	
    // (𝞚) MATHEMATICAL SANS-SERIF BOLD ITALIC CAPITAL LAMDA	[202F 1CAD | 0020 0020 | 000B 0002 | FFFF FFFF |]
    uint32_t const ces_shifted[12] = { 0x202F, 0x1CAD, 0x0000, 0x0020, 0x0020, 0x0000, 0x000B, 0x0002, 0x0000, 0xFFFF, 0xFFFF, 0x0000 };

    auto const shifted = collate_for_tests(
        cps, cps + 2, boost::text::variable_weighting::shifted);

    EXPECT_EQ(shifted.size(), 12);
    EXPECT_TRUE(boost::algorithm::equal(shifted.begin(), shifted.end(), ces_shifted, ces_shifted + 12))
        << "from:     " << ce_dumper(cps)
        << "expected: " << ce_dumper(ces_shifted)
        << "got:      " << ce_dumper(shifted);
}

TEST(collation, verbatim_131_412)
{
    uint32_t const cps[2] = { 0x1D6B2, 0x0041 };

    // 1D6B2 0041;	
    // (𝚲) MATHEMATICAL BOLD CAPITAL LAMDA	[202F 1CAD | 0020 0020 | 000B 0008 |]
    uint32_t const ces_non_ignorable[9] = { 0x202F, 0x1CAD, 0x0000, 0x0020, 0x0020, 0x0000, 0x000B, 0x0008, 0x0000 };

    auto const non_ignorable = collate_for_tests(
        cps, cps + 2, boost::text::variable_weighting::non_ignorable);

    EXPECT_EQ(non_ignorable.size(), 9);
    EXPECT_TRUE(boost::algorithm::equal(non_ignorable.begin(), non_ignorable.end(), ces_non_ignorable, ces_non_ignorable + 9))
        << "from:     " << ce_dumper(cps)
        << "expected: " << ce_dumper(ces_non_ignorable)
        << "got:      " << ce_dumper(non_ignorable);

    // 1D6B2 0041;	
    // (𝚲) MATHEMATICAL BOLD CAPITAL LAMDA	[202F 1CAD | 0020 0020 | 000B 0008 | FFFF FFFF |]
    uint32_t const ces_shifted[12] = { 0x202F, 0x1CAD, 0x0000, 0x0020, 0x0020, 0x0000, 0x000B, 0x0008, 0x0000, 0xFFFF, 0xFFFF, 0x0000 };

    auto const shifted = collate_for_tests(
        cps, cps + 2, boost::text::variable_weighting::shifted);

    EXPECT_EQ(shifted.size(), 12);
    EXPECT_TRUE(boost::algorithm::equal(shifted.begin(), shifted.end(), ces_shifted, ces_shifted + 12))
        << "from:     " << ce_dumper(cps)
        << "expected: " << ce_dumper(ces_shifted)
        << "got:      " << ce_dumper(shifted);
}

TEST(collation, verbatim_131_413)
{
    uint32_t const cps[2] = { 0x1D6EC, 0x0041 };

    // 1D6EC 0041;	
    // (𝛬) MATHEMATICAL ITALIC CAPITAL LAMDA	[202F 1CAD | 0020 0020 | 000B 0008 |]
    uint32_t const ces_non_ignorable[9] = { 0x202F, 0x1CAD, 0x0000, 0x0020, 0x0020, 0x0000, 0x000B, 0x0008, 0x0000 };

    auto const non_ignorable = collate_for_tests(
        cps, cps + 2, boost::text::variable_weighting::non_ignorable);

    EXPECT_EQ(non_ignorable.size(), 9);
    EXPECT_TRUE(boost::algorithm::equal(non_ignorable.begin(), non_ignorable.end(), ces_non_ignorable, ces_non_ignorable + 9))
        << "from:     " << ce_dumper(cps)
        << "expected: " << ce_dumper(ces_non_ignorable)
        << "got:      " << ce_dumper(non_ignorable);

    // 1D6EC 0041;	
    // (𝛬) MATHEMATICAL ITALIC CAPITAL LAMDA	[202F 1CAD | 0020 0020 | 000B 0008 | FFFF FFFF |]
    uint32_t const ces_shifted[12] = { 0x202F, 0x1CAD, 0x0000, 0x0020, 0x0020, 0x0000, 0x000B, 0x0008, 0x0000, 0xFFFF, 0xFFFF, 0x0000 };

    auto const shifted = collate_for_tests(
        cps, cps + 2, boost::text::variable_weighting::shifted);

    EXPECT_EQ(shifted.size(), 12);
    EXPECT_TRUE(boost::algorithm::equal(shifted.begin(), shifted.end(), ces_shifted, ces_shifted + 12))
        << "from:     " << ce_dumper(cps)
        << "expected: " << ce_dumper(ces_shifted)
        << "got:      " << ce_dumper(shifted);
}

TEST(collation, verbatim_131_414)
{
    uint32_t const cps[2] = { 0x1D726, 0x0041 };

    // 1D726 0041;	
    // (𝜦) MATHEMATICAL BOLD ITALIC CAPITAL LAMDA	[202F 1CAD | 0020 0020 | 000B 0008 |]
    uint32_t const ces_non_ignorable[9] = { 0x202F, 0x1CAD, 0x0000, 0x0020, 0x0020, 0x0000, 0x000B, 0x0008, 0x0000 };

    auto const non_ignorable = collate_for_tests(
        cps, cps + 2, boost::text::variable_weighting::non_ignorable);

    EXPECT_EQ(non_ignorable.size(), 9);
    EXPECT_TRUE(boost::algorithm::equal(non_ignorable.begin(), non_ignorable.end(), ces_non_ignorable, ces_non_ignorable + 9))
        << "from:     " << ce_dumper(cps)
        << "expected: " << ce_dumper(ces_non_ignorable)
        << "got:      " << ce_dumper(non_ignorable);

    // 1D726 0041;	
    // (𝜦) MATHEMATICAL BOLD ITALIC CAPITAL LAMDA	[202F 1CAD | 0020 0020 | 000B 0008 | FFFF FFFF |]
    uint32_t const ces_shifted[12] = { 0x202F, 0x1CAD, 0x0000, 0x0020, 0x0020, 0x0000, 0x000B, 0x0008, 0x0000, 0xFFFF, 0xFFFF, 0x0000 };

    auto const shifted = collate_for_tests(
        cps, cps + 2, boost::text::variable_weighting::shifted);

    EXPECT_EQ(shifted.size(), 12);
    EXPECT_TRUE(boost::algorithm::equal(shifted.begin(), shifted.end(), ces_shifted, ces_shifted + 12))
        << "from:     " << ce_dumper(cps)
        << "expected: " << ce_dumper(ces_shifted)
        << "got:      " << ce_dumper(shifted);
}

TEST(collation, verbatim_131_415)
{
    uint32_t const cps[2] = { 0x1D760, 0x0041 };

    // 1D760 0041;	
    // (𝝠) MATHEMATICAL SANS-SERIF BOLD CAPITAL LAMDA	[202F 1CAD | 0020 0020 | 000B 0008 |]
    uint32_t const ces_non_ignorable[9] = { 0x202F, 0x1CAD, 0x0000, 0x0020, 0x0020, 0x0000, 0x000B, 0x0008, 0x0000 };

    auto const non_ignorable = collate_for_tests(
        cps, cps + 2, boost::text::variable_weighting::non_ignorable);

    EXPECT_EQ(non_ignorable.size(), 9);
    EXPECT_TRUE(boost::algorithm::equal(non_ignorable.begin(), non_ignorable.end(), ces_non_ignorable, ces_non_ignorable + 9))
        << "from:     " << ce_dumper(cps)
        << "expected: " << ce_dumper(ces_non_ignorable)
        << "got:      " << ce_dumper(non_ignorable);

    // 1D760 0041;	
    // (𝝠) MATHEMATICAL SANS-SERIF BOLD CAPITAL LAMDA	[202F 1CAD | 0020 0020 | 000B 0008 | FFFF FFFF |]
    uint32_t const ces_shifted[12] = { 0x202F, 0x1CAD, 0x0000, 0x0020, 0x0020, 0x0000, 0x000B, 0x0008, 0x0000, 0xFFFF, 0xFFFF, 0x0000 };

    auto const shifted = collate_for_tests(
        cps, cps + 2, boost::text::variable_weighting::shifted);

    EXPECT_EQ(shifted.size(), 12);
    EXPECT_TRUE(boost::algorithm::equal(shifted.begin(), shifted.end(), ces_shifted, ces_shifted + 12))
        << "from:     " << ce_dumper(cps)
        << "expected: " << ce_dumper(ces_shifted)
        << "got:      " << ce_dumper(shifted);
}

TEST(collation, verbatim_131_416)
{
    uint32_t const cps[2] = { 0x1D79A, 0x0041 };

    // 1D79A 0041;	
    // (𝞚) MATHEMATICAL SANS-SERIF BOLD ITALIC CAPITAL LAMDA	[202F 1CAD | 0020 0020 | 000B 0008 |]
    uint32_t const ces_non_ignorable[9] = { 0x202F, 0x1CAD, 0x0000, 0x0020, 0x0020, 0x0000, 0x000B, 0x0008, 0x0000 };

    auto const non_ignorable = collate_for_tests(
        cps, cps + 2, boost::text::variable_weighting::non_ignorable);

    EXPECT_EQ(non_ignorable.size(), 9);
    EXPECT_TRUE(boost::algorithm::equal(non_ignorable.begin(), non_ignorable.end(), ces_non_ignorable, ces_non_ignorable + 9))
        << "from:     " << ce_dumper(cps)
        << "expected: " << ce_dumper(ces_non_ignorable)
        << "got:      " << ce_dumper(non_ignorable);

    // 1D79A 0041;	
    // (𝞚) MATHEMATICAL SANS-SERIF BOLD ITALIC CAPITAL LAMDA	[202F 1CAD | 0020 0020 | 000B 0008 | FFFF FFFF |]
    uint32_t const ces_shifted[12] = { 0x202F, 0x1CAD, 0x0000, 0x0020, 0x0020, 0x0000, 0x000B, 0x0008, 0x0000, 0xFFFF, 0xFFFF, 0x0000 };

    auto const shifted = collate_for_tests(
        cps, cps + 2, boost::text::variable_weighting::shifted);

    EXPECT_EQ(shifted.size(), 12);
    EXPECT_TRUE(boost::algorithm::equal(shifted.begin(), shifted.end(), ces_shifted, ces_shifted + 12))
        << "from:     " << ce_dumper(cps)
        << "expected: " << ce_dumper(ces_shifted)
        << "got:      " << ce_dumper(shifted);
}

TEST(collation, verbatim_131_417)
{
    uint32_t const cps[2] = { 0x03BB, 0x0062 };

    // 03BB 0062;	
    // (λ) GREEK SMALL LETTER LAMDA	[202F 1CC6 | 0020 0020 | 0002 0002 |]
    uint32_t const ces_non_ignorable[9] = { 0x202F, 0x1CC6, 0x0000, 0x0020, 0x0020, 0x0000, 0x0002, 0x0002, 0x0000 };

    auto const non_ignorable = collate_for_tests(
        cps, cps + 2, boost::text::variable_weighting::non_ignorable);

    EXPECT_EQ(non_ignorable.size(), 9);
    EXPECT_TRUE(boost::algorithm::equal(non_ignorable.begin(), non_ignorable.end(), ces_non_ignorable, ces_non_ignorable + 9))
        << "from:     " << ce_dumper(cps)
        << "expected: " << ce_dumper(ces_non_ignorable)
        << "got:      " << ce_dumper(non_ignorable);

    // 03BB 0062;	
    // (λ) GREEK SMALL LETTER LAMDA	[202F 1CC6 | 0020 0020 | 0002 0002 | FFFF FFFF |]
    uint32_t const ces_shifted[12] = { 0x202F, 0x1CC6, 0x0000, 0x0020, 0x0020, 0x0000, 0x0002, 0x0002, 0x0000, 0xFFFF, 0xFFFF, 0x0000 };

    auto const shifted = collate_for_tests(
        cps, cps + 2, boost::text::variable_weighting::shifted);

    EXPECT_EQ(shifted.size(), 12);
    EXPECT_TRUE(boost::algorithm::equal(shifted.begin(), shifted.end(), ces_shifted, ces_shifted + 12))
        << "from:     " << ce_dumper(cps)
        << "expected: " << ce_dumper(ces_shifted)
        << "got:      " << ce_dumper(shifted);
}

TEST(collation, verbatim_131_418)
{
    uint32_t const cps[2] = { 0x1D6CC, 0x0062 };

    // 1D6CC 0062;	
    // (𝛌) MATHEMATICAL BOLD SMALL LAMDA	[202F 1CC6 | 0020 0020 | 0005 0002 |]
    uint32_t const ces_non_ignorable[9] = { 0x202F, 0x1CC6, 0x0000, 0x0020, 0x0020, 0x0000, 0x0005, 0x0002, 0x0000 };

    auto const non_ignorable = collate_for_tests(
        cps, cps + 2, boost::text::variable_weighting::non_ignorable);

    EXPECT_EQ(non_ignorable.size(), 9);
    EXPECT_TRUE(boost::algorithm::equal(non_ignorable.begin(), non_ignorable.end(), ces_non_ignorable, ces_non_ignorable + 9))
        << "from:     " << ce_dumper(cps)
        << "expected: " << ce_dumper(ces_non_ignorable)
        << "got:      " << ce_dumper(non_ignorable);

    // 1D6CC 0062;	
    // (𝛌) MATHEMATICAL BOLD SMALL LAMDA	[202F 1CC6 | 0020 0020 | 0005 0002 | FFFF FFFF |]
    uint32_t const ces_shifted[12] = { 0x202F, 0x1CC6, 0x0000, 0x0020, 0x0020, 0x0000, 0x0005, 0x0002, 0x0000, 0xFFFF, 0xFFFF, 0x0000 };

    auto const shifted = collate_for_tests(
        cps, cps + 2, boost::text::variable_weighting::shifted);

    EXPECT_EQ(shifted.size(), 12);
    EXPECT_TRUE(boost::algorithm::equal(shifted.begin(), shifted.end(), ces_shifted, ces_shifted + 12))
        << "from:     " << ce_dumper(cps)
        << "expected: " << ce_dumper(ces_shifted)
        << "got:      " << ce_dumper(shifted);
}

TEST(collation, verbatim_131_419)
{
    uint32_t const cps[2] = { 0x1D706, 0x0062 };

    // 1D706 0062;	
    // (𝜆) MATHEMATICAL ITALIC SMALL LAMDA	[202F 1CC6 | 0020 0020 | 0005 0002 |]
    uint32_t const ces_non_ignorable[9] = { 0x202F, 0x1CC6, 0x0000, 0x0020, 0x0020, 0x0000, 0x0005, 0x0002, 0x0000 };

    auto const non_ignorable = collate_for_tests(
        cps, cps + 2, boost::text::variable_weighting::non_ignorable);

    EXPECT_EQ(non_ignorable.size(), 9);
    EXPECT_TRUE(boost::algorithm::equal(non_ignorable.begin(), non_ignorable.end(), ces_non_ignorable, ces_non_ignorable + 9))
        << "from:     " << ce_dumper(cps)
        << "expected: " << ce_dumper(ces_non_ignorable)
        << "got:      " << ce_dumper(non_ignorable);

    // 1D706 0062;	
    // (𝜆) MATHEMATICAL ITALIC SMALL LAMDA	[202F 1CC6 | 0020 0020 | 0005 0002 | FFFF FFFF |]
    uint32_t const ces_shifted[12] = { 0x202F, 0x1CC6, 0x0000, 0x0020, 0x0020, 0x0000, 0x0005, 0x0002, 0x0000, 0xFFFF, 0xFFFF, 0x0000 };

    auto const shifted = collate_for_tests(
        cps, cps + 2, boost::text::variable_weighting::shifted);

    EXPECT_EQ(shifted.size(), 12);
    EXPECT_TRUE(boost::algorithm::equal(shifted.begin(), shifted.end(), ces_shifted, ces_shifted + 12))
        << "from:     " << ce_dumper(cps)
        << "expected: " << ce_dumper(ces_shifted)
        << "got:      " << ce_dumper(shifted);
}

TEST(collation, verbatim_131_420)
{
    uint32_t const cps[2] = { 0x1D740, 0x0062 };

    // 1D740 0062;	
    // (𝝀) MATHEMATICAL BOLD ITALIC SMALL LAMDA	[202F 1CC6 | 0020 0020 | 0005 0002 |]
    uint32_t const ces_non_ignorable[9] = { 0x202F, 0x1CC6, 0x0000, 0x0020, 0x0020, 0x0000, 0x0005, 0x0002, 0x0000 };

    auto const non_ignorable = collate_for_tests(
        cps, cps + 2, boost::text::variable_weighting::non_ignorable);

    EXPECT_EQ(non_ignorable.size(), 9);
    EXPECT_TRUE(boost::algorithm::equal(non_ignorable.begin(), non_ignorable.end(), ces_non_ignorable, ces_non_ignorable + 9))
        << "from:     " << ce_dumper(cps)
        << "expected: " << ce_dumper(ces_non_ignorable)
        << "got:      " << ce_dumper(non_ignorable);

    // 1D740 0062;	
    // (𝝀) MATHEMATICAL BOLD ITALIC SMALL LAMDA	[202F 1CC6 | 0020 0020 | 0005 0002 | FFFF FFFF |]
    uint32_t const ces_shifted[12] = { 0x202F, 0x1CC6, 0x0000, 0x0020, 0x0020, 0x0000, 0x0005, 0x0002, 0x0000, 0xFFFF, 0xFFFF, 0x0000 };

    auto const shifted = collate_for_tests(
        cps, cps + 2, boost::text::variable_weighting::shifted);

    EXPECT_EQ(shifted.size(), 12);
    EXPECT_TRUE(boost::algorithm::equal(shifted.begin(), shifted.end(), ces_shifted, ces_shifted + 12))
        << "from:     " << ce_dumper(cps)
        << "expected: " << ce_dumper(ces_shifted)
        << "got:      " << ce_dumper(shifted);
}

TEST(collation, verbatim_131_421)
{
    uint32_t const cps[2] = { 0x1D77A, 0x0062 };

    // 1D77A 0062;	
    // (𝝺) MATHEMATICAL SANS-SERIF BOLD SMALL LAMDA	[202F 1CC6 | 0020 0020 | 0005 0002 |]
    uint32_t const ces_non_ignorable[9] = { 0x202F, 0x1CC6, 0x0000, 0x0020, 0x0020, 0x0000, 0x0005, 0x0002, 0x0000 };

    auto const non_ignorable = collate_for_tests(
        cps, cps + 2, boost::text::variable_weighting::non_ignorable);

    EXPECT_EQ(non_ignorable.size(), 9);
    EXPECT_TRUE(boost::algorithm::equal(non_ignorable.begin(), non_ignorable.end(), ces_non_ignorable, ces_non_ignorable + 9))
        << "from:     " << ce_dumper(cps)
        << "expected: " << ce_dumper(ces_non_ignorable)
        << "got:      " << ce_dumper(non_ignorable);

    // 1D77A 0062;	
    // (𝝺) MATHEMATICAL SANS-SERIF BOLD SMALL LAMDA	[202F 1CC6 | 0020 0020 | 0005 0002 | FFFF FFFF |]
    uint32_t const ces_shifted[12] = { 0x202F, 0x1CC6, 0x0000, 0x0020, 0x0020, 0x0000, 0x0005, 0x0002, 0x0000, 0xFFFF, 0xFFFF, 0x0000 };

    auto const shifted = collate_for_tests(
        cps, cps + 2, boost::text::variable_weighting::shifted);

    EXPECT_EQ(shifted.size(), 12);
    EXPECT_TRUE(boost::algorithm::equal(shifted.begin(), shifted.end(), ces_shifted, ces_shifted + 12))
        << "from:     " << ce_dumper(cps)
        << "expected: " << ce_dumper(ces_shifted)
        << "got:      " << ce_dumper(shifted);
}

TEST(collation, verbatim_131_422)
{
    uint32_t const cps[2] = { 0x1D7B4, 0x0062 };

    // 1D7B4 0062;	
    // (𝞴) MATHEMATICAL SANS-SERIF BOLD ITALIC SMALL LAMDA	[202F 1CC6 | 0020 0020 | 0005 0002 |]
    uint32_t const ces_non_ignorable[9] = { 0x202F, 0x1CC6, 0x0000, 0x0020, 0x0020, 0x0000, 0x0005, 0x0002, 0x0000 };

    auto const non_ignorable = collate_for_tests(
        cps, cps + 2, boost::text::variable_weighting::non_ignorable);

    EXPECT_EQ(non_ignorable.size(), 9);
    EXPECT_TRUE(boost::algorithm::equal(non_ignorable.begin(), non_ignorable.end(), ces_non_ignorable, ces_non_ignorable + 9))
        << "from:     " << ce_dumper(cps)
        << "expected: " << ce_dumper(ces_non_ignorable)
        << "got:      " << ce_dumper(non_ignorable);

    // 1D7B4 0062;	
    // (𝞴) MATHEMATICAL SANS-SERIF BOLD ITALIC SMALL LAMDA	[202F 1CC6 | 0020 0020 | 0005 0002 | FFFF FFFF |]
    uint32_t const ces_shifted[12] = { 0x202F, 0x1CC6, 0x0000, 0x0020, 0x0020, 0x0000, 0x0005, 0x0002, 0x0000, 0xFFFF, 0xFFFF, 0x0000 };

    auto const shifted = collate_for_tests(
        cps, cps + 2, boost::text::variable_weighting::shifted);

    EXPECT_EQ(shifted.size(), 12);
    EXPECT_TRUE(boost::algorithm::equal(shifted.begin(), shifted.end(), ces_shifted, ces_shifted + 12))
        << "from:     " << ce_dumper(cps)
        << "expected: " << ce_dumper(ces_shifted)
        << "got:      " << ce_dumper(shifted);
}

TEST(collation, verbatim_131_423)
{
    uint32_t const cps[2] = { 0x039B, 0x0062 };

    // 039B 0062;	
    // (Λ) GREEK CAPITAL LETTER LAMDA	[202F 1CC6 | 0020 0020 | 0008 0002 |]
    uint32_t const ces_non_ignorable[9] = { 0x202F, 0x1CC6, 0x0000, 0x0020, 0x0020, 0x0000, 0x0008, 0x0002, 0x0000 };

    auto const non_ignorable = collate_for_tests(
        cps, cps + 2, boost::text::variable_weighting::non_ignorable);

    EXPECT_EQ(non_ignorable.size(), 9);
    EXPECT_TRUE(boost::algorithm::equal(non_ignorable.begin(), non_ignorable.end(), ces_non_ignorable, ces_non_ignorable + 9))
        << "from:     " << ce_dumper(cps)
        << "expected: " << ce_dumper(ces_non_ignorable)
        << "got:      " << ce_dumper(non_ignorable);

    // 039B 0062;	
    // (Λ) GREEK CAPITAL LETTER LAMDA	[202F 1CC6 | 0020 0020 | 0008 0002 | FFFF FFFF |]
    uint32_t const ces_shifted[12] = { 0x202F, 0x1CC6, 0x0000, 0x0020, 0x0020, 0x0000, 0x0008, 0x0002, 0x0000, 0xFFFF, 0xFFFF, 0x0000 };

    auto const shifted = collate_for_tests(
        cps, cps + 2, boost::text::variable_weighting::shifted);

    EXPECT_EQ(shifted.size(), 12);
    EXPECT_TRUE(boost::algorithm::equal(shifted.begin(), shifted.end(), ces_shifted, ces_shifted + 12))
        << "from:     " << ce_dumper(cps)
        << "expected: " << ce_dumper(ces_shifted)
        << "got:      " << ce_dumper(shifted);
}

TEST(collation, verbatim_131_424)
{
    uint32_t const cps[2] = { 0x1D6B2, 0x0062 };

    // 1D6B2 0062;	
    // (𝚲) MATHEMATICAL BOLD CAPITAL LAMDA	[202F 1CC6 | 0020 0020 | 000B 0002 |]
    uint32_t const ces_non_ignorable[9] = { 0x202F, 0x1CC6, 0x0000, 0x0020, 0x0020, 0x0000, 0x000B, 0x0002, 0x0000 };

    auto const non_ignorable = collate_for_tests(
        cps, cps + 2, boost::text::variable_weighting::non_ignorable);

    EXPECT_EQ(non_ignorable.size(), 9);
    EXPECT_TRUE(boost::algorithm::equal(non_ignorable.begin(), non_ignorable.end(), ces_non_ignorable, ces_non_ignorable + 9))
        << "from:     " << ce_dumper(cps)
        << "expected: " << ce_dumper(ces_non_ignorable)
        << "got:      " << ce_dumper(non_ignorable);

    // 1D6B2 0062;	
    // (𝚲) MATHEMATICAL BOLD CAPITAL LAMDA	[202F 1CC6 | 0020 0020 | 000B 0002 | FFFF FFFF |]
    uint32_t const ces_shifted[12] = { 0x202F, 0x1CC6, 0x0000, 0x0020, 0x0020, 0x0000, 0x000B, 0x0002, 0x0000, 0xFFFF, 0xFFFF, 0x0000 };

    auto const shifted = collate_for_tests(
        cps, cps + 2, boost::text::variable_weighting::shifted);

    EXPECT_EQ(shifted.size(), 12);
    EXPECT_TRUE(boost::algorithm::equal(shifted.begin(), shifted.end(), ces_shifted, ces_shifted + 12))
        << "from:     " << ce_dumper(cps)
        << "expected: " << ce_dumper(ces_shifted)
        << "got:      " << ce_dumper(shifted);
}

TEST(collation, verbatim_131_425)
{
    uint32_t const cps[2] = { 0x1D6EC, 0x0062 };

    // 1D6EC 0062;	
    // (𝛬) MATHEMATICAL ITALIC CAPITAL LAMDA	[202F 1CC6 | 0020 0020 | 000B 0002 |]
    uint32_t const ces_non_ignorable[9] = { 0x202F, 0x1CC6, 0x0000, 0x0020, 0x0020, 0x0000, 0x000B, 0x0002, 0x0000 };

    auto const non_ignorable = collate_for_tests(
        cps, cps + 2, boost::text::variable_weighting::non_ignorable);

    EXPECT_EQ(non_ignorable.size(), 9);
    EXPECT_TRUE(boost::algorithm::equal(non_ignorable.begin(), non_ignorable.end(), ces_non_ignorable, ces_non_ignorable + 9))
        << "from:     " << ce_dumper(cps)
        << "expected: " << ce_dumper(ces_non_ignorable)
        << "got:      " << ce_dumper(non_ignorable);

    // 1D6EC 0062;	
    // (𝛬) MATHEMATICAL ITALIC CAPITAL LAMDA	[202F 1CC6 | 0020 0020 | 000B 0002 | FFFF FFFF |]
    uint32_t const ces_shifted[12] = { 0x202F, 0x1CC6, 0x0000, 0x0020, 0x0020, 0x0000, 0x000B, 0x0002, 0x0000, 0xFFFF, 0xFFFF, 0x0000 };

    auto const shifted = collate_for_tests(
        cps, cps + 2, boost::text::variable_weighting::shifted);

    EXPECT_EQ(shifted.size(), 12);
    EXPECT_TRUE(boost::algorithm::equal(shifted.begin(), shifted.end(), ces_shifted, ces_shifted + 12))
        << "from:     " << ce_dumper(cps)
        << "expected: " << ce_dumper(ces_shifted)
        << "got:      " << ce_dumper(shifted);
}

TEST(collation, verbatim_131_426)
{
    uint32_t const cps[2] = { 0x1D726, 0x0062 };

    // 1D726 0062;	
    // (𝜦) MATHEMATICAL BOLD ITALIC CAPITAL LAMDA	[202F 1CC6 | 0020 0020 | 000B 0002 |]
    uint32_t const ces_non_ignorable[9] = { 0x202F, 0x1CC6, 0x0000, 0x0020, 0x0020, 0x0000, 0x000B, 0x0002, 0x0000 };

    auto const non_ignorable = collate_for_tests(
        cps, cps + 2, boost::text::variable_weighting::non_ignorable);

    EXPECT_EQ(non_ignorable.size(), 9);
    EXPECT_TRUE(boost::algorithm::equal(non_ignorable.begin(), non_ignorable.end(), ces_non_ignorable, ces_non_ignorable + 9))
        << "from:     " << ce_dumper(cps)
        << "expected: " << ce_dumper(ces_non_ignorable)
        << "got:      " << ce_dumper(non_ignorable);

    // 1D726 0062;	
    // (𝜦) MATHEMATICAL BOLD ITALIC CAPITAL LAMDA	[202F 1CC6 | 0020 0020 | 000B 0002 | FFFF FFFF |]
    uint32_t const ces_shifted[12] = { 0x202F, 0x1CC6, 0x0000, 0x0020, 0x0020, 0x0000, 0x000B, 0x0002, 0x0000, 0xFFFF, 0xFFFF, 0x0000 };

    auto const shifted = collate_for_tests(
        cps, cps + 2, boost::text::variable_weighting::shifted);

    EXPECT_EQ(shifted.size(), 12);
    EXPECT_TRUE(boost::algorithm::equal(shifted.begin(), shifted.end(), ces_shifted, ces_shifted + 12))
        << "from:     " << ce_dumper(cps)
        << "expected: " << ce_dumper(ces_shifted)
        << "got:      " << ce_dumper(shifted);
}

TEST(collation, verbatim_131_427)
{
    uint32_t const cps[2] = { 0x1D760, 0x0062 };

    // 1D760 0062;	
    // (𝝠) MATHEMATICAL SANS-SERIF BOLD CAPITAL LAMDA	[202F 1CC6 | 0020 0020 | 000B 0002 |]
    uint32_t const ces_non_ignorable[9] = { 0x202F, 0x1CC6, 0x0000, 0x0020, 0x0020, 0x0000, 0x000B, 0x0002, 0x0000 };

    auto const non_ignorable = collate_for_tests(
        cps, cps + 2, boost::text::variable_weighting::non_ignorable);

    EXPECT_EQ(non_ignorable.size(), 9);
    EXPECT_TRUE(boost::algorithm::equal(non_ignorable.begin(), non_ignorable.end(), ces_non_ignorable, ces_non_ignorable + 9))
        << "from:     " << ce_dumper(cps)
        << "expected: " << ce_dumper(ces_non_ignorable)
        << "got:      " << ce_dumper(non_ignorable);

    // 1D760 0062;	
    // (𝝠) MATHEMATICAL SANS-SERIF BOLD CAPITAL LAMDA	[202F 1CC6 | 0020 0020 | 000B 0002 | FFFF FFFF |]
    uint32_t const ces_shifted[12] = { 0x202F, 0x1CC6, 0x0000, 0x0020, 0x0020, 0x0000, 0x000B, 0x0002, 0x0000, 0xFFFF, 0xFFFF, 0x0000 };

    auto const shifted = collate_for_tests(
        cps, cps + 2, boost::text::variable_weighting::shifted);

    EXPECT_EQ(shifted.size(), 12);
    EXPECT_TRUE(boost::algorithm::equal(shifted.begin(), shifted.end(), ces_shifted, ces_shifted + 12))
        << "from:     " << ce_dumper(cps)
        << "expected: " << ce_dumper(ces_shifted)
        << "got:      " << ce_dumper(shifted);
}

TEST(collation, verbatim_131_428)
{
    uint32_t const cps[2] = { 0x1D79A, 0x0062 };

    // 1D79A 0062;	
    // (𝞚) MATHEMATICAL SANS-SERIF BOLD ITALIC CAPITAL LAMDA	[202F 1CC6 | 0020 0020 | 000B 0002 |]
    uint32_t const ces_non_ignorable[9] = { 0x202F, 0x1CC6, 0x0000, 0x0020, 0x0020, 0x0000, 0x000B, 0x0002, 0x0000 };

    auto const non_ignorable = collate_for_tests(
        cps, cps + 2, boost::text::variable_weighting::non_ignorable);

    EXPECT_EQ(non_ignorable.size(), 9);
    EXPECT_TRUE(boost::algorithm::equal(non_ignorable.begin(), non_ignorable.end(), ces_non_ignorable, ces_non_ignorable + 9))
        << "from:     " << ce_dumper(cps)
        << "expected: " << ce_dumper(ces_non_ignorable)
        << "got:      " << ce_dumper(non_ignorable);

    // 1D79A 0062;	
    // (𝞚) MATHEMATICAL SANS-SERIF BOLD ITALIC CAPITAL LAMDA	[202F 1CC6 | 0020 0020 | 000B 0002 | FFFF FFFF |]
    uint32_t const ces_shifted[12] = { 0x202F, 0x1CC6, 0x0000, 0x0020, 0x0020, 0x0000, 0x000B, 0x0002, 0x0000, 0xFFFF, 0xFFFF, 0x0000 };

    auto const shifted = collate_for_tests(
        cps, cps + 2, boost::text::variable_weighting::shifted);

    EXPECT_EQ(shifted.size(), 12);
    EXPECT_TRUE(boost::algorithm::equal(shifted.begin(), shifted.end(), ces_shifted, ces_shifted + 12))
        << "from:     " << ce_dumper(cps)
        << "expected: " << ce_dumper(ces_shifted)
        << "got:      " << ce_dumper(shifted);
}

TEST(collation, verbatim_131_429)
{
    uint32_t const cps[2] = { 0x1D27, 0x0021 };

    // 1D27 0021;	
    // (ᴧ) GREEK LETTER SMALL CAPITAL LAMDA	[2030 0261 | 0020 0020 | 0002 0002 |]
    uint32_t const ces_non_ignorable[9] = { 0x2030, 0x0261, 0x0000, 0x0020, 0x0020, 0x0000, 0x0002, 0x0002, 0x0000 };

    auto const non_ignorable = collate_for_tests(
        cps, cps + 2, boost::text::variable_weighting::non_ignorable);

    EXPECT_EQ(non_ignorable.size(), 9);
    EXPECT_TRUE(boost::algorithm::equal(non_ignorable.begin(), non_ignorable.end(), ces_non_ignorable, ces_non_ignorable + 9))
        << "from:     " << ce_dumper(cps)
        << "expected: " << ce_dumper(ces_non_ignorable)
        << "got:      " << ce_dumper(non_ignorable);

    // 1D27 0021;	
    // (ᴧ) GREEK LETTER SMALL CAPITAL LAMDA	[2030 | 0020 | 0002 | FFFF 0261 |]
    uint32_t const ces_shifted[9] = { 0x2030, 0x0000, 0x0020, 0x0000, 0x0002, 0x0000, 0xFFFF, 0x0261, 0x0000 };

    auto const shifted = collate_for_tests(
        cps, cps + 2, boost::text::variable_weighting::shifted);

    EXPECT_EQ(shifted.size(), 9);
    EXPECT_TRUE(boost::algorithm::equal(shifted.begin(), shifted.end(), ces_shifted, ces_shifted + 9))
        << "from:     " << ce_dumper(cps)
        << "expected: " << ce_dumper(ces_shifted)
        << "got:      " << ce_dumper(shifted);
}

TEST(collation, verbatim_131_430)
{
    uint32_t const cps[2] = { 0x1D27, 0x003F };

    // 1D27 003F;	
    // (ᴧ) GREEK LETTER SMALL CAPITAL LAMDA	[2030 0267 | 0020 0020 | 0002 0002 |]
    uint32_t const ces_non_ignorable[9] = { 0x2030, 0x0267, 0x0000, 0x0020, 0x0020, 0x0000, 0x0002, 0x0002, 0x0000 };

    auto const non_ignorable = collate_for_tests(
        cps, cps + 2, boost::text::variable_weighting::non_ignorable);

    EXPECT_EQ(non_ignorable.size(), 9);
    EXPECT_TRUE(boost::algorithm::equal(non_ignorable.begin(), non_ignorable.end(), ces_non_ignorable, ces_non_ignorable + 9))
        << "from:     " << ce_dumper(cps)
        << "expected: " << ce_dumper(ces_non_ignorable)
        << "got:      " << ce_dumper(non_ignorable);

    // 1D27 003F;	
    // (ᴧ) GREEK LETTER SMALL CAPITAL LAMDA	[2030 | 0020 | 0002 | FFFF 0267 |]
    uint32_t const ces_shifted[9] = { 0x2030, 0x0000, 0x0020, 0x0000, 0x0002, 0x0000, 0xFFFF, 0x0267, 0x0000 };

    auto const shifted = collate_for_tests(
        cps, cps + 2, boost::text::variable_weighting::shifted);

    EXPECT_EQ(shifted.size(), 9);
    EXPECT_TRUE(boost::algorithm::equal(shifted.begin(), shifted.end(), ces_shifted, ces_shifted + 9))
        << "from:     " << ce_dumper(cps)
        << "expected: " << ce_dumper(ces_shifted)
        << "got:      " << ce_dumper(shifted);
}

TEST(collation, verbatim_131_431)
{
    uint32_t const cps[2] = { 0x1D27, 0x0061 };

    // 1D27 0061;	
    // (ᴧ) GREEK LETTER SMALL CAPITAL LAMDA	[2030 1CAD | 0020 0020 | 0002 0002 |]
    uint32_t const ces_non_ignorable[9] = { 0x2030, 0x1CAD, 0x0000, 0x0020, 0x0020, 0x0000, 0x0002, 0x0002, 0x0000 };

    auto const non_ignorable = collate_for_tests(
        cps, cps + 2, boost::text::variable_weighting::non_ignorable);

    EXPECT_EQ(non_ignorable.size(), 9);
    EXPECT_TRUE(boost::algorithm::equal(non_ignorable.begin(), non_ignorable.end(), ces_non_ignorable, ces_non_ignorable + 9))
        << "from:     " << ce_dumper(cps)
        << "expected: " << ce_dumper(ces_non_ignorable)
        << "got:      " << ce_dumper(non_ignorable);

    // 1D27 0061;	
    // (ᴧ) GREEK LETTER SMALL CAPITAL LAMDA	[2030 1CAD | 0020 0020 | 0002 0002 | FFFF FFFF |]
    uint32_t const ces_shifted[12] = { 0x2030, 0x1CAD, 0x0000, 0x0020, 0x0020, 0x0000, 0x0002, 0x0002, 0x0000, 0xFFFF, 0xFFFF, 0x0000 };

    auto const shifted = collate_for_tests(
        cps, cps + 2, boost::text::variable_weighting::shifted);

    EXPECT_EQ(shifted.size(), 12);
    EXPECT_TRUE(boost::algorithm::equal(shifted.begin(), shifted.end(), ces_shifted, ces_shifted + 12))
        << "from:     " << ce_dumper(cps)
        << "expected: " << ce_dumper(ces_shifted)
        << "got:      " << ce_dumper(shifted);
}

TEST(collation, verbatim_131_432)
{
    uint32_t const cps[2] = { 0x1D27, 0x0041 };

    // 1D27 0041;	
    // (ᴧ) GREEK LETTER SMALL CAPITAL LAMDA	[2030 1CAD | 0020 0020 | 0002 0008 |]
    uint32_t const ces_non_ignorable[9] = { 0x2030, 0x1CAD, 0x0000, 0x0020, 0x0020, 0x0000, 0x0002, 0x0008, 0x0000 };

    auto const non_ignorable = collate_for_tests(
        cps, cps + 2, boost::text::variable_weighting::non_ignorable);

    EXPECT_EQ(non_ignorable.size(), 9);
    EXPECT_TRUE(boost::algorithm::equal(non_ignorable.begin(), non_ignorable.end(), ces_non_ignorable, ces_non_ignorable + 9))
        << "from:     " << ce_dumper(cps)
        << "expected: " << ce_dumper(ces_non_ignorable)
        << "got:      " << ce_dumper(non_ignorable);

    // 1D27 0041;	
    // (ᴧ) GREEK LETTER SMALL CAPITAL LAMDA	[2030 1CAD | 0020 0020 | 0002 0008 | FFFF FFFF |]
    uint32_t const ces_shifted[12] = { 0x2030, 0x1CAD, 0x0000, 0x0020, 0x0020, 0x0000, 0x0002, 0x0008, 0x0000, 0xFFFF, 0xFFFF, 0x0000 };

    auto const shifted = collate_for_tests(
        cps, cps + 2, boost::text::variable_weighting::shifted);

    EXPECT_EQ(shifted.size(), 12);
    EXPECT_TRUE(boost::algorithm::equal(shifted.begin(), shifted.end(), ces_shifted, ces_shifted + 12))
        << "from:     " << ce_dumper(cps)
        << "expected: " << ce_dumper(ces_shifted)
        << "got:      " << ce_dumper(shifted);
}

TEST(collation, verbatim_131_433)
{
    uint32_t const cps[2] = { 0x1D27, 0x0062 };

    // 1D27 0062;	
    // (ᴧ) GREEK LETTER SMALL CAPITAL LAMDA	[2030 1CC6 | 0020 0020 | 0002 0002 |]
    uint32_t const ces_non_ignorable[9] = { 0x2030, 0x1CC6, 0x0000, 0x0020, 0x0020, 0x0000, 0x0002, 0x0002, 0x0000 };

    auto const non_ignorable = collate_for_tests(
        cps, cps + 2, boost::text::variable_weighting::non_ignorable);

    EXPECT_EQ(non_ignorable.size(), 9);
    EXPECT_TRUE(boost::algorithm::equal(non_ignorable.begin(), non_ignorable.end(), ces_non_ignorable, ces_non_ignorable + 9))
        << "from:     " << ce_dumper(cps)
        << "expected: " << ce_dumper(ces_non_ignorable)
        << "got:      " << ce_dumper(non_ignorable);

    // 1D27 0062;	
    // (ᴧ) GREEK LETTER SMALL CAPITAL LAMDA	[2030 1CC6 | 0020 0020 | 0002 0002 | FFFF FFFF |]
    uint32_t const ces_shifted[12] = { 0x2030, 0x1CC6, 0x0000, 0x0020, 0x0020, 0x0000, 0x0002, 0x0002, 0x0000, 0xFFFF, 0xFFFF, 0x0000 };

    auto const shifted = collate_for_tests(
        cps, cps + 2, boost::text::variable_weighting::shifted);

    EXPECT_EQ(shifted.size(), 12);
    EXPECT_TRUE(boost::algorithm::equal(shifted.begin(), shifted.end(), ces_shifted, ces_shifted + 12))
        << "from:     " << ce_dumper(cps)
        << "expected: " << ce_dumper(ces_shifted)
        << "got:      " << ce_dumper(shifted);
}

TEST(collation, verbatim_131_434)
{
    uint32_t const cps[2] = { 0x03BC, 0x0021 };

    // 03BC 0021;	
    // (μ) GREEK SMALL LETTER MU	[2031 0261 | 0020 0020 | 0002 0002 |]
    uint32_t const ces_non_ignorable[9] = { 0x2031, 0x0261, 0x0000, 0x0020, 0x0020, 0x0000, 0x0002, 0x0002, 0x0000 };

    auto const non_ignorable = collate_for_tests(
        cps, cps + 2, boost::text::variable_weighting::non_ignorable);

    EXPECT_EQ(non_ignorable.size(), 9);
    EXPECT_TRUE(boost::algorithm::equal(non_ignorable.begin(), non_ignorable.end(), ces_non_ignorable, ces_non_ignorable + 9))
        << "from:     " << ce_dumper(cps)
        << "expected: " << ce_dumper(ces_non_ignorable)
        << "got:      " << ce_dumper(non_ignorable);

    // 03BC 0021;	
    // (μ) GREEK SMALL LETTER MU	[2031 | 0020 | 0002 | FFFF 0261 |]
    uint32_t const ces_shifted[9] = { 0x2031, 0x0000, 0x0020, 0x0000, 0x0002, 0x0000, 0xFFFF, 0x0261, 0x0000 };

    auto const shifted = collate_for_tests(
        cps, cps + 2, boost::text::variable_weighting::shifted);

    EXPECT_EQ(shifted.size(), 9);
    EXPECT_TRUE(boost::algorithm::equal(shifted.begin(), shifted.end(), ces_shifted, ces_shifted + 9))
        << "from:     " << ce_dumper(cps)
        << "expected: " << ce_dumper(ces_shifted)
        << "got:      " << ce_dumper(shifted);
}

TEST(collation, verbatim_131_435)
{
    uint32_t const cps[2] = { 0x00B5, 0x0021 };

    // 00B5 0021;	
    // (µ) MICRO SIGN	[2031 0261 | 0020 0020 | 0004 0002 |]
    uint32_t const ces_non_ignorable[9] = { 0x2031, 0x0261, 0x0000, 0x0020, 0x0020, 0x0000, 0x0004, 0x0002, 0x0000 };

    auto const non_ignorable = collate_for_tests(
        cps, cps + 2, boost::text::variable_weighting::non_ignorable);

    EXPECT_EQ(non_ignorable.size(), 9);
    EXPECT_TRUE(boost::algorithm::equal(non_ignorable.begin(), non_ignorable.end(), ces_non_ignorable, ces_non_ignorable + 9))
        << "from:     " << ce_dumper(cps)
        << "expected: " << ce_dumper(ces_non_ignorable)
        << "got:      " << ce_dumper(non_ignorable);

    // 00B5 0021;	
    // (µ) MICRO SIGN	[2031 | 0020 | 0004 | FFFF 0261 |]
    uint32_t const ces_shifted[9] = { 0x2031, 0x0000, 0x0020, 0x0000, 0x0004, 0x0000, 0xFFFF, 0x0261, 0x0000 };

    auto const shifted = collate_for_tests(
        cps, cps + 2, boost::text::variable_weighting::shifted);

    EXPECT_EQ(shifted.size(), 9);
    EXPECT_TRUE(boost::algorithm::equal(shifted.begin(), shifted.end(), ces_shifted, ces_shifted + 9))
        << "from:     " << ce_dumper(cps)
        << "expected: " << ce_dumper(ces_shifted)
        << "got:      " << ce_dumper(shifted);
}

TEST(collation, verbatim_131_436)
{
    uint32_t const cps[2] = { 0x1D6CD, 0x0021 };

    // 1D6CD 0021;	
    // (𝛍) MATHEMATICAL BOLD SMALL MU	[2031 0261 | 0020 0020 | 0005 0002 |]
    uint32_t const ces_non_ignorable[9] = { 0x2031, 0x0261, 0x0000, 0x0020, 0x0020, 0x0000, 0x0005, 0x0002, 0x0000 };

    auto const non_ignorable = collate_for_tests(
        cps, cps + 2, boost::text::variable_weighting::non_ignorable);

    EXPECT_EQ(non_ignorable.size(), 9);
    EXPECT_TRUE(boost::algorithm::equal(non_ignorable.begin(), non_ignorable.end(), ces_non_ignorable, ces_non_ignorable + 9))
        << "from:     " << ce_dumper(cps)
        << "expected: " << ce_dumper(ces_non_ignorable)
        << "got:      " << ce_dumper(non_ignorable);

    // 1D6CD 0021;	
    // (𝛍) MATHEMATICAL BOLD SMALL MU	[2031 | 0020 | 0005 | FFFF 0261 |]
    uint32_t const ces_shifted[9] = { 0x2031, 0x0000, 0x0020, 0x0000, 0x0005, 0x0000, 0xFFFF, 0x0261, 0x0000 };

    auto const shifted = collate_for_tests(
        cps, cps + 2, boost::text::variable_weighting::shifted);

    EXPECT_EQ(shifted.size(), 9);
    EXPECT_TRUE(boost::algorithm::equal(shifted.begin(), shifted.end(), ces_shifted, ces_shifted + 9))
        << "from:     " << ce_dumper(cps)
        << "expected: " << ce_dumper(ces_shifted)
        << "got:      " << ce_dumper(shifted);
}

TEST(collation, verbatim_131_437)
{
    uint32_t const cps[2] = { 0x1D707, 0x0021 };

    // 1D707 0021;	
    // (𝜇) MATHEMATICAL ITALIC SMALL MU	[2031 0261 | 0020 0020 | 0005 0002 |]
    uint32_t const ces_non_ignorable[9] = { 0x2031, 0x0261, 0x0000, 0x0020, 0x0020, 0x0000, 0x0005, 0x0002, 0x0000 };

    auto const non_ignorable = collate_for_tests(
        cps, cps + 2, boost::text::variable_weighting::non_ignorable);

    EXPECT_EQ(non_ignorable.size(), 9);
    EXPECT_TRUE(boost::algorithm::equal(non_ignorable.begin(), non_ignorable.end(), ces_non_ignorable, ces_non_ignorable + 9))
        << "from:     " << ce_dumper(cps)
        << "expected: " << ce_dumper(ces_non_ignorable)
        << "got:      " << ce_dumper(non_ignorable);

    // 1D707 0021;	
    // (𝜇) MATHEMATICAL ITALIC SMALL MU	[2031 | 0020 | 0005 | FFFF 0261 |]
    uint32_t const ces_shifted[9] = { 0x2031, 0x0000, 0x0020, 0x0000, 0x0005, 0x0000, 0xFFFF, 0x0261, 0x0000 };

    auto const shifted = collate_for_tests(
        cps, cps + 2, boost::text::variable_weighting::shifted);

    EXPECT_EQ(shifted.size(), 9);
    EXPECT_TRUE(boost::algorithm::equal(shifted.begin(), shifted.end(), ces_shifted, ces_shifted + 9))
        << "from:     " << ce_dumper(cps)
        << "expected: " << ce_dumper(ces_shifted)
        << "got:      " << ce_dumper(shifted);
}

TEST(collation, verbatim_131_438)
{
    uint32_t const cps[2] = { 0x1D741, 0x0021 };

    // 1D741 0021;	
    // (𝝁) MATHEMATICAL BOLD ITALIC SMALL MU	[2031 0261 | 0020 0020 | 0005 0002 |]
    uint32_t const ces_non_ignorable[9] = { 0x2031, 0x0261, 0x0000, 0x0020, 0x0020, 0x0000, 0x0005, 0x0002, 0x0000 };

    auto const non_ignorable = collate_for_tests(
        cps, cps + 2, boost::text::variable_weighting::non_ignorable);

    EXPECT_EQ(non_ignorable.size(), 9);
    EXPECT_TRUE(boost::algorithm::equal(non_ignorable.begin(), non_ignorable.end(), ces_non_ignorable, ces_non_ignorable + 9))
        << "from:     " << ce_dumper(cps)
        << "expected: " << ce_dumper(ces_non_ignorable)
        << "got:      " << ce_dumper(non_ignorable);

    // 1D741 0021;	
    // (𝝁) MATHEMATICAL BOLD ITALIC SMALL MU	[2031 | 0020 | 0005 | FFFF 0261 |]
    uint32_t const ces_shifted[9] = { 0x2031, 0x0000, 0x0020, 0x0000, 0x0005, 0x0000, 0xFFFF, 0x0261, 0x0000 };

    auto const shifted = collate_for_tests(
        cps, cps + 2, boost::text::variable_weighting::shifted);

    EXPECT_EQ(shifted.size(), 9);
    EXPECT_TRUE(boost::algorithm::equal(shifted.begin(), shifted.end(), ces_shifted, ces_shifted + 9))
        << "from:     " << ce_dumper(cps)
        << "expected: " << ce_dumper(ces_shifted)
        << "got:      " << ce_dumper(shifted);
}

TEST(collation, verbatim_131_439)
{
    uint32_t const cps[2] = { 0x1D77B, 0x0021 };

    // 1D77B 0021;	
    // (𝝻) MATHEMATICAL SANS-SERIF BOLD SMALL MU	[2031 0261 | 0020 0020 | 0005 0002 |]
    uint32_t const ces_non_ignorable[9] = { 0x2031, 0x0261, 0x0000, 0x0020, 0x0020, 0x0000, 0x0005, 0x0002, 0x0000 };

    auto const non_ignorable = collate_for_tests(
        cps, cps + 2, boost::text::variable_weighting::non_ignorable);

    EXPECT_EQ(non_ignorable.size(), 9);
    EXPECT_TRUE(boost::algorithm::equal(non_ignorable.begin(), non_ignorable.end(), ces_non_ignorable, ces_non_ignorable + 9))
        << "from:     " << ce_dumper(cps)
        << "expected: " << ce_dumper(ces_non_ignorable)
        << "got:      " << ce_dumper(non_ignorable);

    // 1D77B 0021;	
    // (𝝻) MATHEMATICAL SANS-SERIF BOLD SMALL MU	[2031 | 0020 | 0005 | FFFF 0261 |]
    uint32_t const ces_shifted[9] = { 0x2031, 0x0000, 0x0020, 0x0000, 0x0005, 0x0000, 0xFFFF, 0x0261, 0x0000 };

    auto const shifted = collate_for_tests(
        cps, cps + 2, boost::text::variable_weighting::shifted);

    EXPECT_EQ(shifted.size(), 9);
    EXPECT_TRUE(boost::algorithm::equal(shifted.begin(), shifted.end(), ces_shifted, ces_shifted + 9))
        << "from:     " << ce_dumper(cps)
        << "expected: " << ce_dumper(ces_shifted)
        << "got:      " << ce_dumper(shifted);
}

TEST(collation, verbatim_131_440)
{
    uint32_t const cps[2] = { 0x1D7B5, 0x0021 };

    // 1D7B5 0021;	
    // (𝞵) MATHEMATICAL SANS-SERIF BOLD ITALIC SMALL MU	[2031 0261 | 0020 0020 | 0005 0002 |]
    uint32_t const ces_non_ignorable[9] = { 0x2031, 0x0261, 0x0000, 0x0020, 0x0020, 0x0000, 0x0005, 0x0002, 0x0000 };

    auto const non_ignorable = collate_for_tests(
        cps, cps + 2, boost::text::variable_weighting::non_ignorable);

    EXPECT_EQ(non_ignorable.size(), 9);
    EXPECT_TRUE(boost::algorithm::equal(non_ignorable.begin(), non_ignorable.end(), ces_non_ignorable, ces_non_ignorable + 9))
        << "from:     " << ce_dumper(cps)
        << "expected: " << ce_dumper(ces_non_ignorable)
        << "got:      " << ce_dumper(non_ignorable);

    // 1D7B5 0021;	
    // (𝞵) MATHEMATICAL SANS-SERIF BOLD ITALIC SMALL MU	[2031 | 0020 | 0005 | FFFF 0261 |]
    uint32_t const ces_shifted[9] = { 0x2031, 0x0000, 0x0020, 0x0000, 0x0005, 0x0000, 0xFFFF, 0x0261, 0x0000 };

    auto const shifted = collate_for_tests(
        cps, cps + 2, boost::text::variable_weighting::shifted);

    EXPECT_EQ(shifted.size(), 9);
    EXPECT_TRUE(boost::algorithm::equal(shifted.begin(), shifted.end(), ces_shifted, ces_shifted + 9))
        << "from:     " << ce_dumper(cps)
        << "expected: " << ce_dumper(ces_shifted)
        << "got:      " << ce_dumper(shifted);
}

TEST(collation, verbatim_131_441)
{
    uint32_t const cps[2] = { 0x039C, 0x0021 };

    // 039C 0021;	
    // (Μ) GREEK CAPITAL LETTER MU	[2031 0261 | 0020 0020 | 0008 0002 |]
    uint32_t const ces_non_ignorable[9] = { 0x2031, 0x0261, 0x0000, 0x0020, 0x0020, 0x0000, 0x0008, 0x0002, 0x0000 };

    auto const non_ignorable = collate_for_tests(
        cps, cps + 2, boost::text::variable_weighting::non_ignorable);

    EXPECT_EQ(non_ignorable.size(), 9);
    EXPECT_TRUE(boost::algorithm::equal(non_ignorable.begin(), non_ignorable.end(), ces_non_ignorable, ces_non_ignorable + 9))
        << "from:     " << ce_dumper(cps)
        << "expected: " << ce_dumper(ces_non_ignorable)
        << "got:      " << ce_dumper(non_ignorable);

    // 039C 0021;	
    // (Μ) GREEK CAPITAL LETTER MU	[2031 | 0020 | 0008 | FFFF 0261 |]
    uint32_t const ces_shifted[9] = { 0x2031, 0x0000, 0x0020, 0x0000, 0x0008, 0x0000, 0xFFFF, 0x0261, 0x0000 };

    auto const shifted = collate_for_tests(
        cps, cps + 2, boost::text::variable_weighting::shifted);

    EXPECT_EQ(shifted.size(), 9);
    EXPECT_TRUE(boost::algorithm::equal(shifted.begin(), shifted.end(), ces_shifted, ces_shifted + 9))
        << "from:     " << ce_dumper(cps)
        << "expected: " << ce_dumper(ces_shifted)
        << "got:      " << ce_dumper(shifted);
}

TEST(collation, verbatim_131_442)
{
    uint32_t const cps[2] = { 0x1D6B3, 0x0021 };

    // 1D6B3 0021;	
    // (𝚳) MATHEMATICAL BOLD CAPITAL MU	[2031 0261 | 0020 0020 | 000B 0002 |]
    uint32_t const ces_non_ignorable[9] = { 0x2031, 0x0261, 0x0000, 0x0020, 0x0020, 0x0000, 0x000B, 0x0002, 0x0000 };

    auto const non_ignorable = collate_for_tests(
        cps, cps + 2, boost::text::variable_weighting::non_ignorable);

    EXPECT_EQ(non_ignorable.size(), 9);
    EXPECT_TRUE(boost::algorithm::equal(non_ignorable.begin(), non_ignorable.end(), ces_non_ignorable, ces_non_ignorable + 9))
        << "from:     " << ce_dumper(cps)
        << "expected: " << ce_dumper(ces_non_ignorable)
        << "got:      " << ce_dumper(non_ignorable);

    // 1D6B3 0021;	
    // (𝚳) MATHEMATICAL BOLD CAPITAL MU	[2031 | 0020 | 000B | FFFF 0261 |]
    uint32_t const ces_shifted[9] = { 0x2031, 0x0000, 0x0020, 0x0000, 0x000B, 0x0000, 0xFFFF, 0x0261, 0x0000 };

    auto const shifted = collate_for_tests(
        cps, cps + 2, boost::text::variable_weighting::shifted);

    EXPECT_EQ(shifted.size(), 9);
    EXPECT_TRUE(boost::algorithm::equal(shifted.begin(), shifted.end(), ces_shifted, ces_shifted + 9))
        << "from:     " << ce_dumper(cps)
        << "expected: " << ce_dumper(ces_shifted)
        << "got:      " << ce_dumper(shifted);
}

TEST(collation, verbatim_131_443)
{
    uint32_t const cps[2] = { 0x1D6ED, 0x0021 };

    // 1D6ED 0021;	
    // (𝛭) MATHEMATICAL ITALIC CAPITAL MU	[2031 0261 | 0020 0020 | 000B 0002 |]
    uint32_t const ces_non_ignorable[9] = { 0x2031, 0x0261, 0x0000, 0x0020, 0x0020, 0x0000, 0x000B, 0x0002, 0x0000 };

    auto const non_ignorable = collate_for_tests(
        cps, cps + 2, boost::text::variable_weighting::non_ignorable);

    EXPECT_EQ(non_ignorable.size(), 9);
    EXPECT_TRUE(boost::algorithm::equal(non_ignorable.begin(), non_ignorable.end(), ces_non_ignorable, ces_non_ignorable + 9))
        << "from:     " << ce_dumper(cps)
        << "expected: " << ce_dumper(ces_non_ignorable)
        << "got:      " << ce_dumper(non_ignorable);

    // 1D6ED 0021;	
    // (𝛭) MATHEMATICAL ITALIC CAPITAL MU	[2031 | 0020 | 000B | FFFF 0261 |]
    uint32_t const ces_shifted[9] = { 0x2031, 0x0000, 0x0020, 0x0000, 0x000B, 0x0000, 0xFFFF, 0x0261, 0x0000 };

    auto const shifted = collate_for_tests(
        cps, cps + 2, boost::text::variable_weighting::shifted);

    EXPECT_EQ(shifted.size(), 9);
    EXPECT_TRUE(boost::algorithm::equal(shifted.begin(), shifted.end(), ces_shifted, ces_shifted + 9))
        << "from:     " << ce_dumper(cps)
        << "expected: " << ce_dumper(ces_shifted)
        << "got:      " << ce_dumper(shifted);
}

TEST(collation, verbatim_131_444)
{
    uint32_t const cps[2] = { 0x1D727, 0x0021 };

    // 1D727 0021;	
    // (𝜧) MATHEMATICAL BOLD ITALIC CAPITAL MU	[2031 0261 | 0020 0020 | 000B 0002 |]
    uint32_t const ces_non_ignorable[9] = { 0x2031, 0x0261, 0x0000, 0x0020, 0x0020, 0x0000, 0x000B, 0x0002, 0x0000 };

    auto const non_ignorable = collate_for_tests(
        cps, cps + 2, boost::text::variable_weighting::non_ignorable);

    EXPECT_EQ(non_ignorable.size(), 9);
    EXPECT_TRUE(boost::algorithm::equal(non_ignorable.begin(), non_ignorable.end(), ces_non_ignorable, ces_non_ignorable + 9))
        << "from:     " << ce_dumper(cps)
        << "expected: " << ce_dumper(ces_non_ignorable)
        << "got:      " << ce_dumper(non_ignorable);

    // 1D727 0021;	
    // (𝜧) MATHEMATICAL BOLD ITALIC CAPITAL MU	[2031 | 0020 | 000B | FFFF 0261 |]
    uint32_t const ces_shifted[9] = { 0x2031, 0x0000, 0x0020, 0x0000, 0x000B, 0x0000, 0xFFFF, 0x0261, 0x0000 };

    auto const shifted = collate_for_tests(
        cps, cps + 2, boost::text::variable_weighting::shifted);

    EXPECT_EQ(shifted.size(), 9);
    EXPECT_TRUE(boost::algorithm::equal(shifted.begin(), shifted.end(), ces_shifted, ces_shifted + 9))
        << "from:     " << ce_dumper(cps)
        << "expected: " << ce_dumper(ces_shifted)
        << "got:      " << ce_dumper(shifted);
}

TEST(collation, verbatim_131_445)
{
    uint32_t const cps[2] = { 0x1D761, 0x0021 };

    // 1D761 0021;	
    // (𝝡) MATHEMATICAL SANS-SERIF BOLD CAPITAL MU	[2031 0261 | 0020 0020 | 000B 0002 |]
    uint32_t const ces_non_ignorable[9] = { 0x2031, 0x0261, 0x0000, 0x0020, 0x0020, 0x0000, 0x000B, 0x0002, 0x0000 };

    auto const non_ignorable = collate_for_tests(
        cps, cps + 2, boost::text::variable_weighting::non_ignorable);

    EXPECT_EQ(non_ignorable.size(), 9);
    EXPECT_TRUE(boost::algorithm::equal(non_ignorable.begin(), non_ignorable.end(), ces_non_ignorable, ces_non_ignorable + 9))
        << "from:     " << ce_dumper(cps)
        << "expected: " << ce_dumper(ces_non_ignorable)
        << "got:      " << ce_dumper(non_ignorable);

    // 1D761 0021;	
    // (𝝡) MATHEMATICAL SANS-SERIF BOLD CAPITAL MU	[2031 | 0020 | 000B | FFFF 0261 |]
    uint32_t const ces_shifted[9] = { 0x2031, 0x0000, 0x0020, 0x0000, 0x000B, 0x0000, 0xFFFF, 0x0261, 0x0000 };

    auto const shifted = collate_for_tests(
        cps, cps + 2, boost::text::variable_weighting::shifted);

    EXPECT_EQ(shifted.size(), 9);
    EXPECT_TRUE(boost::algorithm::equal(shifted.begin(), shifted.end(), ces_shifted, ces_shifted + 9))
        << "from:     " << ce_dumper(cps)
        << "expected: " << ce_dumper(ces_shifted)
        << "got:      " << ce_dumper(shifted);
}

TEST(collation, verbatim_131_446)
{
    uint32_t const cps[2] = { 0x1D79B, 0x0021 };

    // 1D79B 0021;	
    // (𝞛) MATHEMATICAL SANS-SERIF BOLD ITALIC CAPITAL MU	[2031 0261 | 0020 0020 | 000B 0002 |]
    uint32_t const ces_non_ignorable[9] = { 0x2031, 0x0261, 0x0000, 0x0020, 0x0020, 0x0000, 0x000B, 0x0002, 0x0000 };

    auto const non_ignorable = collate_for_tests(
        cps, cps + 2, boost::text::variable_weighting::non_ignorable);

    EXPECT_EQ(non_ignorable.size(), 9);
    EXPECT_TRUE(boost::algorithm::equal(non_ignorable.begin(), non_ignorable.end(), ces_non_ignorable, ces_non_ignorable + 9))
        << "from:     " << ce_dumper(cps)
        << "expected: " << ce_dumper(ces_non_ignorable)
        << "got:      " << ce_dumper(non_ignorable);

    // 1D79B 0021;	
    // (𝞛) MATHEMATICAL SANS-SERIF BOLD ITALIC CAPITAL MU	[2031 | 0020 | 000B | FFFF 0261 |]
    uint32_t const ces_shifted[9] = { 0x2031, 0x0000, 0x0020, 0x0000, 0x000B, 0x0000, 0xFFFF, 0x0261, 0x0000 };

    auto const shifted = collate_for_tests(
        cps, cps + 2, boost::text::variable_weighting::shifted);

    EXPECT_EQ(shifted.size(), 9);
    EXPECT_TRUE(boost::algorithm::equal(shifted.begin(), shifted.end(), ces_shifted, ces_shifted + 9))
        << "from:     " << ce_dumper(cps)
        << "expected: " << ce_dumper(ces_shifted)
        << "got:      " << ce_dumper(shifted);
}

TEST(collation, verbatim_131_447)
{
    uint32_t const cps[2] = { 0x03BC, 0x003F };

    // 03BC 003F;	
    // (μ) GREEK SMALL LETTER MU	[2031 0267 | 0020 0020 | 0002 0002 |]
    uint32_t const ces_non_ignorable[9] = { 0x2031, 0x0267, 0x0000, 0x0020, 0x0020, 0x0000, 0x0002, 0x0002, 0x0000 };

    auto const non_ignorable = collate_for_tests(
        cps, cps + 2, boost::text::variable_weighting::non_ignorable);

    EXPECT_EQ(non_ignorable.size(), 9);
    EXPECT_TRUE(boost::algorithm::equal(non_ignorable.begin(), non_ignorable.end(), ces_non_ignorable, ces_non_ignorable + 9))
        << "from:     " << ce_dumper(cps)
        << "expected: " << ce_dumper(ces_non_ignorable)
        << "got:      " << ce_dumper(non_ignorable);

    // 03BC 003F;	
    // (μ) GREEK SMALL LETTER MU	[2031 | 0020 | 0002 | FFFF 0267 |]
    uint32_t const ces_shifted[9] = { 0x2031, 0x0000, 0x0020, 0x0000, 0x0002, 0x0000, 0xFFFF, 0x0267, 0x0000 };

    auto const shifted = collate_for_tests(
        cps, cps + 2, boost::text::variable_weighting::shifted);

    EXPECT_EQ(shifted.size(), 9);
    EXPECT_TRUE(boost::algorithm::equal(shifted.begin(), shifted.end(), ces_shifted, ces_shifted + 9))
        << "from:     " << ce_dumper(cps)
        << "expected: " << ce_dumper(ces_shifted)
        << "got:      " << ce_dumper(shifted);
}

TEST(collation, verbatim_131_448)
{
    uint32_t const cps[2] = { 0x00B5, 0x003F };

    // 00B5 003F;	
    // (µ) MICRO SIGN	[2031 0267 | 0020 0020 | 0004 0002 |]
    uint32_t const ces_non_ignorable[9] = { 0x2031, 0x0267, 0x0000, 0x0020, 0x0020, 0x0000, 0x0004, 0x0002, 0x0000 };

    auto const non_ignorable = collate_for_tests(
        cps, cps + 2, boost::text::variable_weighting::non_ignorable);

    EXPECT_EQ(non_ignorable.size(), 9);
    EXPECT_TRUE(boost::algorithm::equal(non_ignorable.begin(), non_ignorable.end(), ces_non_ignorable, ces_non_ignorable + 9))
        << "from:     " << ce_dumper(cps)
        << "expected: " << ce_dumper(ces_non_ignorable)
        << "got:      " << ce_dumper(non_ignorable);

    // 00B5 003F;	
    // (µ) MICRO SIGN	[2031 | 0020 | 0004 | FFFF 0267 |]
    uint32_t const ces_shifted[9] = { 0x2031, 0x0000, 0x0020, 0x0000, 0x0004, 0x0000, 0xFFFF, 0x0267, 0x0000 };

    auto const shifted = collate_for_tests(
        cps, cps + 2, boost::text::variable_weighting::shifted);

    EXPECT_EQ(shifted.size(), 9);
    EXPECT_TRUE(boost::algorithm::equal(shifted.begin(), shifted.end(), ces_shifted, ces_shifted + 9))
        << "from:     " << ce_dumper(cps)
        << "expected: " << ce_dumper(ces_shifted)
        << "got:      " << ce_dumper(shifted);
}

TEST(collation, verbatim_131_449)
{
    uint32_t const cps[2] = { 0x1D6CD, 0x003F };

    // 1D6CD 003F;	
    // (𝛍) MATHEMATICAL BOLD SMALL MU	[2031 0267 | 0020 0020 | 0005 0002 |]
    uint32_t const ces_non_ignorable[9] = { 0x2031, 0x0267, 0x0000, 0x0020, 0x0020, 0x0000, 0x0005, 0x0002, 0x0000 };

    auto const non_ignorable = collate_for_tests(
        cps, cps + 2, boost::text::variable_weighting::non_ignorable);

    EXPECT_EQ(non_ignorable.size(), 9);
    EXPECT_TRUE(boost::algorithm::equal(non_ignorable.begin(), non_ignorable.end(), ces_non_ignorable, ces_non_ignorable + 9))
        << "from:     " << ce_dumper(cps)
        << "expected: " << ce_dumper(ces_non_ignorable)
        << "got:      " << ce_dumper(non_ignorable);

    // 1D6CD 003F;	
    // (𝛍) MATHEMATICAL BOLD SMALL MU	[2031 | 0020 | 0005 | FFFF 0267 |]
    uint32_t const ces_shifted[9] = { 0x2031, 0x0000, 0x0020, 0x0000, 0x0005, 0x0000, 0xFFFF, 0x0267, 0x0000 };

    auto const shifted = collate_for_tests(
        cps, cps + 2, boost::text::variable_weighting::shifted);

    EXPECT_EQ(shifted.size(), 9);
    EXPECT_TRUE(boost::algorithm::equal(shifted.begin(), shifted.end(), ces_shifted, ces_shifted + 9))
        << "from:     " << ce_dumper(cps)
        << "expected: " << ce_dumper(ces_shifted)
        << "got:      " << ce_dumper(shifted);
}

TEST(collation, verbatim_131_450)
{
    uint32_t const cps[2] = { 0x1D707, 0x003F };

    // 1D707 003F;	
    // (𝜇) MATHEMATICAL ITALIC SMALL MU	[2031 0267 | 0020 0020 | 0005 0002 |]
    uint32_t const ces_non_ignorable[9] = { 0x2031, 0x0267, 0x0000, 0x0020, 0x0020, 0x0000, 0x0005, 0x0002, 0x0000 };

    auto const non_ignorable = collate_for_tests(
        cps, cps + 2, boost::text::variable_weighting::non_ignorable);

    EXPECT_EQ(non_ignorable.size(), 9);
    EXPECT_TRUE(boost::algorithm::equal(non_ignorable.begin(), non_ignorable.end(), ces_non_ignorable, ces_non_ignorable + 9))
        << "from:     " << ce_dumper(cps)
        << "expected: " << ce_dumper(ces_non_ignorable)
        << "got:      " << ce_dumper(non_ignorable);

    // 1D707 003F;	
    // (𝜇) MATHEMATICAL ITALIC SMALL MU	[2031 | 0020 | 0005 | FFFF 0267 |]
    uint32_t const ces_shifted[9] = { 0x2031, 0x0000, 0x0020, 0x0000, 0x0005, 0x0000, 0xFFFF, 0x0267, 0x0000 };

    auto const shifted = collate_for_tests(
        cps, cps + 2, boost::text::variable_weighting::shifted);

    EXPECT_EQ(shifted.size(), 9);
    EXPECT_TRUE(boost::algorithm::equal(shifted.begin(), shifted.end(), ces_shifted, ces_shifted + 9))
        << "from:     " << ce_dumper(cps)
        << "expected: " << ce_dumper(ces_shifted)
        << "got:      " << ce_dumper(shifted);
}

TEST(collation, verbatim_131_451)
{
    uint32_t const cps[2] = { 0x1D741, 0x003F };

    // 1D741 003F;	
    // (𝝁) MATHEMATICAL BOLD ITALIC SMALL MU	[2031 0267 | 0020 0020 | 0005 0002 |]
    uint32_t const ces_non_ignorable[9] = { 0x2031, 0x0267, 0x0000, 0x0020, 0x0020, 0x0000, 0x0005, 0x0002, 0x0000 };

    auto const non_ignorable = collate_for_tests(
        cps, cps + 2, boost::text::variable_weighting::non_ignorable);

    EXPECT_EQ(non_ignorable.size(), 9);
    EXPECT_TRUE(boost::algorithm::equal(non_ignorable.begin(), non_ignorable.end(), ces_non_ignorable, ces_non_ignorable + 9))
        << "from:     " << ce_dumper(cps)
        << "expected: " << ce_dumper(ces_non_ignorable)
        << "got:      " << ce_dumper(non_ignorable);

    // 1D741 003F;	
    // (𝝁) MATHEMATICAL BOLD ITALIC SMALL MU	[2031 | 0020 | 0005 | FFFF 0267 |]
    uint32_t const ces_shifted[9] = { 0x2031, 0x0000, 0x0020, 0x0000, 0x0005, 0x0000, 0xFFFF, 0x0267, 0x0000 };

    auto const shifted = collate_for_tests(
        cps, cps + 2, boost::text::variable_weighting::shifted);

    EXPECT_EQ(shifted.size(), 9);
    EXPECT_TRUE(boost::algorithm::equal(shifted.begin(), shifted.end(), ces_shifted, ces_shifted + 9))
        << "from:     " << ce_dumper(cps)
        << "expected: " << ce_dumper(ces_shifted)
        << "got:      " << ce_dumper(shifted);
}

TEST(collation, verbatim_131_452)
{
    uint32_t const cps[2] = { 0x1D77B, 0x003F };

    // 1D77B 003F;	
    // (𝝻) MATHEMATICAL SANS-SERIF BOLD SMALL MU	[2031 0267 | 0020 0020 | 0005 0002 |]
    uint32_t const ces_non_ignorable[9] = { 0x2031, 0x0267, 0x0000, 0x0020, 0x0020, 0x0000, 0x0005, 0x0002, 0x0000 };

    auto const non_ignorable = collate_for_tests(
        cps, cps + 2, boost::text::variable_weighting::non_ignorable);

    EXPECT_EQ(non_ignorable.size(), 9);
    EXPECT_TRUE(boost::algorithm::equal(non_ignorable.begin(), non_ignorable.end(), ces_non_ignorable, ces_non_ignorable + 9))
        << "from:     " << ce_dumper(cps)
        << "expected: " << ce_dumper(ces_non_ignorable)
        << "got:      " << ce_dumper(non_ignorable);

    // 1D77B 003F;	
    // (𝝻) MATHEMATICAL SANS-SERIF BOLD SMALL MU	[2031 | 0020 | 0005 | FFFF 0267 |]
    uint32_t const ces_shifted[9] = { 0x2031, 0x0000, 0x0020, 0x0000, 0x0005, 0x0000, 0xFFFF, 0x0267, 0x0000 };

    auto const shifted = collate_for_tests(
        cps, cps + 2, boost::text::variable_weighting::shifted);

    EXPECT_EQ(shifted.size(), 9);
    EXPECT_TRUE(boost::algorithm::equal(shifted.begin(), shifted.end(), ces_shifted, ces_shifted + 9))
        << "from:     " << ce_dumper(cps)
        << "expected: " << ce_dumper(ces_shifted)
        << "got:      " << ce_dumper(shifted);
}

TEST(collation, verbatim_131_453)
{
    uint32_t const cps[2] = { 0x1D7B5, 0x003F };

    // 1D7B5 003F;	
    // (𝞵) MATHEMATICAL SANS-SERIF BOLD ITALIC SMALL MU	[2031 0267 | 0020 0020 | 0005 0002 |]
    uint32_t const ces_non_ignorable[9] = { 0x2031, 0x0267, 0x0000, 0x0020, 0x0020, 0x0000, 0x0005, 0x0002, 0x0000 };

    auto const non_ignorable = collate_for_tests(
        cps, cps + 2, boost::text::variable_weighting::non_ignorable);

    EXPECT_EQ(non_ignorable.size(), 9);
    EXPECT_TRUE(boost::algorithm::equal(non_ignorable.begin(), non_ignorable.end(), ces_non_ignorable, ces_non_ignorable + 9))
        << "from:     " << ce_dumper(cps)
        << "expected: " << ce_dumper(ces_non_ignorable)
        << "got:      " << ce_dumper(non_ignorable);

    // 1D7B5 003F;	
    // (𝞵) MATHEMATICAL SANS-SERIF BOLD ITALIC SMALL MU	[2031 | 0020 | 0005 | FFFF 0267 |]
    uint32_t const ces_shifted[9] = { 0x2031, 0x0000, 0x0020, 0x0000, 0x0005, 0x0000, 0xFFFF, 0x0267, 0x0000 };

    auto const shifted = collate_for_tests(
        cps, cps + 2, boost::text::variable_weighting::shifted);

    EXPECT_EQ(shifted.size(), 9);
    EXPECT_TRUE(boost::algorithm::equal(shifted.begin(), shifted.end(), ces_shifted, ces_shifted + 9))
        << "from:     " << ce_dumper(cps)
        << "expected: " << ce_dumper(ces_shifted)
        << "got:      " << ce_dumper(shifted);
}

TEST(collation, verbatim_131_454)
{
    uint32_t const cps[2] = { 0x039C, 0x003F };

    // 039C 003F;	
    // (Μ) GREEK CAPITAL LETTER MU	[2031 0267 | 0020 0020 | 0008 0002 |]
    uint32_t const ces_non_ignorable[9] = { 0x2031, 0x0267, 0x0000, 0x0020, 0x0020, 0x0000, 0x0008, 0x0002, 0x0000 };

    auto const non_ignorable = collate_for_tests(
        cps, cps + 2, boost::text::variable_weighting::non_ignorable);

    EXPECT_EQ(non_ignorable.size(), 9);
    EXPECT_TRUE(boost::algorithm::equal(non_ignorable.begin(), non_ignorable.end(), ces_non_ignorable, ces_non_ignorable + 9))
        << "from:     " << ce_dumper(cps)
        << "expected: " << ce_dumper(ces_non_ignorable)
        << "got:      " << ce_dumper(non_ignorable);

    // 039C 003F;	
    // (Μ) GREEK CAPITAL LETTER MU	[2031 | 0020 | 0008 | FFFF 0267 |]
    uint32_t const ces_shifted[9] = { 0x2031, 0x0000, 0x0020, 0x0000, 0x0008, 0x0000, 0xFFFF, 0x0267, 0x0000 };

    auto const shifted = collate_for_tests(
        cps, cps + 2, boost::text::variable_weighting::shifted);

    EXPECT_EQ(shifted.size(), 9);
    EXPECT_TRUE(boost::algorithm::equal(shifted.begin(), shifted.end(), ces_shifted, ces_shifted + 9))
        << "from:     " << ce_dumper(cps)
        << "expected: " << ce_dumper(ces_shifted)
        << "got:      " << ce_dumper(shifted);
}

TEST(collation, verbatim_131_455)
{
    uint32_t const cps[2] = { 0x1D6B3, 0x003F };

    // 1D6B3 003F;	
    // (𝚳) MATHEMATICAL BOLD CAPITAL MU	[2031 0267 | 0020 0020 | 000B 0002 |]
    uint32_t const ces_non_ignorable[9] = { 0x2031, 0x0267, 0x0000, 0x0020, 0x0020, 0x0000, 0x000B, 0x0002, 0x0000 };

    auto const non_ignorable = collate_for_tests(
        cps, cps + 2, boost::text::variable_weighting::non_ignorable);

    EXPECT_EQ(non_ignorable.size(), 9);
    EXPECT_TRUE(boost::algorithm::equal(non_ignorable.begin(), non_ignorable.end(), ces_non_ignorable, ces_non_ignorable + 9))
        << "from:     " << ce_dumper(cps)
        << "expected: " << ce_dumper(ces_non_ignorable)
        << "got:      " << ce_dumper(non_ignorable);

    // 1D6B3 003F;	
    // (𝚳) MATHEMATICAL BOLD CAPITAL MU	[2031 | 0020 | 000B | FFFF 0267 |]
    uint32_t const ces_shifted[9] = { 0x2031, 0x0000, 0x0020, 0x0000, 0x000B, 0x0000, 0xFFFF, 0x0267, 0x0000 };

    auto const shifted = collate_for_tests(
        cps, cps + 2, boost::text::variable_weighting::shifted);

    EXPECT_EQ(shifted.size(), 9);
    EXPECT_TRUE(boost::algorithm::equal(shifted.begin(), shifted.end(), ces_shifted, ces_shifted + 9))
        << "from:     " << ce_dumper(cps)
        << "expected: " << ce_dumper(ces_shifted)
        << "got:      " << ce_dumper(shifted);
}

TEST(collation, verbatim_131_456)
{
    uint32_t const cps[2] = { 0x1D6ED, 0x003F };

    // 1D6ED 003F;	
    // (𝛭) MATHEMATICAL ITALIC CAPITAL MU	[2031 0267 | 0020 0020 | 000B 0002 |]
    uint32_t const ces_non_ignorable[9] = { 0x2031, 0x0267, 0x0000, 0x0020, 0x0020, 0x0000, 0x000B, 0x0002, 0x0000 };

    auto const non_ignorable = collate_for_tests(
        cps, cps + 2, boost::text::variable_weighting::non_ignorable);

    EXPECT_EQ(non_ignorable.size(), 9);
    EXPECT_TRUE(boost::algorithm::equal(non_ignorable.begin(), non_ignorable.end(), ces_non_ignorable, ces_non_ignorable + 9))
        << "from:     " << ce_dumper(cps)
        << "expected: " << ce_dumper(ces_non_ignorable)
        << "got:      " << ce_dumper(non_ignorable);

    // 1D6ED 003F;	
    // (𝛭) MATHEMATICAL ITALIC CAPITAL MU	[2031 | 0020 | 000B | FFFF 0267 |]
    uint32_t const ces_shifted[9] = { 0x2031, 0x0000, 0x0020, 0x0000, 0x000B, 0x0000, 0xFFFF, 0x0267, 0x0000 };

    auto const shifted = collate_for_tests(
        cps, cps + 2, boost::text::variable_weighting::shifted);

    EXPECT_EQ(shifted.size(), 9);
    EXPECT_TRUE(boost::algorithm::equal(shifted.begin(), shifted.end(), ces_shifted, ces_shifted + 9))
        << "from:     " << ce_dumper(cps)
        << "expected: " << ce_dumper(ces_shifted)
        << "got:      " << ce_dumper(shifted);
}

TEST(collation, verbatim_131_457)
{
    uint32_t const cps[2] = { 0x1D727, 0x003F };

    // 1D727 003F;	
    // (𝜧) MATHEMATICAL BOLD ITALIC CAPITAL MU	[2031 0267 | 0020 0020 | 000B 0002 |]
    uint32_t const ces_non_ignorable[9] = { 0x2031, 0x0267, 0x0000, 0x0020, 0x0020, 0x0000, 0x000B, 0x0002, 0x0000 };

    auto const non_ignorable = collate_for_tests(
        cps, cps + 2, boost::text::variable_weighting::non_ignorable);

    EXPECT_EQ(non_ignorable.size(), 9);
    EXPECT_TRUE(boost::algorithm::equal(non_ignorable.begin(), non_ignorable.end(), ces_non_ignorable, ces_non_ignorable + 9))
        << "from:     " << ce_dumper(cps)
        << "expected: " << ce_dumper(ces_non_ignorable)
        << "got:      " << ce_dumper(non_ignorable);

    // 1D727 003F;	
    // (𝜧) MATHEMATICAL BOLD ITALIC CAPITAL MU	[2031 | 0020 | 000B | FFFF 0267 |]
    uint32_t const ces_shifted[9] = { 0x2031, 0x0000, 0x0020, 0x0000, 0x000B, 0x0000, 0xFFFF, 0x0267, 0x0000 };

    auto const shifted = collate_for_tests(
        cps, cps + 2, boost::text::variable_weighting::shifted);

    EXPECT_EQ(shifted.size(), 9);
    EXPECT_TRUE(boost::algorithm::equal(shifted.begin(), shifted.end(), ces_shifted, ces_shifted + 9))
        << "from:     " << ce_dumper(cps)
        << "expected: " << ce_dumper(ces_shifted)
        << "got:      " << ce_dumper(shifted);
}

TEST(collation, verbatim_131_458)
{
    uint32_t const cps[2] = { 0x1D761, 0x003F };

    // 1D761 003F;	
    // (𝝡) MATHEMATICAL SANS-SERIF BOLD CAPITAL MU	[2031 0267 | 0020 0020 | 000B 0002 |]
    uint32_t const ces_non_ignorable[9] = { 0x2031, 0x0267, 0x0000, 0x0020, 0x0020, 0x0000, 0x000B, 0x0002, 0x0000 };

    auto const non_ignorable = collate_for_tests(
        cps, cps + 2, boost::text::variable_weighting::non_ignorable);

    EXPECT_EQ(non_ignorable.size(), 9);
    EXPECT_TRUE(boost::algorithm::equal(non_ignorable.begin(), non_ignorable.end(), ces_non_ignorable, ces_non_ignorable + 9))
        << "from:     " << ce_dumper(cps)
        << "expected: " << ce_dumper(ces_non_ignorable)
        << "got:      " << ce_dumper(non_ignorable);

    // 1D761 003F;	
    // (𝝡) MATHEMATICAL SANS-SERIF BOLD CAPITAL MU	[2031 | 0020 | 000B | FFFF 0267 |]
    uint32_t const ces_shifted[9] = { 0x2031, 0x0000, 0x0020, 0x0000, 0x000B, 0x0000, 0xFFFF, 0x0267, 0x0000 };

    auto const shifted = collate_for_tests(
        cps, cps + 2, boost::text::variable_weighting::shifted);

    EXPECT_EQ(shifted.size(), 9);
    EXPECT_TRUE(boost::algorithm::equal(shifted.begin(), shifted.end(), ces_shifted, ces_shifted + 9))
        << "from:     " << ce_dumper(cps)
        << "expected: " << ce_dumper(ces_shifted)
        << "got:      " << ce_dumper(shifted);
}

TEST(collation, verbatim_131_459)
{
    uint32_t const cps[2] = { 0x1D79B, 0x003F };

    // 1D79B 003F;	
    // (𝞛) MATHEMATICAL SANS-SERIF BOLD ITALIC CAPITAL MU	[2031 0267 | 0020 0020 | 000B 0002 |]
    uint32_t const ces_non_ignorable[9] = { 0x2031, 0x0267, 0x0000, 0x0020, 0x0020, 0x0000, 0x000B, 0x0002, 0x0000 };

    auto const non_ignorable = collate_for_tests(
        cps, cps + 2, boost::text::variable_weighting::non_ignorable);

    EXPECT_EQ(non_ignorable.size(), 9);
    EXPECT_TRUE(boost::algorithm::equal(non_ignorable.begin(), non_ignorable.end(), ces_non_ignorable, ces_non_ignorable + 9))
        << "from:     " << ce_dumper(cps)
        << "expected: " << ce_dumper(ces_non_ignorable)
        << "got:      " << ce_dumper(non_ignorable);

    // 1D79B 003F;	
    // (𝞛) MATHEMATICAL SANS-SERIF BOLD ITALIC CAPITAL MU	[2031 | 0020 | 000B | FFFF 0267 |]
    uint32_t const ces_shifted[9] = { 0x2031, 0x0000, 0x0020, 0x0000, 0x000B, 0x0000, 0xFFFF, 0x0267, 0x0000 };

    auto const shifted = collate_for_tests(
        cps, cps + 2, boost::text::variable_weighting::shifted);

    EXPECT_EQ(shifted.size(), 9);
    EXPECT_TRUE(boost::algorithm::equal(shifted.begin(), shifted.end(), ces_shifted, ces_shifted + 9))
        << "from:     " << ce_dumper(cps)
        << "expected: " << ce_dumper(ces_shifted)
        << "got:      " << ce_dumper(shifted);
}

TEST(collation, verbatim_131_460)
{
    uint32_t const cps[2] = { 0x03BC, 0x0061 };

    // 03BC 0061;	
    // (μ) GREEK SMALL LETTER MU	[2031 1CAD | 0020 0020 | 0002 0002 |]
    uint32_t const ces_non_ignorable[9] = { 0x2031, 0x1CAD, 0x0000, 0x0020, 0x0020, 0x0000, 0x0002, 0x0002, 0x0000 };

    auto const non_ignorable = collate_for_tests(
        cps, cps + 2, boost::text::variable_weighting::non_ignorable);

    EXPECT_EQ(non_ignorable.size(), 9);
    EXPECT_TRUE(boost::algorithm::equal(non_ignorable.begin(), non_ignorable.end(), ces_non_ignorable, ces_non_ignorable + 9))
        << "from:     " << ce_dumper(cps)
        << "expected: " << ce_dumper(ces_non_ignorable)
        << "got:      " << ce_dumper(non_ignorable);

    // 03BC 0061;	
    // (μ) GREEK SMALL LETTER MU	[2031 1CAD | 0020 0020 | 0002 0002 | FFFF FFFF |]
    uint32_t const ces_shifted[12] = { 0x2031, 0x1CAD, 0x0000, 0x0020, 0x0020, 0x0000, 0x0002, 0x0002, 0x0000, 0xFFFF, 0xFFFF, 0x0000 };

    auto const shifted = collate_for_tests(
        cps, cps + 2, boost::text::variable_weighting::shifted);

    EXPECT_EQ(shifted.size(), 12);
    EXPECT_TRUE(boost::algorithm::equal(shifted.begin(), shifted.end(), ces_shifted, ces_shifted + 12))
        << "from:     " << ce_dumper(cps)
        << "expected: " << ce_dumper(ces_shifted)
        << "got:      " << ce_dumper(shifted);
}

TEST(collation, verbatim_131_461)
{
    uint32_t const cps[2] = { 0x03BC, 0x0041 };

    // 03BC 0041;	
    // (μ) GREEK SMALL LETTER MU	[2031 1CAD | 0020 0020 | 0002 0008 |]
    uint32_t const ces_non_ignorable[9] = { 0x2031, 0x1CAD, 0x0000, 0x0020, 0x0020, 0x0000, 0x0002, 0x0008, 0x0000 };

    auto const non_ignorable = collate_for_tests(
        cps, cps + 2, boost::text::variable_weighting::non_ignorable);

    EXPECT_EQ(non_ignorable.size(), 9);
    EXPECT_TRUE(boost::algorithm::equal(non_ignorable.begin(), non_ignorable.end(), ces_non_ignorable, ces_non_ignorable + 9))
        << "from:     " << ce_dumper(cps)
        << "expected: " << ce_dumper(ces_non_ignorable)
        << "got:      " << ce_dumper(non_ignorable);

    // 03BC 0041;	
    // (μ) GREEK SMALL LETTER MU	[2031 1CAD | 0020 0020 | 0002 0008 | FFFF FFFF |]
    uint32_t const ces_shifted[12] = { 0x2031, 0x1CAD, 0x0000, 0x0020, 0x0020, 0x0000, 0x0002, 0x0008, 0x0000, 0xFFFF, 0xFFFF, 0x0000 };

    auto const shifted = collate_for_tests(
        cps, cps + 2, boost::text::variable_weighting::shifted);

    EXPECT_EQ(shifted.size(), 12);
    EXPECT_TRUE(boost::algorithm::equal(shifted.begin(), shifted.end(), ces_shifted, ces_shifted + 12))
        << "from:     " << ce_dumper(cps)
        << "expected: " << ce_dumper(ces_shifted)
        << "got:      " << ce_dumper(shifted);
}

TEST(collation, verbatim_131_462)
{
    uint32_t const cps[2] = { 0x00B5, 0x0061 };

    // 00B5 0061;	
    // (µ) MICRO SIGN	[2031 1CAD | 0020 0020 | 0004 0002 |]
    uint32_t const ces_non_ignorable[9] = { 0x2031, 0x1CAD, 0x0000, 0x0020, 0x0020, 0x0000, 0x0004, 0x0002, 0x0000 };

    auto const non_ignorable = collate_for_tests(
        cps, cps + 2, boost::text::variable_weighting::non_ignorable);

    EXPECT_EQ(non_ignorable.size(), 9);
    EXPECT_TRUE(boost::algorithm::equal(non_ignorable.begin(), non_ignorable.end(), ces_non_ignorable, ces_non_ignorable + 9))
        << "from:     " << ce_dumper(cps)
        << "expected: " << ce_dumper(ces_non_ignorable)
        << "got:      " << ce_dumper(non_ignorable);

    // 00B5 0061;	
    // (µ) MICRO SIGN	[2031 1CAD | 0020 0020 | 0004 0002 | FFFF FFFF |]
    uint32_t const ces_shifted[12] = { 0x2031, 0x1CAD, 0x0000, 0x0020, 0x0020, 0x0000, 0x0004, 0x0002, 0x0000, 0xFFFF, 0xFFFF, 0x0000 };

    auto const shifted = collate_for_tests(
        cps, cps + 2, boost::text::variable_weighting::shifted);

    EXPECT_EQ(shifted.size(), 12);
    EXPECT_TRUE(boost::algorithm::equal(shifted.begin(), shifted.end(), ces_shifted, ces_shifted + 12))
        << "from:     " << ce_dumper(cps)
        << "expected: " << ce_dumper(ces_shifted)
        << "got:      " << ce_dumper(shifted);
}

TEST(collation, verbatim_131_463)
{
    uint32_t const cps[2] = { 0x00B5, 0x0041 };

    // 00B5 0041;	
    // (µ) MICRO SIGN	[2031 1CAD | 0020 0020 | 0004 0008 |]
    uint32_t const ces_non_ignorable[9] = { 0x2031, 0x1CAD, 0x0000, 0x0020, 0x0020, 0x0000, 0x0004, 0x0008, 0x0000 };

    auto const non_ignorable = collate_for_tests(
        cps, cps + 2, boost::text::variable_weighting::non_ignorable);

    EXPECT_EQ(non_ignorable.size(), 9);
    EXPECT_TRUE(boost::algorithm::equal(non_ignorable.begin(), non_ignorable.end(), ces_non_ignorable, ces_non_ignorable + 9))
        << "from:     " << ce_dumper(cps)
        << "expected: " << ce_dumper(ces_non_ignorable)
        << "got:      " << ce_dumper(non_ignorable);

    // 00B5 0041;	
    // (µ) MICRO SIGN	[2031 1CAD | 0020 0020 | 0004 0008 | FFFF FFFF |]
    uint32_t const ces_shifted[12] = { 0x2031, 0x1CAD, 0x0000, 0x0020, 0x0020, 0x0000, 0x0004, 0x0008, 0x0000, 0xFFFF, 0xFFFF, 0x0000 };

    auto const shifted = collate_for_tests(
        cps, cps + 2, boost::text::variable_weighting::shifted);

    EXPECT_EQ(shifted.size(), 12);
    EXPECT_TRUE(boost::algorithm::equal(shifted.begin(), shifted.end(), ces_shifted, ces_shifted + 12))
        << "from:     " << ce_dumper(cps)
        << "expected: " << ce_dumper(ces_shifted)
        << "got:      " << ce_dumper(shifted);
}

TEST(collation, verbatim_131_464)
{
    uint32_t const cps[2] = { 0x1D6CD, 0x0061 };

    // 1D6CD 0061;	
    // (𝛍) MATHEMATICAL BOLD SMALL MU	[2031 1CAD | 0020 0020 | 0005 0002 |]
    uint32_t const ces_non_ignorable[9] = { 0x2031, 0x1CAD, 0x0000, 0x0020, 0x0020, 0x0000, 0x0005, 0x0002, 0x0000 };

    auto const non_ignorable = collate_for_tests(
        cps, cps + 2, boost::text::variable_weighting::non_ignorable);

    EXPECT_EQ(non_ignorable.size(), 9);
    EXPECT_TRUE(boost::algorithm::equal(non_ignorable.begin(), non_ignorable.end(), ces_non_ignorable, ces_non_ignorable + 9))
        << "from:     " << ce_dumper(cps)
        << "expected: " << ce_dumper(ces_non_ignorable)
        << "got:      " << ce_dumper(non_ignorable);

    // 1D6CD 0061;	
    // (𝛍) MATHEMATICAL BOLD SMALL MU	[2031 1CAD | 0020 0020 | 0005 0002 | FFFF FFFF |]
    uint32_t const ces_shifted[12] = { 0x2031, 0x1CAD, 0x0000, 0x0020, 0x0020, 0x0000, 0x0005, 0x0002, 0x0000, 0xFFFF, 0xFFFF, 0x0000 };

    auto const shifted = collate_for_tests(
        cps, cps + 2, boost::text::variable_weighting::shifted);

    EXPECT_EQ(shifted.size(), 12);
    EXPECT_TRUE(boost::algorithm::equal(shifted.begin(), shifted.end(), ces_shifted, ces_shifted + 12))
        << "from:     " << ce_dumper(cps)
        << "expected: " << ce_dumper(ces_shifted)
        << "got:      " << ce_dumper(shifted);
}

TEST(collation, verbatim_131_465)
{
    uint32_t const cps[2] = { 0x1D707, 0x0061 };

    // 1D707 0061;	
    // (𝜇) MATHEMATICAL ITALIC SMALL MU	[2031 1CAD | 0020 0020 | 0005 0002 |]
    uint32_t const ces_non_ignorable[9] = { 0x2031, 0x1CAD, 0x0000, 0x0020, 0x0020, 0x0000, 0x0005, 0x0002, 0x0000 };

    auto const non_ignorable = collate_for_tests(
        cps, cps + 2, boost::text::variable_weighting::non_ignorable);

    EXPECT_EQ(non_ignorable.size(), 9);
    EXPECT_TRUE(boost::algorithm::equal(non_ignorable.begin(), non_ignorable.end(), ces_non_ignorable, ces_non_ignorable + 9))
        << "from:     " << ce_dumper(cps)
        << "expected: " << ce_dumper(ces_non_ignorable)
        << "got:      " << ce_dumper(non_ignorable);

    // 1D707 0061;	
    // (𝜇) MATHEMATICAL ITALIC SMALL MU	[2031 1CAD | 0020 0020 | 0005 0002 | FFFF FFFF |]
    uint32_t const ces_shifted[12] = { 0x2031, 0x1CAD, 0x0000, 0x0020, 0x0020, 0x0000, 0x0005, 0x0002, 0x0000, 0xFFFF, 0xFFFF, 0x0000 };

    auto const shifted = collate_for_tests(
        cps, cps + 2, boost::text::variable_weighting::shifted);

    EXPECT_EQ(shifted.size(), 12);
    EXPECT_TRUE(boost::algorithm::equal(shifted.begin(), shifted.end(), ces_shifted, ces_shifted + 12))
        << "from:     " << ce_dumper(cps)
        << "expected: " << ce_dumper(ces_shifted)
        << "got:      " << ce_dumper(shifted);
}

TEST(collation, verbatim_131_466)
{
    uint32_t const cps[2] = { 0x1D741, 0x0061 };

    // 1D741 0061;	
    // (𝝁) MATHEMATICAL BOLD ITALIC SMALL MU	[2031 1CAD | 0020 0020 | 0005 0002 |]
    uint32_t const ces_non_ignorable[9] = { 0x2031, 0x1CAD, 0x0000, 0x0020, 0x0020, 0x0000, 0x0005, 0x0002, 0x0000 };

    auto const non_ignorable = collate_for_tests(
        cps, cps + 2, boost::text::variable_weighting::non_ignorable);

    EXPECT_EQ(non_ignorable.size(), 9);
    EXPECT_TRUE(boost::algorithm::equal(non_ignorable.begin(), non_ignorable.end(), ces_non_ignorable, ces_non_ignorable + 9))
        << "from:     " << ce_dumper(cps)
        << "expected: " << ce_dumper(ces_non_ignorable)
        << "got:      " << ce_dumper(non_ignorable);

    // 1D741 0061;	
    // (𝝁) MATHEMATICAL BOLD ITALIC SMALL MU	[2031 1CAD | 0020 0020 | 0005 0002 | FFFF FFFF |]
    uint32_t const ces_shifted[12] = { 0x2031, 0x1CAD, 0x0000, 0x0020, 0x0020, 0x0000, 0x0005, 0x0002, 0x0000, 0xFFFF, 0xFFFF, 0x0000 };

    auto const shifted = collate_for_tests(
        cps, cps + 2, boost::text::variable_weighting::shifted);

    EXPECT_EQ(shifted.size(), 12);
    EXPECT_TRUE(boost::algorithm::equal(shifted.begin(), shifted.end(), ces_shifted, ces_shifted + 12))
        << "from:     " << ce_dumper(cps)
        << "expected: " << ce_dumper(ces_shifted)
        << "got:      " << ce_dumper(shifted);
}

TEST(collation, verbatim_131_467)
{
    uint32_t const cps[2] = { 0x1D77B, 0x0061 };

    // 1D77B 0061;	
    // (𝝻) MATHEMATICAL SANS-SERIF BOLD SMALL MU	[2031 1CAD | 0020 0020 | 0005 0002 |]
    uint32_t const ces_non_ignorable[9] = { 0x2031, 0x1CAD, 0x0000, 0x0020, 0x0020, 0x0000, 0x0005, 0x0002, 0x0000 };

    auto const non_ignorable = collate_for_tests(
        cps, cps + 2, boost::text::variable_weighting::non_ignorable);

    EXPECT_EQ(non_ignorable.size(), 9);
    EXPECT_TRUE(boost::algorithm::equal(non_ignorable.begin(), non_ignorable.end(), ces_non_ignorable, ces_non_ignorable + 9))
        << "from:     " << ce_dumper(cps)
        << "expected: " << ce_dumper(ces_non_ignorable)
        << "got:      " << ce_dumper(non_ignorable);

    // 1D77B 0061;	
    // (𝝻) MATHEMATICAL SANS-SERIF BOLD SMALL MU	[2031 1CAD | 0020 0020 | 0005 0002 | FFFF FFFF |]
    uint32_t const ces_shifted[12] = { 0x2031, 0x1CAD, 0x0000, 0x0020, 0x0020, 0x0000, 0x0005, 0x0002, 0x0000, 0xFFFF, 0xFFFF, 0x0000 };

    auto const shifted = collate_for_tests(
        cps, cps + 2, boost::text::variable_weighting::shifted);

    EXPECT_EQ(shifted.size(), 12);
    EXPECT_TRUE(boost::algorithm::equal(shifted.begin(), shifted.end(), ces_shifted, ces_shifted + 12))
        << "from:     " << ce_dumper(cps)
        << "expected: " << ce_dumper(ces_shifted)
        << "got:      " << ce_dumper(shifted);
}

TEST(collation, verbatim_131_468)
{
    uint32_t const cps[2] = { 0x1D7B5, 0x0061 };

    // 1D7B5 0061;	
    // (𝞵) MATHEMATICAL SANS-SERIF BOLD ITALIC SMALL MU	[2031 1CAD | 0020 0020 | 0005 0002 |]
    uint32_t const ces_non_ignorable[9] = { 0x2031, 0x1CAD, 0x0000, 0x0020, 0x0020, 0x0000, 0x0005, 0x0002, 0x0000 };

    auto const non_ignorable = collate_for_tests(
        cps, cps + 2, boost::text::variable_weighting::non_ignorable);

    EXPECT_EQ(non_ignorable.size(), 9);
    EXPECT_TRUE(boost::algorithm::equal(non_ignorable.begin(), non_ignorable.end(), ces_non_ignorable, ces_non_ignorable + 9))
        << "from:     " << ce_dumper(cps)
        << "expected: " << ce_dumper(ces_non_ignorable)
        << "got:      " << ce_dumper(non_ignorable);

    // 1D7B5 0061;	
    // (𝞵) MATHEMATICAL SANS-SERIF BOLD ITALIC SMALL MU	[2031 1CAD | 0020 0020 | 0005 0002 | FFFF FFFF |]
    uint32_t const ces_shifted[12] = { 0x2031, 0x1CAD, 0x0000, 0x0020, 0x0020, 0x0000, 0x0005, 0x0002, 0x0000, 0xFFFF, 0xFFFF, 0x0000 };

    auto const shifted = collate_for_tests(
        cps, cps + 2, boost::text::variable_weighting::shifted);

    EXPECT_EQ(shifted.size(), 12);
    EXPECT_TRUE(boost::algorithm::equal(shifted.begin(), shifted.end(), ces_shifted, ces_shifted + 12))
        << "from:     " << ce_dumper(cps)
        << "expected: " << ce_dumper(ces_shifted)
        << "got:      " << ce_dumper(shifted);
}

TEST(collation, verbatim_131_469)
{
    uint32_t const cps[2] = { 0x1D6CD, 0x0041 };

    // 1D6CD 0041;	
    // (𝛍) MATHEMATICAL BOLD SMALL MU	[2031 1CAD | 0020 0020 | 0005 0008 |]
    uint32_t const ces_non_ignorable[9] = { 0x2031, 0x1CAD, 0x0000, 0x0020, 0x0020, 0x0000, 0x0005, 0x0008, 0x0000 };

    auto const non_ignorable = collate_for_tests(
        cps, cps + 2, boost::text::variable_weighting::non_ignorable);

    EXPECT_EQ(non_ignorable.size(), 9);
    EXPECT_TRUE(boost::algorithm::equal(non_ignorable.begin(), non_ignorable.end(), ces_non_ignorable, ces_non_ignorable + 9))
        << "from:     " << ce_dumper(cps)
        << "expected: " << ce_dumper(ces_non_ignorable)
        << "got:      " << ce_dumper(non_ignorable);

    // 1D6CD 0041;	
    // (𝛍) MATHEMATICAL BOLD SMALL MU	[2031 1CAD | 0020 0020 | 0005 0008 | FFFF FFFF |]
    uint32_t const ces_shifted[12] = { 0x2031, 0x1CAD, 0x0000, 0x0020, 0x0020, 0x0000, 0x0005, 0x0008, 0x0000, 0xFFFF, 0xFFFF, 0x0000 };

    auto const shifted = collate_for_tests(
        cps, cps + 2, boost::text::variable_weighting::shifted);

    EXPECT_EQ(shifted.size(), 12);
    EXPECT_TRUE(boost::algorithm::equal(shifted.begin(), shifted.end(), ces_shifted, ces_shifted + 12))
        << "from:     " << ce_dumper(cps)
        << "expected: " << ce_dumper(ces_shifted)
        << "got:      " << ce_dumper(shifted);
}

TEST(collation, verbatim_131_470)
{
    uint32_t const cps[2] = { 0x1D707, 0x0041 };

    // 1D707 0041;	
    // (𝜇) MATHEMATICAL ITALIC SMALL MU	[2031 1CAD | 0020 0020 | 0005 0008 |]
    uint32_t const ces_non_ignorable[9] = { 0x2031, 0x1CAD, 0x0000, 0x0020, 0x0020, 0x0000, 0x0005, 0x0008, 0x0000 };

    auto const non_ignorable = collate_for_tests(
        cps, cps + 2, boost::text::variable_weighting::non_ignorable);

    EXPECT_EQ(non_ignorable.size(), 9);
    EXPECT_TRUE(boost::algorithm::equal(non_ignorable.begin(), non_ignorable.end(), ces_non_ignorable, ces_non_ignorable + 9))
        << "from:     " << ce_dumper(cps)
        << "expected: " << ce_dumper(ces_non_ignorable)
        << "got:      " << ce_dumper(non_ignorable);

    // 1D707 0041;	
    // (𝜇) MATHEMATICAL ITALIC SMALL MU	[2031 1CAD | 0020 0020 | 0005 0008 | FFFF FFFF |]
    uint32_t const ces_shifted[12] = { 0x2031, 0x1CAD, 0x0000, 0x0020, 0x0020, 0x0000, 0x0005, 0x0008, 0x0000, 0xFFFF, 0xFFFF, 0x0000 };

    auto const shifted = collate_for_tests(
        cps, cps + 2, boost::text::variable_weighting::shifted);

    EXPECT_EQ(shifted.size(), 12);
    EXPECT_TRUE(boost::algorithm::equal(shifted.begin(), shifted.end(), ces_shifted, ces_shifted + 12))
        << "from:     " << ce_dumper(cps)
        << "expected: " << ce_dumper(ces_shifted)
        << "got:      " << ce_dumper(shifted);
}

TEST(collation, verbatim_131_471)
{
    uint32_t const cps[2] = { 0x1D741, 0x0041 };

    // 1D741 0041;	
    // (𝝁) MATHEMATICAL BOLD ITALIC SMALL MU	[2031 1CAD | 0020 0020 | 0005 0008 |]
    uint32_t const ces_non_ignorable[9] = { 0x2031, 0x1CAD, 0x0000, 0x0020, 0x0020, 0x0000, 0x0005, 0x0008, 0x0000 };

    auto const non_ignorable = collate_for_tests(
        cps, cps + 2, boost::text::variable_weighting::non_ignorable);

    EXPECT_EQ(non_ignorable.size(), 9);
    EXPECT_TRUE(boost::algorithm::equal(non_ignorable.begin(), non_ignorable.end(), ces_non_ignorable, ces_non_ignorable + 9))
        << "from:     " << ce_dumper(cps)
        << "expected: " << ce_dumper(ces_non_ignorable)
        << "got:      " << ce_dumper(non_ignorable);

    // 1D741 0041;	
    // (𝝁) MATHEMATICAL BOLD ITALIC SMALL MU	[2031 1CAD | 0020 0020 | 0005 0008 | FFFF FFFF |]
    uint32_t const ces_shifted[12] = { 0x2031, 0x1CAD, 0x0000, 0x0020, 0x0020, 0x0000, 0x0005, 0x0008, 0x0000, 0xFFFF, 0xFFFF, 0x0000 };

    auto const shifted = collate_for_tests(
        cps, cps + 2, boost::text::variable_weighting::shifted);

    EXPECT_EQ(shifted.size(), 12);
    EXPECT_TRUE(boost::algorithm::equal(shifted.begin(), shifted.end(), ces_shifted, ces_shifted + 12))
        << "from:     " << ce_dumper(cps)
        << "expected: " << ce_dumper(ces_shifted)
        << "got:      " << ce_dumper(shifted);
}

TEST(collation, verbatim_131_472)
{
    uint32_t const cps[2] = { 0x1D77B, 0x0041 };

    // 1D77B 0041;	
    // (𝝻) MATHEMATICAL SANS-SERIF BOLD SMALL MU	[2031 1CAD | 0020 0020 | 0005 0008 |]
    uint32_t const ces_non_ignorable[9] = { 0x2031, 0x1CAD, 0x0000, 0x0020, 0x0020, 0x0000, 0x0005, 0x0008, 0x0000 };

    auto const non_ignorable = collate_for_tests(
        cps, cps + 2, boost::text::variable_weighting::non_ignorable);

    EXPECT_EQ(non_ignorable.size(), 9);
    EXPECT_TRUE(boost::algorithm::equal(non_ignorable.begin(), non_ignorable.end(), ces_non_ignorable, ces_non_ignorable + 9))
        << "from:     " << ce_dumper(cps)
        << "expected: " << ce_dumper(ces_non_ignorable)
        << "got:      " << ce_dumper(non_ignorable);

    // 1D77B 0041;	
    // (𝝻) MATHEMATICAL SANS-SERIF BOLD SMALL MU	[2031 1CAD | 0020 0020 | 0005 0008 | FFFF FFFF |]
    uint32_t const ces_shifted[12] = { 0x2031, 0x1CAD, 0x0000, 0x0020, 0x0020, 0x0000, 0x0005, 0x0008, 0x0000, 0xFFFF, 0xFFFF, 0x0000 };

    auto const shifted = collate_for_tests(
        cps, cps + 2, boost::text::variable_weighting::shifted);

    EXPECT_EQ(shifted.size(), 12);
    EXPECT_TRUE(boost::algorithm::equal(shifted.begin(), shifted.end(), ces_shifted, ces_shifted + 12))
        << "from:     " << ce_dumper(cps)
        << "expected: " << ce_dumper(ces_shifted)
        << "got:      " << ce_dumper(shifted);
}

TEST(collation, verbatim_131_473)
{
    uint32_t const cps[2] = { 0x1D7B5, 0x0041 };

    // 1D7B5 0041;	
    // (𝞵) MATHEMATICAL SANS-SERIF BOLD ITALIC SMALL MU	[2031 1CAD | 0020 0020 | 0005 0008 |]
    uint32_t const ces_non_ignorable[9] = { 0x2031, 0x1CAD, 0x0000, 0x0020, 0x0020, 0x0000, 0x0005, 0x0008, 0x0000 };

    auto const non_ignorable = collate_for_tests(
        cps, cps + 2, boost::text::variable_weighting::non_ignorable);

    EXPECT_EQ(non_ignorable.size(), 9);
    EXPECT_TRUE(boost::algorithm::equal(non_ignorable.begin(), non_ignorable.end(), ces_non_ignorable, ces_non_ignorable + 9))
        << "from:     " << ce_dumper(cps)
        << "expected: " << ce_dumper(ces_non_ignorable)
        << "got:      " << ce_dumper(non_ignorable);

    // 1D7B5 0041;	
    // (𝞵) MATHEMATICAL SANS-SERIF BOLD ITALIC SMALL MU	[2031 1CAD | 0020 0020 | 0005 0008 | FFFF FFFF |]
    uint32_t const ces_shifted[12] = { 0x2031, 0x1CAD, 0x0000, 0x0020, 0x0020, 0x0000, 0x0005, 0x0008, 0x0000, 0xFFFF, 0xFFFF, 0x0000 };

    auto const shifted = collate_for_tests(
        cps, cps + 2, boost::text::variable_weighting::shifted);

    EXPECT_EQ(shifted.size(), 12);
    EXPECT_TRUE(boost::algorithm::equal(shifted.begin(), shifted.end(), ces_shifted, ces_shifted + 12))
        << "from:     " << ce_dumper(cps)
        << "expected: " << ce_dumper(ces_shifted)
        << "got:      " << ce_dumper(shifted);
}

TEST(collation, verbatim_131_474)
{
    uint32_t const cps[2] = { 0x039C, 0x0061 };

    // 039C 0061;	
    // (Μ) GREEK CAPITAL LETTER MU	[2031 1CAD | 0020 0020 | 0008 0002 |]
    uint32_t const ces_non_ignorable[9] = { 0x2031, 0x1CAD, 0x0000, 0x0020, 0x0020, 0x0000, 0x0008, 0x0002, 0x0000 };

    auto const non_ignorable = collate_for_tests(
        cps, cps + 2, boost::text::variable_weighting::non_ignorable);

    EXPECT_EQ(non_ignorable.size(), 9);
    EXPECT_TRUE(boost::algorithm::equal(non_ignorable.begin(), non_ignorable.end(), ces_non_ignorable, ces_non_ignorable + 9))
        << "from:     " << ce_dumper(cps)
        << "expected: " << ce_dumper(ces_non_ignorable)
        << "got:      " << ce_dumper(non_ignorable);

    // 039C 0061;	
    // (Μ) GREEK CAPITAL LETTER MU	[2031 1CAD | 0020 0020 | 0008 0002 | FFFF FFFF |]
    uint32_t const ces_shifted[12] = { 0x2031, 0x1CAD, 0x0000, 0x0020, 0x0020, 0x0000, 0x0008, 0x0002, 0x0000, 0xFFFF, 0xFFFF, 0x0000 };

    auto const shifted = collate_for_tests(
        cps, cps + 2, boost::text::variable_weighting::shifted);

    EXPECT_EQ(shifted.size(), 12);
    EXPECT_TRUE(boost::algorithm::equal(shifted.begin(), shifted.end(), ces_shifted, ces_shifted + 12))
        << "from:     " << ce_dumper(cps)
        << "expected: " << ce_dumper(ces_shifted)
        << "got:      " << ce_dumper(shifted);
}

TEST(collation, verbatim_131_475)
{
    uint32_t const cps[2] = { 0x039C, 0x0041 };

    // 039C 0041;	
    // (Μ) GREEK CAPITAL LETTER MU	[2031 1CAD | 0020 0020 | 0008 0008 |]
    uint32_t const ces_non_ignorable[9] = { 0x2031, 0x1CAD, 0x0000, 0x0020, 0x0020, 0x0000, 0x0008, 0x0008, 0x0000 };

    auto const non_ignorable = collate_for_tests(
        cps, cps + 2, boost::text::variable_weighting::non_ignorable);

    EXPECT_EQ(non_ignorable.size(), 9);
    EXPECT_TRUE(boost::algorithm::equal(non_ignorable.begin(), non_ignorable.end(), ces_non_ignorable, ces_non_ignorable + 9))
        << "from:     " << ce_dumper(cps)
        << "expected: " << ce_dumper(ces_non_ignorable)
        << "got:      " << ce_dumper(non_ignorable);

    // 039C 0041;	
    // (Μ) GREEK CAPITAL LETTER MU	[2031 1CAD | 0020 0020 | 0008 0008 | FFFF FFFF |]
    uint32_t const ces_shifted[12] = { 0x2031, 0x1CAD, 0x0000, 0x0020, 0x0020, 0x0000, 0x0008, 0x0008, 0x0000, 0xFFFF, 0xFFFF, 0x0000 };

    auto const shifted = collate_for_tests(
        cps, cps + 2, boost::text::variable_weighting::shifted);

    EXPECT_EQ(shifted.size(), 12);
    EXPECT_TRUE(boost::algorithm::equal(shifted.begin(), shifted.end(), ces_shifted, ces_shifted + 12))
        << "from:     " << ce_dumper(cps)
        << "expected: " << ce_dumper(ces_shifted)
        << "got:      " << ce_dumper(shifted);
}

TEST(collation, verbatim_131_476)
{
    uint32_t const cps[2] = { 0x1D6B3, 0x0061 };

    // 1D6B3 0061;	
    // (𝚳) MATHEMATICAL BOLD CAPITAL MU	[2031 1CAD | 0020 0020 | 000B 0002 |]
    uint32_t const ces_non_ignorable[9] = { 0x2031, 0x1CAD, 0x0000, 0x0020, 0x0020, 0x0000, 0x000B, 0x0002, 0x0000 };

    auto const non_ignorable = collate_for_tests(
        cps, cps + 2, boost::text::variable_weighting::non_ignorable);

    EXPECT_EQ(non_ignorable.size(), 9);
    EXPECT_TRUE(boost::algorithm::equal(non_ignorable.begin(), non_ignorable.end(), ces_non_ignorable, ces_non_ignorable + 9))
        << "from:     " << ce_dumper(cps)
        << "expected: " << ce_dumper(ces_non_ignorable)
        << "got:      " << ce_dumper(non_ignorable);

    // 1D6B3 0061;	
    // (𝚳) MATHEMATICAL BOLD CAPITAL MU	[2031 1CAD | 0020 0020 | 000B 0002 | FFFF FFFF |]
    uint32_t const ces_shifted[12] = { 0x2031, 0x1CAD, 0x0000, 0x0020, 0x0020, 0x0000, 0x000B, 0x0002, 0x0000, 0xFFFF, 0xFFFF, 0x0000 };

    auto const shifted = collate_for_tests(
        cps, cps + 2, boost::text::variable_weighting::shifted);

    EXPECT_EQ(shifted.size(), 12);
    EXPECT_TRUE(boost::algorithm::equal(shifted.begin(), shifted.end(), ces_shifted, ces_shifted + 12))
        << "from:     " << ce_dumper(cps)
        << "expected: " << ce_dumper(ces_shifted)
        << "got:      " << ce_dumper(shifted);
}

TEST(collation, verbatim_131_477)
{
    uint32_t const cps[2] = { 0x1D6ED, 0x0061 };

    // 1D6ED 0061;	
    // (𝛭) MATHEMATICAL ITALIC CAPITAL MU	[2031 1CAD | 0020 0020 | 000B 0002 |]
    uint32_t const ces_non_ignorable[9] = { 0x2031, 0x1CAD, 0x0000, 0x0020, 0x0020, 0x0000, 0x000B, 0x0002, 0x0000 };

    auto const non_ignorable = collate_for_tests(
        cps, cps + 2, boost::text::variable_weighting::non_ignorable);

    EXPECT_EQ(non_ignorable.size(), 9);
    EXPECT_TRUE(boost::algorithm::equal(non_ignorable.begin(), non_ignorable.end(), ces_non_ignorable, ces_non_ignorable + 9))
        << "from:     " << ce_dumper(cps)
        << "expected: " << ce_dumper(ces_non_ignorable)
        << "got:      " << ce_dumper(non_ignorable);

    // 1D6ED 0061;	
    // (𝛭) MATHEMATICAL ITALIC CAPITAL MU	[2031 1CAD | 0020 0020 | 000B 0002 | FFFF FFFF |]
    uint32_t const ces_shifted[12] = { 0x2031, 0x1CAD, 0x0000, 0x0020, 0x0020, 0x0000, 0x000B, 0x0002, 0x0000, 0xFFFF, 0xFFFF, 0x0000 };

    auto const shifted = collate_for_tests(
        cps, cps + 2, boost::text::variable_weighting::shifted);

    EXPECT_EQ(shifted.size(), 12);
    EXPECT_TRUE(boost::algorithm::equal(shifted.begin(), shifted.end(), ces_shifted, ces_shifted + 12))
        << "from:     " << ce_dumper(cps)
        << "expected: " << ce_dumper(ces_shifted)
        << "got:      " << ce_dumper(shifted);
}

TEST(collation, verbatim_131_478)
{
    uint32_t const cps[2] = { 0x1D727, 0x0061 };

    // 1D727 0061;	
    // (𝜧) MATHEMATICAL BOLD ITALIC CAPITAL MU	[2031 1CAD | 0020 0020 | 000B 0002 |]
    uint32_t const ces_non_ignorable[9] = { 0x2031, 0x1CAD, 0x0000, 0x0020, 0x0020, 0x0000, 0x000B, 0x0002, 0x0000 };

    auto const non_ignorable = collate_for_tests(
        cps, cps + 2, boost::text::variable_weighting::non_ignorable);

    EXPECT_EQ(non_ignorable.size(), 9);
    EXPECT_TRUE(boost::algorithm::equal(non_ignorable.begin(), non_ignorable.end(), ces_non_ignorable, ces_non_ignorable + 9))
        << "from:     " << ce_dumper(cps)
        << "expected: " << ce_dumper(ces_non_ignorable)
        << "got:      " << ce_dumper(non_ignorable);

    // 1D727 0061;	
    // (𝜧) MATHEMATICAL BOLD ITALIC CAPITAL MU	[2031 1CAD | 0020 0020 | 000B 0002 | FFFF FFFF |]
    uint32_t const ces_shifted[12] = { 0x2031, 0x1CAD, 0x0000, 0x0020, 0x0020, 0x0000, 0x000B, 0x0002, 0x0000, 0xFFFF, 0xFFFF, 0x0000 };

    auto const shifted = collate_for_tests(
        cps, cps + 2, boost::text::variable_weighting::shifted);

    EXPECT_EQ(shifted.size(), 12);
    EXPECT_TRUE(boost::algorithm::equal(shifted.begin(), shifted.end(), ces_shifted, ces_shifted + 12))
        << "from:     " << ce_dumper(cps)
        << "expected: " << ce_dumper(ces_shifted)
        << "got:      " << ce_dumper(shifted);
}

TEST(collation, verbatim_131_479)
{
    uint32_t const cps[2] = { 0x1D761, 0x0061 };

    // 1D761 0061;	
    // (𝝡) MATHEMATICAL SANS-SERIF BOLD CAPITAL MU	[2031 1CAD | 0020 0020 | 000B 0002 |]
    uint32_t const ces_non_ignorable[9] = { 0x2031, 0x1CAD, 0x0000, 0x0020, 0x0020, 0x0000, 0x000B, 0x0002, 0x0000 };

    auto const non_ignorable = collate_for_tests(
        cps, cps + 2, boost::text::variable_weighting::non_ignorable);

    EXPECT_EQ(non_ignorable.size(), 9);
    EXPECT_TRUE(boost::algorithm::equal(non_ignorable.begin(), non_ignorable.end(), ces_non_ignorable, ces_non_ignorable + 9))
        << "from:     " << ce_dumper(cps)
        << "expected: " << ce_dumper(ces_non_ignorable)
        << "got:      " << ce_dumper(non_ignorable);

    // 1D761 0061;	
    // (𝝡) MATHEMATICAL SANS-SERIF BOLD CAPITAL MU	[2031 1CAD | 0020 0020 | 000B 0002 | FFFF FFFF |]
    uint32_t const ces_shifted[12] = { 0x2031, 0x1CAD, 0x0000, 0x0020, 0x0020, 0x0000, 0x000B, 0x0002, 0x0000, 0xFFFF, 0xFFFF, 0x0000 };

    auto const shifted = collate_for_tests(
        cps, cps + 2, boost::text::variable_weighting::shifted);

    EXPECT_EQ(shifted.size(), 12);
    EXPECT_TRUE(boost::algorithm::equal(shifted.begin(), shifted.end(), ces_shifted, ces_shifted + 12))
        << "from:     " << ce_dumper(cps)
        << "expected: " << ce_dumper(ces_shifted)
        << "got:      " << ce_dumper(shifted);
}

TEST(collation, verbatim_131_480)
{
    uint32_t const cps[2] = { 0x1D79B, 0x0061 };

    // 1D79B 0061;	
    // (𝞛) MATHEMATICAL SANS-SERIF BOLD ITALIC CAPITAL MU	[2031 1CAD | 0020 0020 | 000B 0002 |]
    uint32_t const ces_non_ignorable[9] = { 0x2031, 0x1CAD, 0x0000, 0x0020, 0x0020, 0x0000, 0x000B, 0x0002, 0x0000 };

    auto const non_ignorable = collate_for_tests(
        cps, cps + 2, boost::text::variable_weighting::non_ignorable);

    EXPECT_EQ(non_ignorable.size(), 9);
    EXPECT_TRUE(boost::algorithm::equal(non_ignorable.begin(), non_ignorable.end(), ces_non_ignorable, ces_non_ignorable + 9))
        << "from:     " << ce_dumper(cps)
        << "expected: " << ce_dumper(ces_non_ignorable)
        << "got:      " << ce_dumper(non_ignorable);

    // 1D79B 0061;	
    // (𝞛) MATHEMATICAL SANS-SERIF BOLD ITALIC CAPITAL MU	[2031 1CAD | 0020 0020 | 000B 0002 | FFFF FFFF |]
    uint32_t const ces_shifted[12] = { 0x2031, 0x1CAD, 0x0000, 0x0020, 0x0020, 0x0000, 0x000B, 0x0002, 0x0000, 0xFFFF, 0xFFFF, 0x0000 };

    auto const shifted = collate_for_tests(
        cps, cps + 2, boost::text::variable_weighting::shifted);

    EXPECT_EQ(shifted.size(), 12);
    EXPECT_TRUE(boost::algorithm::equal(shifted.begin(), shifted.end(), ces_shifted, ces_shifted + 12))
        << "from:     " << ce_dumper(cps)
        << "expected: " << ce_dumper(ces_shifted)
        << "got:      " << ce_dumper(shifted);
}

TEST(collation, verbatim_131_481)
{
    uint32_t const cps[2] = { 0x1D6B3, 0x0041 };

    // 1D6B3 0041;	
    // (𝚳) MATHEMATICAL BOLD CAPITAL MU	[2031 1CAD | 0020 0020 | 000B 0008 |]
    uint32_t const ces_non_ignorable[9] = { 0x2031, 0x1CAD, 0x0000, 0x0020, 0x0020, 0x0000, 0x000B, 0x0008, 0x0000 };

    auto const non_ignorable = collate_for_tests(
        cps, cps + 2, boost::text::variable_weighting::non_ignorable);

    EXPECT_EQ(non_ignorable.size(), 9);
    EXPECT_TRUE(boost::algorithm::equal(non_ignorable.begin(), non_ignorable.end(), ces_non_ignorable, ces_non_ignorable + 9))
        << "from:     " << ce_dumper(cps)
        << "expected: " << ce_dumper(ces_non_ignorable)
        << "got:      " << ce_dumper(non_ignorable);

    // 1D6B3 0041;	
    // (𝚳) MATHEMATICAL BOLD CAPITAL MU	[2031 1CAD | 0020 0020 | 000B 0008 | FFFF FFFF |]
    uint32_t const ces_shifted[12] = { 0x2031, 0x1CAD, 0x0000, 0x0020, 0x0020, 0x0000, 0x000B, 0x0008, 0x0000, 0xFFFF, 0xFFFF, 0x0000 };

    auto const shifted = collate_for_tests(
        cps, cps + 2, boost::text::variable_weighting::shifted);

    EXPECT_EQ(shifted.size(), 12);
    EXPECT_TRUE(boost::algorithm::equal(shifted.begin(), shifted.end(), ces_shifted, ces_shifted + 12))
        << "from:     " << ce_dumper(cps)
        << "expected: " << ce_dumper(ces_shifted)
        << "got:      " << ce_dumper(shifted);
}

TEST(collation, verbatim_131_482)
{
    uint32_t const cps[2] = { 0x1D6ED, 0x0041 };

    // 1D6ED 0041;	
    // (𝛭) MATHEMATICAL ITALIC CAPITAL MU	[2031 1CAD | 0020 0020 | 000B 0008 |]
    uint32_t const ces_non_ignorable[9] = { 0x2031, 0x1CAD, 0x0000, 0x0020, 0x0020, 0x0000, 0x000B, 0x0008, 0x0000 };

    auto const non_ignorable = collate_for_tests(
        cps, cps + 2, boost::text::variable_weighting::non_ignorable);

    EXPECT_EQ(non_ignorable.size(), 9);
    EXPECT_TRUE(boost::algorithm::equal(non_ignorable.begin(), non_ignorable.end(), ces_non_ignorable, ces_non_ignorable + 9))
        << "from:     " << ce_dumper(cps)
        << "expected: " << ce_dumper(ces_non_ignorable)
        << "got:      " << ce_dumper(non_ignorable);

    // 1D6ED 0041;	
    // (𝛭) MATHEMATICAL ITALIC CAPITAL MU	[2031 1CAD | 0020 0020 | 000B 0008 | FFFF FFFF |]
    uint32_t const ces_shifted[12] = { 0x2031, 0x1CAD, 0x0000, 0x0020, 0x0020, 0x0000, 0x000B, 0x0008, 0x0000, 0xFFFF, 0xFFFF, 0x0000 };

    auto const shifted = collate_for_tests(
        cps, cps + 2, boost::text::variable_weighting::shifted);

    EXPECT_EQ(shifted.size(), 12);
    EXPECT_TRUE(boost::algorithm::equal(shifted.begin(), shifted.end(), ces_shifted, ces_shifted + 12))
        << "from:     " << ce_dumper(cps)
        << "expected: " << ce_dumper(ces_shifted)
        << "got:      " << ce_dumper(shifted);
}

TEST(collation, verbatim_131_483)
{
    uint32_t const cps[2] = { 0x1D727, 0x0041 };

    // 1D727 0041;	
    // (𝜧) MATHEMATICAL BOLD ITALIC CAPITAL MU	[2031 1CAD | 0020 0020 | 000B 0008 |]
    uint32_t const ces_non_ignorable[9] = { 0x2031, 0x1CAD, 0x0000, 0x0020, 0x0020, 0x0000, 0x000B, 0x0008, 0x0000 };

    auto const non_ignorable = collate_for_tests(
        cps, cps + 2, boost::text::variable_weighting::non_ignorable);

    EXPECT_EQ(non_ignorable.size(), 9);
    EXPECT_TRUE(boost::algorithm::equal(non_ignorable.begin(), non_ignorable.end(), ces_non_ignorable, ces_non_ignorable + 9))
        << "from:     " << ce_dumper(cps)
        << "expected: " << ce_dumper(ces_non_ignorable)
        << "got:      " << ce_dumper(non_ignorable);

    // 1D727 0041;	
    // (𝜧) MATHEMATICAL BOLD ITALIC CAPITAL MU	[2031 1CAD | 0020 0020 | 000B 0008 | FFFF FFFF |]
    uint32_t const ces_shifted[12] = { 0x2031, 0x1CAD, 0x0000, 0x0020, 0x0020, 0x0000, 0x000B, 0x0008, 0x0000, 0xFFFF, 0xFFFF, 0x0000 };

    auto const shifted = collate_for_tests(
        cps, cps + 2, boost::text::variable_weighting::shifted);

    EXPECT_EQ(shifted.size(), 12);
    EXPECT_TRUE(boost::algorithm::equal(shifted.begin(), shifted.end(), ces_shifted, ces_shifted + 12))
        << "from:     " << ce_dumper(cps)
        << "expected: " << ce_dumper(ces_shifted)
        << "got:      " << ce_dumper(shifted);
}

TEST(collation, verbatim_131_484)
{
    uint32_t const cps[2] = { 0x1D761, 0x0041 };

    // 1D761 0041;	
    // (𝝡) MATHEMATICAL SANS-SERIF BOLD CAPITAL MU	[2031 1CAD | 0020 0020 | 000B 0008 |]
    uint32_t const ces_non_ignorable[9] = { 0x2031, 0x1CAD, 0x0000, 0x0020, 0x0020, 0x0000, 0x000B, 0x0008, 0x0000 };

    auto const non_ignorable = collate_for_tests(
        cps, cps + 2, boost::text::variable_weighting::non_ignorable);

    EXPECT_EQ(non_ignorable.size(), 9);
    EXPECT_TRUE(boost::algorithm::equal(non_ignorable.begin(), non_ignorable.end(), ces_non_ignorable, ces_non_ignorable + 9))
        << "from:     " << ce_dumper(cps)
        << "expected: " << ce_dumper(ces_non_ignorable)
        << "got:      " << ce_dumper(non_ignorable);

    // 1D761 0041;	
    // (𝝡) MATHEMATICAL SANS-SERIF BOLD CAPITAL MU	[2031 1CAD | 0020 0020 | 000B 0008 | FFFF FFFF |]
    uint32_t const ces_shifted[12] = { 0x2031, 0x1CAD, 0x0000, 0x0020, 0x0020, 0x0000, 0x000B, 0x0008, 0x0000, 0xFFFF, 0xFFFF, 0x0000 };

    auto const shifted = collate_for_tests(
        cps, cps + 2, boost::text::variable_weighting::shifted);

    EXPECT_EQ(shifted.size(), 12);
    EXPECT_TRUE(boost::algorithm::equal(shifted.begin(), shifted.end(), ces_shifted, ces_shifted + 12))
        << "from:     " << ce_dumper(cps)
        << "expected: " << ce_dumper(ces_shifted)
        << "got:      " << ce_dumper(shifted);
}

TEST(collation, verbatim_131_485)
{
    uint32_t const cps[2] = { 0x1D79B, 0x0041 };

    // 1D79B 0041;	
    // (𝞛) MATHEMATICAL SANS-SERIF BOLD ITALIC CAPITAL MU	[2031 1CAD | 0020 0020 | 000B 0008 |]
    uint32_t const ces_non_ignorable[9] = { 0x2031, 0x1CAD, 0x0000, 0x0020, 0x0020, 0x0000, 0x000B, 0x0008, 0x0000 };

    auto const non_ignorable = collate_for_tests(
        cps, cps + 2, boost::text::variable_weighting::non_ignorable);

    EXPECT_EQ(non_ignorable.size(), 9);
    EXPECT_TRUE(boost::algorithm::equal(non_ignorable.begin(), non_ignorable.end(), ces_non_ignorable, ces_non_ignorable + 9))
        << "from:     " << ce_dumper(cps)
        << "expected: " << ce_dumper(ces_non_ignorable)
        << "got:      " << ce_dumper(non_ignorable);

    // 1D79B 0041;	
    // (𝞛) MATHEMATICAL SANS-SERIF BOLD ITALIC CAPITAL MU	[2031 1CAD | 0020 0020 | 000B 0008 | FFFF FFFF |]
    uint32_t const ces_shifted[12] = { 0x2031, 0x1CAD, 0x0000, 0x0020, 0x0020, 0x0000, 0x000B, 0x0008, 0x0000, 0xFFFF, 0xFFFF, 0x0000 };

    auto const shifted = collate_for_tests(
        cps, cps + 2, boost::text::variable_weighting::shifted);

    EXPECT_EQ(shifted.size(), 12);
    EXPECT_TRUE(boost::algorithm::equal(shifted.begin(), shifted.end(), ces_shifted, ces_shifted + 12))
        << "from:     " << ce_dumper(cps)
        << "expected: " << ce_dumper(ces_shifted)
        << "got:      " << ce_dumper(shifted);
}

TEST(collation, verbatim_131_486)
{
    uint32_t const cps[2] = { 0x3382, 0x0021 };

    // 3382 0021;	
    // (㎂) SQUARE MU A	[2031 1CAD 0261 | 0020 0020 0020 | 001C 001D 0002 |]
    uint32_t const ces_non_ignorable[12] = { 0x2031, 0x1CAD, 0x0261, 0x0000, 0x0020, 0x0020, 0x0020, 0x0000, 0x001C, 0x001D, 0x0002, 0x0000 };

    auto const non_ignorable = collate_for_tests(
        cps, cps + 2, boost::text::variable_weighting::non_ignorable);

    EXPECT_EQ(non_ignorable.size(), 12);
    EXPECT_TRUE(boost::algorithm::equal(non_ignorable.begin(), non_ignorable.end(), ces_non_ignorable, ces_non_ignorable + 12))
        << "from:     " << ce_dumper(cps)
        << "expected: " << ce_dumper(ces_non_ignorable)
        << "got:      " << ce_dumper(non_ignorable);

    // 3382 0021;	
    // (㎂) SQUARE MU A	[2031 1CAD | 0020 0020 | 001C 001D | FFFF FFFF 0261 |]
    uint32_t const ces_shifted[13] = { 0x2031, 0x1CAD, 0x0000, 0x0020, 0x0020, 0x0000, 0x001C, 0x001D, 0x0000, 0xFFFF, 0xFFFF, 0x0261, 0x0000 };

    auto const shifted = collate_for_tests(
        cps, cps + 2, boost::text::variable_weighting::shifted);

    EXPECT_EQ(shifted.size(), 13);
    EXPECT_TRUE(boost::algorithm::equal(shifted.begin(), shifted.end(), ces_shifted, ces_shifted + 13))
        << "from:     " << ce_dumper(cps)
        << "expected: " << ce_dumper(ces_shifted)
        << "got:      " << ce_dumper(shifted);
}

TEST(collation, verbatim_131_487)
{
    uint32_t const cps[2] = { 0x3382, 0x003F };

    // 3382 003F;	
    // (㎂) SQUARE MU A	[2031 1CAD 0267 | 0020 0020 0020 | 001C 001D 0002 |]
    uint32_t const ces_non_ignorable[12] = { 0x2031, 0x1CAD, 0x0267, 0x0000, 0x0020, 0x0020, 0x0020, 0x0000, 0x001C, 0x001D, 0x0002, 0x0000 };

    auto const non_ignorable = collate_for_tests(
        cps, cps + 2, boost::text::variable_weighting::non_ignorable);

    EXPECT_EQ(non_ignorable.size(), 12);
    EXPECT_TRUE(boost::algorithm::equal(non_ignorable.begin(), non_ignorable.end(), ces_non_ignorable, ces_non_ignorable + 12))
        << "from:     " << ce_dumper(cps)
        << "expected: " << ce_dumper(ces_non_ignorable)
        << "got:      " << ce_dumper(non_ignorable);

    // 3382 003F;	
    // (㎂) SQUARE MU A	[2031 1CAD | 0020 0020 | 001C 001D | FFFF FFFF 0267 |]
    uint32_t const ces_shifted[13] = { 0x2031, 0x1CAD, 0x0000, 0x0020, 0x0020, 0x0000, 0x001C, 0x001D, 0x0000, 0xFFFF, 0xFFFF, 0x0267, 0x0000 };

    auto const shifted = collate_for_tests(
        cps, cps + 2, boost::text::variable_weighting::shifted);

    EXPECT_EQ(shifted.size(), 13);
    EXPECT_TRUE(boost::algorithm::equal(shifted.begin(), shifted.end(), ces_shifted, ces_shifted + 13))
        << "from:     " << ce_dumper(cps)
        << "expected: " << ce_dumper(ces_shifted)
        << "got:      " << ce_dumper(shifted);
}

TEST(collation, verbatim_131_488)
{
    uint32_t const cps[2] = { 0x3382, 0x0061 };

    // 3382 0061;	
    // (㎂) SQUARE MU A	[2031 1CAD 1CAD | 0020 0020 0020 | 001C 001D 0002 |]
    uint32_t const ces_non_ignorable[12] = { 0x2031, 0x1CAD, 0x1CAD, 0x0000, 0x0020, 0x0020, 0x0020, 0x0000, 0x001C, 0x001D, 0x0002, 0x0000 };

    auto const non_ignorable = collate_for_tests(
        cps, cps + 2, boost::text::variable_weighting::non_ignorable);

    EXPECT_EQ(non_ignorable.size(), 12);
    EXPECT_TRUE(boost::algorithm::equal(non_ignorable.begin(), non_ignorable.end(), ces_non_ignorable, ces_non_ignorable + 12))
        << "from:     " << ce_dumper(cps)
        << "expected: " << ce_dumper(ces_non_ignorable)
        << "got:      " << ce_dumper(non_ignorable);

    // 3382 0061;	
    // (㎂) SQUARE MU A	[2031 1CAD 1CAD | 0020 0020 0020 | 001C 001D 0002 | FFFF FFFF FFFF |]
    uint32_t const ces_shifted[16] = { 0x2031, 0x1CAD, 0x1CAD, 0x0000, 0x0020, 0x0020, 0x0020, 0x0000, 0x001C, 0x001D, 0x0002, 0x0000, 0xFFFF, 0xFFFF, 0xFFFF, 0x0000 };

    auto const shifted = collate_for_tests(
        cps, cps + 2, boost::text::variable_weighting::shifted);

    EXPECT_EQ(shifted.size(), 16);
    EXPECT_TRUE(boost::algorithm::equal(shifted.begin(), shifted.end(), ces_shifted, ces_shifted + 16))
        << "from:     " << ce_dumper(cps)
        << "expected: " << ce_dumper(ces_shifted)
        << "got:      " << ce_dumper(shifted);
}

TEST(collation, verbatim_131_489)
{
    uint32_t const cps[2] = { 0x3382, 0x0041 };

    // 3382 0041;	
    // (㎂) SQUARE MU A	[2031 1CAD 1CAD | 0020 0020 0020 | 001C 001D 0008 |]
    uint32_t const ces_non_ignorable[12] = { 0x2031, 0x1CAD, 0x1CAD, 0x0000, 0x0020, 0x0020, 0x0020, 0x0000, 0x001C, 0x001D, 0x0008, 0x0000 };

    auto const non_ignorable = collate_for_tests(
        cps, cps + 2, boost::text::variable_weighting::non_ignorable);

    EXPECT_EQ(non_ignorable.size(), 12);
    EXPECT_TRUE(boost::algorithm::equal(non_ignorable.begin(), non_ignorable.end(), ces_non_ignorable, ces_non_ignorable + 12))
        << "from:     " << ce_dumper(cps)
        << "expected: " << ce_dumper(ces_non_ignorable)
        << "got:      " << ce_dumper(non_ignorable);

    // 3382 0041;	
    // (㎂) SQUARE MU A	[2031 1CAD 1CAD | 0020 0020 0020 | 001C 001D 0008 | FFFF FFFF FFFF |]
    uint32_t const ces_shifted[16] = { 0x2031, 0x1CAD, 0x1CAD, 0x0000, 0x0020, 0x0020, 0x0020, 0x0000, 0x001C, 0x001D, 0x0008, 0x0000, 0xFFFF, 0xFFFF, 0xFFFF, 0x0000 };

    auto const shifted = collate_for_tests(
        cps, cps + 2, boost::text::variable_weighting::shifted);

    EXPECT_EQ(shifted.size(), 16);
    EXPECT_TRUE(boost::algorithm::equal(shifted.begin(), shifted.end(), ces_shifted, ces_shifted + 16))
        << "from:     " << ce_dumper(cps)
        << "expected: " << ce_dumper(ces_shifted)
        << "got:      " << ce_dumper(shifted);
}

TEST(collation, verbatim_131_490)
{
    uint32_t const cps[2] = { 0x3382, 0x0062 };

    // 3382 0062;	
    // (㎂) SQUARE MU A	[2031 1CAD 1CC6 | 0020 0020 0020 | 001C 001D 0002 |]
    uint32_t const ces_non_ignorable[12] = { 0x2031, 0x1CAD, 0x1CC6, 0x0000, 0x0020, 0x0020, 0x0020, 0x0000, 0x001C, 0x001D, 0x0002, 0x0000 };

    auto const non_ignorable = collate_for_tests(
        cps, cps + 2, boost::text::variable_weighting::non_ignorable);

    EXPECT_EQ(non_ignorable.size(), 12);
    EXPECT_TRUE(boost::algorithm::equal(non_ignorable.begin(), non_ignorable.end(), ces_non_ignorable, ces_non_ignorable + 12))
        << "from:     " << ce_dumper(cps)
        << "expected: " << ce_dumper(ces_non_ignorable)
        << "got:      " << ce_dumper(non_ignorable);

    // 3382 0062;	
    // (㎂) SQUARE MU A	[2031 1CAD 1CC6 | 0020 0020 0020 | 001C 001D 0002 | FFFF FFFF FFFF |]
    uint32_t const ces_shifted[16] = { 0x2031, 0x1CAD, 0x1CC6, 0x0000, 0x0020, 0x0020, 0x0020, 0x0000, 0x001C, 0x001D, 0x0002, 0x0000, 0xFFFF, 0xFFFF, 0xFFFF, 0x0000 };

    auto const shifted = collate_for_tests(
        cps, cps + 2, boost::text::variable_weighting::shifted);

    EXPECT_EQ(shifted.size(), 16);
    EXPECT_TRUE(boost::algorithm::equal(shifted.begin(), shifted.end(), ces_shifted, ces_shifted + 16))
        << "from:     " << ce_dumper(cps)
        << "expected: " << ce_dumper(ces_shifted)
        << "got:      " << ce_dumper(shifted);
}

TEST(collation, verbatim_131_491)
{
    uint32_t const cps[2] = { 0x03BC, 0x0062 };

    // 03BC 0062;	
    // (μ) GREEK SMALL LETTER MU	[2031 1CC6 | 0020 0020 | 0002 0002 |]
    uint32_t const ces_non_ignorable[9] = { 0x2031, 0x1CC6, 0x0000, 0x0020, 0x0020, 0x0000, 0x0002, 0x0002, 0x0000 };

    auto const non_ignorable = collate_for_tests(
        cps, cps + 2, boost::text::variable_weighting::non_ignorable);

    EXPECT_EQ(non_ignorable.size(), 9);
    EXPECT_TRUE(boost::algorithm::equal(non_ignorable.begin(), non_ignorable.end(), ces_non_ignorable, ces_non_ignorable + 9))
        << "from:     " << ce_dumper(cps)
        << "expected: " << ce_dumper(ces_non_ignorable)
        << "got:      " << ce_dumper(non_ignorable);

    // 03BC 0062;	
    // (μ) GREEK SMALL LETTER MU	[2031 1CC6 | 0020 0020 | 0002 0002 | FFFF FFFF |]
    uint32_t const ces_shifted[12] = { 0x2031, 0x1CC6, 0x0000, 0x0020, 0x0020, 0x0000, 0x0002, 0x0002, 0x0000, 0xFFFF, 0xFFFF, 0x0000 };

    auto const shifted = collate_for_tests(
        cps, cps + 2, boost::text::variable_weighting::shifted);

    EXPECT_EQ(shifted.size(), 12);
    EXPECT_TRUE(boost::algorithm::equal(shifted.begin(), shifted.end(), ces_shifted, ces_shifted + 12))
        << "from:     " << ce_dumper(cps)
        << "expected: " << ce_dumper(ces_shifted)
        << "got:      " << ce_dumper(shifted);
}

TEST(collation, verbatim_131_492)
{
    uint32_t const cps[2] = { 0x00B5, 0x0062 };

    // 00B5 0062;	
    // (µ) MICRO SIGN	[2031 1CC6 | 0020 0020 | 0004 0002 |]
    uint32_t const ces_non_ignorable[9] = { 0x2031, 0x1CC6, 0x0000, 0x0020, 0x0020, 0x0000, 0x0004, 0x0002, 0x0000 };

    auto const non_ignorable = collate_for_tests(
        cps, cps + 2, boost::text::variable_weighting::non_ignorable);

    EXPECT_EQ(non_ignorable.size(), 9);
    EXPECT_TRUE(boost::algorithm::equal(non_ignorable.begin(), non_ignorable.end(), ces_non_ignorable, ces_non_ignorable + 9))
        << "from:     " << ce_dumper(cps)
        << "expected: " << ce_dumper(ces_non_ignorable)
        << "got:      " << ce_dumper(non_ignorable);

    // 00B5 0062;	
    // (µ) MICRO SIGN	[2031 1CC6 | 0020 0020 | 0004 0002 | FFFF FFFF |]
    uint32_t const ces_shifted[12] = { 0x2031, 0x1CC6, 0x0000, 0x0020, 0x0020, 0x0000, 0x0004, 0x0002, 0x0000, 0xFFFF, 0xFFFF, 0x0000 };

    auto const shifted = collate_for_tests(
        cps, cps + 2, boost::text::variable_weighting::shifted);

    EXPECT_EQ(shifted.size(), 12);
    EXPECT_TRUE(boost::algorithm::equal(shifted.begin(), shifted.end(), ces_shifted, ces_shifted + 12))
        << "from:     " << ce_dumper(cps)
        << "expected: " << ce_dumper(ces_shifted)
        << "got:      " << ce_dumper(shifted);
}

TEST(collation, verbatim_131_493)
{
    uint32_t const cps[2] = { 0x1D6CD, 0x0062 };

    // 1D6CD 0062;	
    // (𝛍) MATHEMATICAL BOLD SMALL MU	[2031 1CC6 | 0020 0020 | 0005 0002 |]
    uint32_t const ces_non_ignorable[9] = { 0x2031, 0x1CC6, 0x0000, 0x0020, 0x0020, 0x0000, 0x0005, 0x0002, 0x0000 };

    auto const non_ignorable = collate_for_tests(
        cps, cps + 2, boost::text::variable_weighting::non_ignorable);

    EXPECT_EQ(non_ignorable.size(), 9);
    EXPECT_TRUE(boost::algorithm::equal(non_ignorable.begin(), non_ignorable.end(), ces_non_ignorable, ces_non_ignorable + 9))
        << "from:     " << ce_dumper(cps)
        << "expected: " << ce_dumper(ces_non_ignorable)
        << "got:      " << ce_dumper(non_ignorable);

    // 1D6CD 0062;	
    // (𝛍) MATHEMATICAL BOLD SMALL MU	[2031 1CC6 | 0020 0020 | 0005 0002 | FFFF FFFF |]
    uint32_t const ces_shifted[12] = { 0x2031, 0x1CC6, 0x0000, 0x0020, 0x0020, 0x0000, 0x0005, 0x0002, 0x0000, 0xFFFF, 0xFFFF, 0x0000 };

    auto const shifted = collate_for_tests(
        cps, cps + 2, boost::text::variable_weighting::shifted);

    EXPECT_EQ(shifted.size(), 12);
    EXPECT_TRUE(boost::algorithm::equal(shifted.begin(), shifted.end(), ces_shifted, ces_shifted + 12))
        << "from:     " << ce_dumper(cps)
        << "expected: " << ce_dumper(ces_shifted)
        << "got:      " << ce_dumper(shifted);
}

TEST(collation, verbatim_131_494)
{
    uint32_t const cps[2] = { 0x1D707, 0x0062 };

    // 1D707 0062;	
    // (𝜇) MATHEMATICAL ITALIC SMALL MU	[2031 1CC6 | 0020 0020 | 0005 0002 |]
    uint32_t const ces_non_ignorable[9] = { 0x2031, 0x1CC6, 0x0000, 0x0020, 0x0020, 0x0000, 0x0005, 0x0002, 0x0000 };

    auto const non_ignorable = collate_for_tests(
        cps, cps + 2, boost::text::variable_weighting::non_ignorable);

    EXPECT_EQ(non_ignorable.size(), 9);
    EXPECT_TRUE(boost::algorithm::equal(non_ignorable.begin(), non_ignorable.end(), ces_non_ignorable, ces_non_ignorable + 9))
        << "from:     " << ce_dumper(cps)
        << "expected: " << ce_dumper(ces_non_ignorable)
        << "got:      " << ce_dumper(non_ignorable);

    // 1D707 0062;	
    // (𝜇) MATHEMATICAL ITALIC SMALL MU	[2031 1CC6 | 0020 0020 | 0005 0002 | FFFF FFFF |]
    uint32_t const ces_shifted[12] = { 0x2031, 0x1CC6, 0x0000, 0x0020, 0x0020, 0x0000, 0x0005, 0x0002, 0x0000, 0xFFFF, 0xFFFF, 0x0000 };

    auto const shifted = collate_for_tests(
        cps, cps + 2, boost::text::variable_weighting::shifted);

    EXPECT_EQ(shifted.size(), 12);
    EXPECT_TRUE(boost::algorithm::equal(shifted.begin(), shifted.end(), ces_shifted, ces_shifted + 12))
        << "from:     " << ce_dumper(cps)
        << "expected: " << ce_dumper(ces_shifted)
        << "got:      " << ce_dumper(shifted);
}

TEST(collation, verbatim_131_495)
{
    uint32_t const cps[2] = { 0x1D741, 0x0062 };

    // 1D741 0062;	
    // (𝝁) MATHEMATICAL BOLD ITALIC SMALL MU	[2031 1CC6 | 0020 0020 | 0005 0002 |]
    uint32_t const ces_non_ignorable[9] = { 0x2031, 0x1CC6, 0x0000, 0x0020, 0x0020, 0x0000, 0x0005, 0x0002, 0x0000 };

    auto const non_ignorable = collate_for_tests(
        cps, cps + 2, boost::text::variable_weighting::non_ignorable);

    EXPECT_EQ(non_ignorable.size(), 9);
    EXPECT_TRUE(boost::algorithm::equal(non_ignorable.begin(), non_ignorable.end(), ces_non_ignorable, ces_non_ignorable + 9))
        << "from:     " << ce_dumper(cps)
        << "expected: " << ce_dumper(ces_non_ignorable)
        << "got:      " << ce_dumper(non_ignorable);

    // 1D741 0062;	
    // (𝝁) MATHEMATICAL BOLD ITALIC SMALL MU	[2031 1CC6 | 0020 0020 | 0005 0002 | FFFF FFFF |]
    uint32_t const ces_shifted[12] = { 0x2031, 0x1CC6, 0x0000, 0x0020, 0x0020, 0x0000, 0x0005, 0x0002, 0x0000, 0xFFFF, 0xFFFF, 0x0000 };

    auto const shifted = collate_for_tests(
        cps, cps + 2, boost::text::variable_weighting::shifted);

    EXPECT_EQ(shifted.size(), 12);
    EXPECT_TRUE(boost::algorithm::equal(shifted.begin(), shifted.end(), ces_shifted, ces_shifted + 12))
        << "from:     " << ce_dumper(cps)
        << "expected: " << ce_dumper(ces_shifted)
        << "got:      " << ce_dumper(shifted);
}

TEST(collation, verbatim_131_496)
{
    uint32_t const cps[2] = { 0x1D77B, 0x0062 };

    // 1D77B 0062;	
    // (𝝻) MATHEMATICAL SANS-SERIF BOLD SMALL MU	[2031 1CC6 | 0020 0020 | 0005 0002 |]
    uint32_t const ces_non_ignorable[9] = { 0x2031, 0x1CC6, 0x0000, 0x0020, 0x0020, 0x0000, 0x0005, 0x0002, 0x0000 };

    auto const non_ignorable = collate_for_tests(
        cps, cps + 2, boost::text::variable_weighting::non_ignorable);

    EXPECT_EQ(non_ignorable.size(), 9);
    EXPECT_TRUE(boost::algorithm::equal(non_ignorable.begin(), non_ignorable.end(), ces_non_ignorable, ces_non_ignorable + 9))
        << "from:     " << ce_dumper(cps)
        << "expected: " << ce_dumper(ces_non_ignorable)
        << "got:      " << ce_dumper(non_ignorable);

    // 1D77B 0062;	
    // (𝝻) MATHEMATICAL SANS-SERIF BOLD SMALL MU	[2031 1CC6 | 0020 0020 | 0005 0002 | FFFF FFFF |]
    uint32_t const ces_shifted[12] = { 0x2031, 0x1CC6, 0x0000, 0x0020, 0x0020, 0x0000, 0x0005, 0x0002, 0x0000, 0xFFFF, 0xFFFF, 0x0000 };

    auto const shifted = collate_for_tests(
        cps, cps + 2, boost::text::variable_weighting::shifted);

    EXPECT_EQ(shifted.size(), 12);
    EXPECT_TRUE(boost::algorithm::equal(shifted.begin(), shifted.end(), ces_shifted, ces_shifted + 12))
        << "from:     " << ce_dumper(cps)
        << "expected: " << ce_dumper(ces_shifted)
        << "got:      " << ce_dumper(shifted);
}

TEST(collation, verbatim_131_497)
{
    uint32_t const cps[2] = { 0x1D7B5, 0x0062 };

    // 1D7B5 0062;	
    // (𝞵) MATHEMATICAL SANS-SERIF BOLD ITALIC SMALL MU	[2031 1CC6 | 0020 0020 | 0005 0002 |]
    uint32_t const ces_non_ignorable[9] = { 0x2031, 0x1CC6, 0x0000, 0x0020, 0x0020, 0x0000, 0x0005, 0x0002, 0x0000 };

    auto const non_ignorable = collate_for_tests(
        cps, cps + 2, boost::text::variable_weighting::non_ignorable);

    EXPECT_EQ(non_ignorable.size(), 9);
    EXPECT_TRUE(boost::algorithm::equal(non_ignorable.begin(), non_ignorable.end(), ces_non_ignorable, ces_non_ignorable + 9))
        << "from:     " << ce_dumper(cps)
        << "expected: " << ce_dumper(ces_non_ignorable)
        << "got:      " << ce_dumper(non_ignorable);

    // 1D7B5 0062;	
    // (𝞵) MATHEMATICAL SANS-SERIF BOLD ITALIC SMALL MU	[2031 1CC6 | 0020 0020 | 0005 0002 | FFFF FFFF |]
    uint32_t const ces_shifted[12] = { 0x2031, 0x1CC6, 0x0000, 0x0020, 0x0020, 0x0000, 0x0005, 0x0002, 0x0000, 0xFFFF, 0xFFFF, 0x0000 };

    auto const shifted = collate_for_tests(
        cps, cps + 2, boost::text::variable_weighting::shifted);

    EXPECT_EQ(shifted.size(), 12);
    EXPECT_TRUE(boost::algorithm::equal(shifted.begin(), shifted.end(), ces_shifted, ces_shifted + 12))
        << "from:     " << ce_dumper(cps)
        << "expected: " << ce_dumper(ces_shifted)
        << "got:      " << ce_dumper(shifted);
}

TEST(collation, verbatim_131_498)
{
    uint32_t const cps[2] = { 0x039C, 0x0062 };

    // 039C 0062;	
    // (Μ) GREEK CAPITAL LETTER MU	[2031 1CC6 | 0020 0020 | 0008 0002 |]
    uint32_t const ces_non_ignorable[9] = { 0x2031, 0x1CC6, 0x0000, 0x0020, 0x0020, 0x0000, 0x0008, 0x0002, 0x0000 };

    auto const non_ignorable = collate_for_tests(
        cps, cps + 2, boost::text::variable_weighting::non_ignorable);

    EXPECT_EQ(non_ignorable.size(), 9);
    EXPECT_TRUE(boost::algorithm::equal(non_ignorable.begin(), non_ignorable.end(), ces_non_ignorable, ces_non_ignorable + 9))
        << "from:     " << ce_dumper(cps)
        << "expected: " << ce_dumper(ces_non_ignorable)
        << "got:      " << ce_dumper(non_ignorable);

    // 039C 0062;	
    // (Μ) GREEK CAPITAL LETTER MU	[2031 1CC6 | 0020 0020 | 0008 0002 | FFFF FFFF |]
    uint32_t const ces_shifted[12] = { 0x2031, 0x1CC6, 0x0000, 0x0020, 0x0020, 0x0000, 0x0008, 0x0002, 0x0000, 0xFFFF, 0xFFFF, 0x0000 };

    auto const shifted = collate_for_tests(
        cps, cps + 2, boost::text::variable_weighting::shifted);

    EXPECT_EQ(shifted.size(), 12);
    EXPECT_TRUE(boost::algorithm::equal(shifted.begin(), shifted.end(), ces_shifted, ces_shifted + 12))
        << "from:     " << ce_dumper(cps)
        << "expected: " << ce_dumper(ces_shifted)
        << "got:      " << ce_dumper(shifted);
}

TEST(collation, verbatim_131_499)
{
    uint32_t const cps[2] = { 0x1D6B3, 0x0062 };

    // 1D6B3 0062;	
    // (𝚳) MATHEMATICAL BOLD CAPITAL MU	[2031 1CC6 | 0020 0020 | 000B 0002 |]
    uint32_t const ces_non_ignorable[9] = { 0x2031, 0x1CC6, 0x0000, 0x0020, 0x0020, 0x0000, 0x000B, 0x0002, 0x0000 };

    auto const non_ignorable = collate_for_tests(
        cps, cps + 2, boost::text::variable_weighting::non_ignorable);

    EXPECT_EQ(non_ignorable.size(), 9);
    EXPECT_TRUE(boost::algorithm::equal(non_ignorable.begin(), non_ignorable.end(), ces_non_ignorable, ces_non_ignorable + 9))
        << "from:     " << ce_dumper(cps)
        << "expected: " << ce_dumper(ces_non_ignorable)
        << "got:      " << ce_dumper(non_ignorable);

    // 1D6B3 0062;	
    // (𝚳) MATHEMATICAL BOLD CAPITAL MU	[2031 1CC6 | 0020 0020 | 000B 0002 | FFFF FFFF |]
    uint32_t const ces_shifted[12] = { 0x2031, 0x1CC6, 0x0000, 0x0020, 0x0020, 0x0000, 0x000B, 0x0002, 0x0000, 0xFFFF, 0xFFFF, 0x0000 };

    auto const shifted = collate_for_tests(
        cps, cps + 2, boost::text::variable_weighting::shifted);

    EXPECT_EQ(shifted.size(), 12);
    EXPECT_TRUE(boost::algorithm::equal(shifted.begin(), shifted.end(), ces_shifted, ces_shifted + 12))
        << "from:     " << ce_dumper(cps)
        << "expected: " << ce_dumper(ces_shifted)
        << "got:      " << ce_dumper(shifted);
}

