// Warning! This file is autogenerated.
#include "collation_tests.hpp"

#include <boost/algorithm/cxx14/equal.hpp>

#include <gtest/gtest.h>



TEST(collation, non_ignorable_121_000)
{
    // 0165 0041;	
    // (ť) LATIN SMALL LETTER T WITH CARON	[1EFB 1CAD | 0020 0028 0020 | 0002 0002 0008 |]

    uint32_t cps[2] = { 0x0165, 0x0041 };
    uint32_t const ces[11] = { 0x1EFB, 0x1CAD, 0x0000, 0x0020, 0x0028, 0x0020, 0x0000, 0x0002, 0x0002, 0x0008, 0x0000 };

    auto collation = collate_for_tests(
        cps, cps + 2, boost::text::variable_weighting::non_ignorable);

    EXPECT_EQ(collation.size(), 11);
    EXPECT_TRUE(boost::algorithm::equal(collation.begin(), collation.end(), ces, ces + 11))
        << "from:     " << ce_dumper(cps)
        << "expected: " << ce_dumper(ces)
        << "got:      " << ce_dumper(collation);
}

TEST(collation, non_ignorable_121_001)
{
    // 0164 0061;	
    // (Ť) LATIN CAPITAL LETTER T WITH CARON	[1EFB 1CAD | 0020 0028 0020 | 0008 0002 0002 |]

    uint32_t cps[2] = { 0x0164, 0x0061 };
    uint32_t const ces[11] = { 0x1EFB, 0x1CAD, 0x0000, 0x0020, 0x0028, 0x0020, 0x0000, 0x0008, 0x0002, 0x0002, 0x0000 };

    auto collation = collate_for_tests(
        cps, cps + 2, boost::text::variable_weighting::non_ignorable);

    EXPECT_EQ(collation.size(), 11);
    EXPECT_TRUE(boost::algorithm::equal(collation.begin(), collation.end(), ces, ces + 11))
        << "from:     " << ce_dumper(cps)
        << "expected: " << ce_dumper(ces)
        << "got:      " << ce_dumper(collation);
}

TEST(collation, non_ignorable_121_002)
{
    // 0164 0041;	
    // (Ť) LATIN CAPITAL LETTER T WITH CARON	[1EFB 1CAD | 0020 0028 0020 | 0008 0002 0008 |]

    uint32_t cps[2] = { 0x0164, 0x0041 };
    uint32_t const ces[11] = { 0x1EFB, 0x1CAD, 0x0000, 0x0020, 0x0028, 0x0020, 0x0000, 0x0008, 0x0002, 0x0008, 0x0000 };

    auto collation = collate_for_tests(
        cps, cps + 2, boost::text::variable_weighting::non_ignorable);

    EXPECT_EQ(collation.size(), 11);
    EXPECT_TRUE(boost::algorithm::equal(collation.begin(), collation.end(), ces, ces + 11))
        << "from:     " << ce_dumper(cps)
        << "expected: " << ce_dumper(ces)
        << "got:      " << ce_dumper(collation);
}

TEST(collation, non_ignorable_121_003)
{
    // 1E97 0061;	
    // (ẗ) LATIN SMALL LETTER T WITH DIAERESIS	[1EFB 1CAD | 0020 002B 0020 | 0002 0002 0002 |]

    uint32_t cps[2] = { 0x1E97, 0x0061 };
    uint32_t const ces[11] = { 0x1EFB, 0x1CAD, 0x0000, 0x0020, 0x002B, 0x0020, 0x0000, 0x0002, 0x0002, 0x0002, 0x0000 };

    auto collation = collate_for_tests(
        cps, cps + 2, boost::text::variable_weighting::non_ignorable);

    EXPECT_EQ(collation.size(), 11);
    EXPECT_TRUE(boost::algorithm::equal(collation.begin(), collation.end(), ces, ces + 11))
        << "from:     " << ce_dumper(cps)
        << "expected: " << ce_dumper(ces)
        << "got:      " << ce_dumper(collation);
}

TEST(collation, non_ignorable_121_004)
{
    // 1E97 0041;	
    // (ẗ) LATIN SMALL LETTER T WITH DIAERESIS	[1EFB 1CAD | 0020 002B 0020 | 0002 0002 0008 |]

    uint32_t cps[2] = { 0x1E97, 0x0041 };
    uint32_t const ces[11] = { 0x1EFB, 0x1CAD, 0x0000, 0x0020, 0x002B, 0x0020, 0x0000, 0x0002, 0x0002, 0x0008, 0x0000 };

    auto collation = collate_for_tests(
        cps, cps + 2, boost::text::variable_weighting::non_ignorable);

    EXPECT_EQ(collation.size(), 11);
    EXPECT_TRUE(boost::algorithm::equal(collation.begin(), collation.end(), ces, ces + 11))
        << "from:     " << ce_dumper(cps)
        << "expected: " << ce_dumper(ces)
        << "got:      " << ce_dumper(collation);
}

TEST(collation, non_ignorable_121_005)
{
    // 1E6B 0061;	
    // (ṫ) LATIN SMALL LETTER T WITH DOT ABOVE	[1EFB 1CAD | 0020 002E 0020 | 0002 0002 0002 |]

    uint32_t cps[2] = { 0x1E6B, 0x0061 };
    uint32_t const ces[11] = { 0x1EFB, 0x1CAD, 0x0000, 0x0020, 0x002E, 0x0020, 0x0000, 0x0002, 0x0002, 0x0002, 0x0000 };

    auto collation = collate_for_tests(
        cps, cps + 2, boost::text::variable_weighting::non_ignorable);

    EXPECT_EQ(collation.size(), 11);
    EXPECT_TRUE(boost::algorithm::equal(collation.begin(), collation.end(), ces, ces + 11))
        << "from:     " << ce_dumper(cps)
        << "expected: " << ce_dumper(ces)
        << "got:      " << ce_dumper(collation);
}

TEST(collation, non_ignorable_121_006)
{
    // 1E6B 0041;	
    // (ṫ) LATIN SMALL LETTER T WITH DOT ABOVE	[1EFB 1CAD | 0020 002E 0020 | 0002 0002 0008 |]

    uint32_t cps[2] = { 0x1E6B, 0x0041 };
    uint32_t const ces[11] = { 0x1EFB, 0x1CAD, 0x0000, 0x0020, 0x002E, 0x0020, 0x0000, 0x0002, 0x0002, 0x0008, 0x0000 };

    auto collation = collate_for_tests(
        cps, cps + 2, boost::text::variable_weighting::non_ignorable);

    EXPECT_EQ(collation.size(), 11);
    EXPECT_TRUE(boost::algorithm::equal(collation.begin(), collation.end(), ces, ces + 11))
        << "from:     " << ce_dumper(cps)
        << "expected: " << ce_dumper(ces)
        << "got:      " << ce_dumper(collation);
}

TEST(collation, non_ignorable_121_007)
{
    // 1E6A 0061;	
    // (Ṫ) LATIN CAPITAL LETTER T WITH DOT ABOVE	[1EFB 1CAD | 0020 002E 0020 | 0008 0002 0002 |]

    uint32_t cps[2] = { 0x1E6A, 0x0061 };
    uint32_t const ces[11] = { 0x1EFB, 0x1CAD, 0x0000, 0x0020, 0x002E, 0x0020, 0x0000, 0x0008, 0x0002, 0x0002, 0x0000 };

    auto collation = collate_for_tests(
        cps, cps + 2, boost::text::variable_weighting::non_ignorable);

    EXPECT_EQ(collation.size(), 11);
    EXPECT_TRUE(boost::algorithm::equal(collation.begin(), collation.end(), ces, ces + 11))
        << "from:     " << ce_dumper(cps)
        << "expected: " << ce_dumper(ces)
        << "got:      " << ce_dumper(collation);
}

TEST(collation, non_ignorable_121_008)
{
    // 1E6A 0041;	
    // (Ṫ) LATIN CAPITAL LETTER T WITH DOT ABOVE	[1EFB 1CAD | 0020 002E 0020 | 0008 0002 0008 |]

    uint32_t cps[2] = { 0x1E6A, 0x0041 };
    uint32_t const ces[11] = { 0x1EFB, 0x1CAD, 0x0000, 0x0020, 0x002E, 0x0020, 0x0000, 0x0008, 0x0002, 0x0008, 0x0000 };

    auto collation = collate_for_tests(
        cps, cps + 2, boost::text::variable_weighting::non_ignorable);

    EXPECT_EQ(collation.size(), 11);
    EXPECT_TRUE(boost::algorithm::equal(collation.begin(), collation.end(), ces, ces + 11))
        << "from:     " << ce_dumper(cps)
        << "expected: " << ce_dumper(ces)
        << "got:      " << ce_dumper(collation);
}

TEST(collation, non_ignorable_121_009)
{
    // 0163 0061;	
    // (ţ) LATIN SMALL LETTER T WITH CEDILLA	[1EFB 1CAD | 0020 0030 0020 | 0002 0002 0002 |]

    uint32_t cps[2] = { 0x0163, 0x0061 };
    uint32_t const ces[11] = { 0x1EFB, 0x1CAD, 0x0000, 0x0020, 0x0030, 0x0020, 0x0000, 0x0002, 0x0002, 0x0002, 0x0000 };

    auto collation = collate_for_tests(
        cps, cps + 2, boost::text::variable_weighting::non_ignorable);

    EXPECT_EQ(collation.size(), 11);
    EXPECT_TRUE(boost::algorithm::equal(collation.begin(), collation.end(), ces, ces + 11))
        << "from:     " << ce_dumper(cps)
        << "expected: " << ce_dumper(ces)
        << "got:      " << ce_dumper(collation);
}

TEST(collation, non_ignorable_121_010)
{
    // 0163 0041;	
    // (ţ) LATIN SMALL LETTER T WITH CEDILLA	[1EFB 1CAD | 0020 0030 0020 | 0002 0002 0008 |]

    uint32_t cps[2] = { 0x0163, 0x0041 };
    uint32_t const ces[11] = { 0x1EFB, 0x1CAD, 0x0000, 0x0020, 0x0030, 0x0020, 0x0000, 0x0002, 0x0002, 0x0008, 0x0000 };

    auto collation = collate_for_tests(
        cps, cps + 2, boost::text::variable_weighting::non_ignorable);

    EXPECT_EQ(collation.size(), 11);
    EXPECT_TRUE(boost::algorithm::equal(collation.begin(), collation.end(), ces, ces + 11))
        << "from:     " << ce_dumper(cps)
        << "expected: " << ce_dumper(ces)
        << "got:      " << ce_dumper(collation);
}

TEST(collation, non_ignorable_121_011)
{
    // 0162 0061;	
    // (Ţ) LATIN CAPITAL LETTER T WITH CEDILLA	[1EFB 1CAD | 0020 0030 0020 | 0008 0002 0002 |]

    uint32_t cps[2] = { 0x0162, 0x0061 };
    uint32_t const ces[11] = { 0x1EFB, 0x1CAD, 0x0000, 0x0020, 0x0030, 0x0020, 0x0000, 0x0008, 0x0002, 0x0002, 0x0000 };

    auto collation = collate_for_tests(
        cps, cps + 2, boost::text::variable_weighting::non_ignorable);

    EXPECT_EQ(collation.size(), 11);
    EXPECT_TRUE(boost::algorithm::equal(collation.begin(), collation.end(), ces, ces + 11))
        << "from:     " << ce_dumper(cps)
        << "expected: " << ce_dumper(ces)
        << "got:      " << ce_dumper(collation);
}

TEST(collation, non_ignorable_121_012)
{
    // 0162 0041;	
    // (Ţ) LATIN CAPITAL LETTER T WITH CEDILLA	[1EFB 1CAD | 0020 0030 0020 | 0008 0002 0008 |]

    uint32_t cps[2] = { 0x0162, 0x0041 };
    uint32_t const ces[11] = { 0x1EFB, 0x1CAD, 0x0000, 0x0020, 0x0030, 0x0020, 0x0000, 0x0008, 0x0002, 0x0008, 0x0000 };

    auto collation = collate_for_tests(
        cps, cps + 2, boost::text::variable_weighting::non_ignorable);

    EXPECT_EQ(collation.size(), 11);
    EXPECT_TRUE(boost::algorithm::equal(collation.begin(), collation.end(), ces, ces + 11))
        << "from:     " << ce_dumper(cps)
        << "expected: " << ce_dumper(ces)
        << "got:      " << ce_dumper(collation);
}

TEST(collation, non_ignorable_121_013)
{
    // 1E6D 0061;	
    // (ṭ) LATIN SMALL LETTER T WITH DOT BELOW	[1EFB 1CAD | 0020 0042 0020 | 0002 0002 0002 |]

    uint32_t cps[2] = { 0x1E6D, 0x0061 };
    uint32_t const ces[11] = { 0x1EFB, 0x1CAD, 0x0000, 0x0020, 0x0042, 0x0020, 0x0000, 0x0002, 0x0002, 0x0002, 0x0000 };

    auto collation = collate_for_tests(
        cps, cps + 2, boost::text::variable_weighting::non_ignorable);

    EXPECT_EQ(collation.size(), 11);
    EXPECT_TRUE(boost::algorithm::equal(collation.begin(), collation.end(), ces, ces + 11))
        << "from:     " << ce_dumper(cps)
        << "expected: " << ce_dumper(ces)
        << "got:      " << ce_dumper(collation);
}

TEST(collation, non_ignorable_121_014)
{
    // 1E6D 0041;	
    // (ṭ) LATIN SMALL LETTER T WITH DOT BELOW	[1EFB 1CAD | 0020 0042 0020 | 0002 0002 0008 |]

    uint32_t cps[2] = { 0x1E6D, 0x0041 };
    uint32_t const ces[11] = { 0x1EFB, 0x1CAD, 0x0000, 0x0020, 0x0042, 0x0020, 0x0000, 0x0002, 0x0002, 0x0008, 0x0000 };

    auto collation = collate_for_tests(
        cps, cps + 2, boost::text::variable_weighting::non_ignorable);

    EXPECT_EQ(collation.size(), 11);
    EXPECT_TRUE(boost::algorithm::equal(collation.begin(), collation.end(), ces, ces + 11))
        << "from:     " << ce_dumper(cps)
        << "expected: " << ce_dumper(ces)
        << "got:      " << ce_dumper(collation);
}

TEST(collation, non_ignorable_121_015)
{
    // 1E6C 0061;	
    // (Ṭ) LATIN CAPITAL LETTER T WITH DOT BELOW	[1EFB 1CAD | 0020 0042 0020 | 0008 0002 0002 |]

    uint32_t cps[2] = { 0x1E6C, 0x0061 };
    uint32_t const ces[11] = { 0x1EFB, 0x1CAD, 0x0000, 0x0020, 0x0042, 0x0020, 0x0000, 0x0008, 0x0002, 0x0002, 0x0000 };

    auto collation = collate_for_tests(
        cps, cps + 2, boost::text::variable_weighting::non_ignorable);

    EXPECT_EQ(collation.size(), 11);
    EXPECT_TRUE(boost::algorithm::equal(collation.begin(), collation.end(), ces, ces + 11))
        << "from:     " << ce_dumper(cps)
        << "expected: " << ce_dumper(ces)
        << "got:      " << ce_dumper(collation);
}

TEST(collation, non_ignorable_121_016)
{
    // 1E6C 0041;	
    // (Ṭ) LATIN CAPITAL LETTER T WITH DOT BELOW	[1EFB 1CAD | 0020 0042 0020 | 0008 0002 0008 |]

    uint32_t cps[2] = { 0x1E6C, 0x0041 };
    uint32_t const ces[11] = { 0x1EFB, 0x1CAD, 0x0000, 0x0020, 0x0042, 0x0020, 0x0000, 0x0008, 0x0002, 0x0008, 0x0000 };

    auto collation = collate_for_tests(
        cps, cps + 2, boost::text::variable_weighting::non_ignorable);

    EXPECT_EQ(collation.size(), 11);
    EXPECT_TRUE(boost::algorithm::equal(collation.begin(), collation.end(), ces, ces + 11))
        << "from:     " << ce_dumper(cps)
        << "expected: " << ce_dumper(ces)
        << "got:      " << ce_dumper(collation);
}

TEST(collation, non_ignorable_121_017)
{
    // 021B 0061;	
    // (ț) LATIN SMALL LETTER T WITH COMMA BELOW	[1EFB 1CAD | 0020 0045 0020 | 0002 0002 0002 |]

    uint32_t cps[2] = { 0x021B, 0x0061 };
    uint32_t const ces[11] = { 0x1EFB, 0x1CAD, 0x0000, 0x0020, 0x0045, 0x0020, 0x0000, 0x0002, 0x0002, 0x0002, 0x0000 };

    auto collation = collate_for_tests(
        cps, cps + 2, boost::text::variable_weighting::non_ignorable);

    EXPECT_EQ(collation.size(), 11);
    EXPECT_TRUE(boost::algorithm::equal(collation.begin(), collation.end(), ces, ces + 11))
        << "from:     " << ce_dumper(cps)
        << "expected: " << ce_dumper(ces)
        << "got:      " << ce_dumper(collation);
}

TEST(collation, non_ignorable_121_018)
{
    // 021B 0041;	
    // (ț) LATIN SMALL LETTER T WITH COMMA BELOW	[1EFB 1CAD | 0020 0045 0020 | 0002 0002 0008 |]

    uint32_t cps[2] = { 0x021B, 0x0041 };
    uint32_t const ces[11] = { 0x1EFB, 0x1CAD, 0x0000, 0x0020, 0x0045, 0x0020, 0x0000, 0x0002, 0x0002, 0x0008, 0x0000 };

    auto collation = collate_for_tests(
        cps, cps + 2, boost::text::variable_weighting::non_ignorable);

    EXPECT_EQ(collation.size(), 11);
    EXPECT_TRUE(boost::algorithm::equal(collation.begin(), collation.end(), ces, ces + 11))
        << "from:     " << ce_dumper(cps)
        << "expected: " << ce_dumper(ces)
        << "got:      " << ce_dumper(collation);
}

TEST(collation, non_ignorable_121_019)
{
    // 021A 0061;	
    // (Ț) LATIN CAPITAL LETTER T WITH COMMA BELOW	[1EFB 1CAD | 0020 0045 0020 | 0008 0002 0002 |]

    uint32_t cps[2] = { 0x021A, 0x0061 };
    uint32_t const ces[11] = { 0x1EFB, 0x1CAD, 0x0000, 0x0020, 0x0045, 0x0020, 0x0000, 0x0008, 0x0002, 0x0002, 0x0000 };

    auto collation = collate_for_tests(
        cps, cps + 2, boost::text::variable_weighting::non_ignorable);

    EXPECT_EQ(collation.size(), 11);
    EXPECT_TRUE(boost::algorithm::equal(collation.begin(), collation.end(), ces, ces + 11))
        << "from:     " << ce_dumper(cps)
        << "expected: " << ce_dumper(ces)
        << "got:      " << ce_dumper(collation);
}

TEST(collation, non_ignorable_121_020)
{
    // 021A 0041;	
    // (Ț) LATIN CAPITAL LETTER T WITH COMMA BELOW	[1EFB 1CAD | 0020 0045 0020 | 0008 0002 0008 |]

    uint32_t cps[2] = { 0x021A, 0x0041 };
    uint32_t const ces[11] = { 0x1EFB, 0x1CAD, 0x0000, 0x0020, 0x0045, 0x0020, 0x0000, 0x0008, 0x0002, 0x0008, 0x0000 };

    auto collation = collate_for_tests(
        cps, cps + 2, boost::text::variable_weighting::non_ignorable);

    EXPECT_EQ(collation.size(), 11);
    EXPECT_TRUE(boost::algorithm::equal(collation.begin(), collation.end(), ces, ces + 11))
        << "from:     " << ce_dumper(cps)
        << "expected: " << ce_dumper(ces)
        << "got:      " << ce_dumper(collation);
}

TEST(collation, non_ignorable_121_021)
{
    // 1E71 0061;	
    // (ṱ) LATIN SMALL LETTER T WITH CIRCUMFLEX BELOW	[1EFB 1CAD | 0020 0046 0020 | 0002 0002 0002 |]

    uint32_t cps[2] = { 0x1E71, 0x0061 };
    uint32_t const ces[11] = { 0x1EFB, 0x1CAD, 0x0000, 0x0020, 0x0046, 0x0020, 0x0000, 0x0002, 0x0002, 0x0002, 0x0000 };

    auto collation = collate_for_tests(
        cps, cps + 2, boost::text::variable_weighting::non_ignorable);

    EXPECT_EQ(collation.size(), 11);
    EXPECT_TRUE(boost::algorithm::equal(collation.begin(), collation.end(), ces, ces + 11))
        << "from:     " << ce_dumper(cps)
        << "expected: " << ce_dumper(ces)
        << "got:      " << ce_dumper(collation);
}

TEST(collation, non_ignorable_121_022)
{
    // 1E71 0041;	
    // (ṱ) LATIN SMALL LETTER T WITH CIRCUMFLEX BELOW	[1EFB 1CAD | 0020 0046 0020 | 0002 0002 0008 |]

    uint32_t cps[2] = { 0x1E71, 0x0041 };
    uint32_t const ces[11] = { 0x1EFB, 0x1CAD, 0x0000, 0x0020, 0x0046, 0x0020, 0x0000, 0x0002, 0x0002, 0x0008, 0x0000 };

    auto collation = collate_for_tests(
        cps, cps + 2, boost::text::variable_weighting::non_ignorable);

    EXPECT_EQ(collation.size(), 11);
    EXPECT_TRUE(boost::algorithm::equal(collation.begin(), collation.end(), ces, ces + 11))
        << "from:     " << ce_dumper(cps)
        << "expected: " << ce_dumper(ces)
        << "got:      " << ce_dumper(collation);
}

TEST(collation, non_ignorable_121_023)
{
    // 1E70 0061;	
    // (Ṱ) LATIN CAPITAL LETTER T WITH CIRCUMFLEX BELOW	[1EFB 1CAD | 0020 0046 0020 | 0008 0002 0002 |]

    uint32_t cps[2] = { 0x1E70, 0x0061 };
    uint32_t const ces[11] = { 0x1EFB, 0x1CAD, 0x0000, 0x0020, 0x0046, 0x0020, 0x0000, 0x0008, 0x0002, 0x0002, 0x0000 };

    auto collation = collate_for_tests(
        cps, cps + 2, boost::text::variable_weighting::non_ignorable);

    EXPECT_EQ(collation.size(), 11);
    EXPECT_TRUE(boost::algorithm::equal(collation.begin(), collation.end(), ces, ces + 11))
        << "from:     " << ce_dumper(cps)
        << "expected: " << ce_dumper(ces)
        << "got:      " << ce_dumper(collation);
}

TEST(collation, non_ignorable_121_024)
{
    // 1E70 0041;	
    // (Ṱ) LATIN CAPITAL LETTER T WITH CIRCUMFLEX BELOW	[1EFB 1CAD | 0020 0046 0020 | 0008 0002 0008 |]

    uint32_t cps[2] = { 0x1E70, 0x0041 };
    uint32_t const ces[11] = { 0x1EFB, 0x1CAD, 0x0000, 0x0020, 0x0046, 0x0020, 0x0000, 0x0008, 0x0002, 0x0008, 0x0000 };

    auto collation = collate_for_tests(
        cps, cps + 2, boost::text::variable_weighting::non_ignorable);

    EXPECT_EQ(collation.size(), 11);
    EXPECT_TRUE(boost::algorithm::equal(collation.begin(), collation.end(), ces, ces + 11))
        << "from:     " << ce_dumper(cps)
        << "expected: " << ce_dumper(ces)
        << "got:      " << ce_dumper(collation);
}

TEST(collation, non_ignorable_121_025)
{
    // 1E6F 0061;	
    // (ṯ) LATIN SMALL LETTER T WITH LINE BELOW	[1EFB 1CAD | 0020 0049 0020 | 0002 0002 0002 |]

    uint32_t cps[2] = { 0x1E6F, 0x0061 };
    uint32_t const ces[11] = { 0x1EFB, 0x1CAD, 0x0000, 0x0020, 0x0049, 0x0020, 0x0000, 0x0002, 0x0002, 0x0002, 0x0000 };

    auto collation = collate_for_tests(
        cps, cps + 2, boost::text::variable_weighting::non_ignorable);

    EXPECT_EQ(collation.size(), 11);
    EXPECT_TRUE(boost::algorithm::equal(collation.begin(), collation.end(), ces, ces + 11))
        << "from:     " << ce_dumper(cps)
        << "expected: " << ce_dumper(ces)
        << "got:      " << ce_dumper(collation);
}

TEST(collation, non_ignorable_121_026)
{
    // 1E6F 0041;	
    // (ṯ) LATIN SMALL LETTER T WITH LINE BELOW	[1EFB 1CAD | 0020 0049 0020 | 0002 0002 0008 |]

    uint32_t cps[2] = { 0x1E6F, 0x0041 };
    uint32_t const ces[11] = { 0x1EFB, 0x1CAD, 0x0000, 0x0020, 0x0049, 0x0020, 0x0000, 0x0002, 0x0002, 0x0008, 0x0000 };

    auto collation = collate_for_tests(
        cps, cps + 2, boost::text::variable_weighting::non_ignorable);

    EXPECT_EQ(collation.size(), 11);
    EXPECT_TRUE(boost::algorithm::equal(collation.begin(), collation.end(), ces, ces + 11))
        << "from:     " << ce_dumper(cps)
        << "expected: " << ce_dumper(ces)
        << "got:      " << ce_dumper(collation);
}

TEST(collation, non_ignorable_121_027)
{
    // 1E6E 0061;	
    // (Ṯ) LATIN CAPITAL LETTER T WITH LINE BELOW	[1EFB 1CAD | 0020 0049 0020 | 0008 0002 0002 |]

    uint32_t cps[2] = { 0x1E6E, 0x0061 };
    uint32_t const ces[11] = { 0x1EFB, 0x1CAD, 0x0000, 0x0020, 0x0049, 0x0020, 0x0000, 0x0008, 0x0002, 0x0002, 0x0000 };

    auto collation = collate_for_tests(
        cps, cps + 2, boost::text::variable_weighting::non_ignorable);

    EXPECT_EQ(collation.size(), 11);
    EXPECT_TRUE(boost::algorithm::equal(collation.begin(), collation.end(), ces, ces + 11))
        << "from:     " << ce_dumper(cps)
        << "expected: " << ce_dumper(ces)
        << "got:      " << ce_dumper(collation);
}

TEST(collation, non_ignorable_121_028)
{
    // 1E6E 0041;	
    // (Ṯ) LATIN CAPITAL LETTER T WITH LINE BELOW	[1EFB 1CAD | 0020 0049 0020 | 0008 0002 0008 |]

    uint32_t cps[2] = { 0x1E6E, 0x0041 };
    uint32_t const ces[11] = { 0x1EFB, 0x1CAD, 0x0000, 0x0020, 0x0049, 0x0020, 0x0000, 0x0008, 0x0002, 0x0008, 0x0000 };

    auto collation = collate_for_tests(
        cps, cps + 2, boost::text::variable_weighting::non_ignorable);

    EXPECT_EQ(collation.size(), 11);
    EXPECT_TRUE(boost::algorithm::equal(collation.begin(), collation.end(), ces, ces + 11))
        << "from:     " << ce_dumper(cps)
        << "expected: " << ce_dumper(ces)
        << "got:      " << ce_dumper(collation);
}

TEST(collation, non_ignorable_121_029)
{
    // A787 0061;	
    // (ꞇ) LATIN SMALL LETTER INSULAR T	[1EFB 1CAD | 0020 0112 0020 | 0004 0004 0002 |]

    uint32_t cps[2] = { 0xA787, 0x0061 };
    uint32_t const ces[11] = { 0x1EFB, 0x1CAD, 0x0000, 0x0020, 0x0112, 0x0020, 0x0000, 0x0004, 0x0004, 0x0002, 0x0000 };

    auto collation = collate_for_tests(
        cps, cps + 2, boost::text::variable_weighting::non_ignorable);

    EXPECT_EQ(collation.size(), 11);
    EXPECT_TRUE(boost::algorithm::equal(collation.begin(), collation.end(), ces, ces + 11))
        << "from:     " << ce_dumper(cps)
        << "expected: " << ce_dumper(ces)
        << "got:      " << ce_dumper(collation);
}

TEST(collation, non_ignorable_121_030)
{
    // A787 0041;	
    // (ꞇ) LATIN SMALL LETTER INSULAR T	[1EFB 1CAD | 0020 0112 0020 | 0004 0004 0008 |]

    uint32_t cps[2] = { 0xA787, 0x0041 };
    uint32_t const ces[11] = { 0x1EFB, 0x1CAD, 0x0000, 0x0020, 0x0112, 0x0020, 0x0000, 0x0004, 0x0004, 0x0008, 0x0000 };

    auto collation = collate_for_tests(
        cps, cps + 2, boost::text::variable_weighting::non_ignorable);

    EXPECT_EQ(collation.size(), 11);
    EXPECT_TRUE(boost::algorithm::equal(collation.begin(), collation.end(), ces, ces + 11))
        << "from:     " << ce_dumper(cps)
        << "expected: " << ce_dumper(ces)
        << "got:      " << ce_dumper(collation);
}

TEST(collation, non_ignorable_121_031)
{
    // A786 0061;	
    // (Ꞇ) LATIN CAPITAL LETTER INSULAR T	[1EFB 1CAD | 0020 0112 0020 | 000A 0004 0002 |]

    uint32_t cps[2] = { 0xA786, 0x0061 };
    uint32_t const ces[11] = { 0x1EFB, 0x1CAD, 0x0000, 0x0020, 0x0112, 0x0020, 0x0000, 0x000A, 0x0004, 0x0002, 0x0000 };

    auto collation = collate_for_tests(
        cps, cps + 2, boost::text::variable_weighting::non_ignorable);

    EXPECT_EQ(collation.size(), 11);
    EXPECT_TRUE(boost::algorithm::equal(collation.begin(), collation.end(), ces, ces + 11))
        << "from:     " << ce_dumper(cps)
        << "expected: " << ce_dumper(ces)
        << "got:      " << ce_dumper(collation);
}

TEST(collation, non_ignorable_121_032)
{
    // A786 0041;	
    // (Ꞇ) LATIN CAPITAL LETTER INSULAR T	[1EFB 1CAD | 0020 0112 0020 | 000A 0004 0008 |]

    uint32_t cps[2] = { 0xA786, 0x0041 };
    uint32_t const ces[11] = { 0x1EFB, 0x1CAD, 0x0000, 0x0020, 0x0112, 0x0020, 0x0000, 0x000A, 0x0004, 0x0008, 0x0000 };

    auto collation = collate_for_tests(
        cps, cps + 2, boost::text::variable_weighting::non_ignorable);

    EXPECT_EQ(collation.size(), 11);
    EXPECT_TRUE(boost::algorithm::equal(collation.begin(), collation.end(), ces, ces + 11))
        << "from:     " << ce_dumper(cps)
        << "expected: " << ce_dumper(ces)
        << "got:      " << ce_dumper(collation);
}

TEST(collation, non_ignorable_121_033)
{
    // 0074 0062;	
    // (t) LATIN SMALL LETTER T	[1EFB 1CC6 | 0020 0020 | 0002 0002 |]

    uint32_t cps[2] = { 0x0074, 0x0062 };
    uint32_t const ces[9] = { 0x1EFB, 0x1CC6, 0x0000, 0x0020, 0x0020, 0x0000, 0x0002, 0x0002, 0x0000 };

    auto collation = collate_for_tests(
        cps, cps + 2, boost::text::variable_weighting::non_ignorable);

    EXPECT_EQ(collation.size(), 9);
    EXPECT_TRUE(boost::algorithm::equal(collation.begin(), collation.end(), ces, ces + 9))
        << "from:     " << ce_dumper(cps)
        << "expected: " << ce_dumper(ces)
        << "got:      " << ce_dumper(collation);
}

TEST(collation, non_ignorable_121_034)
{
    // FF54 0062;	
    // (ｔ) FULLWIDTH LATIN SMALL LETTER T	[1EFB 1CC6 | 0020 0020 | 0003 0002 |]

    uint32_t cps[2] = { 0xFF54, 0x0062 };
    uint32_t const ces[9] = { 0x1EFB, 0x1CC6, 0x0000, 0x0020, 0x0020, 0x0000, 0x0003, 0x0002, 0x0000 };

    auto collation = collate_for_tests(
        cps, cps + 2, boost::text::variable_weighting::non_ignorable);

    EXPECT_EQ(collation.size(), 9);
    EXPECT_TRUE(boost::algorithm::equal(collation.begin(), collation.end(), ces, ces + 9))
        << "from:     " << ce_dumper(cps)
        << "expected: " << ce_dumper(ces)
        << "got:      " << ce_dumper(collation);
}

TEST(collation, non_ignorable_121_035)
{
    // 036D 0062;	
    // (ͭ) COMBINING LATIN SMALL LETTER T	[1EFB 1CC6 | 0020 0020 | 0004 0002 |]

    uint32_t cps[2] = { 0x036D, 0x0062 };
    uint32_t const ces[9] = { 0x1EFB, 0x1CC6, 0x0000, 0x0020, 0x0020, 0x0000, 0x0004, 0x0002, 0x0000 };

    auto collation = collate_for_tests(
        cps, cps + 2, boost::text::variable_weighting::non_ignorable);

    EXPECT_EQ(collation.size(), 9);
    EXPECT_TRUE(boost::algorithm::equal(collation.begin(), collation.end(), ces, ces + 9))
        << "from:     " << ce_dumper(cps)
        << "expected: " << ce_dumper(ces)
        << "got:      " << ce_dumper(collation);
}

TEST(collation, non_ignorable_121_036)
{
    // 1D42D 0062;	
    // (𝐭) MATHEMATICAL BOLD SMALL T	[1EFB 1CC6 | 0020 0020 | 0005 0002 |]

    uint32_t cps[2] = { 0x1D42D, 0x0062 };
    uint32_t const ces[9] = { 0x1EFB, 0x1CC6, 0x0000, 0x0020, 0x0020, 0x0000, 0x0005, 0x0002, 0x0000 };

    auto collation = collate_for_tests(
        cps, cps + 2, boost::text::variable_weighting::non_ignorable);

    EXPECT_EQ(collation.size(), 9);
    EXPECT_TRUE(boost::algorithm::equal(collation.begin(), collation.end(), ces, ces + 9))
        << "from:     " << ce_dumper(cps)
        << "expected: " << ce_dumper(ces)
        << "got:      " << ce_dumper(collation);
}

TEST(collation, non_ignorable_121_037)
{
    // 1D461 0062;	
    // (𝑡) MATHEMATICAL ITALIC SMALL T	[1EFB 1CC6 | 0020 0020 | 0005 0002 |]

    uint32_t cps[2] = { 0x1D461, 0x0062 };
    uint32_t const ces[9] = { 0x1EFB, 0x1CC6, 0x0000, 0x0020, 0x0020, 0x0000, 0x0005, 0x0002, 0x0000 };

    auto collation = collate_for_tests(
        cps, cps + 2, boost::text::variable_weighting::non_ignorable);

    EXPECT_EQ(collation.size(), 9);
    EXPECT_TRUE(boost::algorithm::equal(collation.begin(), collation.end(), ces, ces + 9))
        << "from:     " << ce_dumper(cps)
        << "expected: " << ce_dumper(ces)
        << "got:      " << ce_dumper(collation);
}

TEST(collation, non_ignorable_121_038)
{
    // 1D495 0062;	
    // (𝒕) MATHEMATICAL BOLD ITALIC SMALL T	[1EFB 1CC6 | 0020 0020 | 0005 0002 |]

    uint32_t cps[2] = { 0x1D495, 0x0062 };
    uint32_t const ces[9] = { 0x1EFB, 0x1CC6, 0x0000, 0x0020, 0x0020, 0x0000, 0x0005, 0x0002, 0x0000 };

    auto collation = collate_for_tests(
        cps, cps + 2, boost::text::variable_weighting::non_ignorable);

    EXPECT_EQ(collation.size(), 9);
    EXPECT_TRUE(boost::algorithm::equal(collation.begin(), collation.end(), ces, ces + 9))
        << "from:     " << ce_dumper(cps)
        << "expected: " << ce_dumper(ces)
        << "got:      " << ce_dumper(collation);
}

TEST(collation, non_ignorable_121_039)
{
    // 1D4C9 0062;	
    // (𝓉) MATHEMATICAL SCRIPT SMALL T	[1EFB 1CC6 | 0020 0020 | 0005 0002 |]

    uint32_t cps[2] = { 0x1D4C9, 0x0062 };
    uint32_t const ces[9] = { 0x1EFB, 0x1CC6, 0x0000, 0x0020, 0x0020, 0x0000, 0x0005, 0x0002, 0x0000 };

    auto collation = collate_for_tests(
        cps, cps + 2, boost::text::variable_weighting::non_ignorable);

    EXPECT_EQ(collation.size(), 9);
    EXPECT_TRUE(boost::algorithm::equal(collation.begin(), collation.end(), ces, ces + 9))
        << "from:     " << ce_dumper(cps)
        << "expected: " << ce_dumper(ces)
        << "got:      " << ce_dumper(collation);
}

TEST(collation, non_ignorable_121_040)
{
    // 1D4FD 0062;	
    // (𝓽) MATHEMATICAL BOLD SCRIPT SMALL T	[1EFB 1CC6 | 0020 0020 | 0005 0002 |]

    uint32_t cps[2] = { 0x1D4FD, 0x0062 };
    uint32_t const ces[9] = { 0x1EFB, 0x1CC6, 0x0000, 0x0020, 0x0020, 0x0000, 0x0005, 0x0002, 0x0000 };

    auto collation = collate_for_tests(
        cps, cps + 2, boost::text::variable_weighting::non_ignorable);

    EXPECT_EQ(collation.size(), 9);
    EXPECT_TRUE(boost::algorithm::equal(collation.begin(), collation.end(), ces, ces + 9))
        << "from:     " << ce_dumper(cps)
        << "expected: " << ce_dumper(ces)
        << "got:      " << ce_dumper(collation);
}

TEST(collation, non_ignorable_121_041)
{
    // 1D531 0062;	
    // (𝔱) MATHEMATICAL FRAKTUR SMALL T	[1EFB 1CC6 | 0020 0020 | 0005 0002 |]

    uint32_t cps[2] = { 0x1D531, 0x0062 };
    uint32_t const ces[9] = { 0x1EFB, 0x1CC6, 0x0000, 0x0020, 0x0020, 0x0000, 0x0005, 0x0002, 0x0000 };

    auto collation = collate_for_tests(
        cps, cps + 2, boost::text::variable_weighting::non_ignorable);

    EXPECT_EQ(collation.size(), 9);
    EXPECT_TRUE(boost::algorithm::equal(collation.begin(), collation.end(), ces, ces + 9))
        << "from:     " << ce_dumper(cps)
        << "expected: " << ce_dumper(ces)
        << "got:      " << ce_dumper(collation);
}

TEST(collation, non_ignorable_121_042)
{
    // 1D565 0062;	
    // (𝕥) MATHEMATICAL DOUBLE-STRUCK SMALL T	[1EFB 1CC6 | 0020 0020 | 0005 0002 |]

    uint32_t cps[2] = { 0x1D565, 0x0062 };
    uint32_t const ces[9] = { 0x1EFB, 0x1CC6, 0x0000, 0x0020, 0x0020, 0x0000, 0x0005, 0x0002, 0x0000 };

    auto collation = collate_for_tests(
        cps, cps + 2, boost::text::variable_weighting::non_ignorable);

    EXPECT_EQ(collation.size(), 9);
    EXPECT_TRUE(boost::algorithm::equal(collation.begin(), collation.end(), ces, ces + 9))
        << "from:     " << ce_dumper(cps)
        << "expected: " << ce_dumper(ces)
        << "got:      " << ce_dumper(collation);
}

TEST(collation, non_ignorable_121_043)
{
    // 1D599 0062;	
    // (𝖙) MATHEMATICAL BOLD FRAKTUR SMALL T	[1EFB 1CC6 | 0020 0020 | 0005 0002 |]

    uint32_t cps[2] = { 0x1D599, 0x0062 };
    uint32_t const ces[9] = { 0x1EFB, 0x1CC6, 0x0000, 0x0020, 0x0020, 0x0000, 0x0005, 0x0002, 0x0000 };

    auto collation = collate_for_tests(
        cps, cps + 2, boost::text::variable_weighting::non_ignorable);

    EXPECT_EQ(collation.size(), 9);
    EXPECT_TRUE(boost::algorithm::equal(collation.begin(), collation.end(), ces, ces + 9))
        << "from:     " << ce_dumper(cps)
        << "expected: " << ce_dumper(ces)
        << "got:      " << ce_dumper(collation);
}

TEST(collation, non_ignorable_121_044)
{
    // 1D5CD 0062;	
    // (𝗍) MATHEMATICAL SANS-SERIF SMALL T	[1EFB 1CC6 | 0020 0020 | 0005 0002 |]

    uint32_t cps[2] = { 0x1D5CD, 0x0062 };
    uint32_t const ces[9] = { 0x1EFB, 0x1CC6, 0x0000, 0x0020, 0x0020, 0x0000, 0x0005, 0x0002, 0x0000 };

    auto collation = collate_for_tests(
        cps, cps + 2, boost::text::variable_weighting::non_ignorable);

    EXPECT_EQ(collation.size(), 9);
    EXPECT_TRUE(boost::algorithm::equal(collation.begin(), collation.end(), ces, ces + 9))
        << "from:     " << ce_dumper(cps)
        << "expected: " << ce_dumper(ces)
        << "got:      " << ce_dumper(collation);
}

TEST(collation, non_ignorable_121_045)
{
    // 1D601 0062;	
    // (𝘁) MATHEMATICAL SANS-SERIF BOLD SMALL T	[1EFB 1CC6 | 0020 0020 | 0005 0002 |]

    uint32_t cps[2] = { 0x1D601, 0x0062 };
    uint32_t const ces[9] = { 0x1EFB, 0x1CC6, 0x0000, 0x0020, 0x0020, 0x0000, 0x0005, 0x0002, 0x0000 };

    auto collation = collate_for_tests(
        cps, cps + 2, boost::text::variable_weighting::non_ignorable);

    EXPECT_EQ(collation.size(), 9);
    EXPECT_TRUE(boost::algorithm::equal(collation.begin(), collation.end(), ces, ces + 9))
        << "from:     " << ce_dumper(cps)
        << "expected: " << ce_dumper(ces)
        << "got:      " << ce_dumper(collation);
}

TEST(collation, non_ignorable_121_046)
{
    // 1D635 0062;	
    // (𝘵) MATHEMATICAL SANS-SERIF ITALIC SMALL T	[1EFB 1CC6 | 0020 0020 | 0005 0002 |]

    uint32_t cps[2] = { 0x1D635, 0x0062 };
    uint32_t const ces[9] = { 0x1EFB, 0x1CC6, 0x0000, 0x0020, 0x0020, 0x0000, 0x0005, 0x0002, 0x0000 };

    auto collation = collate_for_tests(
        cps, cps + 2, boost::text::variable_weighting::non_ignorable);

    EXPECT_EQ(collation.size(), 9);
    EXPECT_TRUE(boost::algorithm::equal(collation.begin(), collation.end(), ces, ces + 9))
        << "from:     " << ce_dumper(cps)
        << "expected: " << ce_dumper(ces)
        << "got:      " << ce_dumper(collation);
}

TEST(collation, non_ignorable_121_047)
{
    // 1D669 0062;	
    // (𝙩) MATHEMATICAL SANS-SERIF BOLD ITALIC SMALL T	[1EFB 1CC6 | 0020 0020 | 0005 0002 |]

    uint32_t cps[2] = { 0x1D669, 0x0062 };
    uint32_t const ces[9] = { 0x1EFB, 0x1CC6, 0x0000, 0x0020, 0x0020, 0x0000, 0x0005, 0x0002, 0x0000 };

    auto collation = collate_for_tests(
        cps, cps + 2, boost::text::variable_weighting::non_ignorable);

    EXPECT_EQ(collation.size(), 9);
    EXPECT_TRUE(boost::algorithm::equal(collation.begin(), collation.end(), ces, ces + 9))
        << "from:     " << ce_dumper(cps)
        << "expected: " << ce_dumper(ces)
        << "got:      " << ce_dumper(collation);
}

TEST(collation, non_ignorable_121_048)
{
    // 1D69D 0062;	
    // (𝚝) MATHEMATICAL MONOSPACE SMALL T	[1EFB 1CC6 | 0020 0020 | 0005 0002 |]

    uint32_t cps[2] = { 0x1D69D, 0x0062 };
    uint32_t const ces[9] = { 0x1EFB, 0x1CC6, 0x0000, 0x0020, 0x0020, 0x0000, 0x0005, 0x0002, 0x0000 };

    auto collation = collate_for_tests(
        cps, cps + 2, boost::text::variable_weighting::non_ignorable);

    EXPECT_EQ(collation.size(), 9);
    EXPECT_TRUE(boost::algorithm::equal(collation.begin(), collation.end(), ces, ces + 9))
        << "from:     " << ce_dumper(cps)
        << "expected: " << ce_dumper(ces)
        << "got:      " << ce_dumper(collation);
}

TEST(collation, non_ignorable_121_049)
{
    // 24E3 0062;	
    // (ⓣ) CIRCLED LATIN SMALL LETTER T	[1EFB 1CC6 | 0020 0020 | 0006 0002 |]

    uint32_t cps[2] = { 0x24E3, 0x0062 };
    uint32_t const ces[9] = { 0x1EFB, 0x1CC6, 0x0000, 0x0020, 0x0020, 0x0000, 0x0006, 0x0002, 0x0000 };

    auto collation = collate_for_tests(
        cps, cps + 2, boost::text::variable_weighting::non_ignorable);

    EXPECT_EQ(collation.size(), 9);
    EXPECT_TRUE(boost::algorithm::equal(collation.begin(), collation.end(), ces, ces + 9))
        << "from:     " << ce_dumper(cps)
        << "expected: " << ce_dumper(ces)
        << "got:      " << ce_dumper(collation);
}

TEST(collation, non_ignorable_121_050)
{
    // 0054 0062;	
    // (T) LATIN CAPITAL LETTER T	[1EFB 1CC6 | 0020 0020 | 0008 0002 |]

    uint32_t cps[2] = { 0x0054, 0x0062 };
    uint32_t const ces[9] = { 0x1EFB, 0x1CC6, 0x0000, 0x0020, 0x0020, 0x0000, 0x0008, 0x0002, 0x0000 };

    auto collation = collate_for_tests(
        cps, cps + 2, boost::text::variable_weighting::non_ignorable);

    EXPECT_EQ(collation.size(), 9);
    EXPECT_TRUE(boost::algorithm::equal(collation.begin(), collation.end(), ces, ces + 9))
        << "from:     " << ce_dumper(cps)
        << "expected: " << ce_dumper(ces)
        << "got:      " << ce_dumper(collation);
}

TEST(collation, non_ignorable_121_051)
{
    // FF34 0062;	
    // (Ｔ) FULLWIDTH LATIN CAPITAL LETTER T	[1EFB 1CC6 | 0020 0020 | 0009 0002 |]

    uint32_t cps[2] = { 0xFF34, 0x0062 };
    uint32_t const ces[9] = { 0x1EFB, 0x1CC6, 0x0000, 0x0020, 0x0020, 0x0000, 0x0009, 0x0002, 0x0000 };

    auto collation = collate_for_tests(
        cps, cps + 2, boost::text::variable_weighting::non_ignorable);

    EXPECT_EQ(collation.size(), 9);
    EXPECT_TRUE(boost::algorithm::equal(collation.begin(), collation.end(), ces, ces + 9))
        << "from:     " << ce_dumper(cps)
        << "expected: " << ce_dumper(ces)
        << "got:      " << ce_dumper(collation);
}

TEST(collation, non_ignorable_121_052)
{
    // 1D413 0062;	
    // (𝐓) MATHEMATICAL BOLD CAPITAL T	[1EFB 1CC6 | 0020 0020 | 000B 0002 |]

    uint32_t cps[2] = { 0x1D413, 0x0062 };
    uint32_t const ces[9] = { 0x1EFB, 0x1CC6, 0x0000, 0x0020, 0x0020, 0x0000, 0x000B, 0x0002, 0x0000 };

    auto collation = collate_for_tests(
        cps, cps + 2, boost::text::variable_weighting::non_ignorable);

    EXPECT_EQ(collation.size(), 9);
    EXPECT_TRUE(boost::algorithm::equal(collation.begin(), collation.end(), ces, ces + 9))
        << "from:     " << ce_dumper(cps)
        << "expected: " << ce_dumper(ces)
        << "got:      " << ce_dumper(collation);
}

TEST(collation, non_ignorable_121_053)
{
    // 1D447 0062;	
    // (𝑇) MATHEMATICAL ITALIC CAPITAL T	[1EFB 1CC6 | 0020 0020 | 000B 0002 |]

    uint32_t cps[2] = { 0x1D447, 0x0062 };
    uint32_t const ces[9] = { 0x1EFB, 0x1CC6, 0x0000, 0x0020, 0x0020, 0x0000, 0x000B, 0x0002, 0x0000 };

    auto collation = collate_for_tests(
        cps, cps + 2, boost::text::variable_weighting::non_ignorable);

    EXPECT_EQ(collation.size(), 9);
    EXPECT_TRUE(boost::algorithm::equal(collation.begin(), collation.end(), ces, ces + 9))
        << "from:     " << ce_dumper(cps)
        << "expected: " << ce_dumper(ces)
        << "got:      " << ce_dumper(collation);
}

TEST(collation, non_ignorable_121_054)
{
    // 1D47B 0062;	
    // (𝑻) MATHEMATICAL BOLD ITALIC CAPITAL T	[1EFB 1CC6 | 0020 0020 | 000B 0002 |]

    uint32_t cps[2] = { 0x1D47B, 0x0062 };
    uint32_t const ces[9] = { 0x1EFB, 0x1CC6, 0x0000, 0x0020, 0x0020, 0x0000, 0x000B, 0x0002, 0x0000 };

    auto collation = collate_for_tests(
        cps, cps + 2, boost::text::variable_weighting::non_ignorable);

    EXPECT_EQ(collation.size(), 9);
    EXPECT_TRUE(boost::algorithm::equal(collation.begin(), collation.end(), ces, ces + 9))
        << "from:     " << ce_dumper(cps)
        << "expected: " << ce_dumper(ces)
        << "got:      " << ce_dumper(collation);
}

TEST(collation, non_ignorable_121_055)
{
    // 1D4AF 0062;	
    // (𝒯) MATHEMATICAL SCRIPT CAPITAL T	[1EFB 1CC6 | 0020 0020 | 000B 0002 |]

    uint32_t cps[2] = { 0x1D4AF, 0x0062 };
    uint32_t const ces[9] = { 0x1EFB, 0x1CC6, 0x0000, 0x0020, 0x0020, 0x0000, 0x000B, 0x0002, 0x0000 };

    auto collation = collate_for_tests(
        cps, cps + 2, boost::text::variable_weighting::non_ignorable);

    EXPECT_EQ(collation.size(), 9);
    EXPECT_TRUE(boost::algorithm::equal(collation.begin(), collation.end(), ces, ces + 9))
        << "from:     " << ce_dumper(cps)
        << "expected: " << ce_dumper(ces)
        << "got:      " << ce_dumper(collation);
}

TEST(collation, non_ignorable_121_056)
{
    // 1D4E3 0062;	
    // (𝓣) MATHEMATICAL BOLD SCRIPT CAPITAL T	[1EFB 1CC6 | 0020 0020 | 000B 0002 |]

    uint32_t cps[2] = { 0x1D4E3, 0x0062 };
    uint32_t const ces[9] = { 0x1EFB, 0x1CC6, 0x0000, 0x0020, 0x0020, 0x0000, 0x000B, 0x0002, 0x0000 };

    auto collation = collate_for_tests(
        cps, cps + 2, boost::text::variable_weighting::non_ignorable);

    EXPECT_EQ(collation.size(), 9);
    EXPECT_TRUE(boost::algorithm::equal(collation.begin(), collation.end(), ces, ces + 9))
        << "from:     " << ce_dumper(cps)
        << "expected: " << ce_dumper(ces)
        << "got:      " << ce_dumper(collation);
}

TEST(collation, non_ignorable_121_057)
{
    // 1D517 0062;	
    // (𝔗) MATHEMATICAL FRAKTUR CAPITAL T	[1EFB 1CC6 | 0020 0020 | 000B 0002 |]

    uint32_t cps[2] = { 0x1D517, 0x0062 };
    uint32_t const ces[9] = { 0x1EFB, 0x1CC6, 0x0000, 0x0020, 0x0020, 0x0000, 0x000B, 0x0002, 0x0000 };

    auto collation = collate_for_tests(
        cps, cps + 2, boost::text::variable_weighting::non_ignorable);

    EXPECT_EQ(collation.size(), 9);
    EXPECT_TRUE(boost::algorithm::equal(collation.begin(), collation.end(), ces, ces + 9))
        << "from:     " << ce_dumper(cps)
        << "expected: " << ce_dumper(ces)
        << "got:      " << ce_dumper(collation);
}

TEST(collation, non_ignorable_121_058)
{
    // 1D54B 0062;	
    // (𝕋) MATHEMATICAL DOUBLE-STRUCK CAPITAL T	[1EFB 1CC6 | 0020 0020 | 000B 0002 |]

    uint32_t cps[2] = { 0x1D54B, 0x0062 };
    uint32_t const ces[9] = { 0x1EFB, 0x1CC6, 0x0000, 0x0020, 0x0020, 0x0000, 0x000B, 0x0002, 0x0000 };

    auto collation = collate_for_tests(
        cps, cps + 2, boost::text::variable_weighting::non_ignorable);

    EXPECT_EQ(collation.size(), 9);
    EXPECT_TRUE(boost::algorithm::equal(collation.begin(), collation.end(), ces, ces + 9))
        << "from:     " << ce_dumper(cps)
        << "expected: " << ce_dumper(ces)
        << "got:      " << ce_dumper(collation);
}

TEST(collation, non_ignorable_121_059)
{
    // 1D57F 0062;	
    // (𝕿) MATHEMATICAL BOLD FRAKTUR CAPITAL T	[1EFB 1CC6 | 0020 0020 | 000B 0002 |]

    uint32_t cps[2] = { 0x1D57F, 0x0062 };
    uint32_t const ces[9] = { 0x1EFB, 0x1CC6, 0x0000, 0x0020, 0x0020, 0x0000, 0x000B, 0x0002, 0x0000 };

    auto collation = collate_for_tests(
        cps, cps + 2, boost::text::variable_weighting::non_ignorable);

    EXPECT_EQ(collation.size(), 9);
    EXPECT_TRUE(boost::algorithm::equal(collation.begin(), collation.end(), ces, ces + 9))
        << "from:     " << ce_dumper(cps)
        << "expected: " << ce_dumper(ces)
        << "got:      " << ce_dumper(collation);
}

TEST(collation, non_ignorable_121_060)
{
    // 1D5B3 0062;	
    // (𝖳) MATHEMATICAL SANS-SERIF CAPITAL T	[1EFB 1CC6 | 0020 0020 | 000B 0002 |]

    uint32_t cps[2] = { 0x1D5B3, 0x0062 };
    uint32_t const ces[9] = { 0x1EFB, 0x1CC6, 0x0000, 0x0020, 0x0020, 0x0000, 0x000B, 0x0002, 0x0000 };

    auto collation = collate_for_tests(
        cps, cps + 2, boost::text::variable_weighting::non_ignorable);

    EXPECT_EQ(collation.size(), 9);
    EXPECT_TRUE(boost::algorithm::equal(collation.begin(), collation.end(), ces, ces + 9))
        << "from:     " << ce_dumper(cps)
        << "expected: " << ce_dumper(ces)
        << "got:      " << ce_dumper(collation);
}

TEST(collation, non_ignorable_121_061)
{
    // 1D5E7 0062;	
    // (𝗧) MATHEMATICAL SANS-SERIF BOLD CAPITAL T	[1EFB 1CC6 | 0020 0020 | 000B 0002 |]

    uint32_t cps[2] = { 0x1D5E7, 0x0062 };
    uint32_t const ces[9] = { 0x1EFB, 0x1CC6, 0x0000, 0x0020, 0x0020, 0x0000, 0x000B, 0x0002, 0x0000 };

    auto collation = collate_for_tests(
        cps, cps + 2, boost::text::variable_weighting::non_ignorable);

    EXPECT_EQ(collation.size(), 9);
    EXPECT_TRUE(boost::algorithm::equal(collation.begin(), collation.end(), ces, ces + 9))
        << "from:     " << ce_dumper(cps)
        << "expected: " << ce_dumper(ces)
        << "got:      " << ce_dumper(collation);
}

TEST(collation, non_ignorable_121_062)
{
    // 1D61B 0062;	
    // (𝘛) MATHEMATICAL SANS-SERIF ITALIC CAPITAL T	[1EFB 1CC6 | 0020 0020 | 000B 0002 |]

    uint32_t cps[2] = { 0x1D61B, 0x0062 };
    uint32_t const ces[9] = { 0x1EFB, 0x1CC6, 0x0000, 0x0020, 0x0020, 0x0000, 0x000B, 0x0002, 0x0000 };

    auto collation = collate_for_tests(
        cps, cps + 2, boost::text::variable_weighting::non_ignorable);

    EXPECT_EQ(collation.size(), 9);
    EXPECT_TRUE(boost::algorithm::equal(collation.begin(), collation.end(), ces, ces + 9))
        << "from:     " << ce_dumper(cps)
        << "expected: " << ce_dumper(ces)
        << "got:      " << ce_dumper(collation);
}

TEST(collation, non_ignorable_121_063)
{
    // 1D64F 0062;	
    // (𝙏) MATHEMATICAL SANS-SERIF BOLD ITALIC CAPITAL T	[1EFB 1CC6 | 0020 0020 | 000B 0002 |]

    uint32_t cps[2] = { 0x1D64F, 0x0062 };
    uint32_t const ces[9] = { 0x1EFB, 0x1CC6, 0x0000, 0x0020, 0x0020, 0x0000, 0x000B, 0x0002, 0x0000 };

    auto collation = collate_for_tests(
        cps, cps + 2, boost::text::variable_weighting::non_ignorable);

    EXPECT_EQ(collation.size(), 9);
    EXPECT_TRUE(boost::algorithm::equal(collation.begin(), collation.end(), ces, ces + 9))
        << "from:     " << ce_dumper(cps)
        << "expected: " << ce_dumper(ces)
        << "got:      " << ce_dumper(collation);
}

TEST(collation, non_ignorable_121_064)
{
    // 1D683 0062;	
    // (𝚃) MATHEMATICAL MONOSPACE CAPITAL T	[1EFB 1CC6 | 0020 0020 | 000B 0002 |]

    uint32_t cps[2] = { 0x1D683, 0x0062 };
    uint32_t const ces[9] = { 0x1EFB, 0x1CC6, 0x0000, 0x0020, 0x0020, 0x0000, 0x000B, 0x0002, 0x0000 };

    auto collation = collate_for_tests(
        cps, cps + 2, boost::text::variable_weighting::non_ignorable);

    EXPECT_EQ(collation.size(), 9);
    EXPECT_TRUE(boost::algorithm::equal(collation.begin(), collation.end(), ces, ces + 9))
        << "from:     " << ce_dumper(cps)
        << "expected: " << ce_dumper(ces)
        << "got:      " << ce_dumper(collation);
}

TEST(collation, non_ignorable_121_065)
{
    // 24C9 0062;	
    // (Ⓣ) CIRCLED LATIN CAPITAL LETTER T	[1EFB 1CC6 | 0020 0020 | 000C 0002 |]

    uint32_t cps[2] = { 0x24C9, 0x0062 };
    uint32_t const ces[9] = { 0x1EFB, 0x1CC6, 0x0000, 0x0020, 0x0020, 0x0000, 0x000C, 0x0002, 0x0000 };

    auto collation = collate_for_tests(
        cps, cps + 2, boost::text::variable_weighting::non_ignorable);

    EXPECT_EQ(collation.size(), 9);
    EXPECT_TRUE(boost::algorithm::equal(collation.begin(), collation.end(), ces, ces + 9))
        << "from:     " << ce_dumper(cps)
        << "expected: " << ce_dumper(ces)
        << "got:      " << ce_dumper(collation);
}

TEST(collation, non_ignorable_121_066)
{
    // 1F163 0062;	
    // (🅣) NEGATIVE CIRCLED LATIN CAPITAL LETTER T	[1EFB 1CC6 | 0020 0020 | 000C 0002 |]

    uint32_t cps[2] = { 0x1F163, 0x0062 };
    uint32_t const ces[9] = { 0x1EFB, 0x1CC6, 0x0000, 0x0020, 0x0020, 0x0000, 0x000C, 0x0002, 0x0000 };

    auto collation = collate_for_tests(
        cps, cps + 2, boost::text::variable_weighting::non_ignorable);

    EXPECT_EQ(collation.size(), 9);
    EXPECT_TRUE(boost::algorithm::equal(collation.begin(), collation.end(), ces, ces + 9))
        << "from:     " << ce_dumper(cps)
        << "expected: " << ce_dumper(ces)
        << "got:      " << ce_dumper(collation);
}

TEST(collation, non_ignorable_121_067)
{
    // 1D57 0062;	
    // (ᵗ) MODIFIER LETTER SMALL T	[1EFB 1CC6 | 0020 0020 | 0014 0002 |]

    uint32_t cps[2] = { 0x1D57, 0x0062 };
    uint32_t const ces[9] = { 0x1EFB, 0x1CC6, 0x0000, 0x0020, 0x0020, 0x0000, 0x0014, 0x0002, 0x0000 };

    auto collation = collate_for_tests(
        cps, cps + 2, boost::text::variable_weighting::non_ignorable);

    EXPECT_EQ(collation.size(), 9);
    EXPECT_TRUE(boost::algorithm::equal(collation.begin(), collation.end(), ces, ces + 9))
        << "from:     " << ce_dumper(cps)
        << "expected: " << ce_dumper(ces)
        << "got:      " << ce_dumper(collation);
}

TEST(collation, non_ignorable_121_068)
{
    // 209C 0062;	
    // (ₜ) LATIN SUBSCRIPT SMALL LETTER T	[1EFB 1CC6 | 0020 0020 | 0015 0002 |]

    uint32_t cps[2] = { 0x209C, 0x0062 };
    uint32_t const ces[9] = { 0x1EFB, 0x1CC6, 0x0000, 0x0020, 0x0020, 0x0000, 0x0015, 0x0002, 0x0000 };

    auto collation = collate_for_tests(
        cps, cps + 2, boost::text::variable_weighting::non_ignorable);

    EXPECT_EQ(collation.size(), 9);
    EXPECT_TRUE(boost::algorithm::equal(collation.begin(), collation.end(), ces, ces + 9))
        << "from:     " << ce_dumper(cps)
        << "expected: " << ce_dumper(ces)
        << "got:      " << ce_dumper(collation);
}

TEST(collation, non_ignorable_121_069)
{
    // 1D40 0062;	
    // (ᵀ) MODIFIER LETTER CAPITAL T	[1EFB 1CC6 | 0020 0020 | 001D 0002 |]

    uint32_t cps[2] = { 0x1D40, 0x0062 };
    uint32_t const ces[9] = { 0x1EFB, 0x1CC6, 0x0000, 0x0020, 0x0020, 0x0000, 0x001D, 0x0002, 0x0000 };

    auto collation = collate_for_tests(
        cps, cps + 2, boost::text::variable_weighting::non_ignorable);

    EXPECT_EQ(collation.size(), 9);
    EXPECT_TRUE(boost::algorithm::equal(collation.begin(), collation.end(), ces, ces + 9))
        << "from:     " << ce_dumper(cps)
        << "expected: " << ce_dumper(ces)
        << "got:      " << ce_dumper(collation);
}

TEST(collation, non_ignorable_121_070)
{
    // 1F143 0062;	
    // (🅃) SQUARED LATIN CAPITAL LETTER T	[1EFB 1CC6 | 0020 0020 | 001D 0002 |]

    uint32_t cps[2] = { 0x1F143, 0x0062 };
    uint32_t const ces[9] = { 0x1EFB, 0x1CC6, 0x0000, 0x0020, 0x0020, 0x0000, 0x001D, 0x0002, 0x0000 };

    auto collation = collate_for_tests(
        cps, cps + 2, boost::text::variable_weighting::non_ignorable);

    EXPECT_EQ(collation.size(), 9);
    EXPECT_TRUE(boost::algorithm::equal(collation.begin(), collation.end(), ces, ces + 9))
        << "from:     " << ce_dumper(cps)
        << "expected: " << ce_dumper(ces)
        << "got:      " << ce_dumper(collation);
}

TEST(collation, non_ignorable_121_071)
{
    // 1F183 0062;	
    // (🆃) NEGATIVE SQUARED LATIN CAPITAL LETTER T	[1EFB 1CC6 | 0020 0020 | 001D 0002 |]

    uint32_t cps[2] = { 0x1F183, 0x0062 };
    uint32_t const ces[9] = { 0x1EFB, 0x1CC6, 0x0000, 0x0020, 0x0020, 0x0000, 0x001D, 0x0002, 0x0000 };

    auto collation = collate_for_tests(
        cps, cps + 2, boost::text::variable_weighting::non_ignorable);

    EXPECT_EQ(collation.size(), 9);
    EXPECT_TRUE(boost::algorithm::equal(collation.begin(), collation.end(), ces, ces + 9))
        << "from:     " << ce_dumper(cps)
        << "expected: " << ce_dumper(ces)
        << "got:      " << ce_dumper(collation);
}

TEST(collation, non_ignorable_121_072)
{
    // 0165 0062;	
    // (ť) LATIN SMALL LETTER T WITH CARON	[1EFB 1CC6 | 0020 0028 0020 | 0002 0002 0002 |]

    uint32_t cps[2] = { 0x0165, 0x0062 };
    uint32_t const ces[11] = { 0x1EFB, 0x1CC6, 0x0000, 0x0020, 0x0028, 0x0020, 0x0000, 0x0002, 0x0002, 0x0002, 0x0000 };

    auto collation = collate_for_tests(
        cps, cps + 2, boost::text::variable_weighting::non_ignorable);

    EXPECT_EQ(collation.size(), 11);
    EXPECT_TRUE(boost::algorithm::equal(collation.begin(), collation.end(), ces, ces + 11))
        << "from:     " << ce_dumper(cps)
        << "expected: " << ce_dumper(ces)
        << "got:      " << ce_dumper(collation);
}

TEST(collation, non_ignorable_121_073)
{
    // 0164 0062;	
    // (Ť) LATIN CAPITAL LETTER T WITH CARON	[1EFB 1CC6 | 0020 0028 0020 | 0008 0002 0002 |]

    uint32_t cps[2] = { 0x0164, 0x0062 };
    uint32_t const ces[11] = { 0x1EFB, 0x1CC6, 0x0000, 0x0020, 0x0028, 0x0020, 0x0000, 0x0008, 0x0002, 0x0002, 0x0000 };

    auto collation = collate_for_tests(
        cps, cps + 2, boost::text::variable_weighting::non_ignorable);

    EXPECT_EQ(collation.size(), 11);
    EXPECT_TRUE(boost::algorithm::equal(collation.begin(), collation.end(), ces, ces + 11))
        << "from:     " << ce_dumper(cps)
        << "expected: " << ce_dumper(ces)
        << "got:      " << ce_dumper(collation);
}

TEST(collation, non_ignorable_121_074)
{
    // 1E97 0062;	
    // (ẗ) LATIN SMALL LETTER T WITH DIAERESIS	[1EFB 1CC6 | 0020 002B 0020 | 0002 0002 0002 |]

    uint32_t cps[2] = { 0x1E97, 0x0062 };
    uint32_t const ces[11] = { 0x1EFB, 0x1CC6, 0x0000, 0x0020, 0x002B, 0x0020, 0x0000, 0x0002, 0x0002, 0x0002, 0x0000 };

    auto collation = collate_for_tests(
        cps, cps + 2, boost::text::variable_weighting::non_ignorable);

    EXPECT_EQ(collation.size(), 11);
    EXPECT_TRUE(boost::algorithm::equal(collation.begin(), collation.end(), ces, ces + 11))
        << "from:     " << ce_dumper(cps)
        << "expected: " << ce_dumper(ces)
        << "got:      " << ce_dumper(collation);
}

TEST(collation, non_ignorable_121_075)
{
    // 1E6B 0062;	
    // (ṫ) LATIN SMALL LETTER T WITH DOT ABOVE	[1EFB 1CC6 | 0020 002E 0020 | 0002 0002 0002 |]

    uint32_t cps[2] = { 0x1E6B, 0x0062 };
    uint32_t const ces[11] = { 0x1EFB, 0x1CC6, 0x0000, 0x0020, 0x002E, 0x0020, 0x0000, 0x0002, 0x0002, 0x0002, 0x0000 };

    auto collation = collate_for_tests(
        cps, cps + 2, boost::text::variable_weighting::non_ignorable);

    EXPECT_EQ(collation.size(), 11);
    EXPECT_TRUE(boost::algorithm::equal(collation.begin(), collation.end(), ces, ces + 11))
        << "from:     " << ce_dumper(cps)
        << "expected: " << ce_dumper(ces)
        << "got:      " << ce_dumper(collation);
}

TEST(collation, non_ignorable_121_076)
{
    // 1E6A 0062;	
    // (Ṫ) LATIN CAPITAL LETTER T WITH DOT ABOVE	[1EFB 1CC6 | 0020 002E 0020 | 0008 0002 0002 |]

    uint32_t cps[2] = { 0x1E6A, 0x0062 };
    uint32_t const ces[11] = { 0x1EFB, 0x1CC6, 0x0000, 0x0020, 0x002E, 0x0020, 0x0000, 0x0008, 0x0002, 0x0002, 0x0000 };

    auto collation = collate_for_tests(
        cps, cps + 2, boost::text::variable_weighting::non_ignorable);

    EXPECT_EQ(collation.size(), 11);
    EXPECT_TRUE(boost::algorithm::equal(collation.begin(), collation.end(), ces, ces + 11))
        << "from:     " << ce_dumper(cps)
        << "expected: " << ce_dumper(ces)
        << "got:      " << ce_dumper(collation);
}

TEST(collation, non_ignorable_121_077)
{
    // 0163 0062;	
    // (ţ) LATIN SMALL LETTER T WITH CEDILLA	[1EFB 1CC6 | 0020 0030 0020 | 0002 0002 0002 |]

    uint32_t cps[2] = { 0x0163, 0x0062 };
    uint32_t const ces[11] = { 0x1EFB, 0x1CC6, 0x0000, 0x0020, 0x0030, 0x0020, 0x0000, 0x0002, 0x0002, 0x0002, 0x0000 };

    auto collation = collate_for_tests(
        cps, cps + 2, boost::text::variable_weighting::non_ignorable);

    EXPECT_EQ(collation.size(), 11);
    EXPECT_TRUE(boost::algorithm::equal(collation.begin(), collation.end(), ces, ces + 11))
        << "from:     " << ce_dumper(cps)
        << "expected: " << ce_dumper(ces)
        << "got:      " << ce_dumper(collation);
}

TEST(collation, non_ignorable_121_078)
{
    // 0162 0062;	
    // (Ţ) LATIN CAPITAL LETTER T WITH CEDILLA	[1EFB 1CC6 | 0020 0030 0020 | 0008 0002 0002 |]

    uint32_t cps[2] = { 0x0162, 0x0062 };
    uint32_t const ces[11] = { 0x1EFB, 0x1CC6, 0x0000, 0x0020, 0x0030, 0x0020, 0x0000, 0x0008, 0x0002, 0x0002, 0x0000 };

    auto collation = collate_for_tests(
        cps, cps + 2, boost::text::variable_weighting::non_ignorable);

    EXPECT_EQ(collation.size(), 11);
    EXPECT_TRUE(boost::algorithm::equal(collation.begin(), collation.end(), ces, ces + 11))
        << "from:     " << ce_dumper(cps)
        << "expected: " << ce_dumper(ces)
        << "got:      " << ce_dumper(collation);
}

TEST(collation, non_ignorable_121_079)
{
    // 1E6D 0062;	
    // (ṭ) LATIN SMALL LETTER T WITH DOT BELOW	[1EFB 1CC6 | 0020 0042 0020 | 0002 0002 0002 |]

    uint32_t cps[2] = { 0x1E6D, 0x0062 };
    uint32_t const ces[11] = { 0x1EFB, 0x1CC6, 0x0000, 0x0020, 0x0042, 0x0020, 0x0000, 0x0002, 0x0002, 0x0002, 0x0000 };

    auto collation = collate_for_tests(
        cps, cps + 2, boost::text::variable_weighting::non_ignorable);

    EXPECT_EQ(collation.size(), 11);
    EXPECT_TRUE(boost::algorithm::equal(collation.begin(), collation.end(), ces, ces + 11))
        << "from:     " << ce_dumper(cps)
        << "expected: " << ce_dumper(ces)
        << "got:      " << ce_dumper(collation);
}

TEST(collation, non_ignorable_121_080)
{
    // 1E6C 0062;	
    // (Ṭ) LATIN CAPITAL LETTER T WITH DOT BELOW	[1EFB 1CC6 | 0020 0042 0020 | 0008 0002 0002 |]

    uint32_t cps[2] = { 0x1E6C, 0x0062 };
    uint32_t const ces[11] = { 0x1EFB, 0x1CC6, 0x0000, 0x0020, 0x0042, 0x0020, 0x0000, 0x0008, 0x0002, 0x0002, 0x0000 };

    auto collation = collate_for_tests(
        cps, cps + 2, boost::text::variable_weighting::non_ignorable);

    EXPECT_EQ(collation.size(), 11);
    EXPECT_TRUE(boost::algorithm::equal(collation.begin(), collation.end(), ces, ces + 11))
        << "from:     " << ce_dumper(cps)
        << "expected: " << ce_dumper(ces)
        << "got:      " << ce_dumper(collation);
}

TEST(collation, non_ignorable_121_081)
{
    // 021B 0062;	
    // (ț) LATIN SMALL LETTER T WITH COMMA BELOW	[1EFB 1CC6 | 0020 0045 0020 | 0002 0002 0002 |]

    uint32_t cps[2] = { 0x021B, 0x0062 };
    uint32_t const ces[11] = { 0x1EFB, 0x1CC6, 0x0000, 0x0020, 0x0045, 0x0020, 0x0000, 0x0002, 0x0002, 0x0002, 0x0000 };

    auto collation = collate_for_tests(
        cps, cps + 2, boost::text::variable_weighting::non_ignorable);

    EXPECT_EQ(collation.size(), 11);
    EXPECT_TRUE(boost::algorithm::equal(collation.begin(), collation.end(), ces, ces + 11))
        << "from:     " << ce_dumper(cps)
        << "expected: " << ce_dumper(ces)
        << "got:      " << ce_dumper(collation);
}

TEST(collation, non_ignorable_121_082)
{
    // 021A 0062;	
    // (Ț) LATIN CAPITAL LETTER T WITH COMMA BELOW	[1EFB 1CC6 | 0020 0045 0020 | 0008 0002 0002 |]

    uint32_t cps[2] = { 0x021A, 0x0062 };
    uint32_t const ces[11] = { 0x1EFB, 0x1CC6, 0x0000, 0x0020, 0x0045, 0x0020, 0x0000, 0x0008, 0x0002, 0x0002, 0x0000 };

    auto collation = collate_for_tests(
        cps, cps + 2, boost::text::variable_weighting::non_ignorable);

    EXPECT_EQ(collation.size(), 11);
    EXPECT_TRUE(boost::algorithm::equal(collation.begin(), collation.end(), ces, ces + 11))
        << "from:     " << ce_dumper(cps)
        << "expected: " << ce_dumper(ces)
        << "got:      " << ce_dumper(collation);
}

TEST(collation, non_ignorable_121_083)
{
    // 1E71 0062;	
    // (ṱ) LATIN SMALL LETTER T WITH CIRCUMFLEX BELOW	[1EFB 1CC6 | 0020 0046 0020 | 0002 0002 0002 |]

    uint32_t cps[2] = { 0x1E71, 0x0062 };
    uint32_t const ces[11] = { 0x1EFB, 0x1CC6, 0x0000, 0x0020, 0x0046, 0x0020, 0x0000, 0x0002, 0x0002, 0x0002, 0x0000 };

    auto collation = collate_for_tests(
        cps, cps + 2, boost::text::variable_weighting::non_ignorable);

    EXPECT_EQ(collation.size(), 11);
    EXPECT_TRUE(boost::algorithm::equal(collation.begin(), collation.end(), ces, ces + 11))
        << "from:     " << ce_dumper(cps)
        << "expected: " << ce_dumper(ces)
        << "got:      " << ce_dumper(collation);
}

TEST(collation, non_ignorable_121_084)
{
    // 1E70 0062;	
    // (Ṱ) LATIN CAPITAL LETTER T WITH CIRCUMFLEX BELOW	[1EFB 1CC6 | 0020 0046 0020 | 0008 0002 0002 |]

    uint32_t cps[2] = { 0x1E70, 0x0062 };
    uint32_t const ces[11] = { 0x1EFB, 0x1CC6, 0x0000, 0x0020, 0x0046, 0x0020, 0x0000, 0x0008, 0x0002, 0x0002, 0x0000 };

    auto collation = collate_for_tests(
        cps, cps + 2, boost::text::variable_weighting::non_ignorable);

    EXPECT_EQ(collation.size(), 11);
    EXPECT_TRUE(boost::algorithm::equal(collation.begin(), collation.end(), ces, ces + 11))
        << "from:     " << ce_dumper(cps)
        << "expected: " << ce_dumper(ces)
        << "got:      " << ce_dumper(collation);
}

TEST(collation, non_ignorable_121_085)
{
    // 1E6F 0062;	
    // (ṯ) LATIN SMALL LETTER T WITH LINE BELOW	[1EFB 1CC6 | 0020 0049 0020 | 0002 0002 0002 |]

    uint32_t cps[2] = { 0x1E6F, 0x0062 };
    uint32_t const ces[11] = { 0x1EFB, 0x1CC6, 0x0000, 0x0020, 0x0049, 0x0020, 0x0000, 0x0002, 0x0002, 0x0002, 0x0000 };

    auto collation = collate_for_tests(
        cps, cps + 2, boost::text::variable_weighting::non_ignorable);

    EXPECT_EQ(collation.size(), 11);
    EXPECT_TRUE(boost::algorithm::equal(collation.begin(), collation.end(), ces, ces + 11))
        << "from:     " << ce_dumper(cps)
        << "expected: " << ce_dumper(ces)
        << "got:      " << ce_dumper(collation);
}

TEST(collation, non_ignorable_121_086)
{
    // 1E6E 0062;	
    // (Ṯ) LATIN CAPITAL LETTER T WITH LINE BELOW	[1EFB 1CC6 | 0020 0049 0020 | 0008 0002 0002 |]

    uint32_t cps[2] = { 0x1E6E, 0x0062 };
    uint32_t const ces[11] = { 0x1EFB, 0x1CC6, 0x0000, 0x0020, 0x0049, 0x0020, 0x0000, 0x0008, 0x0002, 0x0002, 0x0000 };

    auto collation = collate_for_tests(
        cps, cps + 2, boost::text::variable_weighting::non_ignorable);

    EXPECT_EQ(collation.size(), 11);
    EXPECT_TRUE(boost::algorithm::equal(collation.begin(), collation.end(), ces, ces + 11))
        << "from:     " << ce_dumper(cps)
        << "expected: " << ce_dumper(ces)
        << "got:      " << ce_dumper(collation);
}

TEST(collation, non_ignorable_121_087)
{
    // A787 0062;	
    // (ꞇ) LATIN SMALL LETTER INSULAR T	[1EFB 1CC6 | 0020 0112 0020 | 0004 0004 0002 |]

    uint32_t cps[2] = { 0xA787, 0x0062 };
    uint32_t const ces[11] = { 0x1EFB, 0x1CC6, 0x0000, 0x0020, 0x0112, 0x0020, 0x0000, 0x0004, 0x0004, 0x0002, 0x0000 };

    auto collation = collate_for_tests(
        cps, cps + 2, boost::text::variable_weighting::non_ignorable);

    EXPECT_EQ(collation.size(), 11);
    EXPECT_TRUE(boost::algorithm::equal(collation.begin(), collation.end(), ces, ces + 11))
        << "from:     " << ce_dumper(cps)
        << "expected: " << ce_dumper(ces)
        << "got:      " << ce_dumper(collation);
}

TEST(collation, non_ignorable_121_088)
{
    // A786 0062;	
    // (Ꞇ) LATIN CAPITAL LETTER INSULAR T	[1EFB 1CC6 | 0020 0112 0020 | 000A 0004 0002 |]

    uint32_t cps[2] = { 0xA786, 0x0062 };
    uint32_t const ces[11] = { 0x1EFB, 0x1CC6, 0x0000, 0x0020, 0x0112, 0x0020, 0x0000, 0x000A, 0x0004, 0x0002, 0x0000 };

    auto collation = collate_for_tests(
        cps, cps + 2, boost::text::variable_weighting::non_ignorable);

    EXPECT_EQ(collation.size(), 11);
    EXPECT_TRUE(boost::algorithm::equal(collation.begin(), collation.end(), ces, ces + 11))
        << "from:     " << ce_dumper(cps)
        << "expected: " << ce_dumper(ces)
        << "got:      " << ce_dumper(collation);
}

TEST(collation, non_ignorable_121_089)
{
    // 02A8 0021;	
    // (ʨ) LATIN SMALL LETTER TC DIGRAPH WITH CURL	[1EFB 1CEF 0261 | 0020 0020 0020 | 0004 0004 0002 |]

    uint32_t cps[2] = { 0x02A8, 0x0021 };
    uint32_t const ces[12] = { 0x1EFB, 0x1CEF, 0x0261, 0x0000, 0x0020, 0x0020, 0x0020, 0x0000, 0x0004, 0x0004, 0x0002, 0x0000 };

    auto collation = collate_for_tests(
        cps, cps + 2, boost::text::variable_weighting::non_ignorable);

    EXPECT_EQ(collation.size(), 12);
    EXPECT_TRUE(boost::algorithm::equal(collation.begin(), collation.end(), ces, ces + 12))
        << "from:     " << ce_dumper(cps)
        << "expected: " << ce_dumper(ces)
        << "got:      " << ce_dumper(collation);
}

TEST(collation, non_ignorable_121_090)
{
    // 02A8 003F;	
    // (ʨ) LATIN SMALL LETTER TC DIGRAPH WITH CURL	[1EFB 1CEF 0267 | 0020 0020 0020 | 0004 0004 0002 |]

    uint32_t cps[2] = { 0x02A8, 0x003F };
    uint32_t const ces[12] = { 0x1EFB, 0x1CEF, 0x0267, 0x0000, 0x0020, 0x0020, 0x0020, 0x0000, 0x0004, 0x0004, 0x0002, 0x0000 };

    auto collation = collate_for_tests(
        cps, cps + 2, boost::text::variable_weighting::non_ignorable);

    EXPECT_EQ(collation.size(), 12);
    EXPECT_TRUE(boost::algorithm::equal(collation.begin(), collation.end(), ces, ces + 12))
        << "from:     " << ce_dumper(cps)
        << "expected: " << ce_dumper(ces)
        << "got:      " << ce_dumper(collation);
}

TEST(collation, non_ignorable_121_091)
{
    // 02A8 0061;	
    // (ʨ) LATIN SMALL LETTER TC DIGRAPH WITH CURL	[1EFB 1CEF 1CAD | 0020 0020 0020 | 0004 0004 0002 |]

    uint32_t cps[2] = { 0x02A8, 0x0061 };
    uint32_t const ces[12] = { 0x1EFB, 0x1CEF, 0x1CAD, 0x0000, 0x0020, 0x0020, 0x0020, 0x0000, 0x0004, 0x0004, 0x0002, 0x0000 };

    auto collation = collate_for_tests(
        cps, cps + 2, boost::text::variable_weighting::non_ignorable);

    EXPECT_EQ(collation.size(), 12);
    EXPECT_TRUE(boost::algorithm::equal(collation.begin(), collation.end(), ces, ces + 12))
        << "from:     " << ce_dumper(cps)
        << "expected: " << ce_dumper(ces)
        << "got:      " << ce_dumper(collation);
}

TEST(collation, non_ignorable_121_092)
{
    // 02A8 0041;	
    // (ʨ) LATIN SMALL LETTER TC DIGRAPH WITH CURL	[1EFB 1CEF 1CAD | 0020 0020 0020 | 0004 0004 0008 |]

    uint32_t cps[2] = { 0x02A8, 0x0041 };
    uint32_t const ces[12] = { 0x1EFB, 0x1CEF, 0x1CAD, 0x0000, 0x0020, 0x0020, 0x0020, 0x0000, 0x0004, 0x0004, 0x0008, 0x0000 };

    auto collation = collate_for_tests(
        cps, cps + 2, boost::text::variable_weighting::non_ignorable);

    EXPECT_EQ(collation.size(), 12);
    EXPECT_TRUE(boost::algorithm::equal(collation.begin(), collation.end(), ces, ces + 12))
        << "from:     " << ce_dumper(cps)
        << "expected: " << ce_dumper(ces)
        << "got:      " << ce_dumper(collation);
}

TEST(collation, non_ignorable_121_093)
{
    // 02A8 0062;	
    // (ʨ) LATIN SMALL LETTER TC DIGRAPH WITH CURL	[1EFB 1CEF 1CC6 | 0020 0020 0020 | 0004 0004 0002 |]

    uint32_t cps[2] = { 0x02A8, 0x0062 };
    uint32_t const ces[12] = { 0x1EFB, 0x1CEF, 0x1CC6, 0x0000, 0x0020, 0x0020, 0x0020, 0x0000, 0x0004, 0x0004, 0x0002, 0x0000 };

    auto collation = collate_for_tests(
        cps, cps + 2, boost::text::variable_weighting::non_ignorable);

    EXPECT_EQ(collation.size(), 12);
    EXPECT_TRUE(boost::algorithm::equal(collation.begin(), collation.end(), ces, ces + 12))
        << "from:     " << ce_dumper(cps)
        << "expected: " << ce_dumper(ces)
        << "got:      " << ce_dumper(collation);
}

TEST(collation, non_ignorable_121_094)
{
    // 2121 0021;	
    // (℡) TELEPHONE SIGN	[1EFB 1D10 1DDD 0261 | 0020 0020 0020 0020 | 000A 000A 000A 0002 |]

    uint32_t cps[2] = { 0x2121, 0x0021 };
    uint32_t const ces[15] = { 0x1EFB, 0x1D10, 0x1DDD, 0x0261, 0x0000, 0x0020, 0x0020, 0x0020, 0x0020, 0x0000, 0x000A, 0x000A, 0x000A, 0x0002, 0x0000 };

    auto collation = collate_for_tests(
        cps, cps + 2, boost::text::variable_weighting::non_ignorable);

    EXPECT_EQ(collation.size(), 15);
    EXPECT_TRUE(boost::algorithm::equal(collation.begin(), collation.end(), ces, ces + 15))
        << "from:     " << ce_dumper(cps)
        << "expected: " << ce_dumper(ces)
        << "got:      " << ce_dumper(collation);
}

TEST(collation, non_ignorable_121_095)
{
    // 2121 003F;	
    // (℡) TELEPHONE SIGN	[1EFB 1D10 1DDD 0267 | 0020 0020 0020 0020 | 000A 000A 000A 0002 |]

    uint32_t cps[2] = { 0x2121, 0x003F };
    uint32_t const ces[15] = { 0x1EFB, 0x1D10, 0x1DDD, 0x0267, 0x0000, 0x0020, 0x0020, 0x0020, 0x0020, 0x0000, 0x000A, 0x000A, 0x000A, 0x0002, 0x0000 };

    auto collation = collate_for_tests(
        cps, cps + 2, boost::text::variable_weighting::non_ignorable);

    EXPECT_EQ(collation.size(), 15);
    EXPECT_TRUE(boost::algorithm::equal(collation.begin(), collation.end(), ces, ces + 15))
        << "from:     " << ce_dumper(cps)
        << "expected: " << ce_dumper(ces)
        << "got:      " << ce_dumper(collation);
}

TEST(collation, non_ignorable_121_096)
{
    // 2121 0061;	
    // (℡) TELEPHONE SIGN	[1EFB 1D10 1DDD 1CAD | 0020 0020 0020 0020 | 000A 000A 000A 0002 |]

    uint32_t cps[2] = { 0x2121, 0x0061 };
    uint32_t const ces[15] = { 0x1EFB, 0x1D10, 0x1DDD, 0x1CAD, 0x0000, 0x0020, 0x0020, 0x0020, 0x0020, 0x0000, 0x000A, 0x000A, 0x000A, 0x0002, 0x0000 };

    auto collation = collate_for_tests(
        cps, cps + 2, boost::text::variable_weighting::non_ignorable);

    EXPECT_EQ(collation.size(), 15);
    EXPECT_TRUE(boost::algorithm::equal(collation.begin(), collation.end(), ces, ces + 15))
        << "from:     " << ce_dumper(cps)
        << "expected: " << ce_dumper(ces)
        << "got:      " << ce_dumper(collation);
}

TEST(collation, non_ignorable_121_097)
{
    // 2121 0041;	
    // (℡) TELEPHONE SIGN	[1EFB 1D10 1DDD 1CAD | 0020 0020 0020 0020 | 000A 000A 000A 0008 |]

    uint32_t cps[2] = { 0x2121, 0x0041 };
    uint32_t const ces[15] = { 0x1EFB, 0x1D10, 0x1DDD, 0x1CAD, 0x0000, 0x0020, 0x0020, 0x0020, 0x0020, 0x0000, 0x000A, 0x000A, 0x000A, 0x0008, 0x0000 };

    auto collation = collate_for_tests(
        cps, cps + 2, boost::text::variable_weighting::non_ignorable);

    EXPECT_EQ(collation.size(), 15);
    EXPECT_TRUE(boost::algorithm::equal(collation.begin(), collation.end(), ces, ces + 15))
        << "from:     " << ce_dumper(cps)
        << "expected: " << ce_dumper(ces)
        << "got:      " << ce_dumper(collation);
}

TEST(collation, non_ignorable_121_098)
{
    // 2121 0062;	
    // (℡) TELEPHONE SIGN	[1EFB 1D10 1DDD 1CC6 | 0020 0020 0020 0020 | 000A 000A 000A 0002 |]

    uint32_t cps[2] = { 0x2121, 0x0062 };
    uint32_t const ces[15] = { 0x1EFB, 0x1D10, 0x1DDD, 0x1CC6, 0x0000, 0x0020, 0x0020, 0x0020, 0x0020, 0x0000, 0x000A, 0x000A, 0x000A, 0x0002, 0x0000 };

    auto collation = collate_for_tests(
        cps, cps + 2, boost::text::variable_weighting::non_ignorable);

    EXPECT_EQ(collation.size(), 15);
    EXPECT_TRUE(boost::algorithm::equal(collation.begin(), collation.end(), ces, ces + 15))
        << "from:     " << ce_dumper(cps)
        << "expected: " << ce_dumper(ces)
        << "got:      " << ce_dumper(collation);
}

TEST(collation, non_ignorable_121_099)
{
    // 1D7A 0021;	
    // (ᵺ) LATIN SMALL LETTER TH WITH STRIKETHROUGH	[1EFB 1D7E 0261 | 0020 0111 0020 0020 | 0004 0004 0004 0002 |]

    uint32_t cps[2] = { 0x1D7A, 0x0021 };
    uint32_t const ces[14] = { 0x1EFB, 0x1D7E, 0x0261, 0x0000, 0x0020, 0x0111, 0x0020, 0x0020, 0x0000, 0x0004, 0x0004, 0x0004, 0x0002, 0x0000 };

    auto collation = collate_for_tests(
        cps, cps + 2, boost::text::variable_weighting::non_ignorable);

    EXPECT_EQ(collation.size(), 14);
    EXPECT_TRUE(boost::algorithm::equal(collation.begin(), collation.end(), ces, ces + 14))
        << "from:     " << ce_dumper(cps)
        << "expected: " << ce_dumper(ces)
        << "got:      " << ce_dumper(collation);
}

TEST(collation, non_ignorable_121_100)
{
    // 1D7A 003F;	
    // (ᵺ) LATIN SMALL LETTER TH WITH STRIKETHROUGH	[1EFB 1D7E 0267 | 0020 0111 0020 0020 | 0004 0004 0004 0002 |]

    uint32_t cps[2] = { 0x1D7A, 0x003F };
    uint32_t const ces[14] = { 0x1EFB, 0x1D7E, 0x0267, 0x0000, 0x0020, 0x0111, 0x0020, 0x0020, 0x0000, 0x0004, 0x0004, 0x0004, 0x0002, 0x0000 };

    auto collation = collate_for_tests(
        cps, cps + 2, boost::text::variable_weighting::non_ignorable);

    EXPECT_EQ(collation.size(), 14);
    EXPECT_TRUE(boost::algorithm::equal(collation.begin(), collation.end(), ces, ces + 14))
        << "from:     " << ce_dumper(cps)
        << "expected: " << ce_dumper(ces)
        << "got:      " << ce_dumper(collation);
}

TEST(collation, non_ignorable_121_101)
{
    // 1D7A 0061;	
    // (ᵺ) LATIN SMALL LETTER TH WITH STRIKETHROUGH	[1EFB 1D7E 1CAD | 0020 0111 0020 0020 | 0004 0004 0004 0002 |]

    uint32_t cps[2] = { 0x1D7A, 0x0061 };
    uint32_t const ces[14] = { 0x1EFB, 0x1D7E, 0x1CAD, 0x0000, 0x0020, 0x0111, 0x0020, 0x0020, 0x0000, 0x0004, 0x0004, 0x0004, 0x0002, 0x0000 };

    auto collation = collate_for_tests(
        cps, cps + 2, boost::text::variable_weighting::non_ignorable);

    EXPECT_EQ(collation.size(), 14);
    EXPECT_TRUE(boost::algorithm::equal(collation.begin(), collation.end(), ces, ces + 14))
        << "from:     " << ce_dumper(cps)
        << "expected: " << ce_dumper(ces)
        << "got:      " << ce_dumper(collation);
}

TEST(collation, non_ignorable_121_102)
{
    // 1D7A 0041;	
    // (ᵺ) LATIN SMALL LETTER TH WITH STRIKETHROUGH	[1EFB 1D7E 1CAD | 0020 0111 0020 0020 | 0004 0004 0004 0008 |]

    uint32_t cps[2] = { 0x1D7A, 0x0041 };
    uint32_t const ces[14] = { 0x1EFB, 0x1D7E, 0x1CAD, 0x0000, 0x0020, 0x0111, 0x0020, 0x0020, 0x0000, 0x0004, 0x0004, 0x0004, 0x0008, 0x0000 };

    auto collation = collate_for_tests(
        cps, cps + 2, boost::text::variable_weighting::non_ignorable);

    EXPECT_EQ(collation.size(), 14);
    EXPECT_TRUE(boost::algorithm::equal(collation.begin(), collation.end(), ces, ces + 14))
        << "from:     " << ce_dumper(cps)
        << "expected: " << ce_dumper(ces)
        << "got:      " << ce_dumper(collation);
}

TEST(collation, non_ignorable_121_103)
{
    // 1D7A 0062;	
    // (ᵺ) LATIN SMALL LETTER TH WITH STRIKETHROUGH	[1EFB 1D7E 1CC6 | 0020 0111 0020 0020 | 0004 0004 0004 0002 |]

    uint32_t cps[2] = { 0x1D7A, 0x0062 };
    uint32_t const ces[14] = { 0x1EFB, 0x1D7E, 0x1CC6, 0x0000, 0x0020, 0x0111, 0x0020, 0x0020, 0x0000, 0x0004, 0x0004, 0x0004, 0x0002, 0x0000 };

    auto collation = collate_for_tests(
        cps, cps + 2, boost::text::variable_weighting::non_ignorable);

    EXPECT_EQ(collation.size(), 14);
    EXPECT_TRUE(boost::algorithm::equal(collation.begin(), collation.end(), ces, ces + 14))
        << "from:     " << ce_dumper(cps)
        << "expected: " << ce_dumper(ces)
        << "got:      " << ce_dumper(collation);
}

TEST(collation, non_ignorable_121_104)
{
    // 3394 0021;	
    // (㎔) SQUARE THZ	[1EFB 1D7E 1F87 0261 | 0020 0020 0020 0020 | 001D 001D 001C 0002 |]

    uint32_t cps[2] = { 0x3394, 0x0021 };
    uint32_t const ces[15] = { 0x1EFB, 0x1D7E, 0x1F87, 0x0261, 0x0000, 0x0020, 0x0020, 0x0020, 0x0020, 0x0000, 0x001D, 0x001D, 0x001C, 0x0002, 0x0000 };

    auto collation = collate_for_tests(
        cps, cps + 2, boost::text::variable_weighting::non_ignorable);

    EXPECT_EQ(collation.size(), 15);
    EXPECT_TRUE(boost::algorithm::equal(collation.begin(), collation.end(), ces, ces + 15))
        << "from:     " << ce_dumper(cps)
        << "expected: " << ce_dumper(ces)
        << "got:      " << ce_dumper(collation);
}

TEST(collation, non_ignorable_121_105)
{
    // 3394 003F;	
    // (㎔) SQUARE THZ	[1EFB 1D7E 1F87 0267 | 0020 0020 0020 0020 | 001D 001D 001C 0002 |]

    uint32_t cps[2] = { 0x3394, 0x003F };
    uint32_t const ces[15] = { 0x1EFB, 0x1D7E, 0x1F87, 0x0267, 0x0000, 0x0020, 0x0020, 0x0020, 0x0020, 0x0000, 0x001D, 0x001D, 0x001C, 0x0002, 0x0000 };

    auto collation = collate_for_tests(
        cps, cps + 2, boost::text::variable_weighting::non_ignorable);

    EXPECT_EQ(collation.size(), 15);
    EXPECT_TRUE(boost::algorithm::equal(collation.begin(), collation.end(), ces, ces + 15))
        << "from:     " << ce_dumper(cps)
        << "expected: " << ce_dumper(ces)
        << "got:      " << ce_dumper(collation);
}

TEST(collation, non_ignorable_121_106)
{
    // 3394 0061;	
    // (㎔) SQUARE THZ	[1EFB 1D7E 1F87 1CAD | 0020 0020 0020 0020 | 001D 001D 001C 0002 |]

    uint32_t cps[2] = { 0x3394, 0x0061 };
    uint32_t const ces[15] = { 0x1EFB, 0x1D7E, 0x1F87, 0x1CAD, 0x0000, 0x0020, 0x0020, 0x0020, 0x0020, 0x0000, 0x001D, 0x001D, 0x001C, 0x0002, 0x0000 };

    auto collation = collate_for_tests(
        cps, cps + 2, boost::text::variable_weighting::non_ignorable);

    EXPECT_EQ(collation.size(), 15);
    EXPECT_TRUE(boost::algorithm::equal(collation.begin(), collation.end(), ces, ces + 15))
        << "from:     " << ce_dumper(cps)
        << "expected: " << ce_dumper(ces)
        << "got:      " << ce_dumper(collation);
}

TEST(collation, non_ignorable_121_107)
{
    // 3394 0041;	
    // (㎔) SQUARE THZ	[1EFB 1D7E 1F87 1CAD | 0020 0020 0020 0020 | 001D 001D 001C 0008 |]

    uint32_t cps[2] = { 0x3394, 0x0041 };
    uint32_t const ces[15] = { 0x1EFB, 0x1D7E, 0x1F87, 0x1CAD, 0x0000, 0x0020, 0x0020, 0x0020, 0x0020, 0x0000, 0x001D, 0x001D, 0x001C, 0x0008, 0x0000 };

    auto collation = collate_for_tests(
        cps, cps + 2, boost::text::variable_weighting::non_ignorable);

    EXPECT_EQ(collation.size(), 15);
    EXPECT_TRUE(boost::algorithm::equal(collation.begin(), collation.end(), ces, ces + 15))
        << "from:     " << ce_dumper(cps)
        << "expected: " << ce_dumper(ces)
        << "got:      " << ce_dumper(collation);
}

TEST(collation, non_ignorable_121_108)
{
    // 3394 0062;	
    // (㎔) SQUARE THZ	[1EFB 1D7E 1F87 1CC6 | 0020 0020 0020 0020 | 001D 001D 001C 0002 |]

    uint32_t cps[2] = { 0x3394, 0x0062 };
    uint32_t const ces[15] = { 0x1EFB, 0x1D7E, 0x1F87, 0x1CC6, 0x0000, 0x0020, 0x0020, 0x0020, 0x0020, 0x0000, 0x001D, 0x001D, 0x001C, 0x0002, 0x0000 };

    auto collation = collate_for_tests(
        cps, cps + 2, boost::text::variable_weighting::non_ignorable);

    EXPECT_EQ(collation.size(), 15);
    EXPECT_TRUE(boost::algorithm::equal(collation.begin(), collation.end(), ces, ces + 15))
        << "from:     " << ce_dumper(cps)
        << "expected: " << ce_dumper(ces)
        << "got:      " << ce_dumper(collation);
}

TEST(collation, non_ignorable_121_109)
{
    // 2122 0021;	
    // (™) TRADE MARK SIGN	[1EFB 1E10 0261 | 0020 0020 0020 | 0014 0014 0002 |]

    uint32_t cps[2] = { 0x2122, 0x0021 };
    uint32_t const ces[12] = { 0x1EFB, 0x1E10, 0x0261, 0x0000, 0x0020, 0x0020, 0x0020, 0x0000, 0x0014, 0x0014, 0x0002, 0x0000 };

    auto collation = collate_for_tests(
        cps, cps + 2, boost::text::variable_weighting::non_ignorable);

    EXPECT_EQ(collation.size(), 12);
    EXPECT_TRUE(boost::algorithm::equal(collation.begin(), collation.end(), ces, ces + 12))
        << "from:     " << ce_dumper(cps)
        << "expected: " << ce_dumper(ces)
        << "got:      " << ce_dumper(collation);
}

TEST(collation, non_ignorable_121_110)
{
    // 2122 003F;	
    // (™) TRADE MARK SIGN	[1EFB 1E10 0267 | 0020 0020 0020 | 0014 0014 0002 |]

    uint32_t cps[2] = { 0x2122, 0x003F };
    uint32_t const ces[12] = { 0x1EFB, 0x1E10, 0x0267, 0x0000, 0x0020, 0x0020, 0x0020, 0x0000, 0x0014, 0x0014, 0x0002, 0x0000 };

    auto collation = collate_for_tests(
        cps, cps + 2, boost::text::variable_weighting::non_ignorable);

    EXPECT_EQ(collation.size(), 12);
    EXPECT_TRUE(boost::algorithm::equal(collation.begin(), collation.end(), ces, ces + 12))
        << "from:     " << ce_dumper(cps)
        << "expected: " << ce_dumper(ces)
        << "got:      " << ce_dumper(collation);
}

TEST(collation, non_ignorable_121_111)
{
    // 2122 0061;	
    // (™) TRADE MARK SIGN	[1EFB 1E10 1CAD | 0020 0020 0020 | 0014 0014 0002 |]

    uint32_t cps[2] = { 0x2122, 0x0061 };
    uint32_t const ces[12] = { 0x1EFB, 0x1E10, 0x1CAD, 0x0000, 0x0020, 0x0020, 0x0020, 0x0000, 0x0014, 0x0014, 0x0002, 0x0000 };

    auto collation = collate_for_tests(
        cps, cps + 2, boost::text::variable_weighting::non_ignorable);

    EXPECT_EQ(collation.size(), 12);
    EXPECT_TRUE(boost::algorithm::equal(collation.begin(), collation.end(), ces, ces + 12))
        << "from:     " << ce_dumper(cps)
        << "expected: " << ce_dumper(ces)
        << "got:      " << ce_dumper(collation);
}

TEST(collation, non_ignorable_121_112)
{
    // 2122 0041;	
    // (™) TRADE MARK SIGN	[1EFB 1E10 1CAD | 0020 0020 0020 | 0014 0014 0008 |]

    uint32_t cps[2] = { 0x2122, 0x0041 };
    uint32_t const ces[12] = { 0x1EFB, 0x1E10, 0x1CAD, 0x0000, 0x0020, 0x0020, 0x0020, 0x0000, 0x0014, 0x0014, 0x0008, 0x0000 };

    auto collation = collate_for_tests(
        cps, cps + 2, boost::text::variable_weighting::non_ignorable);

    EXPECT_EQ(collation.size(), 12);
    EXPECT_TRUE(boost::algorithm::equal(collation.begin(), collation.end(), ces, ces + 12))
        << "from:     " << ce_dumper(cps)
        << "expected: " << ce_dumper(ces)
        << "got:      " << ce_dumper(collation);
}

TEST(collation, non_ignorable_121_113)
{
    // 2122 0062;	
    // (™) TRADE MARK SIGN	[1EFB 1E10 1CC6 | 0020 0020 0020 | 0014 0014 0002 |]

    uint32_t cps[2] = { 0x2122, 0x0062 };
    uint32_t const ces[12] = { 0x1EFB, 0x1E10, 0x1CC6, 0x0000, 0x0020, 0x0020, 0x0020, 0x0000, 0x0014, 0x0014, 0x0002, 0x0000 };

    auto collation = collate_for_tests(
        cps, cps + 2, boost::text::variable_weighting::non_ignorable);

    EXPECT_EQ(collation.size(), 12);
    EXPECT_TRUE(boost::algorithm::equal(collation.begin(), collation.end(), ces, ces + 12))
        << "from:     " << ce_dumper(cps)
        << "expected: " << ce_dumper(ces)
        << "got:      " << ce_dumper(collation);
}

TEST(collation, non_ignorable_121_114)
{
    // 01BE 0021;	
    // (ƾ) LATIN LETTER INVERTED GLOTTAL STOP WITH STROKE	[1EFB 1ED7 0261 | 0020 0020 0020 | 0004 0004 0002 |]

    uint32_t cps[2] = { 0x01BE, 0x0021 };
    uint32_t const ces[12] = { 0x1EFB, 0x1ED7, 0x0261, 0x0000, 0x0020, 0x0020, 0x0020, 0x0000, 0x0004, 0x0004, 0x0002, 0x0000 };

    auto collation = collate_for_tests(
        cps, cps + 2, boost::text::variable_weighting::non_ignorable);

    EXPECT_EQ(collation.size(), 12);
    EXPECT_TRUE(boost::algorithm::equal(collation.begin(), collation.end(), ces, ces + 12))
        << "from:     " << ce_dumper(cps)
        << "expected: " << ce_dumper(ces)
        << "got:      " << ce_dumper(collation);
}

TEST(collation, non_ignorable_121_115)
{
    // 02A6 0021;	
    // (ʦ) LATIN SMALL LETTER TS DIGRAPH	[1EFB 1ED7 0261 | 0020 0020 0020 | 0004 0004 0002 |]

    uint32_t cps[2] = { 0x02A6, 0x0021 };
    uint32_t const ces[12] = { 0x1EFB, 0x1ED7, 0x0261, 0x0000, 0x0020, 0x0020, 0x0020, 0x0000, 0x0004, 0x0004, 0x0002, 0x0000 };

    auto collation = collate_for_tests(
        cps, cps + 2, boost::text::variable_weighting::non_ignorable);

    EXPECT_EQ(collation.size(), 12);
    EXPECT_TRUE(boost::algorithm::equal(collation.begin(), collation.end(), ces, ces + 12))
        << "from:     " << ce_dumper(cps)
        << "expected: " << ce_dumper(ces)
        << "got:      " << ce_dumper(collation);
}

TEST(collation, non_ignorable_121_116)
{
    // 01BE 003F;	
    // (ƾ) LATIN LETTER INVERTED GLOTTAL STOP WITH STROKE	[1EFB 1ED7 0267 | 0020 0020 0020 | 0004 0004 0002 |]

    uint32_t cps[2] = { 0x01BE, 0x003F };
    uint32_t const ces[12] = { 0x1EFB, 0x1ED7, 0x0267, 0x0000, 0x0020, 0x0020, 0x0020, 0x0000, 0x0004, 0x0004, 0x0002, 0x0000 };

    auto collation = collate_for_tests(
        cps, cps + 2, boost::text::variable_weighting::non_ignorable);

    EXPECT_EQ(collation.size(), 12);
    EXPECT_TRUE(boost::algorithm::equal(collation.begin(), collation.end(), ces, ces + 12))
        << "from:     " << ce_dumper(cps)
        << "expected: " << ce_dumper(ces)
        << "got:      " << ce_dumper(collation);
}

TEST(collation, non_ignorable_121_117)
{
    // 02A6 003F;	
    // (ʦ) LATIN SMALL LETTER TS DIGRAPH	[1EFB 1ED7 0267 | 0020 0020 0020 | 0004 0004 0002 |]

    uint32_t cps[2] = { 0x02A6, 0x003F };
    uint32_t const ces[12] = { 0x1EFB, 0x1ED7, 0x0267, 0x0000, 0x0020, 0x0020, 0x0020, 0x0000, 0x0004, 0x0004, 0x0002, 0x0000 };

    auto collation = collate_for_tests(
        cps, cps + 2, boost::text::variable_weighting::non_ignorable);

    EXPECT_EQ(collation.size(), 12);
    EXPECT_TRUE(boost::algorithm::equal(collation.begin(), collation.end(), ces, ces + 12))
        << "from:     " << ce_dumper(cps)
        << "expected: " << ce_dumper(ces)
        << "got:      " << ce_dumper(collation);
}

TEST(collation, non_ignorable_121_118)
{
    // 01BE 0061;	
    // (ƾ) LATIN LETTER INVERTED GLOTTAL STOP WITH STROKE	[1EFB 1ED7 1CAD | 0020 0020 0020 | 0004 0004 0002 |]

    uint32_t cps[2] = { 0x01BE, 0x0061 };
    uint32_t const ces[12] = { 0x1EFB, 0x1ED7, 0x1CAD, 0x0000, 0x0020, 0x0020, 0x0020, 0x0000, 0x0004, 0x0004, 0x0002, 0x0000 };

    auto collation = collate_for_tests(
        cps, cps + 2, boost::text::variable_weighting::non_ignorable);

    EXPECT_EQ(collation.size(), 12);
    EXPECT_TRUE(boost::algorithm::equal(collation.begin(), collation.end(), ces, ces + 12))
        << "from:     " << ce_dumper(cps)
        << "expected: " << ce_dumper(ces)
        << "got:      " << ce_dumper(collation);
}

TEST(collation, non_ignorable_121_119)
{
    // 02A6 0061;	
    // (ʦ) LATIN SMALL LETTER TS DIGRAPH	[1EFB 1ED7 1CAD | 0020 0020 0020 | 0004 0004 0002 |]

    uint32_t cps[2] = { 0x02A6, 0x0061 };
    uint32_t const ces[12] = { 0x1EFB, 0x1ED7, 0x1CAD, 0x0000, 0x0020, 0x0020, 0x0020, 0x0000, 0x0004, 0x0004, 0x0002, 0x0000 };

    auto collation = collate_for_tests(
        cps, cps + 2, boost::text::variable_weighting::non_ignorable);

    EXPECT_EQ(collation.size(), 12);
    EXPECT_TRUE(boost::algorithm::equal(collation.begin(), collation.end(), ces, ces + 12))
        << "from:     " << ce_dumper(cps)
        << "expected: " << ce_dumper(ces)
        << "got:      " << ce_dumper(collation);
}

TEST(collation, non_ignorable_121_120)
{
    // 01BE 0041;	
    // (ƾ) LATIN LETTER INVERTED GLOTTAL STOP WITH STROKE	[1EFB 1ED7 1CAD | 0020 0020 0020 | 0004 0004 0008 |]

    uint32_t cps[2] = { 0x01BE, 0x0041 };
    uint32_t const ces[12] = { 0x1EFB, 0x1ED7, 0x1CAD, 0x0000, 0x0020, 0x0020, 0x0020, 0x0000, 0x0004, 0x0004, 0x0008, 0x0000 };

    auto collation = collate_for_tests(
        cps, cps + 2, boost::text::variable_weighting::non_ignorable);

    EXPECT_EQ(collation.size(), 12);
    EXPECT_TRUE(boost::algorithm::equal(collation.begin(), collation.end(), ces, ces + 12))
        << "from:     " << ce_dumper(cps)
        << "expected: " << ce_dumper(ces)
        << "got:      " << ce_dumper(collation);
}

TEST(collation, non_ignorable_121_121)
{
    // 02A6 0041;	
    // (ʦ) LATIN SMALL LETTER TS DIGRAPH	[1EFB 1ED7 1CAD | 0020 0020 0020 | 0004 0004 0008 |]

    uint32_t cps[2] = { 0x02A6, 0x0041 };
    uint32_t const ces[12] = { 0x1EFB, 0x1ED7, 0x1CAD, 0x0000, 0x0020, 0x0020, 0x0020, 0x0000, 0x0004, 0x0004, 0x0008, 0x0000 };

    auto collation = collate_for_tests(
        cps, cps + 2, boost::text::variable_weighting::non_ignorable);

    EXPECT_EQ(collation.size(), 12);
    EXPECT_TRUE(boost::algorithm::equal(collation.begin(), collation.end(), ces, ces + 12))
        << "from:     " << ce_dumper(cps)
        << "expected: " << ce_dumper(ces)
        << "got:      " << ce_dumper(collation);
}

TEST(collation, non_ignorable_121_122)
{
    // 01BE 0062;	
    // (ƾ) LATIN LETTER INVERTED GLOTTAL STOP WITH STROKE	[1EFB 1ED7 1CC6 | 0020 0020 0020 | 0004 0004 0002 |]

    uint32_t cps[2] = { 0x01BE, 0x0062 };
    uint32_t const ces[12] = { 0x1EFB, 0x1ED7, 0x1CC6, 0x0000, 0x0020, 0x0020, 0x0020, 0x0000, 0x0004, 0x0004, 0x0002, 0x0000 };

    auto collation = collate_for_tests(
        cps, cps + 2, boost::text::variable_weighting::non_ignorable);

    EXPECT_EQ(collation.size(), 12);
    EXPECT_TRUE(boost::algorithm::equal(collation.begin(), collation.end(), ces, ces + 12))
        << "from:     " << ce_dumper(cps)
        << "expected: " << ce_dumper(ces)
        << "got:      " << ce_dumper(collation);
}

TEST(collation, non_ignorable_121_123)
{
    // 02A6 0062;	
    // (ʦ) LATIN SMALL LETTER TS DIGRAPH	[1EFB 1ED7 1CC6 | 0020 0020 0020 | 0004 0004 0002 |]

    uint32_t cps[2] = { 0x02A6, 0x0062 };
    uint32_t const ces[12] = { 0x1EFB, 0x1ED7, 0x1CC6, 0x0000, 0x0020, 0x0020, 0x0020, 0x0000, 0x0004, 0x0004, 0x0002, 0x0000 };

    auto collation = collate_for_tests(
        cps, cps + 2, boost::text::variable_weighting::non_ignorable);

    EXPECT_EQ(collation.size(), 12);
    EXPECT_TRUE(boost::algorithm::equal(collation.begin(), collation.end(), ces, ces + 12))
        << "from:     " << ce_dumper(cps)
        << "expected: " << ce_dumper(ces)
        << "got:      " << ce_dumper(collation);
}

TEST(collation, non_ignorable_121_124)
{
    // 02A7 0021;	
    // (ʧ) LATIN SMALL LETTER TESH DIGRAPH	[1EFB 1EE8 0261 | 0020 0020 0020 | 0004 0004 0002 |]

    uint32_t cps[2] = { 0x02A7, 0x0021 };
    uint32_t const ces[12] = { 0x1EFB, 0x1EE8, 0x0261, 0x0000, 0x0020, 0x0020, 0x0020, 0x0000, 0x0004, 0x0004, 0x0002, 0x0000 };

    auto collation = collate_for_tests(
        cps, cps + 2, boost::text::variable_weighting::non_ignorable);

    EXPECT_EQ(collation.size(), 12);
    EXPECT_TRUE(boost::algorithm::equal(collation.begin(), collation.end(), ces, ces + 12))
        << "from:     " << ce_dumper(cps)
        << "expected: " << ce_dumper(ces)
        << "got:      " << ce_dumper(collation);
}

TEST(collation, non_ignorable_121_125)
{
    // 02A7 003F;	
    // (ʧ) LATIN SMALL LETTER TESH DIGRAPH	[1EFB 1EE8 0267 | 0020 0020 0020 | 0004 0004 0002 |]

    uint32_t cps[2] = { 0x02A7, 0x003F };
    uint32_t const ces[12] = { 0x1EFB, 0x1EE8, 0x0267, 0x0000, 0x0020, 0x0020, 0x0020, 0x0000, 0x0004, 0x0004, 0x0002, 0x0000 };

    auto collation = collate_for_tests(
        cps, cps + 2, boost::text::variable_weighting::non_ignorable);

    EXPECT_EQ(collation.size(), 12);
    EXPECT_TRUE(boost::algorithm::equal(collation.begin(), collation.end(), ces, ces + 12))
        << "from:     " << ce_dumper(cps)
        << "expected: " << ce_dumper(ces)
        << "got:      " << ce_dumper(collation);
}

TEST(collation, non_ignorable_121_126)
{
    // 02A7 0061;	
    // (ʧ) LATIN SMALL LETTER TESH DIGRAPH	[1EFB 1EE8 1CAD | 0020 0020 0020 | 0004 0004 0002 |]

    uint32_t cps[2] = { 0x02A7, 0x0061 };
    uint32_t const ces[12] = { 0x1EFB, 0x1EE8, 0x1CAD, 0x0000, 0x0020, 0x0020, 0x0020, 0x0000, 0x0004, 0x0004, 0x0002, 0x0000 };

    auto collation = collate_for_tests(
        cps, cps + 2, boost::text::variable_weighting::non_ignorable);

    EXPECT_EQ(collation.size(), 12);
    EXPECT_TRUE(boost::algorithm::equal(collation.begin(), collation.end(), ces, ces + 12))
        << "from:     " << ce_dumper(cps)
        << "expected: " << ce_dumper(ces)
        << "got:      " << ce_dumper(collation);
}

TEST(collation, non_ignorable_121_127)
{
    // 02A7 0041;	
    // (ʧ) LATIN SMALL LETTER TESH DIGRAPH	[1EFB 1EE8 1CAD | 0020 0020 0020 | 0004 0004 0008 |]

    uint32_t cps[2] = { 0x02A7, 0x0041 };
    uint32_t const ces[12] = { 0x1EFB, 0x1EE8, 0x1CAD, 0x0000, 0x0020, 0x0020, 0x0020, 0x0000, 0x0004, 0x0004, 0x0008, 0x0000 };

    auto collation = collate_for_tests(
        cps, cps + 2, boost::text::variable_weighting::non_ignorable);

    EXPECT_EQ(collation.size(), 12);
    EXPECT_TRUE(boost::algorithm::equal(collation.begin(), collation.end(), ces, ces + 12))
        << "from:     " << ce_dumper(cps)
        << "expected: " << ce_dumper(ces)
        << "got:      " << ce_dumper(collation);
}

TEST(collation, non_ignorable_121_128)
{
    // 02A7 0062;	
    // (ʧ) LATIN SMALL LETTER TESH DIGRAPH	[1EFB 1EE8 1CC6 | 0020 0020 0020 | 0004 0004 0002 |]

    uint32_t cps[2] = { 0x02A7, 0x0062 };
    uint32_t const ces[12] = { 0x1EFB, 0x1EE8, 0x1CC6, 0x0000, 0x0020, 0x0020, 0x0020, 0x0000, 0x0004, 0x0004, 0x0002, 0x0000 };

    auto collation = collate_for_tests(
        cps, cps + 2, boost::text::variable_weighting::non_ignorable);

    EXPECT_EQ(collation.size(), 12);
    EXPECT_TRUE(boost::algorithm::equal(collation.begin(), collation.end(), ces, ces + 12))
        << "from:     " << ce_dumper(cps)
        << "expected: " << ce_dumper(ces)
        << "got:      " << ce_dumper(collation);
}

TEST(collation, non_ignorable_121_129)
{
    // A729 0021;	
    // (ꜩ) LATIN SMALL LETTER TZ	[1EFB 1F87 0261 | 0020 0020 0020 | 0004 0004 0002 |]

    uint32_t cps[2] = { 0xA729, 0x0021 };
    uint32_t const ces[12] = { 0x1EFB, 0x1F87, 0x0261, 0x0000, 0x0020, 0x0020, 0x0020, 0x0000, 0x0004, 0x0004, 0x0002, 0x0000 };

    auto collation = collate_for_tests(
        cps, cps + 2, boost::text::variable_weighting::non_ignorable);

    EXPECT_EQ(collation.size(), 12);
    EXPECT_TRUE(boost::algorithm::equal(collation.begin(), collation.end(), ces, ces + 12))
        << "from:     " << ce_dumper(cps)
        << "expected: " << ce_dumper(ces)
        << "got:      " << ce_dumper(collation);
}

TEST(collation, non_ignorable_121_130)
{
    // A728 0021;	
    // (Ꜩ) LATIN CAPITAL LETTER TZ	[1EFB 1F87 0261 | 0020 0020 0020 | 000A 0004 0002 |]

    uint32_t cps[2] = { 0xA728, 0x0021 };
    uint32_t const ces[12] = { 0x1EFB, 0x1F87, 0x0261, 0x0000, 0x0020, 0x0020, 0x0020, 0x0000, 0x000A, 0x0004, 0x0002, 0x0000 };

    auto collation = collate_for_tests(
        cps, cps + 2, boost::text::variable_weighting::non_ignorable);

    EXPECT_EQ(collation.size(), 12);
    EXPECT_TRUE(boost::algorithm::equal(collation.begin(), collation.end(), ces, ces + 12))
        << "from:     " << ce_dumper(cps)
        << "expected: " << ce_dumper(ces)
        << "got:      " << ce_dumper(collation);
}

TEST(collation, non_ignorable_121_131)
{
    // A729 003F;	
    // (ꜩ) LATIN SMALL LETTER TZ	[1EFB 1F87 0267 | 0020 0020 0020 | 0004 0004 0002 |]

    uint32_t cps[2] = { 0xA729, 0x003F };
    uint32_t const ces[12] = { 0x1EFB, 0x1F87, 0x0267, 0x0000, 0x0020, 0x0020, 0x0020, 0x0000, 0x0004, 0x0004, 0x0002, 0x0000 };

    auto collation = collate_for_tests(
        cps, cps + 2, boost::text::variable_weighting::non_ignorable);

    EXPECT_EQ(collation.size(), 12);
    EXPECT_TRUE(boost::algorithm::equal(collation.begin(), collation.end(), ces, ces + 12))
        << "from:     " << ce_dumper(cps)
        << "expected: " << ce_dumper(ces)
        << "got:      " << ce_dumper(collation);
}

TEST(collation, non_ignorable_121_132)
{
    // A728 003F;	
    // (Ꜩ) LATIN CAPITAL LETTER TZ	[1EFB 1F87 0267 | 0020 0020 0020 | 000A 0004 0002 |]

    uint32_t cps[2] = { 0xA728, 0x003F };
    uint32_t const ces[12] = { 0x1EFB, 0x1F87, 0x0267, 0x0000, 0x0020, 0x0020, 0x0020, 0x0000, 0x000A, 0x0004, 0x0002, 0x0000 };

    auto collation = collate_for_tests(
        cps, cps + 2, boost::text::variable_weighting::non_ignorable);

    EXPECT_EQ(collation.size(), 12);
    EXPECT_TRUE(boost::algorithm::equal(collation.begin(), collation.end(), ces, ces + 12))
        << "from:     " << ce_dumper(cps)
        << "expected: " << ce_dumper(ces)
        << "got:      " << ce_dumper(collation);
}

TEST(collation, non_ignorable_121_133)
{
    // A729 0061;	
    // (ꜩ) LATIN SMALL LETTER TZ	[1EFB 1F87 1CAD | 0020 0020 0020 | 0004 0004 0002 |]

    uint32_t cps[2] = { 0xA729, 0x0061 };
    uint32_t const ces[12] = { 0x1EFB, 0x1F87, 0x1CAD, 0x0000, 0x0020, 0x0020, 0x0020, 0x0000, 0x0004, 0x0004, 0x0002, 0x0000 };

    auto collation = collate_for_tests(
        cps, cps + 2, boost::text::variable_weighting::non_ignorable);

    EXPECT_EQ(collation.size(), 12);
    EXPECT_TRUE(boost::algorithm::equal(collation.begin(), collation.end(), ces, ces + 12))
        << "from:     " << ce_dumper(cps)
        << "expected: " << ce_dumper(ces)
        << "got:      " << ce_dumper(collation);
}

TEST(collation, non_ignorable_121_134)
{
    // A729 0041;	
    // (ꜩ) LATIN SMALL LETTER TZ	[1EFB 1F87 1CAD | 0020 0020 0020 | 0004 0004 0008 |]

    uint32_t cps[2] = { 0xA729, 0x0041 };
    uint32_t const ces[12] = { 0x1EFB, 0x1F87, 0x1CAD, 0x0000, 0x0020, 0x0020, 0x0020, 0x0000, 0x0004, 0x0004, 0x0008, 0x0000 };

    auto collation = collate_for_tests(
        cps, cps + 2, boost::text::variable_weighting::non_ignorable);

    EXPECT_EQ(collation.size(), 12);
    EXPECT_TRUE(boost::algorithm::equal(collation.begin(), collation.end(), ces, ces + 12))
        << "from:     " << ce_dumper(cps)
        << "expected: " << ce_dumper(ces)
        << "got:      " << ce_dumper(collation);
}

TEST(collation, non_ignorable_121_135)
{
    // A728 0061;	
    // (Ꜩ) LATIN CAPITAL LETTER TZ	[1EFB 1F87 1CAD | 0020 0020 0020 | 000A 0004 0002 |]

    uint32_t cps[2] = { 0xA728, 0x0061 };
    uint32_t const ces[12] = { 0x1EFB, 0x1F87, 0x1CAD, 0x0000, 0x0020, 0x0020, 0x0020, 0x0000, 0x000A, 0x0004, 0x0002, 0x0000 };

    auto collation = collate_for_tests(
        cps, cps + 2, boost::text::variable_weighting::non_ignorable);

    EXPECT_EQ(collation.size(), 12);
    EXPECT_TRUE(boost::algorithm::equal(collation.begin(), collation.end(), ces, ces + 12))
        << "from:     " << ce_dumper(cps)
        << "expected: " << ce_dumper(ces)
        << "got:      " << ce_dumper(collation);
}

TEST(collation, non_ignorable_121_136)
{
    // A728 0041;	
    // (Ꜩ) LATIN CAPITAL LETTER TZ	[1EFB 1F87 1CAD | 0020 0020 0020 | 000A 0004 0008 |]

    uint32_t cps[2] = { 0xA728, 0x0041 };
    uint32_t const ces[12] = { 0x1EFB, 0x1F87, 0x1CAD, 0x0000, 0x0020, 0x0020, 0x0020, 0x0000, 0x000A, 0x0004, 0x0008, 0x0000 };

    auto collation = collate_for_tests(
        cps, cps + 2, boost::text::variable_weighting::non_ignorable);

    EXPECT_EQ(collation.size(), 12);
    EXPECT_TRUE(boost::algorithm::equal(collation.begin(), collation.end(), ces, ces + 12))
        << "from:     " << ce_dumper(cps)
        << "expected: " << ce_dumper(ces)
        << "got:      " << ce_dumper(collation);
}

TEST(collation, non_ignorable_121_137)
{
    // A729 0062;	
    // (ꜩ) LATIN SMALL LETTER TZ	[1EFB 1F87 1CC6 | 0020 0020 0020 | 0004 0004 0002 |]

    uint32_t cps[2] = { 0xA729, 0x0062 };
    uint32_t const ces[12] = { 0x1EFB, 0x1F87, 0x1CC6, 0x0000, 0x0020, 0x0020, 0x0020, 0x0000, 0x0004, 0x0004, 0x0002, 0x0000 };

    auto collation = collate_for_tests(
        cps, cps + 2, boost::text::variable_weighting::non_ignorable);

    EXPECT_EQ(collation.size(), 12);
    EXPECT_TRUE(boost::algorithm::equal(collation.begin(), collation.end(), ces, ces + 12))
        << "from:     " << ce_dumper(cps)
        << "expected: " << ce_dumper(ces)
        << "got:      " << ce_dumper(collation);
}

TEST(collation, non_ignorable_121_138)
{
    // A728 0062;	
    // (Ꜩ) LATIN CAPITAL LETTER TZ	[1EFB 1F87 1CC6 | 0020 0020 0020 | 000A 0004 0002 |]

    uint32_t cps[2] = { 0xA728, 0x0062 };
    uint32_t const ces[12] = { 0x1EFB, 0x1F87, 0x1CC6, 0x0000, 0x0020, 0x0020, 0x0020, 0x0000, 0x000A, 0x0004, 0x0002, 0x0000 };

    auto collation = collate_for_tests(
        cps, cps + 2, boost::text::variable_weighting::non_ignorable);

    EXPECT_EQ(collation.size(), 12);
    EXPECT_TRUE(boost::algorithm::equal(collation.begin(), collation.end(), ces, ces + 12))
        << "from:     " << ce_dumper(cps)
        << "expected: " << ce_dumper(ces)
        << "got:      " << ce_dumper(collation);
}

TEST(collation, non_ignorable_121_139)
{
    // 1D1B 0021;	
    // (ᴛ) LATIN LETTER SMALL CAPITAL T	[1EFF 0261 | 0020 0020 | 0002 0002 |]

    uint32_t cps[2] = { 0x1D1B, 0x0021 };
    uint32_t const ces[9] = { 0x1EFF, 0x0261, 0x0000, 0x0020, 0x0020, 0x0000, 0x0002, 0x0002, 0x0000 };

    auto collation = collate_for_tests(
        cps, cps + 2, boost::text::variable_weighting::non_ignorable);

    EXPECT_EQ(collation.size(), 9);
    EXPECT_TRUE(boost::algorithm::equal(collation.begin(), collation.end(), ces, ces + 9))
        << "from:     " << ce_dumper(cps)
        << "expected: " << ce_dumper(ces)
        << "got:      " << ce_dumper(collation);
}

TEST(collation, non_ignorable_121_140)
{
    // 1D1B 003F;	
    // (ᴛ) LATIN LETTER SMALL CAPITAL T	[1EFF 0267 | 0020 0020 | 0002 0002 |]

    uint32_t cps[2] = { 0x1D1B, 0x003F };
    uint32_t const ces[9] = { 0x1EFF, 0x0267, 0x0000, 0x0020, 0x0020, 0x0000, 0x0002, 0x0002, 0x0000 };

    auto collation = collate_for_tests(
        cps, cps + 2, boost::text::variable_weighting::non_ignorable);

    EXPECT_EQ(collation.size(), 9);
    EXPECT_TRUE(boost::algorithm::equal(collation.begin(), collation.end(), ces, ces + 9))
        << "from:     " << ce_dumper(cps)
        << "expected: " << ce_dumper(ces)
        << "got:      " << ce_dumper(collation);
}

TEST(collation, non_ignorable_121_141)
{
    // 1D1B 0061;	
    // (ᴛ) LATIN LETTER SMALL CAPITAL T	[1EFF 1CAD | 0020 0020 | 0002 0002 |]

    uint32_t cps[2] = { 0x1D1B, 0x0061 };
    uint32_t const ces[9] = { 0x1EFF, 0x1CAD, 0x0000, 0x0020, 0x0020, 0x0000, 0x0002, 0x0002, 0x0000 };

    auto collation = collate_for_tests(
        cps, cps + 2, boost::text::variable_weighting::non_ignorable);

    EXPECT_EQ(collation.size(), 9);
    EXPECT_TRUE(boost::algorithm::equal(collation.begin(), collation.end(), ces, ces + 9))
        << "from:     " << ce_dumper(cps)
        << "expected: " << ce_dumper(ces)
        << "got:      " << ce_dumper(collation);
}

TEST(collation, non_ignorable_121_142)
{
    // 1D1B 0041;	
    // (ᴛ) LATIN LETTER SMALL CAPITAL T	[1EFF 1CAD | 0020 0020 | 0002 0008 |]

    uint32_t cps[2] = { 0x1D1B, 0x0041 };
    uint32_t const ces[9] = { 0x1EFF, 0x1CAD, 0x0000, 0x0020, 0x0020, 0x0000, 0x0002, 0x0008, 0x0000 };

    auto collation = collate_for_tests(
        cps, cps + 2, boost::text::variable_weighting::non_ignorable);

    EXPECT_EQ(collation.size(), 9);
    EXPECT_TRUE(boost::algorithm::equal(collation.begin(), collation.end(), ces, ces + 9))
        << "from:     " << ce_dumper(cps)
        << "expected: " << ce_dumper(ces)
        << "got:      " << ce_dumper(collation);
}

TEST(collation, non_ignorable_121_143)
{
    // 1D1B 0062;	
    // (ᴛ) LATIN LETTER SMALL CAPITAL T	[1EFF 1CC6 | 0020 0020 | 0002 0002 |]

    uint32_t cps[2] = { 0x1D1B, 0x0062 };
    uint32_t const ces[9] = { 0x1EFF, 0x1CC6, 0x0000, 0x0020, 0x0020, 0x0000, 0x0002, 0x0002, 0x0000 };

    auto collation = collate_for_tests(
        cps, cps + 2, boost::text::variable_weighting::non_ignorable);

    EXPECT_EQ(collation.size(), 9);
    EXPECT_TRUE(boost::algorithm::equal(collation.begin(), collation.end(), ces, ces + 9))
        << "from:     " << ce_dumper(cps)
        << "expected: " << ce_dumper(ces)
        << "got:      " << ce_dumper(collation);
}

TEST(collation, non_ignorable_121_144)
{
    // 0167 0021;	
    // (ŧ) LATIN SMALL LETTER T WITH STROKE	[1F00 0261 | 0020 0020 | 0002 0002 |]

    uint32_t cps[2] = { 0x0167, 0x0021 };
    uint32_t const ces[9] = { 0x1F00, 0x0261, 0x0000, 0x0020, 0x0020, 0x0000, 0x0002, 0x0002, 0x0000 };

    auto collation = collate_for_tests(
        cps, cps + 2, boost::text::variable_weighting::non_ignorable);

    EXPECT_EQ(collation.size(), 9);
    EXPECT_TRUE(boost::algorithm::equal(collation.begin(), collation.end(), ces, ces + 9))
        << "from:     " << ce_dumper(cps)
        << "expected: " << ce_dumper(ces)
        << "got:      " << ce_dumper(collation);
}

TEST(collation, non_ignorable_121_145)
{
    // 0166 0021;	
    // (Ŧ) LATIN CAPITAL LETTER T WITH STROKE	[1F00 0261 | 0020 0020 | 0008 0002 |]

    uint32_t cps[2] = { 0x0166, 0x0021 };
    uint32_t const ces[9] = { 0x1F00, 0x0261, 0x0000, 0x0020, 0x0020, 0x0000, 0x0008, 0x0002, 0x0000 };

    auto collation = collate_for_tests(
        cps, cps + 2, boost::text::variable_weighting::non_ignorable);

    EXPECT_EQ(collation.size(), 9);
    EXPECT_TRUE(boost::algorithm::equal(collation.begin(), collation.end(), ces, ces + 9))
        << "from:     " << ce_dumper(cps)
        << "expected: " << ce_dumper(ces)
        << "got:      " << ce_dumper(collation);
}

TEST(collation, non_ignorable_121_146)
{
    // 0167 003F;	
    // (ŧ) LATIN SMALL LETTER T WITH STROKE	[1F00 0267 | 0020 0020 | 0002 0002 |]

    uint32_t cps[2] = { 0x0167, 0x003F };
    uint32_t const ces[9] = { 0x1F00, 0x0267, 0x0000, 0x0020, 0x0020, 0x0000, 0x0002, 0x0002, 0x0000 };

    auto collation = collate_for_tests(
        cps, cps + 2, boost::text::variable_weighting::non_ignorable);

    EXPECT_EQ(collation.size(), 9);
    EXPECT_TRUE(boost::algorithm::equal(collation.begin(), collation.end(), ces, ces + 9))
        << "from:     " << ce_dumper(cps)
        << "expected: " << ce_dumper(ces)
        << "got:      " << ce_dumper(collation);
}

TEST(collation, non_ignorable_121_147)
{
    // 0166 003F;	
    // (Ŧ) LATIN CAPITAL LETTER T WITH STROKE	[1F00 0267 | 0020 0020 | 0008 0002 |]

    uint32_t cps[2] = { 0x0166, 0x003F };
    uint32_t const ces[9] = { 0x1F00, 0x0267, 0x0000, 0x0020, 0x0020, 0x0000, 0x0008, 0x0002, 0x0000 };

    auto collation = collate_for_tests(
        cps, cps + 2, boost::text::variable_weighting::non_ignorable);

    EXPECT_EQ(collation.size(), 9);
    EXPECT_TRUE(boost::algorithm::equal(collation.begin(), collation.end(), ces, ces + 9))
        << "from:     " << ce_dumper(cps)
        << "expected: " << ce_dumper(ces)
        << "got:      " << ce_dumper(collation);
}

TEST(collation, non_ignorable_121_148)
{
    // 0167 0061;	
    // (ŧ) LATIN SMALL LETTER T WITH STROKE	[1F00 1CAD | 0020 0020 | 0002 0002 |]

    uint32_t cps[2] = { 0x0167, 0x0061 };
    uint32_t const ces[9] = { 0x1F00, 0x1CAD, 0x0000, 0x0020, 0x0020, 0x0000, 0x0002, 0x0002, 0x0000 };

    auto collation = collate_for_tests(
        cps, cps + 2, boost::text::variable_weighting::non_ignorable);

    EXPECT_EQ(collation.size(), 9);
    EXPECT_TRUE(boost::algorithm::equal(collation.begin(), collation.end(), ces, ces + 9))
        << "from:     " << ce_dumper(cps)
        << "expected: " << ce_dumper(ces)
        << "got:      " << ce_dumper(collation);
}

TEST(collation, non_ignorable_121_149)
{
    // 0167 0041;	
    // (ŧ) LATIN SMALL LETTER T WITH STROKE	[1F00 1CAD | 0020 0020 | 0002 0008 |]

    uint32_t cps[2] = { 0x0167, 0x0041 };
    uint32_t const ces[9] = { 0x1F00, 0x1CAD, 0x0000, 0x0020, 0x0020, 0x0000, 0x0002, 0x0008, 0x0000 };

    auto collation = collate_for_tests(
        cps, cps + 2, boost::text::variable_weighting::non_ignorable);

    EXPECT_EQ(collation.size(), 9);
    EXPECT_TRUE(boost::algorithm::equal(collation.begin(), collation.end(), ces, ces + 9))
        << "from:     " << ce_dumper(cps)
        << "expected: " << ce_dumper(ces)
        << "got:      " << ce_dumper(collation);
}

TEST(collation, non_ignorable_121_150)
{
    // 0166 0061;	
    // (Ŧ) LATIN CAPITAL LETTER T WITH STROKE	[1F00 1CAD | 0020 0020 | 0008 0002 |]

    uint32_t cps[2] = { 0x0166, 0x0061 };
    uint32_t const ces[9] = { 0x1F00, 0x1CAD, 0x0000, 0x0020, 0x0020, 0x0000, 0x0008, 0x0002, 0x0000 };

    auto collation = collate_for_tests(
        cps, cps + 2, boost::text::variable_weighting::non_ignorable);

    EXPECT_EQ(collation.size(), 9);
    EXPECT_TRUE(boost::algorithm::equal(collation.begin(), collation.end(), ces, ces + 9))
        << "from:     " << ce_dumper(cps)
        << "expected: " << ce_dumper(ces)
        << "got:      " << ce_dumper(collation);
}

TEST(collation, non_ignorable_121_151)
{
    // 0166 0041;	
    // (Ŧ) LATIN CAPITAL LETTER T WITH STROKE	[1F00 1CAD | 0020 0020 | 0008 0008 |]

    uint32_t cps[2] = { 0x0166, 0x0041 };
    uint32_t const ces[9] = { 0x1F00, 0x1CAD, 0x0000, 0x0020, 0x0020, 0x0000, 0x0008, 0x0008, 0x0000 };

    auto collation = collate_for_tests(
        cps, cps + 2, boost::text::variable_weighting::non_ignorable);

    EXPECT_EQ(collation.size(), 9);
    EXPECT_TRUE(boost::algorithm::equal(collation.begin(), collation.end(), ces, ces + 9))
        << "from:     " << ce_dumper(cps)
        << "expected: " << ce_dumper(ces)
        << "got:      " << ce_dumper(collation);
}

TEST(collation, non_ignorable_121_152)
{
    // 0167 0062;	
    // (ŧ) LATIN SMALL LETTER T WITH STROKE	[1F00 1CC6 | 0020 0020 | 0002 0002 |]

    uint32_t cps[2] = { 0x0167, 0x0062 };
    uint32_t const ces[9] = { 0x1F00, 0x1CC6, 0x0000, 0x0020, 0x0020, 0x0000, 0x0002, 0x0002, 0x0000 };

    auto collation = collate_for_tests(
        cps, cps + 2, boost::text::variable_weighting::non_ignorable);

    EXPECT_EQ(collation.size(), 9);
    EXPECT_TRUE(boost::algorithm::equal(collation.begin(), collation.end(), ces, ces + 9))
        << "from:     " << ce_dumper(cps)
        << "expected: " << ce_dumper(ces)
        << "got:      " << ce_dumper(collation);
}

TEST(collation, non_ignorable_121_153)
{
    // 0166 0062;	
    // (Ŧ) LATIN CAPITAL LETTER T WITH STROKE	[1F00 1CC6 | 0020 0020 | 0008 0002 |]

    uint32_t cps[2] = { 0x0166, 0x0062 };
    uint32_t const ces[9] = { 0x1F00, 0x1CC6, 0x0000, 0x0020, 0x0020, 0x0000, 0x0008, 0x0002, 0x0000 };

    auto collation = collate_for_tests(
        cps, cps + 2, boost::text::variable_weighting::non_ignorable);

    EXPECT_EQ(collation.size(), 9);
    EXPECT_TRUE(boost::algorithm::equal(collation.begin(), collation.end(), ces, ces + 9))
        << "from:     " << ce_dumper(cps)
        << "expected: " << ce_dumper(ces)
        << "got:      " << ce_dumper(collation);
}

TEST(collation, non_ignorable_121_154)
{
    // 2C66 0021;	
    // (ⱦ) LATIN SMALL LETTER T WITH DIAGONAL STROKE	[1F04 0261 | 0020 0020 | 0002 0002 |]

    uint32_t cps[2] = { 0x2C66, 0x0021 };
    uint32_t const ces[9] = { 0x1F04, 0x0261, 0x0000, 0x0020, 0x0020, 0x0000, 0x0002, 0x0002, 0x0000 };

    auto collation = collate_for_tests(
        cps, cps + 2, boost::text::variable_weighting::non_ignorable);

    EXPECT_EQ(collation.size(), 9);
    EXPECT_TRUE(boost::algorithm::equal(collation.begin(), collation.end(), ces, ces + 9))
        << "from:     " << ce_dumper(cps)
        << "expected: " << ce_dumper(ces)
        << "got:      " << ce_dumper(collation);
}

TEST(collation, non_ignorable_121_155)
{
    // 023E 0021;	
    // (Ⱦ) LATIN CAPITAL LETTER T WITH DIAGONAL STROKE	[1F04 0261 | 0020 0020 | 0008 0002 |]

    uint32_t cps[2] = { 0x023E, 0x0021 };
    uint32_t const ces[9] = { 0x1F04, 0x0261, 0x0000, 0x0020, 0x0020, 0x0000, 0x0008, 0x0002, 0x0000 };

    auto collation = collate_for_tests(
        cps, cps + 2, boost::text::variable_weighting::non_ignorable);

    EXPECT_EQ(collation.size(), 9);
    EXPECT_TRUE(boost::algorithm::equal(collation.begin(), collation.end(), ces, ces + 9))
        << "from:     " << ce_dumper(cps)
        << "expected: " << ce_dumper(ces)
        << "got:      " << ce_dumper(collation);
}

TEST(collation, non_ignorable_121_156)
{
    // 2C66 003F;	
    // (ⱦ) LATIN SMALL LETTER T WITH DIAGONAL STROKE	[1F04 0267 | 0020 0020 | 0002 0002 |]

    uint32_t cps[2] = { 0x2C66, 0x003F };
    uint32_t const ces[9] = { 0x1F04, 0x0267, 0x0000, 0x0020, 0x0020, 0x0000, 0x0002, 0x0002, 0x0000 };

    auto collation = collate_for_tests(
        cps, cps + 2, boost::text::variable_weighting::non_ignorable);

    EXPECT_EQ(collation.size(), 9);
    EXPECT_TRUE(boost::algorithm::equal(collation.begin(), collation.end(), ces, ces + 9))
        << "from:     " << ce_dumper(cps)
        << "expected: " << ce_dumper(ces)
        << "got:      " << ce_dumper(collation);
}

TEST(collation, non_ignorable_121_157)
{
    // 023E 003F;	
    // (Ⱦ) LATIN CAPITAL LETTER T WITH DIAGONAL STROKE	[1F04 0267 | 0020 0020 | 0008 0002 |]

    uint32_t cps[2] = { 0x023E, 0x003F };
    uint32_t const ces[9] = { 0x1F04, 0x0267, 0x0000, 0x0020, 0x0020, 0x0000, 0x0008, 0x0002, 0x0000 };

    auto collation = collate_for_tests(
        cps, cps + 2, boost::text::variable_weighting::non_ignorable);

    EXPECT_EQ(collation.size(), 9);
    EXPECT_TRUE(boost::algorithm::equal(collation.begin(), collation.end(), ces, ces + 9))
        << "from:     " << ce_dumper(cps)
        << "expected: " << ce_dumper(ces)
        << "got:      " << ce_dumper(collation);
}

TEST(collation, non_ignorable_121_158)
{
    // 2C66 0061;	
    // (ⱦ) LATIN SMALL LETTER T WITH DIAGONAL STROKE	[1F04 1CAD | 0020 0020 | 0002 0002 |]

    uint32_t cps[2] = { 0x2C66, 0x0061 };
    uint32_t const ces[9] = { 0x1F04, 0x1CAD, 0x0000, 0x0020, 0x0020, 0x0000, 0x0002, 0x0002, 0x0000 };

    auto collation = collate_for_tests(
        cps, cps + 2, boost::text::variable_weighting::non_ignorable);

    EXPECT_EQ(collation.size(), 9);
    EXPECT_TRUE(boost::algorithm::equal(collation.begin(), collation.end(), ces, ces + 9))
        << "from:     " << ce_dumper(cps)
        << "expected: " << ce_dumper(ces)
        << "got:      " << ce_dumper(collation);
}

TEST(collation, non_ignorable_121_159)
{
    // 2C66 0041;	
    // (ⱦ) LATIN SMALL LETTER T WITH DIAGONAL STROKE	[1F04 1CAD | 0020 0020 | 0002 0008 |]

    uint32_t cps[2] = { 0x2C66, 0x0041 };
    uint32_t const ces[9] = { 0x1F04, 0x1CAD, 0x0000, 0x0020, 0x0020, 0x0000, 0x0002, 0x0008, 0x0000 };

    auto collation = collate_for_tests(
        cps, cps + 2, boost::text::variable_weighting::non_ignorable);

    EXPECT_EQ(collation.size(), 9);
    EXPECT_TRUE(boost::algorithm::equal(collation.begin(), collation.end(), ces, ces + 9))
        << "from:     " << ce_dumper(cps)
        << "expected: " << ce_dumper(ces)
        << "got:      " << ce_dumper(collation);
}

TEST(collation, non_ignorable_121_160)
{
    // 023E 0061;	
    // (Ⱦ) LATIN CAPITAL LETTER T WITH DIAGONAL STROKE	[1F04 1CAD | 0020 0020 | 0008 0002 |]

    uint32_t cps[2] = { 0x023E, 0x0061 };
    uint32_t const ces[9] = { 0x1F04, 0x1CAD, 0x0000, 0x0020, 0x0020, 0x0000, 0x0008, 0x0002, 0x0000 };

    auto collation = collate_for_tests(
        cps, cps + 2, boost::text::variable_weighting::non_ignorable);

    EXPECT_EQ(collation.size(), 9);
    EXPECT_TRUE(boost::algorithm::equal(collation.begin(), collation.end(), ces, ces + 9))
        << "from:     " << ce_dumper(cps)
        << "expected: " << ce_dumper(ces)
        << "got:      " << ce_dumper(collation);
}

TEST(collation, non_ignorable_121_161)
{
    // 023E 0041;	
    // (Ⱦ) LATIN CAPITAL LETTER T WITH DIAGONAL STROKE	[1F04 1CAD | 0020 0020 | 0008 0008 |]

    uint32_t cps[2] = { 0x023E, 0x0041 };
    uint32_t const ces[9] = { 0x1F04, 0x1CAD, 0x0000, 0x0020, 0x0020, 0x0000, 0x0008, 0x0008, 0x0000 };

    auto collation = collate_for_tests(
        cps, cps + 2, boost::text::variable_weighting::non_ignorable);

    EXPECT_EQ(collation.size(), 9);
    EXPECT_TRUE(boost::algorithm::equal(collation.begin(), collation.end(), ces, ces + 9))
        << "from:     " << ce_dumper(cps)
        << "expected: " << ce_dumper(ces)
        << "got:      " << ce_dumper(collation);
}

TEST(collation, non_ignorable_121_162)
{
    // 2C66 0062;	
    // (ⱦ) LATIN SMALL LETTER T WITH DIAGONAL STROKE	[1F04 1CC6 | 0020 0020 | 0002 0002 |]

    uint32_t cps[2] = { 0x2C66, 0x0062 };
    uint32_t const ces[9] = { 0x1F04, 0x1CC6, 0x0000, 0x0020, 0x0020, 0x0000, 0x0002, 0x0002, 0x0000 };

    auto collation = collate_for_tests(
        cps, cps + 2, boost::text::variable_weighting::non_ignorable);

    EXPECT_EQ(collation.size(), 9);
    EXPECT_TRUE(boost::algorithm::equal(collation.begin(), collation.end(), ces, ces + 9))
        << "from:     " << ce_dumper(cps)
        << "expected: " << ce_dumper(ces)
        << "got:      " << ce_dumper(collation);
}

TEST(collation, non_ignorable_121_163)
{
    // 023E 0062;	
    // (Ⱦ) LATIN CAPITAL LETTER T WITH DIAGONAL STROKE	[1F04 1CC6 | 0020 0020 | 0008 0002 |]

    uint32_t cps[2] = { 0x023E, 0x0062 };
    uint32_t const ces[9] = { 0x1F04, 0x1CC6, 0x0000, 0x0020, 0x0020, 0x0000, 0x0008, 0x0002, 0x0000 };

    auto collation = collate_for_tests(
        cps, cps + 2, boost::text::variable_weighting::non_ignorable);

    EXPECT_EQ(collation.size(), 9);
    EXPECT_TRUE(boost::algorithm::equal(collation.begin(), collation.end(), ces, ces + 9))
        << "from:     " << ce_dumper(cps)
        << "expected: " << ce_dumper(ces)
        << "got:      " << ce_dumper(collation);
}

TEST(collation, non_ignorable_121_164)
{
    // 1D75 0021;	
    // (ᵵ) LATIN SMALL LETTER T WITH MIDDLE TILDE	[1F05 0261 | 0020 0020 | 0002 0002 |]

    uint32_t cps[2] = { 0x1D75, 0x0021 };
    uint32_t const ces[9] = { 0x1F05, 0x0261, 0x0000, 0x0020, 0x0020, 0x0000, 0x0002, 0x0002, 0x0000 };

    auto collation = collate_for_tests(
        cps, cps + 2, boost::text::variable_weighting::non_ignorable);

    EXPECT_EQ(collation.size(), 9);
    EXPECT_TRUE(boost::algorithm::equal(collation.begin(), collation.end(), ces, ces + 9))
        << "from:     " << ce_dumper(cps)
        << "expected: " << ce_dumper(ces)
        << "got:      " << ce_dumper(collation);
}

TEST(collation, non_ignorable_121_165)
{
    // 1D75 003F;	
    // (ᵵ) LATIN SMALL LETTER T WITH MIDDLE TILDE	[1F05 0267 | 0020 0020 | 0002 0002 |]

    uint32_t cps[2] = { 0x1D75, 0x003F };
    uint32_t const ces[9] = { 0x1F05, 0x0267, 0x0000, 0x0020, 0x0020, 0x0000, 0x0002, 0x0002, 0x0000 };

    auto collation = collate_for_tests(
        cps, cps + 2, boost::text::variable_weighting::non_ignorable);

    EXPECT_EQ(collation.size(), 9);
    EXPECT_TRUE(boost::algorithm::equal(collation.begin(), collation.end(), ces, ces + 9))
        << "from:     " << ce_dumper(cps)
        << "expected: " << ce_dumper(ces)
        << "got:      " << ce_dumper(collation);
}

TEST(collation, non_ignorable_121_166)
{
    // 1D75 0061;	
    // (ᵵ) LATIN SMALL LETTER T WITH MIDDLE TILDE	[1F05 1CAD | 0020 0020 | 0002 0002 |]

    uint32_t cps[2] = { 0x1D75, 0x0061 };
    uint32_t const ces[9] = { 0x1F05, 0x1CAD, 0x0000, 0x0020, 0x0020, 0x0000, 0x0002, 0x0002, 0x0000 };

    auto collation = collate_for_tests(
        cps, cps + 2, boost::text::variable_weighting::non_ignorable);

    EXPECT_EQ(collation.size(), 9);
    EXPECT_TRUE(boost::algorithm::equal(collation.begin(), collation.end(), ces, ces + 9))
        << "from:     " << ce_dumper(cps)
        << "expected: " << ce_dumper(ces)
        << "got:      " << ce_dumper(collation);
}

TEST(collation, non_ignorable_121_167)
{
    // 1D75 0041;	
    // (ᵵ) LATIN SMALL LETTER T WITH MIDDLE TILDE	[1F05 1CAD | 0020 0020 | 0002 0008 |]

    uint32_t cps[2] = { 0x1D75, 0x0041 };
    uint32_t const ces[9] = { 0x1F05, 0x1CAD, 0x0000, 0x0020, 0x0020, 0x0000, 0x0002, 0x0008, 0x0000 };

    auto collation = collate_for_tests(
        cps, cps + 2, boost::text::variable_weighting::non_ignorable);

    EXPECT_EQ(collation.size(), 9);
    EXPECT_TRUE(boost::algorithm::equal(collation.begin(), collation.end(), ces, ces + 9))
        << "from:     " << ce_dumper(cps)
        << "expected: " << ce_dumper(ces)
        << "got:      " << ce_dumper(collation);
}

TEST(collation, non_ignorable_121_168)
{
    // 1D75 0062;	
    // (ᵵ) LATIN SMALL LETTER T WITH MIDDLE TILDE	[1F05 1CC6 | 0020 0020 | 0002 0002 |]

    uint32_t cps[2] = { 0x1D75, 0x0062 };
    uint32_t const ces[9] = { 0x1F05, 0x1CC6, 0x0000, 0x0020, 0x0020, 0x0000, 0x0002, 0x0002, 0x0000 };

    auto collation = collate_for_tests(
        cps, cps + 2, boost::text::variable_weighting::non_ignorable);

    EXPECT_EQ(collation.size(), 9);
    EXPECT_TRUE(boost::algorithm::equal(collation.begin(), collation.end(), ces, ces + 9))
        << "from:     " << ce_dumper(cps)
        << "expected: " << ce_dumper(ces)
        << "got:      " << ce_dumper(collation);
}

TEST(collation, non_ignorable_121_169)
{
    // 01AB 0021;	
    // (ƫ) LATIN SMALL LETTER T WITH PALATAL HOOK	[1F06 0261 | 0020 0020 | 0002 0002 |]

    uint32_t cps[2] = { 0x01AB, 0x0021 };
    uint32_t const ces[9] = { 0x1F06, 0x0261, 0x0000, 0x0020, 0x0020, 0x0000, 0x0002, 0x0002, 0x0000 };

    auto collation = collate_for_tests(
        cps, cps + 2, boost::text::variable_weighting::non_ignorable);

    EXPECT_EQ(collation.size(), 9);
    EXPECT_TRUE(boost::algorithm::equal(collation.begin(), collation.end(), ces, ces + 9))
        << "from:     " << ce_dumper(cps)
        << "expected: " << ce_dumper(ces)
        << "got:      " << ce_dumper(collation);
}

TEST(collation, non_ignorable_121_170)
{
    // 1DB5 0021;	
    // (ᶵ) MODIFIER LETTER SMALL T WITH PALATAL HOOK	[1F06 0261 | 0020 0020 | 0014 0002 |]

    uint32_t cps[2] = { 0x1DB5, 0x0021 };
    uint32_t const ces[9] = { 0x1F06, 0x0261, 0x0000, 0x0020, 0x0020, 0x0000, 0x0014, 0x0002, 0x0000 };

    auto collation = collate_for_tests(
        cps, cps + 2, boost::text::variable_weighting::non_ignorable);

    EXPECT_EQ(collation.size(), 9);
    EXPECT_TRUE(boost::algorithm::equal(collation.begin(), collation.end(), ces, ces + 9))
        << "from:     " << ce_dumper(cps)
        << "expected: " << ce_dumper(ces)
        << "got:      " << ce_dumper(collation);
}

TEST(collation, non_ignorable_121_171)
{
    // 01AB 003F;	
    // (ƫ) LATIN SMALL LETTER T WITH PALATAL HOOK	[1F06 0267 | 0020 0020 | 0002 0002 |]

    uint32_t cps[2] = { 0x01AB, 0x003F };
    uint32_t const ces[9] = { 0x1F06, 0x0267, 0x0000, 0x0020, 0x0020, 0x0000, 0x0002, 0x0002, 0x0000 };

    auto collation = collate_for_tests(
        cps, cps + 2, boost::text::variable_weighting::non_ignorable);

    EXPECT_EQ(collation.size(), 9);
    EXPECT_TRUE(boost::algorithm::equal(collation.begin(), collation.end(), ces, ces + 9))
        << "from:     " << ce_dumper(cps)
        << "expected: " << ce_dumper(ces)
        << "got:      " << ce_dumper(collation);
}

TEST(collation, non_ignorable_121_172)
{
    // 1DB5 003F;	
    // (ᶵ) MODIFIER LETTER SMALL T WITH PALATAL HOOK	[1F06 0267 | 0020 0020 | 0014 0002 |]

    uint32_t cps[2] = { 0x1DB5, 0x003F };
    uint32_t const ces[9] = { 0x1F06, 0x0267, 0x0000, 0x0020, 0x0020, 0x0000, 0x0014, 0x0002, 0x0000 };

    auto collation = collate_for_tests(
        cps, cps + 2, boost::text::variable_weighting::non_ignorable);

    EXPECT_EQ(collation.size(), 9);
    EXPECT_TRUE(boost::algorithm::equal(collation.begin(), collation.end(), ces, ces + 9))
        << "from:     " << ce_dumper(cps)
        << "expected: " << ce_dumper(ces)
        << "got:      " << ce_dumper(collation);
}

TEST(collation, non_ignorable_121_173)
{
    // 01AB 0061;	
    // (ƫ) LATIN SMALL LETTER T WITH PALATAL HOOK	[1F06 1CAD | 0020 0020 | 0002 0002 |]

    uint32_t cps[2] = { 0x01AB, 0x0061 };
    uint32_t const ces[9] = { 0x1F06, 0x1CAD, 0x0000, 0x0020, 0x0020, 0x0000, 0x0002, 0x0002, 0x0000 };

    auto collation = collate_for_tests(
        cps, cps + 2, boost::text::variable_weighting::non_ignorable);

    EXPECT_EQ(collation.size(), 9);
    EXPECT_TRUE(boost::algorithm::equal(collation.begin(), collation.end(), ces, ces + 9))
        << "from:     " << ce_dumper(cps)
        << "expected: " << ce_dumper(ces)
        << "got:      " << ce_dumper(collation);
}

TEST(collation, non_ignorable_121_174)
{
    // 01AB 0041;	
    // (ƫ) LATIN SMALL LETTER T WITH PALATAL HOOK	[1F06 1CAD | 0020 0020 | 0002 0008 |]

    uint32_t cps[2] = { 0x01AB, 0x0041 };
    uint32_t const ces[9] = { 0x1F06, 0x1CAD, 0x0000, 0x0020, 0x0020, 0x0000, 0x0002, 0x0008, 0x0000 };

    auto collation = collate_for_tests(
        cps, cps + 2, boost::text::variable_weighting::non_ignorable);

    EXPECT_EQ(collation.size(), 9);
    EXPECT_TRUE(boost::algorithm::equal(collation.begin(), collation.end(), ces, ces + 9))
        << "from:     " << ce_dumper(cps)
        << "expected: " << ce_dumper(ces)
        << "got:      " << ce_dumper(collation);
}

TEST(collation, non_ignorable_121_175)
{
    // 1DB5 0061;	
    // (ᶵ) MODIFIER LETTER SMALL T WITH PALATAL HOOK	[1F06 1CAD | 0020 0020 | 0014 0002 |]

    uint32_t cps[2] = { 0x1DB5, 0x0061 };
    uint32_t const ces[9] = { 0x1F06, 0x1CAD, 0x0000, 0x0020, 0x0020, 0x0000, 0x0014, 0x0002, 0x0000 };

    auto collation = collate_for_tests(
        cps, cps + 2, boost::text::variable_weighting::non_ignorable);

    EXPECT_EQ(collation.size(), 9);
    EXPECT_TRUE(boost::algorithm::equal(collation.begin(), collation.end(), ces, ces + 9))
        << "from:     " << ce_dumper(cps)
        << "expected: " << ce_dumper(ces)
        << "got:      " << ce_dumper(collation);
}

TEST(collation, non_ignorable_121_176)
{
    // 1DB5 0041;	
    // (ᶵ) MODIFIER LETTER SMALL T WITH PALATAL HOOK	[1F06 1CAD | 0020 0020 | 0014 0008 |]

    uint32_t cps[2] = { 0x1DB5, 0x0041 };
    uint32_t const ces[9] = { 0x1F06, 0x1CAD, 0x0000, 0x0020, 0x0020, 0x0000, 0x0014, 0x0008, 0x0000 };

    auto collation = collate_for_tests(
        cps, cps + 2, boost::text::variable_weighting::non_ignorable);

    EXPECT_EQ(collation.size(), 9);
    EXPECT_TRUE(boost::algorithm::equal(collation.begin(), collation.end(), ces, ces + 9))
        << "from:     " << ce_dumper(cps)
        << "expected: " << ce_dumper(ces)
        << "got:      " << ce_dumper(collation);
}

TEST(collation, non_ignorable_121_177)
{
    // 01AB 0062;	
    // (ƫ) LATIN SMALL LETTER T WITH PALATAL HOOK	[1F06 1CC6 | 0020 0020 | 0002 0002 |]

    uint32_t cps[2] = { 0x01AB, 0x0062 };
    uint32_t const ces[9] = { 0x1F06, 0x1CC6, 0x0000, 0x0020, 0x0020, 0x0000, 0x0002, 0x0002, 0x0000 };

    auto collation = collate_for_tests(
        cps, cps + 2, boost::text::variable_weighting::non_ignorable);

    EXPECT_EQ(collation.size(), 9);
    EXPECT_TRUE(boost::algorithm::equal(collation.begin(), collation.end(), ces, ces + 9))
        << "from:     " << ce_dumper(cps)
        << "expected: " << ce_dumper(ces)
        << "got:      " << ce_dumper(collation);
}

TEST(collation, non_ignorable_121_178)
{
    // 1DB5 0062;	
    // (ᶵ) MODIFIER LETTER SMALL T WITH PALATAL HOOK	[1F06 1CC6 | 0020 0020 | 0014 0002 |]

    uint32_t cps[2] = { 0x1DB5, 0x0062 };
    uint32_t const ces[9] = { 0x1F06, 0x1CC6, 0x0000, 0x0020, 0x0020, 0x0000, 0x0014, 0x0002, 0x0000 };

    auto collation = collate_for_tests(
        cps, cps + 2, boost::text::variable_weighting::non_ignorable);

    EXPECT_EQ(collation.size(), 9);
    EXPECT_TRUE(boost::algorithm::equal(collation.begin(), collation.end(), ces, ces + 9))
        << "from:     " << ce_dumper(cps)
        << "expected: " << ce_dumper(ces)
        << "got:      " << ce_dumper(collation);
}

TEST(collation, non_ignorable_121_179)
{
    // 01AD 0021;	
    // (ƭ) LATIN SMALL LETTER T WITH HOOK	[1F0A 0261 | 0020 0020 | 0002 0002 |]

    uint32_t cps[2] = { 0x01AD, 0x0021 };
    uint32_t const ces[9] = { 0x1F0A, 0x0261, 0x0000, 0x0020, 0x0020, 0x0000, 0x0002, 0x0002, 0x0000 };

    auto collation = collate_for_tests(
        cps, cps + 2, boost::text::variable_weighting::non_ignorable);

    EXPECT_EQ(collation.size(), 9);
    EXPECT_TRUE(boost::algorithm::equal(collation.begin(), collation.end(), ces, ces + 9))
        << "from:     " << ce_dumper(cps)
        << "expected: " << ce_dumper(ces)
        << "got:      " << ce_dumper(collation);
}

TEST(collation, non_ignorable_121_180)
{
    // 01AC 0021;	
    // (Ƭ) LATIN CAPITAL LETTER T WITH HOOK	[1F0A 0261 | 0020 0020 | 0008 0002 |]

    uint32_t cps[2] = { 0x01AC, 0x0021 };
    uint32_t const ces[9] = { 0x1F0A, 0x0261, 0x0000, 0x0020, 0x0020, 0x0000, 0x0008, 0x0002, 0x0000 };

    auto collation = collate_for_tests(
        cps, cps + 2, boost::text::variable_weighting::non_ignorable);

    EXPECT_EQ(collation.size(), 9);
    EXPECT_TRUE(boost::algorithm::equal(collation.begin(), collation.end(), ces, ces + 9))
        << "from:     " << ce_dumper(cps)
        << "expected: " << ce_dumper(ces)
        << "got:      " << ce_dumper(collation);
}

TEST(collation, non_ignorable_121_181)
{
    // 01AD 003F;	
    // (ƭ) LATIN SMALL LETTER T WITH HOOK	[1F0A 0267 | 0020 0020 | 0002 0002 |]

    uint32_t cps[2] = { 0x01AD, 0x003F };
    uint32_t const ces[9] = { 0x1F0A, 0x0267, 0x0000, 0x0020, 0x0020, 0x0000, 0x0002, 0x0002, 0x0000 };

    auto collation = collate_for_tests(
        cps, cps + 2, boost::text::variable_weighting::non_ignorable);

    EXPECT_EQ(collation.size(), 9);
    EXPECT_TRUE(boost::algorithm::equal(collation.begin(), collation.end(), ces, ces + 9))
        << "from:     " << ce_dumper(cps)
        << "expected: " << ce_dumper(ces)
        << "got:      " << ce_dumper(collation);
}

TEST(collation, non_ignorable_121_182)
{
    // 01AC 003F;	
    // (Ƭ) LATIN CAPITAL LETTER T WITH HOOK	[1F0A 0267 | 0020 0020 | 0008 0002 |]

    uint32_t cps[2] = { 0x01AC, 0x003F };
    uint32_t const ces[9] = { 0x1F0A, 0x0267, 0x0000, 0x0020, 0x0020, 0x0000, 0x0008, 0x0002, 0x0000 };

    auto collation = collate_for_tests(
        cps, cps + 2, boost::text::variable_weighting::non_ignorable);

    EXPECT_EQ(collation.size(), 9);
    EXPECT_TRUE(boost::algorithm::equal(collation.begin(), collation.end(), ces, ces + 9))
        << "from:     " << ce_dumper(cps)
        << "expected: " << ce_dumper(ces)
        << "got:      " << ce_dumper(collation);
}

TEST(collation, non_ignorable_121_183)
{
    // 01AD 0061;	
    // (ƭ) LATIN SMALL LETTER T WITH HOOK	[1F0A 1CAD | 0020 0020 | 0002 0002 |]

    uint32_t cps[2] = { 0x01AD, 0x0061 };
    uint32_t const ces[9] = { 0x1F0A, 0x1CAD, 0x0000, 0x0020, 0x0020, 0x0000, 0x0002, 0x0002, 0x0000 };

    auto collation = collate_for_tests(
        cps, cps + 2, boost::text::variable_weighting::non_ignorable);

    EXPECT_EQ(collation.size(), 9);
    EXPECT_TRUE(boost::algorithm::equal(collation.begin(), collation.end(), ces, ces + 9))
        << "from:     " << ce_dumper(cps)
        << "expected: " << ce_dumper(ces)
        << "got:      " << ce_dumper(collation);
}

TEST(collation, non_ignorable_121_184)
{
    // 01AD 0041;	
    // (ƭ) LATIN SMALL LETTER T WITH HOOK	[1F0A 1CAD | 0020 0020 | 0002 0008 |]

    uint32_t cps[2] = { 0x01AD, 0x0041 };
    uint32_t const ces[9] = { 0x1F0A, 0x1CAD, 0x0000, 0x0020, 0x0020, 0x0000, 0x0002, 0x0008, 0x0000 };

    auto collation = collate_for_tests(
        cps, cps + 2, boost::text::variable_weighting::non_ignorable);

    EXPECT_EQ(collation.size(), 9);
    EXPECT_TRUE(boost::algorithm::equal(collation.begin(), collation.end(), ces, ces + 9))
        << "from:     " << ce_dumper(cps)
        << "expected: " << ce_dumper(ces)
        << "got:      " << ce_dumper(collation);
}

TEST(collation, non_ignorable_121_185)
{
    // 01AC 0061;	
    // (Ƭ) LATIN CAPITAL LETTER T WITH HOOK	[1F0A 1CAD | 0020 0020 | 0008 0002 |]

    uint32_t cps[2] = { 0x01AC, 0x0061 };
    uint32_t const ces[9] = { 0x1F0A, 0x1CAD, 0x0000, 0x0020, 0x0020, 0x0000, 0x0008, 0x0002, 0x0000 };

    auto collation = collate_for_tests(
        cps, cps + 2, boost::text::variable_weighting::non_ignorable);

    EXPECT_EQ(collation.size(), 9);
    EXPECT_TRUE(boost::algorithm::equal(collation.begin(), collation.end(), ces, ces + 9))
        << "from:     " << ce_dumper(cps)
        << "expected: " << ce_dumper(ces)
        << "got:      " << ce_dumper(collation);
}

TEST(collation, non_ignorable_121_186)
{
    // 01AC 0041;	
    // (Ƭ) LATIN CAPITAL LETTER T WITH HOOK	[1F0A 1CAD | 0020 0020 | 0008 0008 |]

    uint32_t cps[2] = { 0x01AC, 0x0041 };
    uint32_t const ces[9] = { 0x1F0A, 0x1CAD, 0x0000, 0x0020, 0x0020, 0x0000, 0x0008, 0x0008, 0x0000 };

    auto collation = collate_for_tests(
        cps, cps + 2, boost::text::variable_weighting::non_ignorable);

    EXPECT_EQ(collation.size(), 9);
    EXPECT_TRUE(boost::algorithm::equal(collation.begin(), collation.end(), ces, ces + 9))
        << "from:     " << ce_dumper(cps)
        << "expected: " << ce_dumper(ces)
        << "got:      " << ce_dumper(collation);
}

TEST(collation, non_ignorable_121_187)
{
    // 01AD 0062;	
    // (ƭ) LATIN SMALL LETTER T WITH HOOK	[1F0A 1CC6 | 0020 0020 | 0002 0002 |]

    uint32_t cps[2] = { 0x01AD, 0x0062 };
    uint32_t const ces[9] = { 0x1F0A, 0x1CC6, 0x0000, 0x0020, 0x0020, 0x0000, 0x0002, 0x0002, 0x0000 };

    auto collation = collate_for_tests(
        cps, cps + 2, boost::text::variable_weighting::non_ignorable);

    EXPECT_EQ(collation.size(), 9);
    EXPECT_TRUE(boost::algorithm::equal(collation.begin(), collation.end(), ces, ces + 9))
        << "from:     " << ce_dumper(cps)
        << "expected: " << ce_dumper(ces)
        << "got:      " << ce_dumper(collation);
}

TEST(collation, non_ignorable_121_188)
{
    // 01AC 0062;	
    // (Ƭ) LATIN CAPITAL LETTER T WITH HOOK	[1F0A 1CC6 | 0020 0020 | 0008 0002 |]

    uint32_t cps[2] = { 0x01AC, 0x0062 };
    uint32_t const ces[9] = { 0x1F0A, 0x1CC6, 0x0000, 0x0020, 0x0020, 0x0000, 0x0008, 0x0002, 0x0000 };

    auto collation = collate_for_tests(
        cps, cps + 2, boost::text::variable_weighting::non_ignorable);

    EXPECT_EQ(collation.size(), 9);
    EXPECT_TRUE(boost::algorithm::equal(collation.begin(), collation.end(), ces, ces + 9))
        << "from:     " << ce_dumper(cps)
        << "expected: " << ce_dumper(ces)
        << "got:      " << ce_dumper(collation);
}

TEST(collation, non_ignorable_121_189)
{
    // 0288 0021;	
    // (ʈ) LATIN SMALL LETTER T WITH RETROFLEX HOOK	[1F0E 0261 | 0020 0020 | 0002 0002 |]

    uint32_t cps[2] = { 0x0288, 0x0021 };
    uint32_t const ces[9] = { 0x1F0E, 0x0261, 0x0000, 0x0020, 0x0020, 0x0000, 0x0002, 0x0002, 0x0000 };

    auto collation = collate_for_tests(
        cps, cps + 2, boost::text::variable_weighting::non_ignorable);

    EXPECT_EQ(collation.size(), 9);
    EXPECT_TRUE(boost::algorithm::equal(collation.begin(), collation.end(), ces, ces + 9))
        << "from:     " << ce_dumper(cps)
        << "expected: " << ce_dumper(ces)
        << "got:      " << ce_dumper(collation);
}

TEST(collation, non_ignorable_121_190)
{
    // 01AE 0021;	
    // (Ʈ) LATIN CAPITAL LETTER T WITH RETROFLEX HOOK	[1F0E 0261 | 0020 0020 | 0008 0002 |]

    uint32_t cps[2] = { 0x01AE, 0x0021 };
    uint32_t const ces[9] = { 0x1F0E, 0x0261, 0x0000, 0x0020, 0x0020, 0x0000, 0x0008, 0x0002, 0x0000 };

    auto collation = collate_for_tests(
        cps, cps + 2, boost::text::variable_weighting::non_ignorable);

    EXPECT_EQ(collation.size(), 9);
    EXPECT_TRUE(boost::algorithm::equal(collation.begin(), collation.end(), ces, ces + 9))
        << "from:     " << ce_dumper(cps)
        << "expected: " << ce_dumper(ces)
        << "got:      " << ce_dumper(collation);
}

TEST(collation, non_ignorable_121_191)
{
    // 0288 003F;	
    // (ʈ) LATIN SMALL LETTER T WITH RETROFLEX HOOK	[1F0E 0267 | 0020 0020 | 0002 0002 |]

    uint32_t cps[2] = { 0x0288, 0x003F };
    uint32_t const ces[9] = { 0x1F0E, 0x0267, 0x0000, 0x0020, 0x0020, 0x0000, 0x0002, 0x0002, 0x0000 };

    auto collation = collate_for_tests(
        cps, cps + 2, boost::text::variable_weighting::non_ignorable);

    EXPECT_EQ(collation.size(), 9);
    EXPECT_TRUE(boost::algorithm::equal(collation.begin(), collation.end(), ces, ces + 9))
        << "from:     " << ce_dumper(cps)
        << "expected: " << ce_dumper(ces)
        << "got:      " << ce_dumper(collation);
}

TEST(collation, non_ignorable_121_192)
{
    // 01AE 003F;	
    // (Ʈ) LATIN CAPITAL LETTER T WITH RETROFLEX HOOK	[1F0E 0267 | 0020 0020 | 0008 0002 |]

    uint32_t cps[2] = { 0x01AE, 0x003F };
    uint32_t const ces[9] = { 0x1F0E, 0x0267, 0x0000, 0x0020, 0x0020, 0x0000, 0x0008, 0x0002, 0x0000 };

    auto collation = collate_for_tests(
        cps, cps + 2, boost::text::variable_weighting::non_ignorable);

    EXPECT_EQ(collation.size(), 9);
    EXPECT_TRUE(boost::algorithm::equal(collation.begin(), collation.end(), ces, ces + 9))
        << "from:     " << ce_dumper(cps)
        << "expected: " << ce_dumper(ces)
        << "got:      " << ce_dumper(collation);
}

TEST(collation, non_ignorable_121_193)
{
    // 0288 0061;	
    // (ʈ) LATIN SMALL LETTER T WITH RETROFLEX HOOK	[1F0E 1CAD | 0020 0020 | 0002 0002 |]

    uint32_t cps[2] = { 0x0288, 0x0061 };
    uint32_t const ces[9] = { 0x1F0E, 0x1CAD, 0x0000, 0x0020, 0x0020, 0x0000, 0x0002, 0x0002, 0x0000 };

    auto collation = collate_for_tests(
        cps, cps + 2, boost::text::variable_weighting::non_ignorable);

    EXPECT_EQ(collation.size(), 9);
    EXPECT_TRUE(boost::algorithm::equal(collation.begin(), collation.end(), ces, ces + 9))
        << "from:     " << ce_dumper(cps)
        << "expected: " << ce_dumper(ces)
        << "got:      " << ce_dumper(collation);
}

TEST(collation, non_ignorable_121_194)
{
    // 0288 0041;	
    // (ʈ) LATIN SMALL LETTER T WITH RETROFLEX HOOK	[1F0E 1CAD | 0020 0020 | 0002 0008 |]

    uint32_t cps[2] = { 0x0288, 0x0041 };
    uint32_t const ces[9] = { 0x1F0E, 0x1CAD, 0x0000, 0x0020, 0x0020, 0x0000, 0x0002, 0x0008, 0x0000 };

    auto collation = collate_for_tests(
        cps, cps + 2, boost::text::variable_weighting::non_ignorable);

    EXPECT_EQ(collation.size(), 9);
    EXPECT_TRUE(boost::algorithm::equal(collation.begin(), collation.end(), ces, ces + 9))
        << "from:     " << ce_dumper(cps)
        << "expected: " << ce_dumper(ces)
        << "got:      " << ce_dumper(collation);
}

TEST(collation, non_ignorable_121_195)
{
    // 01AE 0061;	
    // (Ʈ) LATIN CAPITAL LETTER T WITH RETROFLEX HOOK	[1F0E 1CAD | 0020 0020 | 0008 0002 |]

    uint32_t cps[2] = { 0x01AE, 0x0061 };
    uint32_t const ces[9] = { 0x1F0E, 0x1CAD, 0x0000, 0x0020, 0x0020, 0x0000, 0x0008, 0x0002, 0x0000 };

    auto collation = collate_for_tests(
        cps, cps + 2, boost::text::variable_weighting::non_ignorable);

    EXPECT_EQ(collation.size(), 9);
    EXPECT_TRUE(boost::algorithm::equal(collation.begin(), collation.end(), ces, ces + 9))
        << "from:     " << ce_dumper(cps)
        << "expected: " << ce_dumper(ces)
        << "got:      " << ce_dumper(collation);
}

TEST(collation, non_ignorable_121_196)
{
    // 01AE 0041;	
    // (Ʈ) LATIN CAPITAL LETTER T WITH RETROFLEX HOOK	[1F0E 1CAD | 0020 0020 | 0008 0008 |]

    uint32_t cps[2] = { 0x01AE, 0x0041 };
    uint32_t const ces[9] = { 0x1F0E, 0x1CAD, 0x0000, 0x0020, 0x0020, 0x0000, 0x0008, 0x0008, 0x0000 };

    auto collation = collate_for_tests(
        cps, cps + 2, boost::text::variable_weighting::non_ignorable);

    EXPECT_EQ(collation.size(), 9);
    EXPECT_TRUE(boost::algorithm::equal(collation.begin(), collation.end(), ces, ces + 9))
        << "from:     " << ce_dumper(cps)
        << "expected: " << ce_dumper(ces)
        << "got:      " << ce_dumper(collation);
}

TEST(collation, non_ignorable_121_197)
{
    // 0288 0062;	
    // (ʈ) LATIN SMALL LETTER T WITH RETROFLEX HOOK	[1F0E 1CC6 | 0020 0020 | 0002 0002 |]

    uint32_t cps[2] = { 0x0288, 0x0062 };
    uint32_t const ces[9] = { 0x1F0E, 0x1CC6, 0x0000, 0x0020, 0x0020, 0x0000, 0x0002, 0x0002, 0x0000 };

    auto collation = collate_for_tests(
        cps, cps + 2, boost::text::variable_weighting::non_ignorable);

    EXPECT_EQ(collation.size(), 9);
    EXPECT_TRUE(boost::algorithm::equal(collation.begin(), collation.end(), ces, ces + 9))
        << "from:     " << ce_dumper(cps)
        << "expected: " << ce_dumper(ces)
        << "got:      " << ce_dumper(collation);
}

TEST(collation, non_ignorable_121_198)
{
    // 01AE 0062;	
    // (Ʈ) LATIN CAPITAL LETTER T WITH RETROFLEX HOOK	[1F0E 1CC6 | 0020 0020 | 0008 0002 |]

    uint32_t cps[2] = { 0x01AE, 0x0062 };
    uint32_t const ces[9] = { 0x1F0E, 0x1CC6, 0x0000, 0x0020, 0x0020, 0x0000, 0x0008, 0x0002, 0x0000 };

    auto collation = collate_for_tests(
        cps, cps + 2, boost::text::variable_weighting::non_ignorable);

    EXPECT_EQ(collation.size(), 9);
    EXPECT_TRUE(boost::algorithm::equal(collation.begin(), collation.end(), ces, ces + 9))
        << "from:     " << ce_dumper(cps)
        << "expected: " << ce_dumper(ces)
        << "got:      " << ce_dumper(collation);
}

TEST(collation, non_ignorable_121_199)
{
    // 0236 0021;	
    // (ȶ) LATIN SMALL LETTER T WITH CURL	[1F12 0261 | 0020 0020 | 0002 0002 |]

    uint32_t cps[2] = { 0x0236, 0x0021 };
    uint32_t const ces[9] = { 0x1F12, 0x0261, 0x0000, 0x0020, 0x0020, 0x0000, 0x0002, 0x0002, 0x0000 };

    auto collation = collate_for_tests(
        cps, cps + 2, boost::text::variable_weighting::non_ignorable);

    EXPECT_EQ(collation.size(), 9);
    EXPECT_TRUE(boost::algorithm::equal(collation.begin(), collation.end(), ces, ces + 9))
        << "from:     " << ce_dumper(cps)
        << "expected: " << ce_dumper(ces)
        << "got:      " << ce_dumper(collation);
}

TEST(collation, non_ignorable_121_200)
{
    // 0236 003F;	
    // (ȶ) LATIN SMALL LETTER T WITH CURL	[1F12 0267 | 0020 0020 | 0002 0002 |]

    uint32_t cps[2] = { 0x0236, 0x003F };
    uint32_t const ces[9] = { 0x1F12, 0x0267, 0x0000, 0x0020, 0x0020, 0x0000, 0x0002, 0x0002, 0x0000 };

    auto collation = collate_for_tests(
        cps, cps + 2, boost::text::variable_weighting::non_ignorable);

    EXPECT_EQ(collation.size(), 9);
    EXPECT_TRUE(boost::algorithm::equal(collation.begin(), collation.end(), ces, ces + 9))
        << "from:     " << ce_dumper(cps)
        << "expected: " << ce_dumper(ces)
        << "got:      " << ce_dumper(collation);
}

TEST(collation, non_ignorable_121_201)
{
    // 0236 0061;	
    // (ȶ) LATIN SMALL LETTER T WITH CURL	[1F12 1CAD | 0020 0020 | 0002 0002 |]

    uint32_t cps[2] = { 0x0236, 0x0061 };
    uint32_t const ces[9] = { 0x1F12, 0x1CAD, 0x0000, 0x0020, 0x0020, 0x0000, 0x0002, 0x0002, 0x0000 };

    auto collation = collate_for_tests(
        cps, cps + 2, boost::text::variable_weighting::non_ignorable);

    EXPECT_EQ(collation.size(), 9);
    EXPECT_TRUE(boost::algorithm::equal(collation.begin(), collation.end(), ces, ces + 9))
        << "from:     " << ce_dumper(cps)
        << "expected: " << ce_dumper(ces)
        << "got:      " << ce_dumper(collation);
}

TEST(collation, non_ignorable_121_202)
{
    // 0236 0041;	
    // (ȶ) LATIN SMALL LETTER T WITH CURL	[1F12 1CAD | 0020 0020 | 0002 0008 |]

    uint32_t cps[2] = { 0x0236, 0x0041 };
    uint32_t const ces[9] = { 0x1F12, 0x1CAD, 0x0000, 0x0020, 0x0020, 0x0000, 0x0002, 0x0008, 0x0000 };

    auto collation = collate_for_tests(
        cps, cps + 2, boost::text::variable_weighting::non_ignorable);

    EXPECT_EQ(collation.size(), 9);
    EXPECT_TRUE(boost::algorithm::equal(collation.begin(), collation.end(), ces, ces + 9))
        << "from:     " << ce_dumper(cps)
        << "expected: " << ce_dumper(ces)
        << "got:      " << ce_dumper(collation);
}

TEST(collation, non_ignorable_121_203)
{
    // 0236 0062;	
    // (ȶ) LATIN SMALL LETTER T WITH CURL	[1F12 1CC6 | 0020 0020 | 0002 0002 |]

    uint32_t cps[2] = { 0x0236, 0x0062 };
    uint32_t const ces[9] = { 0x1F12, 0x1CC6, 0x0000, 0x0020, 0x0020, 0x0000, 0x0002, 0x0002, 0x0000 };

    auto collation = collate_for_tests(
        cps, cps + 2, boost::text::variable_weighting::non_ignorable);

    EXPECT_EQ(collation.size(), 9);
    EXPECT_TRUE(boost::algorithm::equal(collation.begin(), collation.end(), ces, ces + 9))
        << "from:     " << ce_dumper(cps)
        << "expected: " << ce_dumper(ces)
        << "got:      " << ce_dumper(collation);
}

TEST(collation, non_ignorable_121_204)
{
    // A777 0021;	
    // (ꝷ) LATIN SMALL LETTER TUM	[1F16 0261 | 0020 0020 | 0002 0002 |]

    uint32_t cps[2] = { 0xA777, 0x0021 };
    uint32_t const ces[9] = { 0x1F16, 0x0261, 0x0000, 0x0020, 0x0020, 0x0000, 0x0002, 0x0002, 0x0000 };

    auto collation = collate_for_tests(
        cps, cps + 2, boost::text::variable_weighting::non_ignorable);

    EXPECT_EQ(collation.size(), 9);
    EXPECT_TRUE(boost::algorithm::equal(collation.begin(), collation.end(), ces, ces + 9))
        << "from:     " << ce_dumper(cps)
        << "expected: " << ce_dumper(ces)
        << "got:      " << ce_dumper(collation);
}

TEST(collation, non_ignorable_121_205)
{
    // A777 003F;	
    // (ꝷ) LATIN SMALL LETTER TUM	[1F16 0267 | 0020 0020 | 0002 0002 |]

    uint32_t cps[2] = { 0xA777, 0x003F };
    uint32_t const ces[9] = { 0x1F16, 0x0267, 0x0000, 0x0020, 0x0020, 0x0000, 0x0002, 0x0002, 0x0000 };

    auto collation = collate_for_tests(
        cps, cps + 2, boost::text::variable_weighting::non_ignorable);

    EXPECT_EQ(collation.size(), 9);
    EXPECT_TRUE(boost::algorithm::equal(collation.begin(), collation.end(), ces, ces + 9))
        << "from:     " << ce_dumper(cps)
        << "expected: " << ce_dumper(ces)
        << "got:      " << ce_dumper(collation);
}

TEST(collation, non_ignorable_121_206)
{
    // A777 0061;	
    // (ꝷ) LATIN SMALL LETTER TUM	[1F16 1CAD | 0020 0020 | 0002 0002 |]

    uint32_t cps[2] = { 0xA777, 0x0061 };
    uint32_t const ces[9] = { 0x1F16, 0x1CAD, 0x0000, 0x0020, 0x0020, 0x0000, 0x0002, 0x0002, 0x0000 };

    auto collation = collate_for_tests(
        cps, cps + 2, boost::text::variable_weighting::non_ignorable);

    EXPECT_EQ(collation.size(), 9);
    EXPECT_TRUE(boost::algorithm::equal(collation.begin(), collation.end(), ces, ces + 9))
        << "from:     " << ce_dumper(cps)
        << "expected: " << ce_dumper(ces)
        << "got:      " << ce_dumper(collation);
}

TEST(collation, non_ignorable_121_207)
{
    // A777 0041;	
    // (ꝷ) LATIN SMALL LETTER TUM	[1F16 1CAD | 0020 0020 | 0002 0008 |]

    uint32_t cps[2] = { 0xA777, 0x0041 };
    uint32_t const ces[9] = { 0x1F16, 0x1CAD, 0x0000, 0x0020, 0x0020, 0x0000, 0x0002, 0x0008, 0x0000 };

    auto collation = collate_for_tests(
        cps, cps + 2, boost::text::variable_weighting::non_ignorable);

    EXPECT_EQ(collation.size(), 9);
    EXPECT_TRUE(boost::algorithm::equal(collation.begin(), collation.end(), ces, ces + 9))
        << "from:     " << ce_dumper(cps)
        << "expected: " << ce_dumper(ces)
        << "got:      " << ce_dumper(collation);
}

TEST(collation, non_ignorable_121_208)
{
    // A777 0062;	
    // (ꝷ) LATIN SMALL LETTER TUM	[1F16 1CC6 | 0020 0020 | 0002 0002 |]

    uint32_t cps[2] = { 0xA777, 0x0062 };
    uint32_t const ces[9] = { 0x1F16, 0x1CC6, 0x0000, 0x0020, 0x0020, 0x0000, 0x0002, 0x0002, 0x0000 };

    auto collation = collate_for_tests(
        cps, cps + 2, boost::text::variable_weighting::non_ignorable);

    EXPECT_EQ(collation.size(), 9);
    EXPECT_TRUE(boost::algorithm::equal(collation.begin(), collation.end(), ces, ces + 9))
        << "from:     " << ce_dumper(cps)
        << "expected: " << ce_dumper(ces)
        << "got:      " << ce_dumper(collation);
}

TEST(collation, non_ignorable_121_209)
{
    // 0287 0021;	
    // (ʇ) LATIN SMALL LETTER TURNED T	[1F17 0261 | 0020 0020 | 0002 0002 |]

    uint32_t cps[2] = { 0x0287, 0x0021 };
    uint32_t const ces[9] = { 0x1F17, 0x0261, 0x0000, 0x0020, 0x0020, 0x0000, 0x0002, 0x0002, 0x0000 };

    auto collation = collate_for_tests(
        cps, cps + 2, boost::text::variable_weighting::non_ignorable);

    EXPECT_EQ(collation.size(), 9);
    EXPECT_TRUE(boost::algorithm::equal(collation.begin(), collation.end(), ces, ces + 9))
        << "from:     " << ce_dumper(cps)
        << "expected: " << ce_dumper(ces)
        << "got:      " << ce_dumper(collation);
}

TEST(collation, non_ignorable_121_210)
{
    // A7B1 0021;	
    // (Ʇ) LATIN CAPITAL LETTER TURNED T	[1F17 0261 | 0020 0020 | 0008 0002 |]

    uint32_t cps[2] = { 0xA7B1, 0x0021 };
    uint32_t const ces[9] = { 0x1F17, 0x0261, 0x0000, 0x0020, 0x0020, 0x0000, 0x0008, 0x0002, 0x0000 };

    auto collation = collate_for_tests(
        cps, cps + 2, boost::text::variable_weighting::non_ignorable);

    EXPECT_EQ(collation.size(), 9);
    EXPECT_TRUE(boost::algorithm::equal(collation.begin(), collation.end(), ces, ces + 9))
        << "from:     " << ce_dumper(cps)
        << "expected: " << ce_dumper(ces)
        << "got:      " << ce_dumper(collation);
}

TEST(collation, non_ignorable_121_211)
{
    // 0287 003F;	
    // (ʇ) LATIN SMALL LETTER TURNED T	[1F17 0267 | 0020 0020 | 0002 0002 |]

    uint32_t cps[2] = { 0x0287, 0x003F };
    uint32_t const ces[9] = { 0x1F17, 0x0267, 0x0000, 0x0020, 0x0020, 0x0000, 0x0002, 0x0002, 0x0000 };

    auto collation = collate_for_tests(
        cps, cps + 2, boost::text::variable_weighting::non_ignorable);

    EXPECT_EQ(collation.size(), 9);
    EXPECT_TRUE(boost::algorithm::equal(collation.begin(), collation.end(), ces, ces + 9))
        << "from:     " << ce_dumper(cps)
        << "expected: " << ce_dumper(ces)
        << "got:      " << ce_dumper(collation);
}

TEST(collation, non_ignorable_121_212)
{
    // A7B1 003F;	
    // (Ʇ) LATIN CAPITAL LETTER TURNED T	[1F17 0267 | 0020 0020 | 0008 0002 |]

    uint32_t cps[2] = { 0xA7B1, 0x003F };
    uint32_t const ces[9] = { 0x1F17, 0x0267, 0x0000, 0x0020, 0x0020, 0x0000, 0x0008, 0x0002, 0x0000 };

    auto collation = collate_for_tests(
        cps, cps + 2, boost::text::variable_weighting::non_ignorable);

    EXPECT_EQ(collation.size(), 9);
    EXPECT_TRUE(boost::algorithm::equal(collation.begin(), collation.end(), ces, ces + 9))
        << "from:     " << ce_dumper(cps)
        << "expected: " << ce_dumper(ces)
        << "got:      " << ce_dumper(collation);
}

TEST(collation, non_ignorable_121_213)
{
    // 0287 0061;	
    // (ʇ) LATIN SMALL LETTER TURNED T	[1F17 1CAD | 0020 0020 | 0002 0002 |]

    uint32_t cps[2] = { 0x0287, 0x0061 };
    uint32_t const ces[9] = { 0x1F17, 0x1CAD, 0x0000, 0x0020, 0x0020, 0x0000, 0x0002, 0x0002, 0x0000 };

    auto collation = collate_for_tests(
        cps, cps + 2, boost::text::variable_weighting::non_ignorable);

    EXPECT_EQ(collation.size(), 9);
    EXPECT_TRUE(boost::algorithm::equal(collation.begin(), collation.end(), ces, ces + 9))
        << "from:     " << ce_dumper(cps)
        << "expected: " << ce_dumper(ces)
        << "got:      " << ce_dumper(collation);
}

TEST(collation, non_ignorable_121_214)
{
    // 0287 0041;	
    // (ʇ) LATIN SMALL LETTER TURNED T	[1F17 1CAD | 0020 0020 | 0002 0008 |]

    uint32_t cps[2] = { 0x0287, 0x0041 };
    uint32_t const ces[9] = { 0x1F17, 0x1CAD, 0x0000, 0x0020, 0x0020, 0x0000, 0x0002, 0x0008, 0x0000 };

    auto collation = collate_for_tests(
        cps, cps + 2, boost::text::variable_weighting::non_ignorable);

    EXPECT_EQ(collation.size(), 9);
    EXPECT_TRUE(boost::algorithm::equal(collation.begin(), collation.end(), ces, ces + 9))
        << "from:     " << ce_dumper(cps)
        << "expected: " << ce_dumper(ces)
        << "got:      " << ce_dumper(collation);
}

TEST(collation, non_ignorable_121_215)
{
    // A7B1 0061;	
    // (Ʇ) LATIN CAPITAL LETTER TURNED T	[1F17 1CAD | 0020 0020 | 0008 0002 |]

    uint32_t cps[2] = { 0xA7B1, 0x0061 };
    uint32_t const ces[9] = { 0x1F17, 0x1CAD, 0x0000, 0x0020, 0x0020, 0x0000, 0x0008, 0x0002, 0x0000 };

    auto collation = collate_for_tests(
        cps, cps + 2, boost::text::variable_weighting::non_ignorable);

    EXPECT_EQ(collation.size(), 9);
    EXPECT_TRUE(boost::algorithm::equal(collation.begin(), collation.end(), ces, ces + 9))
        << "from:     " << ce_dumper(cps)
        << "expected: " << ce_dumper(ces)
        << "got:      " << ce_dumper(collation);
}

TEST(collation, non_ignorable_121_216)
{
    // A7B1 0041;	
    // (Ʇ) LATIN CAPITAL LETTER TURNED T	[1F17 1CAD | 0020 0020 | 0008 0008 |]

    uint32_t cps[2] = { 0xA7B1, 0x0041 };
    uint32_t const ces[9] = { 0x1F17, 0x1CAD, 0x0000, 0x0020, 0x0020, 0x0000, 0x0008, 0x0008, 0x0000 };

    auto collation = collate_for_tests(
        cps, cps + 2, boost::text::variable_weighting::non_ignorable);

    EXPECT_EQ(collation.size(), 9);
    EXPECT_TRUE(boost::algorithm::equal(collation.begin(), collation.end(), ces, ces + 9))
        << "from:     " << ce_dumper(cps)
        << "expected: " << ce_dumper(ces)
        << "got:      " << ce_dumper(collation);
}

TEST(collation, non_ignorable_121_217)
{
    // 0287 0062;	
    // (ʇ) LATIN SMALL LETTER TURNED T	[1F17 1CC6 | 0020 0020 | 0002 0002 |]

    uint32_t cps[2] = { 0x0287, 0x0062 };
    uint32_t const ces[9] = { 0x1F17, 0x1CC6, 0x0000, 0x0020, 0x0020, 0x0000, 0x0002, 0x0002, 0x0000 };

    auto collation = collate_for_tests(
        cps, cps + 2, boost::text::variable_weighting::non_ignorable);

    EXPECT_EQ(collation.size(), 9);
    EXPECT_TRUE(boost::algorithm::equal(collation.begin(), collation.end(), ces, ces + 9))
        << "from:     " << ce_dumper(cps)
        << "expected: " << ce_dumper(ces)
        << "got:      " << ce_dumper(collation);
}

TEST(collation, non_ignorable_121_218)
{
    // A7B1 0062;	
    // (Ʇ) LATIN CAPITAL LETTER TURNED T	[1F17 1CC6 | 0020 0020 | 0008 0002 |]

    uint32_t cps[2] = { 0xA7B1, 0x0062 };
    uint32_t const ces[9] = { 0x1F17, 0x1CC6, 0x0000, 0x0020, 0x0020, 0x0000, 0x0008, 0x0002, 0x0000 };

    auto collation = collate_for_tests(
        cps, cps + 2, boost::text::variable_weighting::non_ignorable);

    EXPECT_EQ(collation.size(), 9);
    EXPECT_TRUE(boost::algorithm::equal(collation.begin(), collation.end(), ces, ces + 9))
        << "from:     " << ce_dumper(cps)
        << "expected: " << ce_dumper(ces)
        << "got:      " << ce_dumper(collation);
}

TEST(collation, non_ignorable_121_219)
{
    // 0075 0301 0334;	
    // (ú) LATIN SMALL LETTER U, COMBINING ACUTE ACCENT	[1F1B | 0020 004A 0024 | 0002 0002 0002 |]

    uint32_t cps[3] = { 0x0075, 0x0301, 0x0334 };
    uint32_t const ces[10] = { 0x1F1B, 0x0000, 0x0020, 0x004A, 0x0024, 0x0000, 0x0002, 0x0002, 0x0002, 0x0000 };

    auto collation = collate_for_tests(
        cps, cps + 3, boost::text::variable_weighting::non_ignorable);

    EXPECT_EQ(collation.size(), 10);
    EXPECT_TRUE(boost::algorithm::equal(collation.begin(), collation.end(), ces, ces + 10))
        << "from:     " << ce_dumper(cps)
        << "expected: " << ce_dumper(ces)
        << "got:      " << ce_dumper(collation);
}

TEST(collation, non_ignorable_121_220)
{
    // 0075 0334 0301;	
    // (u̴) LATIN SMALL LETTER U, COMBINING TILDE OVERLAY	[1F1B | 0020 004A 0024 | 0002 0002 0002 |]

    uint32_t cps[3] = { 0x0075, 0x0334, 0x0301 };
    uint32_t const ces[10] = { 0x1F1B, 0x0000, 0x0020, 0x004A, 0x0024, 0x0000, 0x0002, 0x0002, 0x0002, 0x0000 };

    auto collation = collate_for_tests(
        cps, cps + 3, boost::text::variable_weighting::non_ignorable);

    EXPECT_EQ(collation.size(), 10);
    EXPECT_TRUE(boost::algorithm::equal(collation.begin(), collation.end(), ces, ces + 10))
        << "from:     " << ce_dumper(cps)
        << "expected: " << ce_dumper(ces)
        << "got:      " << ce_dumper(collation);
}

TEST(collation, non_ignorable_121_221)
{
    // 0075 0334 0341;	
    // (u̴) LATIN SMALL LETTER U, COMBINING TILDE OVERLAY	[1F1B | 0020 004A 0024 | 0002 0002 0002 |]

    uint32_t cps[3] = { 0x0075, 0x0334, 0x0341 };
    uint32_t const ces[10] = { 0x1F1B, 0x0000, 0x0020, 0x004A, 0x0024, 0x0000, 0x0002, 0x0002, 0x0002, 0x0000 };

    auto collation = collate_for_tests(
        cps, cps + 3, boost::text::variable_weighting::non_ignorable);

    EXPECT_EQ(collation.size(), 10);
    EXPECT_TRUE(boost::algorithm::equal(collation.begin(), collation.end(), ces, ces + 10))
        << "from:     " << ce_dumper(cps)
        << "expected: " << ce_dumper(ces)
        << "got:      " << ce_dumper(collation);
}

TEST(collation, non_ignorable_121_222)
{
    // 0075 0341 0334;	
    // (ú) LATIN SMALL LETTER U, COMBINING ACUTE TONE MARK	[1F1B | 0020 004A 0024 | 0002 0002 0002 |]

    uint32_t cps[3] = { 0x0075, 0x0341, 0x0334 };
    uint32_t const ces[10] = { 0x1F1B, 0x0000, 0x0020, 0x004A, 0x0024, 0x0000, 0x0002, 0x0002, 0x0002, 0x0000 };

    auto collation = collate_for_tests(
        cps, cps + 3, boost::text::variable_weighting::non_ignorable);

    EXPECT_EQ(collation.size(), 10);
    EXPECT_TRUE(boost::algorithm::equal(collation.begin(), collation.end(), ces, ces + 10))
        << "from:     " << ce_dumper(cps)
        << "expected: " << ce_dumper(ces)
        << "got:      " << ce_dumper(collation);
}

TEST(collation, non_ignorable_121_223)
{
    // 0055 0301 0334;	
    // (Ú) LATIN CAPITAL LETTER U, COMBINING ACUTE ACCENT	[1F1B | 0020 004A 0024 | 0008 0002 0002 |]

    uint32_t cps[3] = { 0x0055, 0x0301, 0x0334 };
    uint32_t const ces[10] = { 0x1F1B, 0x0000, 0x0020, 0x004A, 0x0024, 0x0000, 0x0008, 0x0002, 0x0002, 0x0000 };

    auto collation = collate_for_tests(
        cps, cps + 3, boost::text::variable_weighting::non_ignorable);

    EXPECT_EQ(collation.size(), 10);
    EXPECT_TRUE(boost::algorithm::equal(collation.begin(), collation.end(), ces, ces + 10))
        << "from:     " << ce_dumper(cps)
        << "expected: " << ce_dumper(ces)
        << "got:      " << ce_dumper(collation);
}

TEST(collation, non_ignorable_121_224)
{
    // 0055 0334 0301;	
    // (U̴) LATIN CAPITAL LETTER U, COMBINING TILDE OVERLAY	[1F1B | 0020 004A 0024 | 0008 0002 0002 |]

    uint32_t cps[3] = { 0x0055, 0x0334, 0x0301 };
    uint32_t const ces[10] = { 0x1F1B, 0x0000, 0x0020, 0x004A, 0x0024, 0x0000, 0x0008, 0x0002, 0x0002, 0x0000 };

    auto collation = collate_for_tests(
        cps, cps + 3, boost::text::variable_weighting::non_ignorable);

    EXPECT_EQ(collation.size(), 10);
    EXPECT_TRUE(boost::algorithm::equal(collation.begin(), collation.end(), ces, ces + 10))
        << "from:     " << ce_dumper(cps)
        << "expected: " << ce_dumper(ces)
        << "got:      " << ce_dumper(collation);
}

TEST(collation, non_ignorable_121_225)
{
    // 0055 0334 0341;	
    // (U̴) LATIN CAPITAL LETTER U, COMBINING TILDE OVERLAY	[1F1B | 0020 004A 0024 | 0008 0002 0002 |]

    uint32_t cps[3] = { 0x0055, 0x0334, 0x0341 };
    uint32_t const ces[10] = { 0x1F1B, 0x0000, 0x0020, 0x004A, 0x0024, 0x0000, 0x0008, 0x0002, 0x0002, 0x0000 };

    auto collation = collate_for_tests(
        cps, cps + 3, boost::text::variable_weighting::non_ignorable);

    EXPECT_EQ(collation.size(), 10);
    EXPECT_TRUE(boost::algorithm::equal(collation.begin(), collation.end(), ces, ces + 10))
        << "from:     " << ce_dumper(cps)
        << "expected: " << ce_dumper(ces)
        << "got:      " << ce_dumper(collation);
}

TEST(collation, non_ignorable_121_226)
{
    // 0055 0341 0334;	
    // (Ú) LATIN CAPITAL LETTER U, COMBINING ACUTE TONE MARK	[1F1B | 0020 004A 0024 | 0008 0002 0002 |]

    uint32_t cps[3] = { 0x0055, 0x0341, 0x0334 };
    uint32_t const ces[10] = { 0x1F1B, 0x0000, 0x0020, 0x004A, 0x0024, 0x0000, 0x0008, 0x0002, 0x0002, 0x0000 };

    auto collation = collate_for_tests(
        cps, cps + 3, boost::text::variable_weighting::non_ignorable);

    EXPECT_EQ(collation.size(), 10);
    EXPECT_TRUE(boost::algorithm::equal(collation.begin(), collation.end(), ces, ces + 10))
        << "from:     " << ce_dumper(cps)
        << "expected: " << ce_dumper(ces)
        << "got:      " << ce_dumper(collation);
}

TEST(collation, non_ignorable_121_227)
{
    // 0075 0300 0334;	
    // (ù) LATIN SMALL LETTER U, COMBINING GRAVE ACCENT	[1F1B | 0020 004A 0025 | 0002 0002 0002 |]

    uint32_t cps[3] = { 0x0075, 0x0300, 0x0334 };
    uint32_t const ces[10] = { 0x1F1B, 0x0000, 0x0020, 0x004A, 0x0025, 0x0000, 0x0002, 0x0002, 0x0002, 0x0000 };

    auto collation = collate_for_tests(
        cps, cps + 3, boost::text::variable_weighting::non_ignorable);

    EXPECT_EQ(collation.size(), 10);
    EXPECT_TRUE(boost::algorithm::equal(collation.begin(), collation.end(), ces, ces + 10))
        << "from:     " << ce_dumper(cps)
        << "expected: " << ce_dumper(ces)
        << "got:      " << ce_dumper(collation);
}

TEST(collation, non_ignorable_121_228)
{
    // 0075 0334 0300;	
    // (u̴) LATIN SMALL LETTER U, COMBINING TILDE OVERLAY	[1F1B | 0020 004A 0025 | 0002 0002 0002 |]

    uint32_t cps[3] = { 0x0075, 0x0334, 0x0300 };
    uint32_t const ces[10] = { 0x1F1B, 0x0000, 0x0020, 0x004A, 0x0025, 0x0000, 0x0002, 0x0002, 0x0002, 0x0000 };

    auto collation = collate_for_tests(
        cps, cps + 3, boost::text::variable_weighting::non_ignorable);

    EXPECT_EQ(collation.size(), 10);
    EXPECT_TRUE(boost::algorithm::equal(collation.begin(), collation.end(), ces, ces + 10))
        << "from:     " << ce_dumper(cps)
        << "expected: " << ce_dumper(ces)
        << "got:      " << ce_dumper(collation);
}

TEST(collation, non_ignorable_121_229)
{
    // 0075 0334 0340;	
    // (u̴) LATIN SMALL LETTER U, COMBINING TILDE OVERLAY	[1F1B | 0020 004A 0025 | 0002 0002 0002 |]

    uint32_t cps[3] = { 0x0075, 0x0334, 0x0340 };
    uint32_t const ces[10] = { 0x1F1B, 0x0000, 0x0020, 0x004A, 0x0025, 0x0000, 0x0002, 0x0002, 0x0002, 0x0000 };

    auto collation = collate_for_tests(
        cps, cps + 3, boost::text::variable_weighting::non_ignorable);

    EXPECT_EQ(collation.size(), 10);
    EXPECT_TRUE(boost::algorithm::equal(collation.begin(), collation.end(), ces, ces + 10))
        << "from:     " << ce_dumper(cps)
        << "expected: " << ce_dumper(ces)
        << "got:      " << ce_dumper(collation);
}

TEST(collation, non_ignorable_121_230)
{
    // 0075 0340 0334;	
    // (ù) LATIN SMALL LETTER U, COMBINING GRAVE TONE MARK	[1F1B | 0020 004A 0025 | 0002 0002 0002 |]

    uint32_t cps[3] = { 0x0075, 0x0340, 0x0334 };
    uint32_t const ces[10] = { 0x1F1B, 0x0000, 0x0020, 0x004A, 0x0025, 0x0000, 0x0002, 0x0002, 0x0002, 0x0000 };

    auto collation = collate_for_tests(
        cps, cps + 3, boost::text::variable_weighting::non_ignorable);

    EXPECT_EQ(collation.size(), 10);
    EXPECT_TRUE(boost::algorithm::equal(collation.begin(), collation.end(), ces, ces + 10))
        << "from:     " << ce_dumper(cps)
        << "expected: " << ce_dumper(ces)
        << "got:      " << ce_dumper(collation);
}

TEST(collation, non_ignorable_121_231)
{
    // 0055 0300 0334;	
    // (Ù) LATIN CAPITAL LETTER U, COMBINING GRAVE ACCENT	[1F1B | 0020 004A 0025 | 0008 0002 0002 |]

    uint32_t cps[3] = { 0x0055, 0x0300, 0x0334 };
    uint32_t const ces[10] = { 0x1F1B, 0x0000, 0x0020, 0x004A, 0x0025, 0x0000, 0x0008, 0x0002, 0x0002, 0x0000 };

    auto collation = collate_for_tests(
        cps, cps + 3, boost::text::variable_weighting::non_ignorable);

    EXPECT_EQ(collation.size(), 10);
    EXPECT_TRUE(boost::algorithm::equal(collation.begin(), collation.end(), ces, ces + 10))
        << "from:     " << ce_dumper(cps)
        << "expected: " << ce_dumper(ces)
        << "got:      " << ce_dumper(collation);
}

TEST(collation, non_ignorable_121_232)
{
    // 0055 0334 0300;	
    // (U̴) LATIN CAPITAL LETTER U, COMBINING TILDE OVERLAY	[1F1B | 0020 004A 0025 | 0008 0002 0002 |]

    uint32_t cps[3] = { 0x0055, 0x0334, 0x0300 };
    uint32_t const ces[10] = { 0x1F1B, 0x0000, 0x0020, 0x004A, 0x0025, 0x0000, 0x0008, 0x0002, 0x0002, 0x0000 };

    auto collation = collate_for_tests(
        cps, cps + 3, boost::text::variable_weighting::non_ignorable);

    EXPECT_EQ(collation.size(), 10);
    EXPECT_TRUE(boost::algorithm::equal(collation.begin(), collation.end(), ces, ces + 10))
        << "from:     " << ce_dumper(cps)
        << "expected: " << ce_dumper(ces)
        << "got:      " << ce_dumper(collation);
}

TEST(collation, non_ignorable_121_233)
{
    // 0055 0334 0340;	
    // (U̴) LATIN CAPITAL LETTER U, COMBINING TILDE OVERLAY	[1F1B | 0020 004A 0025 | 0008 0002 0002 |]

    uint32_t cps[3] = { 0x0055, 0x0334, 0x0340 };
    uint32_t const ces[10] = { 0x1F1B, 0x0000, 0x0020, 0x004A, 0x0025, 0x0000, 0x0008, 0x0002, 0x0002, 0x0000 };

    auto collation = collate_for_tests(
        cps, cps + 3, boost::text::variable_weighting::non_ignorable);

    EXPECT_EQ(collation.size(), 10);
    EXPECT_TRUE(boost::algorithm::equal(collation.begin(), collation.end(), ces, ces + 10))
        << "from:     " << ce_dumper(cps)
        << "expected: " << ce_dumper(ces)
        << "got:      " << ce_dumper(collation);
}

TEST(collation, non_ignorable_121_234)
{
    // 0055 0340 0334;	
    // (Ù) LATIN CAPITAL LETTER U, COMBINING GRAVE TONE MARK	[1F1B | 0020 004A 0025 | 0008 0002 0002 |]

    uint32_t cps[3] = { 0x0055, 0x0340, 0x0334 };
    uint32_t const ces[10] = { 0x1F1B, 0x0000, 0x0020, 0x004A, 0x0025, 0x0000, 0x0008, 0x0002, 0x0002, 0x0000 };

    auto collation = collate_for_tests(
        cps, cps + 3, boost::text::variable_weighting::non_ignorable);

    EXPECT_EQ(collation.size(), 10);
    EXPECT_TRUE(boost::algorithm::equal(collation.begin(), collation.end(), ces, ces + 10))
        << "from:     " << ce_dumper(cps)
        << "expected: " << ce_dumper(ces)
        << "got:      " << ce_dumper(collation);
}

TEST(collation, non_ignorable_121_235)
{
    // 0075 0306 0334;	
    // (ŭ) LATIN SMALL LETTER U, COMBINING BREVE	[1F1B | 0020 004A 0026 | 0002 0002 0002 |]

    uint32_t cps[3] = { 0x0075, 0x0306, 0x0334 };
    uint32_t const ces[10] = { 0x1F1B, 0x0000, 0x0020, 0x004A, 0x0026, 0x0000, 0x0002, 0x0002, 0x0002, 0x0000 };

    auto collation = collate_for_tests(
        cps, cps + 3, boost::text::variable_weighting::non_ignorable);

    EXPECT_EQ(collation.size(), 10);
    EXPECT_TRUE(boost::algorithm::equal(collation.begin(), collation.end(), ces, ces + 10))
        << "from:     " << ce_dumper(cps)
        << "expected: " << ce_dumper(ces)
        << "got:      " << ce_dumper(collation);
}

TEST(collation, non_ignorable_121_236)
{
    // 0075 0334 0306;	
    // (u̴) LATIN SMALL LETTER U, COMBINING TILDE OVERLAY	[1F1B | 0020 004A 0026 | 0002 0002 0002 |]

    uint32_t cps[3] = { 0x0075, 0x0334, 0x0306 };
    uint32_t const ces[10] = { 0x1F1B, 0x0000, 0x0020, 0x004A, 0x0026, 0x0000, 0x0002, 0x0002, 0x0002, 0x0000 };

    auto collation = collate_for_tests(
        cps, cps + 3, boost::text::variable_weighting::non_ignorable);

    EXPECT_EQ(collation.size(), 10);
    EXPECT_TRUE(boost::algorithm::equal(collation.begin(), collation.end(), ces, ces + 10))
        << "from:     " << ce_dumper(cps)
        << "expected: " << ce_dumper(ces)
        << "got:      " << ce_dumper(collation);
}

TEST(collation, non_ignorable_121_237)
{
    // 016D 0334;	
    // (ŭ) LATIN SMALL LETTER U WITH BREVE	[1F1B | 0020 004A 0026 | 0002 0002 0002 |]

    uint32_t cps[2] = { 0x016D, 0x0334 };
    uint32_t const ces[10] = { 0x1F1B, 0x0000, 0x0020, 0x004A, 0x0026, 0x0000, 0x0002, 0x0002, 0x0002, 0x0000 };

    auto collation = collate_for_tests(
        cps, cps + 2, boost::text::variable_weighting::non_ignorable);

    EXPECT_EQ(collation.size(), 10);
    EXPECT_TRUE(boost::algorithm::equal(collation.begin(), collation.end(), ces, ces + 10))
        << "from:     " << ce_dumper(cps)
        << "expected: " << ce_dumper(ces)
        << "got:      " << ce_dumper(collation);
}

TEST(collation, non_ignorable_121_238)
{
    // 0055 0306 0334;	
    // (Ŭ) LATIN CAPITAL LETTER U, COMBINING BREVE	[1F1B | 0020 004A 0026 | 0008 0002 0002 |]

    uint32_t cps[3] = { 0x0055, 0x0306, 0x0334 };
    uint32_t const ces[10] = { 0x1F1B, 0x0000, 0x0020, 0x004A, 0x0026, 0x0000, 0x0008, 0x0002, 0x0002, 0x0000 };

    auto collation = collate_for_tests(
        cps, cps + 3, boost::text::variable_weighting::non_ignorable);

    EXPECT_EQ(collation.size(), 10);
    EXPECT_TRUE(boost::algorithm::equal(collation.begin(), collation.end(), ces, ces + 10))
        << "from:     " << ce_dumper(cps)
        << "expected: " << ce_dumper(ces)
        << "got:      " << ce_dumper(collation);
}

TEST(collation, non_ignorable_121_239)
{
    // 0055 0334 0306;	
    // (U̴) LATIN CAPITAL LETTER U, COMBINING TILDE OVERLAY	[1F1B | 0020 004A 0026 | 0008 0002 0002 |]

    uint32_t cps[3] = { 0x0055, 0x0334, 0x0306 };
    uint32_t const ces[10] = { 0x1F1B, 0x0000, 0x0020, 0x004A, 0x0026, 0x0000, 0x0008, 0x0002, 0x0002, 0x0000 };

    auto collation = collate_for_tests(
        cps, cps + 3, boost::text::variable_weighting::non_ignorable);

    EXPECT_EQ(collation.size(), 10);
    EXPECT_TRUE(boost::algorithm::equal(collation.begin(), collation.end(), ces, ces + 10))
        << "from:     " << ce_dumper(cps)
        << "expected: " << ce_dumper(ces)
        << "got:      " << ce_dumper(collation);
}

TEST(collation, non_ignorable_121_240)
{
    // 016C 0334;	
    // (Ŭ) LATIN CAPITAL LETTER U WITH BREVE	[1F1B | 0020 004A 0026 | 0008 0002 0002 |]

    uint32_t cps[2] = { 0x016C, 0x0334 };
    uint32_t const ces[10] = { 0x1F1B, 0x0000, 0x0020, 0x004A, 0x0026, 0x0000, 0x0008, 0x0002, 0x0002, 0x0000 };

    auto collation = collate_for_tests(
        cps, cps + 2, boost::text::variable_weighting::non_ignorable);

    EXPECT_EQ(collation.size(), 10);
    EXPECT_TRUE(boost::algorithm::equal(collation.begin(), collation.end(), ces, ces + 10))
        << "from:     " << ce_dumper(cps)
        << "expected: " << ce_dumper(ces)
        << "got:      " << ce_dumper(collation);
}

TEST(collation, non_ignorable_121_241)
{
    // 0075 0302 0334;	
    // (û) LATIN SMALL LETTER U, COMBINING CIRCUMFLEX ACCENT	[1F1B | 0020 004A 0027 | 0002 0002 0002 |]

    uint32_t cps[3] = { 0x0075, 0x0302, 0x0334 };
    uint32_t const ces[10] = { 0x1F1B, 0x0000, 0x0020, 0x004A, 0x0027, 0x0000, 0x0002, 0x0002, 0x0002, 0x0000 };

    auto collation = collate_for_tests(
        cps, cps + 3, boost::text::variable_weighting::non_ignorable);

    EXPECT_EQ(collation.size(), 10);
    EXPECT_TRUE(boost::algorithm::equal(collation.begin(), collation.end(), ces, ces + 10))
        << "from:     " << ce_dumper(cps)
        << "expected: " << ce_dumper(ces)
        << "got:      " << ce_dumper(collation);
}

TEST(collation, non_ignorable_121_242)
{
    // 0075 0334 0302;	
    // (u̴) LATIN SMALL LETTER U, COMBINING TILDE OVERLAY	[1F1B | 0020 004A 0027 | 0002 0002 0002 |]

    uint32_t cps[3] = { 0x0075, 0x0334, 0x0302 };
    uint32_t const ces[10] = { 0x1F1B, 0x0000, 0x0020, 0x004A, 0x0027, 0x0000, 0x0002, 0x0002, 0x0002, 0x0000 };

    auto collation = collate_for_tests(
        cps, cps + 3, boost::text::variable_weighting::non_ignorable);

    EXPECT_EQ(collation.size(), 10);
    EXPECT_TRUE(boost::algorithm::equal(collation.begin(), collation.end(), ces, ces + 10))
        << "from:     " << ce_dumper(cps)
        << "expected: " << ce_dumper(ces)
        << "got:      " << ce_dumper(collation);
}

TEST(collation, non_ignorable_121_243)
{
    // 00FB 0334;	
    // (û) LATIN SMALL LETTER U WITH CIRCUMFLEX	[1F1B | 0020 004A 0027 | 0002 0002 0002 |]

    uint32_t cps[2] = { 0x00FB, 0x0334 };
    uint32_t const ces[10] = { 0x1F1B, 0x0000, 0x0020, 0x004A, 0x0027, 0x0000, 0x0002, 0x0002, 0x0002, 0x0000 };

    auto collation = collate_for_tests(
        cps, cps + 2, boost::text::variable_weighting::non_ignorable);

    EXPECT_EQ(collation.size(), 10);
    EXPECT_TRUE(boost::algorithm::equal(collation.begin(), collation.end(), ces, ces + 10))
        << "from:     " << ce_dumper(cps)
        << "expected: " << ce_dumper(ces)
        << "got:      " << ce_dumper(collation);
}

TEST(collation, non_ignorable_121_244)
{
    // 0055 0302 0334;	
    // (Û) LATIN CAPITAL LETTER U, COMBINING CIRCUMFLEX ACCENT	[1F1B | 0020 004A 0027 | 0008 0002 0002 |]

    uint32_t cps[3] = { 0x0055, 0x0302, 0x0334 };
    uint32_t const ces[10] = { 0x1F1B, 0x0000, 0x0020, 0x004A, 0x0027, 0x0000, 0x0008, 0x0002, 0x0002, 0x0000 };

    auto collation = collate_for_tests(
        cps, cps + 3, boost::text::variable_weighting::non_ignorable);

    EXPECT_EQ(collation.size(), 10);
    EXPECT_TRUE(boost::algorithm::equal(collation.begin(), collation.end(), ces, ces + 10))
        << "from:     " << ce_dumper(cps)
        << "expected: " << ce_dumper(ces)
        << "got:      " << ce_dumper(collation);
}

TEST(collation, non_ignorable_121_245)
{
    // 0055 0334 0302;	
    // (U̴) LATIN CAPITAL LETTER U, COMBINING TILDE OVERLAY	[1F1B | 0020 004A 0027 | 0008 0002 0002 |]

    uint32_t cps[3] = { 0x0055, 0x0334, 0x0302 };
    uint32_t const ces[10] = { 0x1F1B, 0x0000, 0x0020, 0x004A, 0x0027, 0x0000, 0x0008, 0x0002, 0x0002, 0x0000 };

    auto collation = collate_for_tests(
        cps, cps + 3, boost::text::variable_weighting::non_ignorable);

    EXPECT_EQ(collation.size(), 10);
    EXPECT_TRUE(boost::algorithm::equal(collation.begin(), collation.end(), ces, ces + 10))
        << "from:     " << ce_dumper(cps)
        << "expected: " << ce_dumper(ces)
        << "got:      " << ce_dumper(collation);
}

TEST(collation, non_ignorable_121_246)
{
    // 00DB 0334;	
    // (Û) LATIN CAPITAL LETTER U WITH CIRCUMFLEX	[1F1B | 0020 004A 0027 | 0008 0002 0002 |]

    uint32_t cps[2] = { 0x00DB, 0x0334 };
    uint32_t const ces[10] = { 0x1F1B, 0x0000, 0x0020, 0x004A, 0x0027, 0x0000, 0x0008, 0x0002, 0x0002, 0x0000 };

    auto collation = collate_for_tests(
        cps, cps + 2, boost::text::variable_weighting::non_ignorable);

    EXPECT_EQ(collation.size(), 10);
    EXPECT_TRUE(boost::algorithm::equal(collation.begin(), collation.end(), ces, ces + 10))
        << "from:     " << ce_dumper(cps)
        << "expected: " << ce_dumper(ces)
        << "got:      " << ce_dumper(collation);
}

TEST(collation, non_ignorable_121_247)
{
    // 0075 030C 0334;	
    // (ǔ) LATIN SMALL LETTER U, COMBINING CARON	[1F1B | 0020 004A 0028 | 0002 0002 0002 |]

    uint32_t cps[3] = { 0x0075, 0x030C, 0x0334 };
    uint32_t const ces[10] = { 0x1F1B, 0x0000, 0x0020, 0x004A, 0x0028, 0x0000, 0x0002, 0x0002, 0x0002, 0x0000 };

    auto collation = collate_for_tests(
        cps, cps + 3, boost::text::variable_weighting::non_ignorable);

    EXPECT_EQ(collation.size(), 10);
    EXPECT_TRUE(boost::algorithm::equal(collation.begin(), collation.end(), ces, ces + 10))
        << "from:     " << ce_dumper(cps)
        << "expected: " << ce_dumper(ces)
        << "got:      " << ce_dumper(collation);
}

TEST(collation, non_ignorable_121_248)
{
    // 0075 0334 030C;	
    // (u̴) LATIN SMALL LETTER U, COMBINING TILDE OVERLAY	[1F1B | 0020 004A 0028 | 0002 0002 0002 |]

    uint32_t cps[3] = { 0x0075, 0x0334, 0x030C };
    uint32_t const ces[10] = { 0x1F1B, 0x0000, 0x0020, 0x004A, 0x0028, 0x0000, 0x0002, 0x0002, 0x0002, 0x0000 };

    auto collation = collate_for_tests(
        cps, cps + 3, boost::text::variable_weighting::non_ignorable);

    EXPECT_EQ(collation.size(), 10);
    EXPECT_TRUE(boost::algorithm::equal(collation.begin(), collation.end(), ces, ces + 10))
        << "from:     " << ce_dumper(cps)
        << "expected: " << ce_dumper(ces)
        << "got:      " << ce_dumper(collation);
}

TEST(collation, non_ignorable_121_249)
{
    // 01D4 0334;	
    // (ǔ) LATIN SMALL LETTER U WITH CARON	[1F1B | 0020 004A 0028 | 0002 0002 0002 |]

    uint32_t cps[2] = { 0x01D4, 0x0334 };
    uint32_t const ces[10] = { 0x1F1B, 0x0000, 0x0020, 0x004A, 0x0028, 0x0000, 0x0002, 0x0002, 0x0002, 0x0000 };

    auto collation = collate_for_tests(
        cps, cps + 2, boost::text::variable_weighting::non_ignorable);

    EXPECT_EQ(collation.size(), 10);
    EXPECT_TRUE(boost::algorithm::equal(collation.begin(), collation.end(), ces, ces + 10))
        << "from:     " << ce_dumper(cps)
        << "expected: " << ce_dumper(ces)
        << "got:      " << ce_dumper(collation);
}

TEST(collation, non_ignorable_121_250)
{
    // 0055 030C 0334;	
    // (Ǔ) LATIN CAPITAL LETTER U, COMBINING CARON	[1F1B | 0020 004A 0028 | 0008 0002 0002 |]

    uint32_t cps[3] = { 0x0055, 0x030C, 0x0334 };
    uint32_t const ces[10] = { 0x1F1B, 0x0000, 0x0020, 0x004A, 0x0028, 0x0000, 0x0008, 0x0002, 0x0002, 0x0000 };

    auto collation = collate_for_tests(
        cps, cps + 3, boost::text::variable_weighting::non_ignorable);

    EXPECT_EQ(collation.size(), 10);
    EXPECT_TRUE(boost::algorithm::equal(collation.begin(), collation.end(), ces, ces + 10))
        << "from:     " << ce_dumper(cps)
        << "expected: " << ce_dumper(ces)
        << "got:      " << ce_dumper(collation);
}

TEST(collation, non_ignorable_121_251)
{
    // 0055 0334 030C;	
    // (U̴) LATIN CAPITAL LETTER U, COMBINING TILDE OVERLAY	[1F1B | 0020 004A 0028 | 0008 0002 0002 |]

    uint32_t cps[3] = { 0x0055, 0x0334, 0x030C };
    uint32_t const ces[10] = { 0x1F1B, 0x0000, 0x0020, 0x004A, 0x0028, 0x0000, 0x0008, 0x0002, 0x0002, 0x0000 };

    auto collation = collate_for_tests(
        cps, cps + 3, boost::text::variable_weighting::non_ignorable);

    EXPECT_EQ(collation.size(), 10);
    EXPECT_TRUE(boost::algorithm::equal(collation.begin(), collation.end(), ces, ces + 10))
        << "from:     " << ce_dumper(cps)
        << "expected: " << ce_dumper(ces)
        << "got:      " << ce_dumper(collation);
}

TEST(collation, non_ignorable_121_252)
{
    // 01D3 0334;	
    // (Ǔ) LATIN CAPITAL LETTER U WITH CARON	[1F1B | 0020 004A 0028 | 0008 0002 0002 |]

    uint32_t cps[2] = { 0x01D3, 0x0334 };
    uint32_t const ces[10] = { 0x1F1B, 0x0000, 0x0020, 0x004A, 0x0028, 0x0000, 0x0008, 0x0002, 0x0002, 0x0000 };

    auto collation = collate_for_tests(
        cps, cps + 2, boost::text::variable_weighting::non_ignorable);

    EXPECT_EQ(collation.size(), 10);
    EXPECT_TRUE(boost::algorithm::equal(collation.begin(), collation.end(), ces, ces + 10))
        << "from:     " << ce_dumper(cps)
        << "expected: " << ce_dumper(ces)
        << "got:      " << ce_dumper(collation);
}

TEST(collation, non_ignorable_121_253)
{
    // 0075 030A 0334;	
    // (ů) LATIN SMALL LETTER U, COMBINING RING ABOVE	[1F1B | 0020 004A 0029 | 0002 0002 0002 |]

    uint32_t cps[3] = { 0x0075, 0x030A, 0x0334 };
    uint32_t const ces[10] = { 0x1F1B, 0x0000, 0x0020, 0x004A, 0x0029, 0x0000, 0x0002, 0x0002, 0x0002, 0x0000 };

    auto collation = collate_for_tests(
        cps, cps + 3, boost::text::variable_weighting::non_ignorable);

    EXPECT_EQ(collation.size(), 10);
    EXPECT_TRUE(boost::algorithm::equal(collation.begin(), collation.end(), ces, ces + 10))
        << "from:     " << ce_dumper(cps)
        << "expected: " << ce_dumper(ces)
        << "got:      " << ce_dumper(collation);
}

TEST(collation, non_ignorable_121_254)
{
    // 0075 0334 030A;	
    // (u̴) LATIN SMALL LETTER U, COMBINING TILDE OVERLAY	[1F1B | 0020 004A 0029 | 0002 0002 0002 |]

    uint32_t cps[3] = { 0x0075, 0x0334, 0x030A };
    uint32_t const ces[10] = { 0x1F1B, 0x0000, 0x0020, 0x004A, 0x0029, 0x0000, 0x0002, 0x0002, 0x0002, 0x0000 };

    auto collation = collate_for_tests(
        cps, cps + 3, boost::text::variable_weighting::non_ignorable);

    EXPECT_EQ(collation.size(), 10);
    EXPECT_TRUE(boost::algorithm::equal(collation.begin(), collation.end(), ces, ces + 10))
        << "from:     " << ce_dumper(cps)
        << "expected: " << ce_dumper(ces)
        << "got:      " << ce_dumper(collation);
}

TEST(collation, non_ignorable_121_255)
{
    // 016F 0334;	
    // (ů) LATIN SMALL LETTER U WITH RING ABOVE	[1F1B | 0020 004A 0029 | 0002 0002 0002 |]

    uint32_t cps[2] = { 0x016F, 0x0334 };
    uint32_t const ces[10] = { 0x1F1B, 0x0000, 0x0020, 0x004A, 0x0029, 0x0000, 0x0002, 0x0002, 0x0002, 0x0000 };

    auto collation = collate_for_tests(
        cps, cps + 2, boost::text::variable_weighting::non_ignorable);

    EXPECT_EQ(collation.size(), 10);
    EXPECT_TRUE(boost::algorithm::equal(collation.begin(), collation.end(), ces, ces + 10))
        << "from:     " << ce_dumper(cps)
        << "expected: " << ce_dumper(ces)
        << "got:      " << ce_dumper(collation);
}

TEST(collation, non_ignorable_121_256)
{
    // 0055 030A 0334;	
    // (Ů) LATIN CAPITAL LETTER U, COMBINING RING ABOVE	[1F1B | 0020 004A 0029 | 0008 0002 0002 |]

    uint32_t cps[3] = { 0x0055, 0x030A, 0x0334 };
    uint32_t const ces[10] = { 0x1F1B, 0x0000, 0x0020, 0x004A, 0x0029, 0x0000, 0x0008, 0x0002, 0x0002, 0x0000 };

    auto collation = collate_for_tests(
        cps, cps + 3, boost::text::variable_weighting::non_ignorable);

    EXPECT_EQ(collation.size(), 10);
    EXPECT_TRUE(boost::algorithm::equal(collation.begin(), collation.end(), ces, ces + 10))
        << "from:     " << ce_dumper(cps)
        << "expected: " << ce_dumper(ces)
        << "got:      " << ce_dumper(collation);
}

TEST(collation, non_ignorable_121_257)
{
    // 0055 0334 030A;	
    // (U̴) LATIN CAPITAL LETTER U, COMBINING TILDE OVERLAY	[1F1B | 0020 004A 0029 | 0008 0002 0002 |]

    uint32_t cps[3] = { 0x0055, 0x0334, 0x030A };
    uint32_t const ces[10] = { 0x1F1B, 0x0000, 0x0020, 0x004A, 0x0029, 0x0000, 0x0008, 0x0002, 0x0002, 0x0000 };

    auto collation = collate_for_tests(
        cps, cps + 3, boost::text::variable_weighting::non_ignorable);

    EXPECT_EQ(collation.size(), 10);
    EXPECT_TRUE(boost::algorithm::equal(collation.begin(), collation.end(), ces, ces + 10))
        << "from:     " << ce_dumper(cps)
        << "expected: " << ce_dumper(ces)
        << "got:      " << ce_dumper(collation);
}

TEST(collation, non_ignorable_121_258)
{
    // 016E 0334;	
    // (Ů) LATIN CAPITAL LETTER U WITH RING ABOVE	[1F1B | 0020 004A 0029 | 0008 0002 0002 |]

    uint32_t cps[2] = { 0x016E, 0x0334 };
    uint32_t const ces[10] = { 0x1F1B, 0x0000, 0x0020, 0x004A, 0x0029, 0x0000, 0x0008, 0x0002, 0x0002, 0x0000 };

    auto collation = collate_for_tests(
        cps, cps + 2, boost::text::variable_weighting::non_ignorable);

    EXPECT_EQ(collation.size(), 10);
    EXPECT_TRUE(boost::algorithm::equal(collation.begin(), collation.end(), ces, ces + 10))
        << "from:     " << ce_dumper(cps)
        << "expected: " << ce_dumper(ces)
        << "got:      " << ce_dumper(collation);
}

TEST(collation, non_ignorable_121_259)
{
    // 0075 0308 0334;	
    // (ü) LATIN SMALL LETTER U, COMBINING DIAERESIS	[1F1B | 0020 004A 002B | 0002 0002 0002 |]

    uint32_t cps[3] = { 0x0075, 0x0308, 0x0334 };
    uint32_t const ces[10] = { 0x1F1B, 0x0000, 0x0020, 0x004A, 0x002B, 0x0000, 0x0002, 0x0002, 0x0002, 0x0000 };

    auto collation = collate_for_tests(
        cps, cps + 3, boost::text::variable_weighting::non_ignorable);

    EXPECT_EQ(collation.size(), 10);
    EXPECT_TRUE(boost::algorithm::equal(collation.begin(), collation.end(), ces, ces + 10))
        << "from:     " << ce_dumper(cps)
        << "expected: " << ce_dumper(ces)
        << "got:      " << ce_dumper(collation);
}

TEST(collation, non_ignorable_121_260)
{
    // 0075 0334 0308;	
    // (u̴) LATIN SMALL LETTER U, COMBINING TILDE OVERLAY	[1F1B | 0020 004A 002B | 0002 0002 0002 |]

    uint32_t cps[3] = { 0x0075, 0x0334, 0x0308 };
    uint32_t const ces[10] = { 0x1F1B, 0x0000, 0x0020, 0x004A, 0x002B, 0x0000, 0x0002, 0x0002, 0x0002, 0x0000 };

    auto collation = collate_for_tests(
        cps, cps + 3, boost::text::variable_weighting::non_ignorable);

    EXPECT_EQ(collation.size(), 10);
    EXPECT_TRUE(boost::algorithm::equal(collation.begin(), collation.end(), ces, ces + 10))
        << "from:     " << ce_dumper(cps)
        << "expected: " << ce_dumper(ces)
        << "got:      " << ce_dumper(collation);
}

TEST(collation, non_ignorable_121_261)
{
    // 00FC 0334;	
    // (ü) LATIN SMALL LETTER U WITH DIAERESIS	[1F1B | 0020 004A 002B | 0002 0002 0002 |]

    uint32_t cps[2] = { 0x00FC, 0x0334 };
    uint32_t const ces[10] = { 0x1F1B, 0x0000, 0x0020, 0x004A, 0x002B, 0x0000, 0x0002, 0x0002, 0x0002, 0x0000 };

    auto collation = collate_for_tests(
        cps, cps + 2, boost::text::variable_weighting::non_ignorable);

    EXPECT_EQ(collation.size(), 10);
    EXPECT_TRUE(boost::algorithm::equal(collation.begin(), collation.end(), ces, ces + 10))
        << "from:     " << ce_dumper(cps)
        << "expected: " << ce_dumper(ces)
        << "got:      " << ce_dumper(collation);
}

TEST(collation, non_ignorable_121_262)
{
    // 0055 0308 0334;	
    // (Ü) LATIN CAPITAL LETTER U, COMBINING DIAERESIS	[1F1B | 0020 004A 002B | 0008 0002 0002 |]

    uint32_t cps[3] = { 0x0055, 0x0308, 0x0334 };
    uint32_t const ces[10] = { 0x1F1B, 0x0000, 0x0020, 0x004A, 0x002B, 0x0000, 0x0008, 0x0002, 0x0002, 0x0000 };

    auto collation = collate_for_tests(
        cps, cps + 3, boost::text::variable_weighting::non_ignorable);

    EXPECT_EQ(collation.size(), 10);
    EXPECT_TRUE(boost::algorithm::equal(collation.begin(), collation.end(), ces, ces + 10))
        << "from:     " << ce_dumper(cps)
        << "expected: " << ce_dumper(ces)
        << "got:      " << ce_dumper(collation);
}

TEST(collation, non_ignorable_121_263)
{
    // 0055 0334 0308;	
    // (U̴) LATIN CAPITAL LETTER U, COMBINING TILDE OVERLAY	[1F1B | 0020 004A 002B | 0008 0002 0002 |]

    uint32_t cps[3] = { 0x0055, 0x0334, 0x0308 };
    uint32_t const ces[10] = { 0x1F1B, 0x0000, 0x0020, 0x004A, 0x002B, 0x0000, 0x0008, 0x0002, 0x0002, 0x0000 };

    auto collation = collate_for_tests(
        cps, cps + 3, boost::text::variable_weighting::non_ignorable);

    EXPECT_EQ(collation.size(), 10);
    EXPECT_TRUE(boost::algorithm::equal(collation.begin(), collation.end(), ces, ces + 10))
        << "from:     " << ce_dumper(cps)
        << "expected: " << ce_dumper(ces)
        << "got:      " << ce_dumper(collation);
}

TEST(collation, non_ignorable_121_264)
{
    // 00DC 0334;	
    // (Ü) LATIN CAPITAL LETTER U WITH DIAERESIS	[1F1B | 0020 004A 002B | 0008 0002 0002 |]

    uint32_t cps[2] = { 0x00DC, 0x0334 };
    uint32_t const ces[10] = { 0x1F1B, 0x0000, 0x0020, 0x004A, 0x002B, 0x0000, 0x0008, 0x0002, 0x0002, 0x0000 };

    auto collation = collate_for_tests(
        cps, cps + 2, boost::text::variable_weighting::non_ignorable);

    EXPECT_EQ(collation.size(), 10);
    EXPECT_TRUE(boost::algorithm::equal(collation.begin(), collation.end(), ces, ces + 10))
        << "from:     " << ce_dumper(cps)
        << "expected: " << ce_dumper(ces)
        << "got:      " << ce_dumper(collation);
}

TEST(collation, non_ignorable_121_265)
{
    // 0075 0308 0301 0334;	
    // (ǘ) LATIN SMALL LETTER U, COMBINING DIAERESIS, COMBINING ACUTE ACCENT	[1F1B | 0020 004A 002B 0024 | 0002 0002 0002 0002 |]

    uint32_t cps[4] = { 0x0075, 0x0308, 0x0301, 0x0334 };
    uint32_t const ces[12] = { 0x1F1B, 0x0000, 0x0020, 0x004A, 0x002B, 0x0024, 0x0000, 0x0002, 0x0002, 0x0002, 0x0002, 0x0000 };

    auto collation = collate_for_tests(
        cps, cps + 4, boost::text::variable_weighting::non_ignorable);

    EXPECT_EQ(collation.size(), 12);
    EXPECT_TRUE(boost::algorithm::equal(collation.begin(), collation.end(), ces, ces + 12))
        << "from:     " << ce_dumper(cps)
        << "expected: " << ce_dumper(ces)
        << "got:      " << ce_dumper(collation);
}

TEST(collation, non_ignorable_121_266)
{
    // 0075 0308 0334 0301;	
    // (ü̴) LATIN SMALL LETTER U, COMBINING DIAERESIS, COMBINING TILDE OVERLAY	[1F1B | 0020 004A 002B 0024 | 0002 0002 0002 0002 |]

    uint32_t cps[4] = { 0x0075, 0x0308, 0x0334, 0x0301 };
    uint32_t const ces[12] = { 0x1F1B, 0x0000, 0x0020, 0x004A, 0x002B, 0x0024, 0x0000, 0x0002, 0x0002, 0x0002, 0x0002, 0x0000 };

    auto collation = collate_for_tests(
        cps, cps + 4, boost::text::variable_weighting::non_ignorable);

    EXPECT_EQ(collation.size(), 12);
    EXPECT_TRUE(boost::algorithm::equal(collation.begin(), collation.end(), ces, ces + 12))
        << "from:     " << ce_dumper(cps)
        << "expected: " << ce_dumper(ces)
        << "got:      " << ce_dumper(collation);
}

TEST(collation, non_ignorable_121_267)
{
    // 0075 0308 0334 0341;	
    // (ü̴) LATIN SMALL LETTER U, COMBINING DIAERESIS, COMBINING TILDE OVERLAY	[1F1B | 0020 004A 002B 0024 | 0002 0002 0002 0002 |]

    uint32_t cps[4] = { 0x0075, 0x0308, 0x0334, 0x0341 };
    uint32_t const ces[12] = { 0x1F1B, 0x0000, 0x0020, 0x004A, 0x002B, 0x0024, 0x0000, 0x0002, 0x0002, 0x0002, 0x0002, 0x0000 };

    auto collation = collate_for_tests(
        cps, cps + 4, boost::text::variable_weighting::non_ignorable);

    EXPECT_EQ(collation.size(), 12);
    EXPECT_TRUE(boost::algorithm::equal(collation.begin(), collation.end(), ces, ces + 12))
        << "from:     " << ce_dumper(cps)
        << "expected: " << ce_dumper(ces)
        << "got:      " << ce_dumper(collation);
}

TEST(collation, non_ignorable_121_268)
{
    // 0075 0308 0341 0334;	
    // (ǘ) LATIN SMALL LETTER U, COMBINING DIAERESIS, COMBINING ACUTE TONE MARK	[1F1B | 0020 004A 002B 0024 | 0002 0002 0002 0002 |]

    uint32_t cps[4] = { 0x0075, 0x0308, 0x0341, 0x0334 };
    uint32_t const ces[12] = { 0x1F1B, 0x0000, 0x0020, 0x004A, 0x002B, 0x0024, 0x0000, 0x0002, 0x0002, 0x0002, 0x0002, 0x0000 };

    auto collation = collate_for_tests(
        cps, cps + 4, boost::text::variable_weighting::non_ignorable);

    EXPECT_EQ(collation.size(), 12);
    EXPECT_TRUE(boost::algorithm::equal(collation.begin(), collation.end(), ces, ces + 12))
        << "from:     " << ce_dumper(cps)
        << "expected: " << ce_dumper(ces)
        << "got:      " << ce_dumper(collation);
}

TEST(collation, non_ignorable_121_269)
{
    // 0055 0334 0344;	
    // (U̴) LATIN CAPITAL LETTER U, COMBINING TILDE OVERLAY	[1F1B | 0020 004A 002B 0024 | 0008 0002 0002 0002 |]

    uint32_t cps[3] = { 0x0055, 0x0334, 0x0344 };
    uint32_t const ces[12] = { 0x1F1B, 0x0000, 0x0020, 0x004A, 0x002B, 0x0024, 0x0000, 0x0008, 0x0002, 0x0002, 0x0002, 0x0000 };

    auto collation = collate_for_tests(
        cps, cps + 3, boost::text::variable_weighting::non_ignorable);

    EXPECT_EQ(collation.size(), 12);
    EXPECT_TRUE(boost::algorithm::equal(collation.begin(), collation.end(), ces, ces + 12))
        << "from:     " << ce_dumper(cps)
        << "expected: " << ce_dumper(ces)
        << "got:      " << ce_dumper(collation);
}

TEST(collation, non_ignorable_121_270)
{
    // 0055 0344 0334;	
    // (Ǘ) LATIN CAPITAL LETTER U, COMBINING GREEK DIALYTIKA TONOS	[1F1B | 0020 004A 002B 0024 | 0008 0002 0002 0002 |]

    uint32_t cps[3] = { 0x0055, 0x0344, 0x0334 };
    uint32_t const ces[12] = { 0x1F1B, 0x0000, 0x0020, 0x004A, 0x002B, 0x0024, 0x0000, 0x0008, 0x0002, 0x0002, 0x0002, 0x0000 };

    auto collation = collate_for_tests(
        cps, cps + 3, boost::text::variable_weighting::non_ignorable);

    EXPECT_EQ(collation.size(), 12);
    EXPECT_TRUE(boost::algorithm::equal(collation.begin(), collation.end(), ces, ces + 12))
        << "from:     " << ce_dumper(cps)
        << "expected: " << ce_dumper(ces)
        << "got:      " << ce_dumper(collation);
}

TEST(collation, non_ignorable_121_271)
{
    // 00DC 0334 0301;	
    // (Ü̴) LATIN CAPITAL LETTER U WITH DIAERESIS, COMBINING TILDE OVERLAY	[1F1B | 0020 004A 002B 0024 | 0008 0002 0002 0002 |]

    uint32_t cps[3] = { 0x00DC, 0x0334, 0x0301 };
    uint32_t const ces[12] = { 0x1F1B, 0x0000, 0x0020, 0x004A, 0x002B, 0x0024, 0x0000, 0x0008, 0x0002, 0x0002, 0x0002, 0x0000 };

    auto collation = collate_for_tests(
        cps, cps + 3, boost::text::variable_weighting::non_ignorable);

    EXPECT_EQ(collation.size(), 12);
    EXPECT_TRUE(boost::algorithm::equal(collation.begin(), collation.end(), ces, ces + 12))
        << "from:     " << ce_dumper(cps)
        << "expected: " << ce_dumper(ces)
        << "got:      " << ce_dumper(collation);
}

TEST(collation, non_ignorable_121_272)
{
    // 00DC 0334 0341;	
    // (Ü̴) LATIN CAPITAL LETTER U WITH DIAERESIS, COMBINING TILDE OVERLAY	[1F1B | 0020 004A 002B 0024 | 0008 0002 0002 0002 |]

    uint32_t cps[3] = { 0x00DC, 0x0334, 0x0341 };
    uint32_t const ces[12] = { 0x1F1B, 0x0000, 0x0020, 0x004A, 0x002B, 0x0024, 0x0000, 0x0008, 0x0002, 0x0002, 0x0002, 0x0000 };

    auto collation = collate_for_tests(
        cps, cps + 3, boost::text::variable_weighting::non_ignorable);

    EXPECT_EQ(collation.size(), 12);
    EXPECT_TRUE(boost::algorithm::equal(collation.begin(), collation.end(), ces, ces + 12))
        << "from:     " << ce_dumper(cps)
        << "expected: " << ce_dumper(ces)
        << "got:      " << ce_dumper(collation);
}

TEST(collation, non_ignorable_121_273)
{
    // 0075 0334 0308 0300;	
    // (ü̴) LATIN SMALL LETTER U, COMBINING TILDE OVERLAY, COMBINING DIAERESIS	[1F1B | 0020 004A 002B 0025 | 0002 0002 0002 0002 |]

    uint32_t cps[4] = { 0x0075, 0x0334, 0x0308, 0x0300 };
    uint32_t const ces[12] = { 0x1F1B, 0x0000, 0x0020, 0x004A, 0x002B, 0x0025, 0x0000, 0x0002, 0x0002, 0x0002, 0x0002, 0x0000 };

    auto collation = collate_for_tests(
        cps, cps + 4, boost::text::variable_weighting::non_ignorable);

    EXPECT_EQ(collation.size(), 12);
    EXPECT_TRUE(boost::algorithm::equal(collation.begin(), collation.end(), ces, ces + 12))
        << "from:     " << ce_dumper(cps)
        << "expected: " << ce_dumper(ces)
        << "got:      " << ce_dumper(collation);
}

TEST(collation, non_ignorable_121_274)
{
    // 0075 0334 0308 0340;	
    // (ü̴) LATIN SMALL LETTER U, COMBINING TILDE OVERLAY, COMBINING DIAERESIS	[1F1B | 0020 004A 002B 0025 | 0002 0002 0002 0002 |]

    uint32_t cps[4] = { 0x0075, 0x0334, 0x0308, 0x0340 };
    uint32_t const ces[12] = { 0x1F1B, 0x0000, 0x0020, 0x004A, 0x002B, 0x0025, 0x0000, 0x0002, 0x0002, 0x0002, 0x0002, 0x0000 };

    auto collation = collate_for_tests(
        cps, cps + 4, boost::text::variable_weighting::non_ignorable);

    EXPECT_EQ(collation.size(), 12);
    EXPECT_TRUE(boost::algorithm::equal(collation.begin(), collation.end(), ces, ces + 12))
        << "from:     " << ce_dumper(cps)
        << "expected: " << ce_dumper(ces)
        << "got:      " << ce_dumper(collation);
}

TEST(collation, non_ignorable_121_275)
{
    // 00FC 0300 0334;	
    // (ǜ) LATIN SMALL LETTER U WITH DIAERESIS, COMBINING GRAVE ACCENT	[1F1B | 0020 004A 002B 0025 | 0002 0002 0002 0002 |]

    uint32_t cps[3] = { 0x00FC, 0x0300, 0x0334 };
    uint32_t const ces[12] = { 0x1F1B, 0x0000, 0x0020, 0x004A, 0x002B, 0x0025, 0x0000, 0x0002, 0x0002, 0x0002, 0x0002, 0x0000 };

    auto collation = collate_for_tests(
        cps, cps + 3, boost::text::variable_weighting::non_ignorable);

    EXPECT_EQ(collation.size(), 12);
    EXPECT_TRUE(boost::algorithm::equal(collation.begin(), collation.end(), ces, ces + 12))
        << "from:     " << ce_dumper(cps)
        << "expected: " << ce_dumper(ces)
        << "got:      " << ce_dumper(collation);
}

TEST(collation, non_ignorable_121_276)
{
    // 00FC 0340 0334;	
    // (ǜ) LATIN SMALL LETTER U WITH DIAERESIS, COMBINING GRAVE TONE MARK	[1F1B | 0020 004A 002B 0025 | 0002 0002 0002 0002 |]

    uint32_t cps[3] = { 0x00FC, 0x0340, 0x0334 };
    uint32_t const ces[12] = { 0x1F1B, 0x0000, 0x0020, 0x004A, 0x002B, 0x0025, 0x0000, 0x0002, 0x0002, 0x0002, 0x0002, 0x0000 };

    auto collation = collate_for_tests(
        cps, cps + 3, boost::text::variable_weighting::non_ignorable);

    EXPECT_EQ(collation.size(), 12);
    EXPECT_TRUE(boost::algorithm::equal(collation.begin(), collation.end(), ces, ces + 12))
        << "from:     " << ce_dumper(cps)
        << "expected: " << ce_dumper(ces)
        << "got:      " << ce_dumper(collation);
}

TEST(collation, non_ignorable_121_277)
{
    // 0055 0334 0308 0300;	
    // (Ü̴) LATIN CAPITAL LETTER U, COMBINING TILDE OVERLAY, COMBINING DIAERESIS	[1F1B | 0020 004A 002B 0025 | 0008 0002 0002 0002 |]

    uint32_t cps[4] = { 0x0055, 0x0334, 0x0308, 0x0300 };
    uint32_t const ces[12] = { 0x1F1B, 0x0000, 0x0020, 0x004A, 0x002B, 0x0025, 0x0000, 0x0008, 0x0002, 0x0002, 0x0002, 0x0000 };

    auto collation = collate_for_tests(
        cps, cps + 4, boost::text::variable_weighting::non_ignorable);

    EXPECT_EQ(collation.size(), 12);
    EXPECT_TRUE(boost::algorithm::equal(collation.begin(), collation.end(), ces, ces + 12))
        << "from:     " << ce_dumper(cps)
        << "expected: " << ce_dumper(ces)
        << "got:      " << ce_dumper(collation);
}

TEST(collation, non_ignorable_121_278)
{
    // 0055 0334 0308 0340;	
    // (Ü̴) LATIN CAPITAL LETTER U, COMBINING TILDE OVERLAY, COMBINING DIAERESIS	[1F1B | 0020 004A 002B 0025 | 0008 0002 0002 0002 |]

    uint32_t cps[4] = { 0x0055, 0x0334, 0x0308, 0x0340 };
    uint32_t const ces[12] = { 0x1F1B, 0x0000, 0x0020, 0x004A, 0x002B, 0x0025, 0x0000, 0x0008, 0x0002, 0x0002, 0x0002, 0x0000 };

    auto collation = collate_for_tests(
        cps, cps + 4, boost::text::variable_weighting::non_ignorable);

    EXPECT_EQ(collation.size(), 12);
    EXPECT_TRUE(boost::algorithm::equal(collation.begin(), collation.end(), ces, ces + 12))
        << "from:     " << ce_dumper(cps)
        << "expected: " << ce_dumper(ces)
        << "got:      " << ce_dumper(collation);
}

TEST(collation, non_ignorable_121_279)
{
    // 00DC 0300 0334;	
    // (Ǜ) LATIN CAPITAL LETTER U WITH DIAERESIS, COMBINING GRAVE ACCENT	[1F1B | 0020 004A 002B 0025 | 0008 0002 0002 0002 |]

    uint32_t cps[3] = { 0x00DC, 0x0300, 0x0334 };
    uint32_t const ces[12] = { 0x1F1B, 0x0000, 0x0020, 0x004A, 0x002B, 0x0025, 0x0000, 0x0008, 0x0002, 0x0002, 0x0002, 0x0000 };

    auto collation = collate_for_tests(
        cps, cps + 3, boost::text::variable_weighting::non_ignorable);

    EXPECT_EQ(collation.size(), 12);
    EXPECT_TRUE(boost::algorithm::equal(collation.begin(), collation.end(), ces, ces + 12))
        << "from:     " << ce_dumper(cps)
        << "expected: " << ce_dumper(ces)
        << "got:      " << ce_dumper(collation);
}

TEST(collation, non_ignorable_121_280)
{
    // 00DC 0340 0334;	
    // (Ǜ) LATIN CAPITAL LETTER U WITH DIAERESIS, COMBINING GRAVE TONE MARK	[1F1B | 0020 004A 002B 0025 | 0008 0002 0002 0002 |]

    uint32_t cps[3] = { 0x00DC, 0x0340, 0x0334 };
    uint32_t const ces[12] = { 0x1F1B, 0x0000, 0x0020, 0x004A, 0x002B, 0x0025, 0x0000, 0x0008, 0x0002, 0x0002, 0x0002, 0x0000 };

    auto collation = collate_for_tests(
        cps, cps + 3, boost::text::variable_weighting::non_ignorable);

    EXPECT_EQ(collation.size(), 12);
    EXPECT_TRUE(boost::algorithm::equal(collation.begin(), collation.end(), ces, ces + 12))
        << "from:     " << ce_dumper(cps)
        << "expected: " << ce_dumper(ces)
        << "got:      " << ce_dumper(collation);
}

TEST(collation, non_ignorable_121_281)
{
    // 0075 0334 0308 030C;	
    // (ü̴) LATIN SMALL LETTER U, COMBINING TILDE OVERLAY, COMBINING DIAERESIS	[1F1B | 0020 004A 002B 0028 | 0002 0002 0002 0002 |]

    uint32_t cps[4] = { 0x0075, 0x0334, 0x0308, 0x030C };
    uint32_t const ces[12] = { 0x1F1B, 0x0000, 0x0020, 0x004A, 0x002B, 0x0028, 0x0000, 0x0002, 0x0002, 0x0002, 0x0002, 0x0000 };

    auto collation = collate_for_tests(
        cps, cps + 4, boost::text::variable_weighting::non_ignorable);

    EXPECT_EQ(collation.size(), 12);
    EXPECT_TRUE(boost::algorithm::equal(collation.begin(), collation.end(), ces, ces + 12))
        << "from:     " << ce_dumper(cps)
        << "expected: " << ce_dumper(ces)
        << "got:      " << ce_dumper(collation);
}

TEST(collation, non_ignorable_121_282)
{
    // 00FC 030C 0334;	
    // (ǚ) LATIN SMALL LETTER U WITH DIAERESIS, COMBINING CARON	[1F1B | 0020 004A 002B 0028 | 0002 0002 0002 0002 |]

    uint32_t cps[3] = { 0x00FC, 0x030C, 0x0334 };
    uint32_t const ces[12] = { 0x1F1B, 0x0000, 0x0020, 0x004A, 0x002B, 0x0028, 0x0000, 0x0002, 0x0002, 0x0002, 0x0002, 0x0000 };

    auto collation = collate_for_tests(
        cps, cps + 3, boost::text::variable_weighting::non_ignorable);

    EXPECT_EQ(collation.size(), 12);
    EXPECT_TRUE(boost::algorithm::equal(collation.begin(), collation.end(), ces, ces + 12))
        << "from:     " << ce_dumper(cps)
        << "expected: " << ce_dumper(ces)
        << "got:      " << ce_dumper(collation);
}

TEST(collation, non_ignorable_121_283)
{
    // 00FC 0334 030C;	
    // (ü̴) LATIN SMALL LETTER U WITH DIAERESIS, COMBINING TILDE OVERLAY	[1F1B | 0020 004A 002B 0028 | 0002 0002 0002 0002 |]

    uint32_t cps[3] = { 0x00FC, 0x0334, 0x030C };
    uint32_t const ces[12] = { 0x1F1B, 0x0000, 0x0020, 0x004A, 0x002B, 0x0028, 0x0000, 0x0002, 0x0002, 0x0002, 0x0002, 0x0000 };

    auto collation = collate_for_tests(
        cps, cps + 3, boost::text::variable_weighting::non_ignorable);

    EXPECT_EQ(collation.size(), 12);
    EXPECT_TRUE(boost::algorithm::equal(collation.begin(), collation.end(), ces, ces + 12))
        << "from:     " << ce_dumper(cps)
        << "expected: " << ce_dumper(ces)
        << "got:      " << ce_dumper(collation);
}

TEST(collation, non_ignorable_121_284)
{
    // 01DA 0334;	
    // (ǚ) LATIN SMALL LETTER U WITH DIAERESIS AND CARON	[1F1B | 0020 004A 002B 0028 | 0002 0002 0002 0002 |]

    uint32_t cps[2] = { 0x01DA, 0x0334 };
    uint32_t const ces[12] = { 0x1F1B, 0x0000, 0x0020, 0x004A, 0x002B, 0x0028, 0x0000, 0x0002, 0x0002, 0x0002, 0x0002, 0x0000 };

    auto collation = collate_for_tests(
        cps, cps + 2, boost::text::variable_weighting::non_ignorable);

    EXPECT_EQ(collation.size(), 12);
    EXPECT_TRUE(boost::algorithm::equal(collation.begin(), collation.end(), ces, ces + 12))
        << "from:     " << ce_dumper(cps)
        << "expected: " << ce_dumper(ces)
        << "got:      " << ce_dumper(collation);
}

TEST(collation, non_ignorable_121_285)
{
    // 0055 0308 030C 0334;	
    // (Ǚ) LATIN CAPITAL LETTER U, COMBINING DIAERESIS, COMBINING CARON	[1F1B | 0020 004A 002B 0028 | 0008 0002 0002 0002 |]

    uint32_t cps[4] = { 0x0055, 0x0308, 0x030C, 0x0334 };
    uint32_t const ces[12] = { 0x1F1B, 0x0000, 0x0020, 0x004A, 0x002B, 0x0028, 0x0000, 0x0008, 0x0002, 0x0002, 0x0002, 0x0000 };

    auto collation = collate_for_tests(
        cps, cps + 4, boost::text::variable_weighting::non_ignorable);

    EXPECT_EQ(collation.size(), 12);
    EXPECT_TRUE(boost::algorithm::equal(collation.begin(), collation.end(), ces, ces + 12))
        << "from:     " << ce_dumper(cps)
        << "expected: " << ce_dumper(ces)
        << "got:      " << ce_dumper(collation);
}

TEST(collation, non_ignorable_121_286)
{
    // 0055 0334 0308 030C;	
    // (Ü̴) LATIN CAPITAL LETTER U, COMBINING TILDE OVERLAY, COMBINING DIAERESIS	[1F1B | 0020 004A 002B 0028 | 0008 0002 0002 0002 |]

    uint32_t cps[4] = { 0x0055, 0x0334, 0x0308, 0x030C };
    uint32_t const ces[12] = { 0x1F1B, 0x0000, 0x0020, 0x004A, 0x002B, 0x0028, 0x0000, 0x0008, 0x0002, 0x0002, 0x0002, 0x0000 };

    auto collation = collate_for_tests(
        cps, cps + 4, boost::text::variable_weighting::non_ignorable);

    EXPECT_EQ(collation.size(), 12);
    EXPECT_TRUE(boost::algorithm::equal(collation.begin(), collation.end(), ces, ces + 12))
        << "from:     " << ce_dumper(cps)
        << "expected: " << ce_dumper(ces)
        << "got:      " << ce_dumper(collation);
}

TEST(collation, non_ignorable_121_287)
{
    // 00DC 030C 0334;	
    // (Ǚ) LATIN CAPITAL LETTER U WITH DIAERESIS, COMBINING CARON	[1F1B | 0020 004A 002B 0028 | 0008 0002 0002 0002 |]

    uint32_t cps[3] = { 0x00DC, 0x030C, 0x0334 };
    uint32_t const ces[12] = { 0x1F1B, 0x0000, 0x0020, 0x004A, 0x002B, 0x0028, 0x0000, 0x0008, 0x0002, 0x0002, 0x0002, 0x0000 };

    auto collation = collate_for_tests(
        cps, cps + 3, boost::text::variable_weighting::non_ignorable);

    EXPECT_EQ(collation.size(), 12);
    EXPECT_TRUE(boost::algorithm::equal(collation.begin(), collation.end(), ces, ces + 12))
        << "from:     " << ce_dumper(cps)
        << "expected: " << ce_dumper(ces)
        << "got:      " << ce_dumper(collation);
}

TEST(collation, non_ignorable_121_288)
{
    // 00DC 0334 030C;	
    // (Ü̴) LATIN CAPITAL LETTER U WITH DIAERESIS, COMBINING TILDE OVERLAY	[1F1B | 0020 004A 002B 0028 | 0008 0002 0002 0002 |]

    uint32_t cps[3] = { 0x00DC, 0x0334, 0x030C };
    uint32_t const ces[12] = { 0x1F1B, 0x0000, 0x0020, 0x004A, 0x002B, 0x0028, 0x0000, 0x0008, 0x0002, 0x0002, 0x0002, 0x0000 };

    auto collation = collate_for_tests(
        cps, cps + 3, boost::text::variable_weighting::non_ignorable);

    EXPECT_EQ(collation.size(), 12);
    EXPECT_TRUE(boost::algorithm::equal(collation.begin(), collation.end(), ces, ces + 12))
        << "from:     " << ce_dumper(cps)
        << "expected: " << ce_dumper(ces)
        << "got:      " << ce_dumper(collation);
}

TEST(collation, non_ignorable_121_289)
{
    // 0075 0308 0304 0334;	
    // (ǖ) LATIN SMALL LETTER U, COMBINING DIAERESIS, COMBINING MACRON	[1F1B | 0020 004A 002B 0032 | 0002 0002 0002 0002 |]

    uint32_t cps[4] = { 0x0075, 0x0308, 0x0304, 0x0334 };
    uint32_t const ces[12] = { 0x1F1B, 0x0000, 0x0020, 0x004A, 0x002B, 0x0032, 0x0000, 0x0002, 0x0002, 0x0002, 0x0002, 0x0000 };

    auto collation = collate_for_tests(
        cps, cps + 4, boost::text::variable_weighting::non_ignorable);

    EXPECT_EQ(collation.size(), 12);
    EXPECT_TRUE(boost::algorithm::equal(collation.begin(), collation.end(), ces, ces + 12))
        << "from:     " << ce_dumper(cps)
        << "expected: " << ce_dumper(ces)
        << "got:      " << ce_dumper(collation);
}

TEST(collation, non_ignorable_121_290)
{
    // 0075 0308 0334 0304;	
    // (ü̴) LATIN SMALL LETTER U, COMBINING DIAERESIS, COMBINING TILDE OVERLAY	[1F1B | 0020 004A 002B 0032 | 0002 0002 0002 0002 |]

    uint32_t cps[4] = { 0x0075, 0x0308, 0x0334, 0x0304 };
    uint32_t const ces[12] = { 0x1F1B, 0x0000, 0x0020, 0x004A, 0x002B, 0x0032, 0x0000, 0x0002, 0x0002, 0x0002, 0x0002, 0x0000 };

    auto collation = collate_for_tests(
        cps, cps + 4, boost::text::variable_weighting::non_ignorable);

    EXPECT_EQ(collation.size(), 12);
    EXPECT_TRUE(boost::algorithm::equal(collation.begin(), collation.end(), ces, ces + 12))
        << "from:     " << ce_dumper(cps)
        << "expected: " << ce_dumper(ces)
        << "got:      " << ce_dumper(collation);
}

TEST(collation, non_ignorable_121_291)
{
    // 00FC 0304 0334;	
    // (ǖ) LATIN SMALL LETTER U WITH DIAERESIS, COMBINING MACRON	[1F1B | 0020 004A 002B 0032 | 0002 0002 0002 0002 |]

    uint32_t cps[3] = { 0x00FC, 0x0304, 0x0334 };
    uint32_t const ces[12] = { 0x1F1B, 0x0000, 0x0020, 0x004A, 0x002B, 0x0032, 0x0000, 0x0002, 0x0002, 0x0002, 0x0002, 0x0000 };

    auto collation = collate_for_tests(
        cps, cps + 3, boost::text::variable_weighting::non_ignorable);

    EXPECT_EQ(collation.size(), 12);
    EXPECT_TRUE(boost::algorithm::equal(collation.begin(), collation.end(), ces, ces + 12))
        << "from:     " << ce_dumper(cps)
        << "expected: " << ce_dumper(ces)
        << "got:      " << ce_dumper(collation);
}

TEST(collation, non_ignorable_121_292)
{
    // 00FC 0334 0304;	
    // (ü̴) LATIN SMALL LETTER U WITH DIAERESIS, COMBINING TILDE OVERLAY	[1F1B | 0020 004A 002B 0032 | 0002 0002 0002 0002 |]

    uint32_t cps[3] = { 0x00FC, 0x0334, 0x0304 };
    uint32_t const ces[12] = { 0x1F1B, 0x0000, 0x0020, 0x004A, 0x002B, 0x0032, 0x0000, 0x0002, 0x0002, 0x0002, 0x0002, 0x0000 };

    auto collation = collate_for_tests(
        cps, cps + 3, boost::text::variable_weighting::non_ignorable);

    EXPECT_EQ(collation.size(), 12);
    EXPECT_TRUE(boost::algorithm::equal(collation.begin(), collation.end(), ces, ces + 12))
        << "from:     " << ce_dumper(cps)
        << "expected: " << ce_dumper(ces)
        << "got:      " << ce_dumper(collation);
}

TEST(collation, non_ignorable_121_293)
{
    // 0055 0308 0304 0334;	
    // (Ǖ) LATIN CAPITAL LETTER U, COMBINING DIAERESIS, COMBINING MACRON	[1F1B | 0020 004A 002B 0032 | 0008 0002 0002 0002 |]

    uint32_t cps[4] = { 0x0055, 0x0308, 0x0304, 0x0334 };
    uint32_t const ces[12] = { 0x1F1B, 0x0000, 0x0020, 0x004A, 0x002B, 0x0032, 0x0000, 0x0008, 0x0002, 0x0002, 0x0002, 0x0000 };

    auto collation = collate_for_tests(
        cps, cps + 4, boost::text::variable_weighting::non_ignorable);

    EXPECT_EQ(collation.size(), 12);
    EXPECT_TRUE(boost::algorithm::equal(collation.begin(), collation.end(), ces, ces + 12))
        << "from:     " << ce_dumper(cps)
        << "expected: " << ce_dumper(ces)
        << "got:      " << ce_dumper(collation);
}

TEST(collation, non_ignorable_121_294)
{
    // 0055 0308 0334 0304;	
    // (Ü̴) LATIN CAPITAL LETTER U, COMBINING DIAERESIS, COMBINING TILDE OVERLAY	[1F1B | 0020 004A 002B 0032 | 0008 0002 0002 0002 |]

    uint32_t cps[4] = { 0x0055, 0x0308, 0x0334, 0x0304 };
    uint32_t const ces[12] = { 0x1F1B, 0x0000, 0x0020, 0x004A, 0x002B, 0x0032, 0x0000, 0x0008, 0x0002, 0x0002, 0x0002, 0x0000 };

    auto collation = collate_for_tests(
        cps, cps + 4, boost::text::variable_weighting::non_ignorable);

    EXPECT_EQ(collation.size(), 12);
    EXPECT_TRUE(boost::algorithm::equal(collation.begin(), collation.end(), ces, ces + 12))
        << "from:     " << ce_dumper(cps)
        << "expected: " << ce_dumper(ces)
        << "got:      " << ce_dumper(collation);
}

TEST(collation, non_ignorable_121_295)
{
    // 0055 0334 0308 0304;	
    // (Ü̴) LATIN CAPITAL LETTER U, COMBINING TILDE OVERLAY, COMBINING DIAERESIS	[1F1B | 0020 004A 002B 0032 | 0008 0002 0002 0002 |]

    uint32_t cps[4] = { 0x0055, 0x0334, 0x0308, 0x0304 };
    uint32_t const ces[12] = { 0x1F1B, 0x0000, 0x0020, 0x004A, 0x002B, 0x0032, 0x0000, 0x0008, 0x0002, 0x0002, 0x0002, 0x0000 };

    auto collation = collate_for_tests(
        cps, cps + 4, boost::text::variable_weighting::non_ignorable);

    EXPECT_EQ(collation.size(), 12);
    EXPECT_TRUE(boost::algorithm::equal(collation.begin(), collation.end(), ces, ces + 12))
        << "from:     " << ce_dumper(cps)
        << "expected: " << ce_dumper(ces)
        << "got:      " << ce_dumper(collation);
}

TEST(collation, non_ignorable_121_296)
{
    // 00DC 0334 0304;	
    // (Ü̴) LATIN CAPITAL LETTER U WITH DIAERESIS, COMBINING TILDE OVERLAY	[1F1B | 0020 004A 002B 0032 | 0008 0002 0002 0002 |]

    uint32_t cps[3] = { 0x00DC, 0x0334, 0x0304 };
    uint32_t const ces[12] = { 0x1F1B, 0x0000, 0x0020, 0x004A, 0x002B, 0x0032, 0x0000, 0x0008, 0x0002, 0x0002, 0x0002, 0x0000 };

    auto collation = collate_for_tests(
        cps, cps + 3, boost::text::variable_weighting::non_ignorable);

    EXPECT_EQ(collation.size(), 12);
    EXPECT_TRUE(boost::algorithm::equal(collation.begin(), collation.end(), ces, ces + 12))
        << "from:     " << ce_dumper(cps)
        << "expected: " << ce_dumper(ces)
        << "got:      " << ce_dumper(collation);
}

TEST(collation, non_ignorable_121_297)
{
    // 0075 030B 0334;	
    // (ű) LATIN SMALL LETTER U, COMBINING DOUBLE ACUTE ACCENT	[1F1B | 0020 004A 002C | 0002 0002 0002 |]

    uint32_t cps[3] = { 0x0075, 0x030B, 0x0334 };
    uint32_t const ces[10] = { 0x1F1B, 0x0000, 0x0020, 0x004A, 0x002C, 0x0000, 0x0002, 0x0002, 0x0002, 0x0000 };

    auto collation = collate_for_tests(
        cps, cps + 3, boost::text::variable_weighting::non_ignorable);

    EXPECT_EQ(collation.size(), 10);
    EXPECT_TRUE(boost::algorithm::equal(collation.begin(), collation.end(), ces, ces + 10))
        << "from:     " << ce_dumper(cps)
        << "expected: " << ce_dumper(ces)
        << "got:      " << ce_dumper(collation);
}

TEST(collation, non_ignorable_121_298)
{
    // 0075 0334 030B;	
    // (u̴) LATIN SMALL LETTER U, COMBINING TILDE OVERLAY	[1F1B | 0020 004A 002C | 0002 0002 0002 |]

    uint32_t cps[3] = { 0x0075, 0x0334, 0x030B };
    uint32_t const ces[10] = { 0x1F1B, 0x0000, 0x0020, 0x004A, 0x002C, 0x0000, 0x0002, 0x0002, 0x0002, 0x0000 };

    auto collation = collate_for_tests(
        cps, cps + 3, boost::text::variable_weighting::non_ignorable);

    EXPECT_EQ(collation.size(), 10);
    EXPECT_TRUE(boost::algorithm::equal(collation.begin(), collation.end(), ces, ces + 10))
        << "from:     " << ce_dumper(cps)
        << "expected: " << ce_dumper(ces)
        << "got:      " << ce_dumper(collation);
}

TEST(collation, non_ignorable_121_299)
{
    // 0171 0334;	
    // (ű) LATIN SMALL LETTER U WITH DOUBLE ACUTE	[1F1B | 0020 004A 002C | 0002 0002 0002 |]

    uint32_t cps[2] = { 0x0171, 0x0334 };
    uint32_t const ces[10] = { 0x1F1B, 0x0000, 0x0020, 0x004A, 0x002C, 0x0000, 0x0002, 0x0002, 0x0002, 0x0000 };

    auto collation = collate_for_tests(
        cps, cps + 2, boost::text::variable_weighting::non_ignorable);

    EXPECT_EQ(collation.size(), 10);
    EXPECT_TRUE(boost::algorithm::equal(collation.begin(), collation.end(), ces, ces + 10))
        << "from:     " << ce_dumper(cps)
        << "expected: " << ce_dumper(ces)
        << "got:      " << ce_dumper(collation);
}

TEST(collation, non_ignorable_121_300)
{
    // 0055 030B 0334;	
    // (Ű) LATIN CAPITAL LETTER U, COMBINING DOUBLE ACUTE ACCENT	[1F1B | 0020 004A 002C | 0008 0002 0002 |]

    uint32_t cps[3] = { 0x0055, 0x030B, 0x0334 };
    uint32_t const ces[10] = { 0x1F1B, 0x0000, 0x0020, 0x004A, 0x002C, 0x0000, 0x0008, 0x0002, 0x0002, 0x0000 };

    auto collation = collate_for_tests(
        cps, cps + 3, boost::text::variable_weighting::non_ignorable);

    EXPECT_EQ(collation.size(), 10);
    EXPECT_TRUE(boost::algorithm::equal(collation.begin(), collation.end(), ces, ces + 10))
        << "from:     " << ce_dumper(cps)
        << "expected: " << ce_dumper(ces)
        << "got:      " << ce_dumper(collation);
}

TEST(collation, non_ignorable_121_301)
{
    // 0055 0334 030B;	
    // (U̴) LATIN CAPITAL LETTER U, COMBINING TILDE OVERLAY	[1F1B | 0020 004A 002C | 0008 0002 0002 |]

    uint32_t cps[3] = { 0x0055, 0x0334, 0x030B };
    uint32_t const ces[10] = { 0x1F1B, 0x0000, 0x0020, 0x004A, 0x002C, 0x0000, 0x0008, 0x0002, 0x0002, 0x0000 };

    auto collation = collate_for_tests(
        cps, cps + 3, boost::text::variable_weighting::non_ignorable);

    EXPECT_EQ(collation.size(), 10);
    EXPECT_TRUE(boost::algorithm::equal(collation.begin(), collation.end(), ces, ces + 10))
        << "from:     " << ce_dumper(cps)
        << "expected: " << ce_dumper(ces)
        << "got:      " << ce_dumper(collation);
}

TEST(collation, non_ignorable_121_302)
{
    // 0170 0334;	
    // (Ű) LATIN CAPITAL LETTER U WITH DOUBLE ACUTE	[1F1B | 0020 004A 002C | 0008 0002 0002 |]

    uint32_t cps[2] = { 0x0170, 0x0334 };
    uint32_t const ces[10] = { 0x1F1B, 0x0000, 0x0020, 0x004A, 0x002C, 0x0000, 0x0008, 0x0002, 0x0002, 0x0000 };

    auto collation = collate_for_tests(
        cps, cps + 2, boost::text::variable_weighting::non_ignorable);

    EXPECT_EQ(collation.size(), 10);
    EXPECT_TRUE(boost::algorithm::equal(collation.begin(), collation.end(), ces, ces + 10))
        << "from:     " << ce_dumper(cps)
        << "expected: " << ce_dumper(ces)
        << "got:      " << ce_dumper(collation);
}

TEST(collation, non_ignorable_121_303)
{
    // 0075 0303 0334;	
    // (ũ) LATIN SMALL LETTER U, COMBINING TILDE	[1F1B | 0020 004A 002D | 0002 0002 0002 |]

    uint32_t cps[3] = { 0x0075, 0x0303, 0x0334 };
    uint32_t const ces[10] = { 0x1F1B, 0x0000, 0x0020, 0x004A, 0x002D, 0x0000, 0x0002, 0x0002, 0x0002, 0x0000 };

    auto collation = collate_for_tests(
        cps, cps + 3, boost::text::variable_weighting::non_ignorable);

    EXPECT_EQ(collation.size(), 10);
    EXPECT_TRUE(boost::algorithm::equal(collation.begin(), collation.end(), ces, ces + 10))
        << "from:     " << ce_dumper(cps)
        << "expected: " << ce_dumper(ces)
        << "got:      " << ce_dumper(collation);
}

TEST(collation, non_ignorable_121_304)
{
    // 0075 0334 0303;	
    // (u̴) LATIN SMALL LETTER U, COMBINING TILDE OVERLAY	[1F1B | 0020 004A 002D | 0002 0002 0002 |]

    uint32_t cps[3] = { 0x0075, 0x0334, 0x0303 };
    uint32_t const ces[10] = { 0x1F1B, 0x0000, 0x0020, 0x004A, 0x002D, 0x0000, 0x0002, 0x0002, 0x0002, 0x0000 };

    auto collation = collate_for_tests(
        cps, cps + 3, boost::text::variable_weighting::non_ignorable);

    EXPECT_EQ(collation.size(), 10);
    EXPECT_TRUE(boost::algorithm::equal(collation.begin(), collation.end(), ces, ces + 10))
        << "from:     " << ce_dumper(cps)
        << "expected: " << ce_dumper(ces)
        << "got:      " << ce_dumper(collation);
}

TEST(collation, non_ignorable_121_305)
{
    // 0169 0334;	
    // (ũ) LATIN SMALL LETTER U WITH TILDE	[1F1B | 0020 004A 002D | 0002 0002 0002 |]

    uint32_t cps[2] = { 0x0169, 0x0334 };
    uint32_t const ces[10] = { 0x1F1B, 0x0000, 0x0020, 0x004A, 0x002D, 0x0000, 0x0002, 0x0002, 0x0002, 0x0000 };

    auto collation = collate_for_tests(
        cps, cps + 2, boost::text::variable_weighting::non_ignorable);

    EXPECT_EQ(collation.size(), 10);
    EXPECT_TRUE(boost::algorithm::equal(collation.begin(), collation.end(), ces, ces + 10))
        << "from:     " << ce_dumper(cps)
        << "expected: " << ce_dumper(ces)
        << "got:      " << ce_dumper(collation);
}

TEST(collation, non_ignorable_121_306)
{
    // 0055 0303 0334;	
    // (Ũ) LATIN CAPITAL LETTER U, COMBINING TILDE	[1F1B | 0020 004A 002D | 0008 0002 0002 |]

    uint32_t cps[3] = { 0x0055, 0x0303, 0x0334 };
    uint32_t const ces[10] = { 0x1F1B, 0x0000, 0x0020, 0x004A, 0x002D, 0x0000, 0x0008, 0x0002, 0x0002, 0x0000 };

    auto collation = collate_for_tests(
        cps, cps + 3, boost::text::variable_weighting::non_ignorable);

    EXPECT_EQ(collation.size(), 10);
    EXPECT_TRUE(boost::algorithm::equal(collation.begin(), collation.end(), ces, ces + 10))
        << "from:     " << ce_dumper(cps)
        << "expected: " << ce_dumper(ces)
        << "got:      " << ce_dumper(collation);
}

TEST(collation, non_ignorable_121_307)
{
    // 0055 0334 0303;	
    // (U̴) LATIN CAPITAL LETTER U, COMBINING TILDE OVERLAY	[1F1B | 0020 004A 002D | 0008 0002 0002 |]

    uint32_t cps[3] = { 0x0055, 0x0334, 0x0303 };
    uint32_t const ces[10] = { 0x1F1B, 0x0000, 0x0020, 0x004A, 0x002D, 0x0000, 0x0008, 0x0002, 0x0002, 0x0000 };

    auto collation = collate_for_tests(
        cps, cps + 3, boost::text::variable_weighting::non_ignorable);

    EXPECT_EQ(collation.size(), 10);
    EXPECT_TRUE(boost::algorithm::equal(collation.begin(), collation.end(), ces, ces + 10))
        << "from:     " << ce_dumper(cps)
        << "expected: " << ce_dumper(ces)
        << "got:      " << ce_dumper(collation);
}

TEST(collation, non_ignorable_121_308)
{
    // 0168 0334;	
    // (Ũ) LATIN CAPITAL LETTER U WITH TILDE	[1F1B | 0020 004A 002D | 0008 0002 0002 |]

    uint32_t cps[2] = { 0x0168, 0x0334 };
    uint32_t const ces[10] = { 0x1F1B, 0x0000, 0x0020, 0x004A, 0x002D, 0x0000, 0x0008, 0x0002, 0x0002, 0x0000 };

    auto collation = collate_for_tests(
        cps, cps + 2, boost::text::variable_weighting::non_ignorable);

    EXPECT_EQ(collation.size(), 10);
    EXPECT_TRUE(boost::algorithm::equal(collation.begin(), collation.end(), ces, ces + 10))
        << "from:     " << ce_dumper(cps)
        << "expected: " << ce_dumper(ces)
        << "got:      " << ce_dumper(collation);
}

TEST(collation, non_ignorable_121_309)
{
    // 0075 0303 0301 0334;	
    // (ṹ) LATIN SMALL LETTER U, COMBINING TILDE, COMBINING ACUTE ACCENT	[1F1B | 0020 004A 002D 0024 | 0002 0002 0002 0002 |]

    uint32_t cps[4] = { 0x0075, 0x0303, 0x0301, 0x0334 };
    uint32_t const ces[12] = { 0x1F1B, 0x0000, 0x0020, 0x004A, 0x002D, 0x0024, 0x0000, 0x0002, 0x0002, 0x0002, 0x0002, 0x0000 };

    auto collation = collate_for_tests(
        cps, cps + 4, boost::text::variable_weighting::non_ignorable);

    EXPECT_EQ(collation.size(), 12);
    EXPECT_TRUE(boost::algorithm::equal(collation.begin(), collation.end(), ces, ces + 12))
        << "from:     " << ce_dumper(cps)
        << "expected: " << ce_dumper(ces)
        << "got:      " << ce_dumper(collation);
}

TEST(collation, non_ignorable_121_310)
{
    // 0075 0303 0341 0334;	
    // (ṹ) LATIN SMALL LETTER U, COMBINING TILDE, COMBINING ACUTE TONE MARK	[1F1B | 0020 004A 002D 0024 | 0002 0002 0002 0002 |]

    uint32_t cps[4] = { 0x0075, 0x0303, 0x0341, 0x0334 };
    uint32_t const ces[12] = { 0x1F1B, 0x0000, 0x0020, 0x004A, 0x002D, 0x0024, 0x0000, 0x0002, 0x0002, 0x0002, 0x0002, 0x0000 };

    auto collation = collate_for_tests(
        cps, cps + 4, boost::text::variable_weighting::non_ignorable);

    EXPECT_EQ(collation.size(), 12);
    EXPECT_TRUE(boost::algorithm::equal(collation.begin(), collation.end(), ces, ces + 12))
        << "from:     " << ce_dumper(cps)
        << "expected: " << ce_dumper(ces)
        << "got:      " << ce_dumper(collation);
}

TEST(collation, non_ignorable_121_311)
{
    // 0169 0334 0301;	
    // (ũ̴) LATIN SMALL LETTER U WITH TILDE, COMBINING TILDE OVERLAY	[1F1B | 0020 004A 002D 0024 | 0002 0002 0002 0002 |]

    uint32_t cps[3] = { 0x0169, 0x0334, 0x0301 };
    uint32_t const ces[12] = { 0x1F1B, 0x0000, 0x0020, 0x004A, 0x002D, 0x0024, 0x0000, 0x0002, 0x0002, 0x0002, 0x0002, 0x0000 };

    auto collation = collate_for_tests(
        cps, cps + 3, boost::text::variable_weighting::non_ignorable);

    EXPECT_EQ(collation.size(), 12);
    EXPECT_TRUE(boost::algorithm::equal(collation.begin(), collation.end(), ces, ces + 12))
        << "from:     " << ce_dumper(cps)
        << "expected: " << ce_dumper(ces)
        << "got:      " << ce_dumper(collation);
}

TEST(collation, non_ignorable_121_312)
{
    // 0169 0334 0341;	
    // (ũ̴) LATIN SMALL LETTER U WITH TILDE, COMBINING TILDE OVERLAY	[1F1B | 0020 004A 002D 0024 | 0002 0002 0002 0002 |]

    uint32_t cps[3] = { 0x0169, 0x0334, 0x0341 };
    uint32_t const ces[12] = { 0x1F1B, 0x0000, 0x0020, 0x004A, 0x002D, 0x0024, 0x0000, 0x0002, 0x0002, 0x0002, 0x0002, 0x0000 };

    auto collation = collate_for_tests(
        cps, cps + 3, boost::text::variable_weighting::non_ignorable);

    EXPECT_EQ(collation.size(), 12);
    EXPECT_TRUE(boost::algorithm::equal(collation.begin(), collation.end(), ces, ces + 12))
        << "from:     " << ce_dumper(cps)
        << "expected: " << ce_dumper(ces)
        << "got:      " << ce_dumper(collation);
}

TEST(collation, non_ignorable_121_313)
{
    // 0055 0303 0301 0334;	
    // (Ṹ) LATIN CAPITAL LETTER U, COMBINING TILDE, COMBINING ACUTE ACCENT	[1F1B | 0020 004A 002D 0024 | 0008 0002 0002 0002 |]

    uint32_t cps[4] = { 0x0055, 0x0303, 0x0301, 0x0334 };
    uint32_t const ces[12] = { 0x1F1B, 0x0000, 0x0020, 0x004A, 0x002D, 0x0024, 0x0000, 0x0008, 0x0002, 0x0002, 0x0002, 0x0000 };

    auto collation = collate_for_tests(
        cps, cps + 4, boost::text::variable_weighting::non_ignorable);

    EXPECT_EQ(collation.size(), 12);
    EXPECT_TRUE(boost::algorithm::equal(collation.begin(), collation.end(), ces, ces + 12))
        << "from:     " << ce_dumper(cps)
        << "expected: " << ce_dumper(ces)
        << "got:      " << ce_dumper(collation);
}

TEST(collation, non_ignorable_121_314)
{
    // 0055 0303 0341 0334;	
    // (Ṹ) LATIN CAPITAL LETTER U, COMBINING TILDE, COMBINING ACUTE TONE MARK	[1F1B | 0020 004A 002D 0024 | 0008 0002 0002 0002 |]

    uint32_t cps[4] = { 0x0055, 0x0303, 0x0341, 0x0334 };
    uint32_t const ces[12] = { 0x1F1B, 0x0000, 0x0020, 0x004A, 0x002D, 0x0024, 0x0000, 0x0008, 0x0002, 0x0002, 0x0002, 0x0000 };

    auto collation = collate_for_tests(
        cps, cps + 4, boost::text::variable_weighting::non_ignorable);

    EXPECT_EQ(collation.size(), 12);
    EXPECT_TRUE(boost::algorithm::equal(collation.begin(), collation.end(), ces, ces + 12))
        << "from:     " << ce_dumper(cps)
        << "expected: " << ce_dumper(ces)
        << "got:      " << ce_dumper(collation);
}

TEST(collation, non_ignorable_121_315)
{
    // 0168 0334 0301;	
    // (Ũ̴) LATIN CAPITAL LETTER U WITH TILDE, COMBINING TILDE OVERLAY	[1F1B | 0020 004A 002D 0024 | 0008 0002 0002 0002 |]

    uint32_t cps[3] = { 0x0168, 0x0334, 0x0301 };
    uint32_t const ces[12] = { 0x1F1B, 0x0000, 0x0020, 0x004A, 0x002D, 0x0024, 0x0000, 0x0008, 0x0002, 0x0002, 0x0002, 0x0000 };

    auto collation = collate_for_tests(
        cps, cps + 3, boost::text::variable_weighting::non_ignorable);

    EXPECT_EQ(collation.size(), 12);
    EXPECT_TRUE(boost::algorithm::equal(collation.begin(), collation.end(), ces, ces + 12))
        << "from:     " << ce_dumper(cps)
        << "expected: " << ce_dumper(ces)
        << "got:      " << ce_dumper(collation);
}

TEST(collation, non_ignorable_121_316)
{
    // 0168 0334 0341;	
    // (Ũ̴) LATIN CAPITAL LETTER U WITH TILDE, COMBINING TILDE OVERLAY	[1F1B | 0020 004A 002D 0024 | 0008 0002 0002 0002 |]

    uint32_t cps[3] = { 0x0168, 0x0334, 0x0341 };
    uint32_t const ces[12] = { 0x1F1B, 0x0000, 0x0020, 0x004A, 0x002D, 0x0024, 0x0000, 0x0008, 0x0002, 0x0002, 0x0002, 0x0000 };

    auto collation = collate_for_tests(
        cps, cps + 3, boost::text::variable_weighting::non_ignorable);

    EXPECT_EQ(collation.size(), 12);
    EXPECT_TRUE(boost::algorithm::equal(collation.begin(), collation.end(), ces, ces + 12))
        << "from:     " << ce_dumper(cps)
        << "expected: " << ce_dumper(ces)
        << "got:      " << ce_dumper(collation);
}

TEST(collation, non_ignorable_121_317)
{
    // 0075 0328 0334;	
    // (ų) LATIN SMALL LETTER U, COMBINING OGONEK	[1F1B | 0020 004A 0031 | 0002 0002 0002 |]

    uint32_t cps[3] = { 0x0075, 0x0328, 0x0334 };
    uint32_t const ces[10] = { 0x1F1B, 0x0000, 0x0020, 0x004A, 0x0031, 0x0000, 0x0002, 0x0002, 0x0002, 0x0000 };

    auto collation = collate_for_tests(
        cps, cps + 3, boost::text::variable_weighting::non_ignorable);

    EXPECT_EQ(collation.size(), 10);
    EXPECT_TRUE(boost::algorithm::equal(collation.begin(), collation.end(), ces, ces + 10))
        << "from:     " << ce_dumper(cps)
        << "expected: " << ce_dumper(ces)
        << "got:      " << ce_dumper(collation);
}

TEST(collation, non_ignorable_121_318)
{
    // 0075 0334 0328;	
    // (u̴) LATIN SMALL LETTER U, COMBINING TILDE OVERLAY	[1F1B | 0020 004A 0031 | 0002 0002 0002 |]

    uint32_t cps[3] = { 0x0075, 0x0334, 0x0328 };
    uint32_t const ces[10] = { 0x1F1B, 0x0000, 0x0020, 0x004A, 0x0031, 0x0000, 0x0002, 0x0002, 0x0002, 0x0000 };

    auto collation = collate_for_tests(
        cps, cps + 3, boost::text::variable_weighting::non_ignorable);

    EXPECT_EQ(collation.size(), 10);
    EXPECT_TRUE(boost::algorithm::equal(collation.begin(), collation.end(), ces, ces + 10))
        << "from:     " << ce_dumper(cps)
        << "expected: " << ce_dumper(ces)
        << "got:      " << ce_dumper(collation);
}

TEST(collation, non_ignorable_121_319)
{
    // 0173 0334;	
    // (ų) LATIN SMALL LETTER U WITH OGONEK	[1F1B | 0020 004A 0031 | 0002 0002 0002 |]

    uint32_t cps[2] = { 0x0173, 0x0334 };
    uint32_t const ces[10] = { 0x1F1B, 0x0000, 0x0020, 0x004A, 0x0031, 0x0000, 0x0002, 0x0002, 0x0002, 0x0000 };

    auto collation = collate_for_tests(
        cps, cps + 2, boost::text::variable_weighting::non_ignorable);

    EXPECT_EQ(collation.size(), 10);
    EXPECT_TRUE(boost::algorithm::equal(collation.begin(), collation.end(), ces, ces + 10))
        << "from:     " << ce_dumper(cps)
        << "expected: " << ce_dumper(ces)
        << "got:      " << ce_dumper(collation);
}

TEST(collation, non_ignorable_121_320)
{
    // 0055 0328 0334;	
    // (Ų) LATIN CAPITAL LETTER U, COMBINING OGONEK	[1F1B | 0020 004A 0031 | 0008 0002 0002 |]

    uint32_t cps[3] = { 0x0055, 0x0328, 0x0334 };
    uint32_t const ces[10] = { 0x1F1B, 0x0000, 0x0020, 0x004A, 0x0031, 0x0000, 0x0008, 0x0002, 0x0002, 0x0000 };

    auto collation = collate_for_tests(
        cps, cps + 3, boost::text::variable_weighting::non_ignorable);

    EXPECT_EQ(collation.size(), 10);
    EXPECT_TRUE(boost::algorithm::equal(collation.begin(), collation.end(), ces, ces + 10))
        << "from:     " << ce_dumper(cps)
        << "expected: " << ce_dumper(ces)
        << "got:      " << ce_dumper(collation);
}

TEST(collation, non_ignorable_121_321)
{
    // 0055 0334 0328;	
    // (U̴) LATIN CAPITAL LETTER U, COMBINING TILDE OVERLAY	[1F1B | 0020 004A 0031 | 0008 0002 0002 |]

    uint32_t cps[3] = { 0x0055, 0x0334, 0x0328 };
    uint32_t const ces[10] = { 0x1F1B, 0x0000, 0x0020, 0x004A, 0x0031, 0x0000, 0x0008, 0x0002, 0x0002, 0x0000 };

    auto collation = collate_for_tests(
        cps, cps + 3, boost::text::variable_weighting::non_ignorable);

    EXPECT_EQ(collation.size(), 10);
    EXPECT_TRUE(boost::algorithm::equal(collation.begin(), collation.end(), ces, ces + 10))
        << "from:     " << ce_dumper(cps)
        << "expected: " << ce_dumper(ces)
        << "got:      " << ce_dumper(collation);
}

TEST(collation, non_ignorable_121_322)
{
    // 0172 0334;	
    // (Ų) LATIN CAPITAL LETTER U WITH OGONEK	[1F1B | 0020 004A 0031 | 0008 0002 0002 |]

    uint32_t cps[2] = { 0x0172, 0x0334 };
    uint32_t const ces[10] = { 0x1F1B, 0x0000, 0x0020, 0x004A, 0x0031, 0x0000, 0x0008, 0x0002, 0x0002, 0x0000 };

    auto collation = collate_for_tests(
        cps, cps + 2, boost::text::variable_weighting::non_ignorable);

    EXPECT_EQ(collation.size(), 10);
    EXPECT_TRUE(boost::algorithm::equal(collation.begin(), collation.end(), ces, ces + 10))
        << "from:     " << ce_dumper(cps)
        << "expected: " << ce_dumper(ces)
        << "got:      " << ce_dumper(collation);
}

TEST(collation, non_ignorable_121_323)
{
    // 0075 0304 0334;	
    // (ū) LATIN SMALL LETTER U, COMBINING MACRON	[1F1B | 0020 004A 0032 | 0002 0002 0002 |]

    uint32_t cps[3] = { 0x0075, 0x0304, 0x0334 };
    uint32_t const ces[10] = { 0x1F1B, 0x0000, 0x0020, 0x004A, 0x0032, 0x0000, 0x0002, 0x0002, 0x0002, 0x0000 };

    auto collation = collate_for_tests(
        cps, cps + 3, boost::text::variable_weighting::non_ignorable);

    EXPECT_EQ(collation.size(), 10);
    EXPECT_TRUE(boost::algorithm::equal(collation.begin(), collation.end(), ces, ces + 10))
        << "from:     " << ce_dumper(cps)
        << "expected: " << ce_dumper(ces)
        << "got:      " << ce_dumper(collation);
}

TEST(collation, non_ignorable_121_324)
{
    // 0075 0334 0304;	
    // (u̴) LATIN SMALL LETTER U, COMBINING TILDE OVERLAY	[1F1B | 0020 004A 0032 | 0002 0002 0002 |]

    uint32_t cps[3] = { 0x0075, 0x0334, 0x0304 };
    uint32_t const ces[10] = { 0x1F1B, 0x0000, 0x0020, 0x004A, 0x0032, 0x0000, 0x0002, 0x0002, 0x0002, 0x0000 };

    auto collation = collate_for_tests(
        cps, cps + 3, boost::text::variable_weighting::non_ignorable);

    EXPECT_EQ(collation.size(), 10);
    EXPECT_TRUE(boost::algorithm::equal(collation.begin(), collation.end(), ces, ces + 10))
        << "from:     " << ce_dumper(cps)
        << "expected: " << ce_dumper(ces)
        << "got:      " << ce_dumper(collation);
}

TEST(collation, non_ignorable_121_325)
{
    // 016B 0334;	
    // (ū) LATIN SMALL LETTER U WITH MACRON	[1F1B | 0020 004A 0032 | 0002 0002 0002 |]

    uint32_t cps[2] = { 0x016B, 0x0334 };
    uint32_t const ces[10] = { 0x1F1B, 0x0000, 0x0020, 0x004A, 0x0032, 0x0000, 0x0002, 0x0002, 0x0002, 0x0000 };

    auto collation = collate_for_tests(
        cps, cps + 2, boost::text::variable_weighting::non_ignorable);

    EXPECT_EQ(collation.size(), 10);
    EXPECT_TRUE(boost::algorithm::equal(collation.begin(), collation.end(), ces, ces + 10))
        << "from:     " << ce_dumper(cps)
        << "expected: " << ce_dumper(ces)
        << "got:      " << ce_dumper(collation);
}

TEST(collation, non_ignorable_121_326)
{
    // 0055 0304 0334;	
    // (Ū) LATIN CAPITAL LETTER U, COMBINING MACRON	[1F1B | 0020 004A 0032 | 0008 0002 0002 |]

    uint32_t cps[3] = { 0x0055, 0x0304, 0x0334 };
    uint32_t const ces[10] = { 0x1F1B, 0x0000, 0x0020, 0x004A, 0x0032, 0x0000, 0x0008, 0x0002, 0x0002, 0x0000 };

    auto collation = collate_for_tests(
        cps, cps + 3, boost::text::variable_weighting::non_ignorable);

    EXPECT_EQ(collation.size(), 10);
    EXPECT_TRUE(boost::algorithm::equal(collation.begin(), collation.end(), ces, ces + 10))
        << "from:     " << ce_dumper(cps)
        << "expected: " << ce_dumper(ces)
        << "got:      " << ce_dumper(collation);
}

TEST(collation, non_ignorable_121_327)
{
    // 0055 0334 0304;	
    // (U̴) LATIN CAPITAL LETTER U, COMBINING TILDE OVERLAY	[1F1B | 0020 004A 0032 | 0008 0002 0002 |]

    uint32_t cps[3] = { 0x0055, 0x0334, 0x0304 };
    uint32_t const ces[10] = { 0x1F1B, 0x0000, 0x0020, 0x004A, 0x0032, 0x0000, 0x0008, 0x0002, 0x0002, 0x0000 };

    auto collation = collate_for_tests(
        cps, cps + 3, boost::text::variable_weighting::non_ignorable);

    EXPECT_EQ(collation.size(), 10);
    EXPECT_TRUE(boost::algorithm::equal(collation.begin(), collation.end(), ces, ces + 10))
        << "from:     " << ce_dumper(cps)
        << "expected: " << ce_dumper(ces)
        << "got:      " << ce_dumper(collation);
}

TEST(collation, non_ignorable_121_328)
{
    // 016A 0334;	
    // (Ū) LATIN CAPITAL LETTER U WITH MACRON	[1F1B | 0020 004A 0032 | 0008 0002 0002 |]

    uint32_t cps[2] = { 0x016A, 0x0334 };
    uint32_t const ces[10] = { 0x1F1B, 0x0000, 0x0020, 0x004A, 0x0032, 0x0000, 0x0008, 0x0002, 0x0002, 0x0000 };

    auto collation = collate_for_tests(
        cps, cps + 2, boost::text::variable_weighting::non_ignorable);

    EXPECT_EQ(collation.size(), 10);
    EXPECT_TRUE(boost::algorithm::equal(collation.begin(), collation.end(), ces, ces + 10))
        << "from:     " << ce_dumper(cps)
        << "expected: " << ce_dumper(ces)
        << "got:      " << ce_dumper(collation);
}

TEST(collation, non_ignorable_121_329)
{
    // 0075 0304 0334 0308;	
    // (ū̴) LATIN SMALL LETTER U, COMBINING MACRON, COMBINING TILDE OVERLAY	[1F1B | 0020 004A 0032 002B | 0002 0002 0002 0002 |]

    uint32_t cps[4] = { 0x0075, 0x0304, 0x0334, 0x0308 };
    uint32_t const ces[12] = { 0x1F1B, 0x0000, 0x0020, 0x004A, 0x0032, 0x002B, 0x0000, 0x0002, 0x0002, 0x0002, 0x0002, 0x0000 };

    auto collation = collate_for_tests(
        cps, cps + 4, boost::text::variable_weighting::non_ignorable);

    EXPECT_EQ(collation.size(), 12);
    EXPECT_TRUE(boost::algorithm::equal(collation.begin(), collation.end(), ces, ces + 12))
        << "from:     " << ce_dumper(cps)
        << "expected: " << ce_dumper(ces)
        << "got:      " << ce_dumper(collation);
}

TEST(collation, non_ignorable_121_330)
{
    // 0075 0334 0304 0308;	
    // (ū̴) LATIN SMALL LETTER U, COMBINING TILDE OVERLAY, COMBINING MACRON	[1F1B | 0020 004A 0032 002B | 0002 0002 0002 0002 |]

    uint32_t cps[4] = { 0x0075, 0x0334, 0x0304, 0x0308 };
    uint32_t const ces[12] = { 0x1F1B, 0x0000, 0x0020, 0x004A, 0x0032, 0x002B, 0x0000, 0x0002, 0x0002, 0x0002, 0x0002, 0x0000 };

    auto collation = collate_for_tests(
        cps, cps + 4, boost::text::variable_weighting::non_ignorable);

    EXPECT_EQ(collation.size(), 12);
    EXPECT_TRUE(boost::algorithm::equal(collation.begin(), collation.end(), ces, ces + 12))
        << "from:     " << ce_dumper(cps)
        << "expected: " << ce_dumper(ces)
        << "got:      " << ce_dumper(collation);
}

TEST(collation, non_ignorable_121_331)
{
    // 016B 0308 0334;	
    // (ṻ) LATIN SMALL LETTER U WITH MACRON, COMBINING DIAERESIS	[1F1B | 0020 004A 0032 002B | 0002 0002 0002 0002 |]

    uint32_t cps[3] = { 0x016B, 0x0308, 0x0334 };
    uint32_t const ces[12] = { 0x1F1B, 0x0000, 0x0020, 0x004A, 0x0032, 0x002B, 0x0000, 0x0002, 0x0002, 0x0002, 0x0002, 0x0000 };

    auto collation = collate_for_tests(
        cps, cps + 3, boost::text::variable_weighting::non_ignorable);

    EXPECT_EQ(collation.size(), 12);
    EXPECT_TRUE(boost::algorithm::equal(collation.begin(), collation.end(), ces, ces + 12))
        << "from:     " << ce_dumper(cps)
        << "expected: " << ce_dumper(ces)
        << "got:      " << ce_dumper(collation);
}

TEST(collation, non_ignorable_121_332)
{
    // 016B 0334 0308;	
    // (ū̴) LATIN SMALL LETTER U WITH MACRON, COMBINING TILDE OVERLAY	[1F1B | 0020 004A 0032 002B | 0002 0002 0002 0002 |]

    uint32_t cps[3] = { 0x016B, 0x0334, 0x0308 };
    uint32_t const ces[12] = { 0x1F1B, 0x0000, 0x0020, 0x004A, 0x0032, 0x002B, 0x0000, 0x0002, 0x0002, 0x0002, 0x0002, 0x0000 };

    auto collation = collate_for_tests(
        cps, cps + 3, boost::text::variable_weighting::non_ignorable);

    EXPECT_EQ(collation.size(), 12);
    EXPECT_TRUE(boost::algorithm::equal(collation.begin(), collation.end(), ces, ces + 12))
        << "from:     " << ce_dumper(cps)
        << "expected: " << ce_dumper(ces)
        << "got:      " << ce_dumper(collation);
}

TEST(collation, non_ignorable_121_333)
{
    // 0055 0304 0308 0334;	
    // (Ṻ) LATIN CAPITAL LETTER U, COMBINING MACRON, COMBINING DIAERESIS	[1F1B | 0020 004A 0032 002B | 0008 0002 0002 0002 |]

    uint32_t cps[4] = { 0x0055, 0x0304, 0x0308, 0x0334 };
    uint32_t const ces[12] = { 0x1F1B, 0x0000, 0x0020, 0x004A, 0x0032, 0x002B, 0x0000, 0x0008, 0x0002, 0x0002, 0x0002, 0x0000 };

    auto collation = collate_for_tests(
        cps, cps + 4, boost::text::variable_weighting::non_ignorable);

    EXPECT_EQ(collation.size(), 12);
    EXPECT_TRUE(boost::algorithm::equal(collation.begin(), collation.end(), ces, ces + 12))
        << "from:     " << ce_dumper(cps)
        << "expected: " << ce_dumper(ces)
        << "got:      " << ce_dumper(collation);
}

TEST(collation, non_ignorable_121_334)
{
    // 0055 0304 0334 0308;	
    // (Ū̴) LATIN CAPITAL LETTER U, COMBINING MACRON, COMBINING TILDE OVERLAY	[1F1B | 0020 004A 0032 002B | 0008 0002 0002 0002 |]

    uint32_t cps[4] = { 0x0055, 0x0304, 0x0334, 0x0308 };
    uint32_t const ces[12] = { 0x1F1B, 0x0000, 0x0020, 0x004A, 0x0032, 0x002B, 0x0000, 0x0008, 0x0002, 0x0002, 0x0002, 0x0000 };

    auto collation = collate_for_tests(
        cps, cps + 4, boost::text::variable_weighting::non_ignorable);

    EXPECT_EQ(collation.size(), 12);
    EXPECT_TRUE(boost::algorithm::equal(collation.begin(), collation.end(), ces, ces + 12))
        << "from:     " << ce_dumper(cps)
        << "expected: " << ce_dumper(ces)
        << "got:      " << ce_dumper(collation);
}

TEST(collation, non_ignorable_121_335)
{
    // 0055 0334 0304 0308;	
    // (Ū̴) LATIN CAPITAL LETTER U, COMBINING TILDE OVERLAY, COMBINING MACRON	[1F1B | 0020 004A 0032 002B | 0008 0002 0002 0002 |]

    uint32_t cps[4] = { 0x0055, 0x0334, 0x0304, 0x0308 };
    uint32_t const ces[12] = { 0x1F1B, 0x0000, 0x0020, 0x004A, 0x0032, 0x002B, 0x0000, 0x0008, 0x0002, 0x0002, 0x0002, 0x0000 };

    auto collation = collate_for_tests(
        cps, cps + 4, boost::text::variable_weighting::non_ignorable);

    EXPECT_EQ(collation.size(), 12);
    EXPECT_TRUE(boost::algorithm::equal(collation.begin(), collation.end(), ces, ces + 12))
        << "from:     " << ce_dumper(cps)
        << "expected: " << ce_dumper(ces)
        << "got:      " << ce_dumper(collation);
}

TEST(collation, non_ignorable_121_336)
{
    // 016A 0308 0334;	
    // (Ṻ) LATIN CAPITAL LETTER U WITH MACRON, COMBINING DIAERESIS	[1F1B | 0020 004A 0032 002B | 0008 0002 0002 0002 |]

    uint32_t cps[3] = { 0x016A, 0x0308, 0x0334 };
    uint32_t const ces[12] = { 0x1F1B, 0x0000, 0x0020, 0x004A, 0x0032, 0x002B, 0x0000, 0x0008, 0x0002, 0x0002, 0x0002, 0x0000 };

    auto collation = collate_for_tests(
        cps, cps + 3, boost::text::variable_weighting::non_ignorable);

    EXPECT_EQ(collation.size(), 12);
    EXPECT_TRUE(boost::algorithm::equal(collation.begin(), collation.end(), ces, ces + 12))
        << "from:     " << ce_dumper(cps)
        << "expected: " << ce_dumper(ces)
        << "got:      " << ce_dumper(collation);
}

TEST(collation, non_ignorable_121_337)
{
    // 0075 0309 0334;	
    // (ủ) LATIN SMALL LETTER U, COMBINING HOOK ABOVE	[1F1B | 0020 004A 003B | 0002 0002 0002 |]

    uint32_t cps[3] = { 0x0075, 0x0309, 0x0334 };
    uint32_t const ces[10] = { 0x1F1B, 0x0000, 0x0020, 0x004A, 0x003B, 0x0000, 0x0002, 0x0002, 0x0002, 0x0000 };

    auto collation = collate_for_tests(
        cps, cps + 3, boost::text::variable_weighting::non_ignorable);

    EXPECT_EQ(collation.size(), 10);
    EXPECT_TRUE(boost::algorithm::equal(collation.begin(), collation.end(), ces, ces + 10))
        << "from:     " << ce_dumper(cps)
        << "expected: " << ce_dumper(ces)
        << "got:      " << ce_dumper(collation);
}

TEST(collation, non_ignorable_121_338)
{
    // 0075 0334 0309;	
    // (u̴) LATIN SMALL LETTER U, COMBINING TILDE OVERLAY	[1F1B | 0020 004A 003B | 0002 0002 0002 |]

    uint32_t cps[3] = { 0x0075, 0x0334, 0x0309 };
    uint32_t const ces[10] = { 0x1F1B, 0x0000, 0x0020, 0x004A, 0x003B, 0x0000, 0x0002, 0x0002, 0x0002, 0x0000 };

    auto collation = collate_for_tests(
        cps, cps + 3, boost::text::variable_weighting::non_ignorable);

    EXPECT_EQ(collation.size(), 10);
    EXPECT_TRUE(boost::algorithm::equal(collation.begin(), collation.end(), ces, ces + 10))
        << "from:     " << ce_dumper(cps)
        << "expected: " << ce_dumper(ces)
        << "got:      " << ce_dumper(collation);
}

TEST(collation, non_ignorable_121_339)
{
    // 1EE7 0334;	
    // (ủ) LATIN SMALL LETTER U WITH HOOK ABOVE	[1F1B | 0020 004A 003B | 0002 0002 0002 |]

    uint32_t cps[2] = { 0x1EE7, 0x0334 };
    uint32_t const ces[10] = { 0x1F1B, 0x0000, 0x0020, 0x004A, 0x003B, 0x0000, 0x0002, 0x0002, 0x0002, 0x0000 };

    auto collation = collate_for_tests(
        cps, cps + 2, boost::text::variable_weighting::non_ignorable);

    EXPECT_EQ(collation.size(), 10);
    EXPECT_TRUE(boost::algorithm::equal(collation.begin(), collation.end(), ces, ces + 10))
        << "from:     " << ce_dumper(cps)
        << "expected: " << ce_dumper(ces)
        << "got:      " << ce_dumper(collation);
}

TEST(collation, non_ignorable_121_340)
{
    // 0055 0309 0334;	
    // (Ủ) LATIN CAPITAL LETTER U, COMBINING HOOK ABOVE	[1F1B | 0020 004A 003B | 0008 0002 0002 |]

    uint32_t cps[3] = { 0x0055, 0x0309, 0x0334 };
    uint32_t const ces[10] = { 0x1F1B, 0x0000, 0x0020, 0x004A, 0x003B, 0x0000, 0x0008, 0x0002, 0x0002, 0x0000 };

    auto collation = collate_for_tests(
        cps, cps + 3, boost::text::variable_weighting::non_ignorable);

    EXPECT_EQ(collation.size(), 10);
    EXPECT_TRUE(boost::algorithm::equal(collation.begin(), collation.end(), ces, ces + 10))
        << "from:     " << ce_dumper(cps)
        << "expected: " << ce_dumper(ces)
        << "got:      " << ce_dumper(collation);
}

TEST(collation, non_ignorable_121_341)
{
    // 0055 0334 0309;	
    // (U̴) LATIN CAPITAL LETTER U, COMBINING TILDE OVERLAY	[1F1B | 0020 004A 003B | 0008 0002 0002 |]

    uint32_t cps[3] = { 0x0055, 0x0334, 0x0309 };
    uint32_t const ces[10] = { 0x1F1B, 0x0000, 0x0020, 0x004A, 0x003B, 0x0000, 0x0008, 0x0002, 0x0002, 0x0000 };

    auto collation = collate_for_tests(
        cps, cps + 3, boost::text::variable_weighting::non_ignorable);

    EXPECT_EQ(collation.size(), 10);
    EXPECT_TRUE(boost::algorithm::equal(collation.begin(), collation.end(), ces, ces + 10))
        << "from:     " << ce_dumper(cps)
        << "expected: " << ce_dumper(ces)
        << "got:      " << ce_dumper(collation);
}

TEST(collation, non_ignorable_121_342)
{
    // 1EE6 0334;	
    // (Ủ) LATIN CAPITAL LETTER U WITH HOOK ABOVE	[1F1B | 0020 004A 003B | 0008 0002 0002 |]

    uint32_t cps[2] = { 0x1EE6, 0x0334 };
    uint32_t const ces[10] = { 0x1F1B, 0x0000, 0x0020, 0x004A, 0x003B, 0x0000, 0x0008, 0x0002, 0x0002, 0x0000 };

    auto collation = collate_for_tests(
        cps, cps + 2, boost::text::variable_weighting::non_ignorable);

    EXPECT_EQ(collation.size(), 10);
    EXPECT_TRUE(boost::algorithm::equal(collation.begin(), collation.end(), ces, ces + 10))
        << "from:     " << ce_dumper(cps)
        << "expected: " << ce_dumper(ces)
        << "got:      " << ce_dumper(collation);
}

TEST(collation, non_ignorable_121_343)
{
    // 0075 030F 0334;	
    // (ȕ) LATIN SMALL LETTER U, COMBINING DOUBLE GRAVE ACCENT	[1F1B | 0020 004A 003C | 0002 0002 0002 |]

    uint32_t cps[3] = { 0x0075, 0x030F, 0x0334 };
    uint32_t const ces[10] = { 0x1F1B, 0x0000, 0x0020, 0x004A, 0x003C, 0x0000, 0x0002, 0x0002, 0x0002, 0x0000 };

    auto collation = collate_for_tests(
        cps, cps + 3, boost::text::variable_weighting::non_ignorable);

    EXPECT_EQ(collation.size(), 10);
    EXPECT_TRUE(boost::algorithm::equal(collation.begin(), collation.end(), ces, ces + 10))
        << "from:     " << ce_dumper(cps)
        << "expected: " << ce_dumper(ces)
        << "got:      " << ce_dumper(collation);
}

TEST(collation, non_ignorable_121_344)
{
    // 0075 0334 030F;	
    // (u̴) LATIN SMALL LETTER U, COMBINING TILDE OVERLAY	[1F1B | 0020 004A 003C | 0002 0002 0002 |]

    uint32_t cps[3] = { 0x0075, 0x0334, 0x030F };
    uint32_t const ces[10] = { 0x1F1B, 0x0000, 0x0020, 0x004A, 0x003C, 0x0000, 0x0002, 0x0002, 0x0002, 0x0000 };

    auto collation = collate_for_tests(
        cps, cps + 3, boost::text::variable_weighting::non_ignorable);

    EXPECT_EQ(collation.size(), 10);
    EXPECT_TRUE(boost::algorithm::equal(collation.begin(), collation.end(), ces, ces + 10))
        << "from:     " << ce_dumper(cps)
        << "expected: " << ce_dumper(ces)
        << "got:      " << ce_dumper(collation);
}

TEST(collation, non_ignorable_121_345)
{
    // 0215 0334;	
    // (ȕ) LATIN SMALL LETTER U WITH DOUBLE GRAVE	[1F1B | 0020 004A 003C | 0002 0002 0002 |]

    uint32_t cps[2] = { 0x0215, 0x0334 };
    uint32_t const ces[10] = { 0x1F1B, 0x0000, 0x0020, 0x004A, 0x003C, 0x0000, 0x0002, 0x0002, 0x0002, 0x0000 };

    auto collation = collate_for_tests(
        cps, cps + 2, boost::text::variable_weighting::non_ignorable);

    EXPECT_EQ(collation.size(), 10);
    EXPECT_TRUE(boost::algorithm::equal(collation.begin(), collation.end(), ces, ces + 10))
        << "from:     " << ce_dumper(cps)
        << "expected: " << ce_dumper(ces)
        << "got:      " << ce_dumper(collation);
}

TEST(collation, non_ignorable_121_346)
{
    // 0055 030F 0334;	
    // (Ȕ) LATIN CAPITAL LETTER U, COMBINING DOUBLE GRAVE ACCENT	[1F1B | 0020 004A 003C | 0008 0002 0002 |]

    uint32_t cps[3] = { 0x0055, 0x030F, 0x0334 };
    uint32_t const ces[10] = { 0x1F1B, 0x0000, 0x0020, 0x004A, 0x003C, 0x0000, 0x0008, 0x0002, 0x0002, 0x0000 };

    auto collation = collate_for_tests(
        cps, cps + 3, boost::text::variable_weighting::non_ignorable);

    EXPECT_EQ(collation.size(), 10);
    EXPECT_TRUE(boost::algorithm::equal(collation.begin(), collation.end(), ces, ces + 10))
        << "from:     " << ce_dumper(cps)
        << "expected: " << ce_dumper(ces)
        << "got:      " << ce_dumper(collation);
}

TEST(collation, non_ignorable_121_347)
{
    // 0055 0334 030F;	
    // (U̴) LATIN CAPITAL LETTER U, COMBINING TILDE OVERLAY	[1F1B | 0020 004A 003C | 0008 0002 0002 |]

    uint32_t cps[3] = { 0x0055, 0x0334, 0x030F };
    uint32_t const ces[10] = { 0x1F1B, 0x0000, 0x0020, 0x004A, 0x003C, 0x0000, 0x0008, 0x0002, 0x0002, 0x0000 };

    auto collation = collate_for_tests(
        cps, cps + 3, boost::text::variable_weighting::non_ignorable);

    EXPECT_EQ(collation.size(), 10);
    EXPECT_TRUE(boost::algorithm::equal(collation.begin(), collation.end(), ces, ces + 10))
        << "from:     " << ce_dumper(cps)
        << "expected: " << ce_dumper(ces)
        << "got:      " << ce_dumper(collation);
}

TEST(collation, non_ignorable_121_348)
{
    // 0214 0334;	
    // (Ȕ) LATIN CAPITAL LETTER U WITH DOUBLE GRAVE	[1F1B | 0020 004A 003C | 0008 0002 0002 |]

    uint32_t cps[2] = { 0x0214, 0x0334 };
    uint32_t const ces[10] = { 0x1F1B, 0x0000, 0x0020, 0x004A, 0x003C, 0x0000, 0x0008, 0x0002, 0x0002, 0x0000 };

    auto collation = collate_for_tests(
        cps, cps + 2, boost::text::variable_weighting::non_ignorable);

    EXPECT_EQ(collation.size(), 10);
    EXPECT_TRUE(boost::algorithm::equal(collation.begin(), collation.end(), ces, ces + 10))
        << "from:     " << ce_dumper(cps)
        << "expected: " << ce_dumper(ces)
        << "got:      " << ce_dumper(collation);
}

TEST(collation, non_ignorable_121_349)
{
    // 0075 0311 0334;	
    // (ȗ) LATIN SMALL LETTER U, COMBINING INVERTED BREVE	[1F1B | 0020 004A 003E | 0002 0002 0002 |]

    uint32_t cps[3] = { 0x0075, 0x0311, 0x0334 };
    uint32_t const ces[10] = { 0x1F1B, 0x0000, 0x0020, 0x004A, 0x003E, 0x0000, 0x0002, 0x0002, 0x0002, 0x0000 };

    auto collation = collate_for_tests(
        cps, cps + 3, boost::text::variable_weighting::non_ignorable);

    EXPECT_EQ(collation.size(), 10);
    EXPECT_TRUE(boost::algorithm::equal(collation.begin(), collation.end(), ces, ces + 10))
        << "from:     " << ce_dumper(cps)
        << "expected: " << ce_dumper(ces)
        << "got:      " << ce_dumper(collation);
}

TEST(collation, non_ignorable_121_350)
{
    // 0075 0334 0311;	
    // (u̴) LATIN SMALL LETTER U, COMBINING TILDE OVERLAY	[1F1B | 0020 004A 003E | 0002 0002 0002 |]

    uint32_t cps[3] = { 0x0075, 0x0334, 0x0311 };
    uint32_t const ces[10] = { 0x1F1B, 0x0000, 0x0020, 0x004A, 0x003E, 0x0000, 0x0002, 0x0002, 0x0002, 0x0000 };

    auto collation = collate_for_tests(
        cps, cps + 3, boost::text::variable_weighting::non_ignorable);

    EXPECT_EQ(collation.size(), 10);
    EXPECT_TRUE(boost::algorithm::equal(collation.begin(), collation.end(), ces, ces + 10))
        << "from:     " << ce_dumper(cps)
        << "expected: " << ce_dumper(ces)
        << "got:      " << ce_dumper(collation);
}

TEST(collation, non_ignorable_121_351)
{
    // 0217 0334;	
    // (ȗ) LATIN SMALL LETTER U WITH INVERTED BREVE	[1F1B | 0020 004A 003E | 0002 0002 0002 |]

    uint32_t cps[2] = { 0x0217, 0x0334 };
    uint32_t const ces[10] = { 0x1F1B, 0x0000, 0x0020, 0x004A, 0x003E, 0x0000, 0x0002, 0x0002, 0x0002, 0x0000 };

    auto collation = collate_for_tests(
        cps, cps + 2, boost::text::variable_weighting::non_ignorable);

    EXPECT_EQ(collation.size(), 10);
    EXPECT_TRUE(boost::algorithm::equal(collation.begin(), collation.end(), ces, ces + 10))
        << "from:     " << ce_dumper(cps)
        << "expected: " << ce_dumper(ces)
        << "got:      " << ce_dumper(collation);
}

TEST(collation, non_ignorable_121_352)
{
    // 0055 0311 0334;	
    // (Ȗ) LATIN CAPITAL LETTER U, COMBINING INVERTED BREVE	[1F1B | 0020 004A 003E | 0008 0002 0002 |]

    uint32_t cps[3] = { 0x0055, 0x0311, 0x0334 };
    uint32_t const ces[10] = { 0x1F1B, 0x0000, 0x0020, 0x004A, 0x003E, 0x0000, 0x0008, 0x0002, 0x0002, 0x0000 };

    auto collation = collate_for_tests(
        cps, cps + 3, boost::text::variable_weighting::non_ignorable);

    EXPECT_EQ(collation.size(), 10);
    EXPECT_TRUE(boost::algorithm::equal(collation.begin(), collation.end(), ces, ces + 10))
        << "from:     " << ce_dumper(cps)
        << "expected: " << ce_dumper(ces)
        << "got:      " << ce_dumper(collation);
}

TEST(collation, non_ignorable_121_353)
{
    // 0055 0334 0311;	
    // (U̴) LATIN CAPITAL LETTER U, COMBINING TILDE OVERLAY	[1F1B | 0020 004A 003E | 0008 0002 0002 |]

    uint32_t cps[3] = { 0x0055, 0x0334, 0x0311 };
    uint32_t const ces[10] = { 0x1F1B, 0x0000, 0x0020, 0x004A, 0x003E, 0x0000, 0x0008, 0x0002, 0x0002, 0x0000 };

    auto collation = collate_for_tests(
        cps, cps + 3, boost::text::variable_weighting::non_ignorable);

    EXPECT_EQ(collation.size(), 10);
    EXPECT_TRUE(boost::algorithm::equal(collation.begin(), collation.end(), ces, ces + 10))
        << "from:     " << ce_dumper(cps)
        << "expected: " << ce_dumper(ces)
        << "got:      " << ce_dumper(collation);
}

TEST(collation, non_ignorable_121_354)
{
    // 0216 0334;	
    // (Ȗ) LATIN CAPITAL LETTER U WITH INVERTED BREVE	[1F1B | 0020 004A 003E | 0008 0002 0002 |]

    uint32_t cps[2] = { 0x0216, 0x0334 };
    uint32_t const ces[10] = { 0x1F1B, 0x0000, 0x0020, 0x004A, 0x003E, 0x0000, 0x0008, 0x0002, 0x0002, 0x0000 };

    auto collation = collate_for_tests(
        cps, cps + 2, boost::text::variable_weighting::non_ignorable);

    EXPECT_EQ(collation.size(), 10);
    EXPECT_TRUE(boost::algorithm::equal(collation.begin(), collation.end(), ces, ces + 10))
        << "from:     " << ce_dumper(cps)
        << "expected: " << ce_dumper(ces)
        << "got:      " << ce_dumper(collation);
}

TEST(collation, non_ignorable_121_355)
{
    // 0075 031B 0334;	
    // (ư) LATIN SMALL LETTER U, COMBINING HORN	[1F1B | 0020 004A 003F | 0002 0002 0002 |]

    uint32_t cps[3] = { 0x0075, 0x031B, 0x0334 };
    uint32_t const ces[10] = { 0x1F1B, 0x0000, 0x0020, 0x004A, 0x003F, 0x0000, 0x0002, 0x0002, 0x0002, 0x0000 };

    auto collation = collate_for_tests(
        cps, cps + 3, boost::text::variable_weighting::non_ignorable);

    EXPECT_EQ(collation.size(), 10);
    EXPECT_TRUE(boost::algorithm::equal(collation.begin(), collation.end(), ces, ces + 10))
        << "from:     " << ce_dumper(cps)
        << "expected: " << ce_dumper(ces)
        << "got:      " << ce_dumper(collation);
}

TEST(collation, non_ignorable_121_356)
{
    // 0075 0334 031B;	
    // (u̴) LATIN SMALL LETTER U, COMBINING TILDE OVERLAY	[1F1B | 0020 004A 003F | 0002 0002 0002 |]

    uint32_t cps[3] = { 0x0075, 0x0334, 0x031B };
    uint32_t const ces[10] = { 0x1F1B, 0x0000, 0x0020, 0x004A, 0x003F, 0x0000, 0x0002, 0x0002, 0x0002, 0x0000 };

    auto collation = collate_for_tests(
        cps, cps + 3, boost::text::variable_weighting::non_ignorable);

    EXPECT_EQ(collation.size(), 10);
    EXPECT_TRUE(boost::algorithm::equal(collation.begin(), collation.end(), ces, ces + 10))
        << "from:     " << ce_dumper(cps)
        << "expected: " << ce_dumper(ces)
        << "got:      " << ce_dumper(collation);
}

TEST(collation, non_ignorable_121_357)
{
    // 01B0 0334;	
    // (ư) LATIN SMALL LETTER U WITH HORN	[1F1B | 0020 004A 003F | 0002 0002 0002 |]

    uint32_t cps[2] = { 0x01B0, 0x0334 };
    uint32_t const ces[10] = { 0x1F1B, 0x0000, 0x0020, 0x004A, 0x003F, 0x0000, 0x0002, 0x0002, 0x0002, 0x0000 };

    auto collation = collate_for_tests(
        cps, cps + 2, boost::text::variable_weighting::non_ignorable);

    EXPECT_EQ(collation.size(), 10);
    EXPECT_TRUE(boost::algorithm::equal(collation.begin(), collation.end(), ces, ces + 10))
        << "from:     " << ce_dumper(cps)
        << "expected: " << ce_dumper(ces)
        << "got:      " << ce_dumper(collation);
}

TEST(collation, non_ignorable_121_358)
{
    // 0055 031B 0334;	
    // (Ư) LATIN CAPITAL LETTER U, COMBINING HORN	[1F1B | 0020 004A 003F | 0008 0002 0002 |]

    uint32_t cps[3] = { 0x0055, 0x031B, 0x0334 };
    uint32_t const ces[10] = { 0x1F1B, 0x0000, 0x0020, 0x004A, 0x003F, 0x0000, 0x0008, 0x0002, 0x0002, 0x0000 };

    auto collation = collate_for_tests(
        cps, cps + 3, boost::text::variable_weighting::non_ignorable);

    EXPECT_EQ(collation.size(), 10);
    EXPECT_TRUE(boost::algorithm::equal(collation.begin(), collation.end(), ces, ces + 10))
        << "from:     " << ce_dumper(cps)
        << "expected: " << ce_dumper(ces)
        << "got:      " << ce_dumper(collation);
}

TEST(collation, non_ignorable_121_359)
{
    // 0055 0334 031B;	
    // (U̴) LATIN CAPITAL LETTER U, COMBINING TILDE OVERLAY	[1F1B | 0020 004A 003F | 0008 0002 0002 |]

    uint32_t cps[3] = { 0x0055, 0x0334, 0x031B };
    uint32_t const ces[10] = { 0x1F1B, 0x0000, 0x0020, 0x004A, 0x003F, 0x0000, 0x0008, 0x0002, 0x0002, 0x0000 };

    auto collation = collate_for_tests(
        cps, cps + 3, boost::text::variable_weighting::non_ignorable);

    EXPECT_EQ(collation.size(), 10);
    EXPECT_TRUE(boost::algorithm::equal(collation.begin(), collation.end(), ces, ces + 10))
        << "from:     " << ce_dumper(cps)
        << "expected: " << ce_dumper(ces)
        << "got:      " << ce_dumper(collation);
}

TEST(collation, non_ignorable_121_360)
{
    // 01AF 0334;	
    // (Ư) LATIN CAPITAL LETTER U WITH HORN	[1F1B | 0020 004A 003F | 0008 0002 0002 |]

    uint32_t cps[2] = { 0x01AF, 0x0334 };
    uint32_t const ces[10] = { 0x1F1B, 0x0000, 0x0020, 0x004A, 0x003F, 0x0000, 0x0008, 0x0002, 0x0002, 0x0000 };

    auto collation = collate_for_tests(
        cps, cps + 2, boost::text::variable_weighting::non_ignorable);

    EXPECT_EQ(collation.size(), 10);
    EXPECT_TRUE(boost::algorithm::equal(collation.begin(), collation.end(), ces, ces + 10))
        << "from:     " << ce_dumper(cps)
        << "expected: " << ce_dumper(ces)
        << "got:      " << ce_dumper(collation);
}

TEST(collation, non_ignorable_121_361)
{
    // 0075 0301 031B 0334;	
    // (ứ) LATIN SMALL LETTER U, COMBINING ACUTE ACCENT, COMBINING HORN	[1F1B | 0020 004A 003F 0024 | 0002 0002 0002 0002 |]

    uint32_t cps[4] = { 0x0075, 0x0301, 0x031B, 0x0334 };
    uint32_t const ces[12] = { 0x1F1B, 0x0000, 0x0020, 0x004A, 0x003F, 0x0024, 0x0000, 0x0002, 0x0002, 0x0002, 0x0002, 0x0000 };

    auto collation = collate_for_tests(
        cps, cps + 4, boost::text::variable_weighting::non_ignorable);

    EXPECT_EQ(collation.size(), 12);
    EXPECT_TRUE(boost::algorithm::equal(collation.begin(), collation.end(), ces, ces + 12))
        << "from:     " << ce_dumper(cps)
        << "expected: " << ce_dumper(ces)
        << "got:      " << ce_dumper(collation);
}

TEST(collation, non_ignorable_121_362)
{
    // 0075 0334 031B 0301;	
    // (ư̴) LATIN SMALL LETTER U, COMBINING TILDE OVERLAY, COMBINING HORN	[1F1B | 0020 004A 003F 0024 | 0002 0002 0002 0002 |]

    uint32_t cps[4] = { 0x0075, 0x0334, 0x031B, 0x0301 };
    uint32_t const ces[12] = { 0x1F1B, 0x0000, 0x0020, 0x004A, 0x003F, 0x0024, 0x0000, 0x0002, 0x0002, 0x0002, 0x0002, 0x0000 };

    auto collation = collate_for_tests(
        cps, cps + 4, boost::text::variable_weighting::non_ignorable);

    EXPECT_EQ(collation.size(), 12);
    EXPECT_TRUE(boost::algorithm::equal(collation.begin(), collation.end(), ces, ces + 12))
        << "from:     " << ce_dumper(cps)
        << "expected: " << ce_dumper(ces)
        << "got:      " << ce_dumper(collation);
}

TEST(collation, non_ignorable_121_363)
{
    // 0075 0334 031B 0341;	
    // (ư̴) LATIN SMALL LETTER U, COMBINING TILDE OVERLAY, COMBINING HORN	[1F1B | 0020 004A 003F 0024 | 0002 0002 0002 0002 |]

    uint32_t cps[4] = { 0x0075, 0x0334, 0x031B, 0x0341 };
    uint32_t const ces[12] = { 0x1F1B, 0x0000, 0x0020, 0x004A, 0x003F, 0x0024, 0x0000, 0x0002, 0x0002, 0x0002, 0x0002, 0x0000 };

    auto collation = collate_for_tests(
        cps, cps + 4, boost::text::variable_weighting::non_ignorable);

    EXPECT_EQ(collation.size(), 12);
    EXPECT_TRUE(boost::algorithm::equal(collation.begin(), collation.end(), ces, ces + 12))
        << "from:     " << ce_dumper(cps)
        << "expected: " << ce_dumper(ces)
        << "got:      " << ce_dumper(collation);
}

TEST(collation, non_ignorable_121_364)
{
    // 0075 0341 031B 0334;	
    // (ứ) LATIN SMALL LETTER U, COMBINING ACUTE TONE MARK, COMBINING HORN	[1F1B | 0020 004A 003F 0024 | 0002 0002 0002 0002 |]

    uint32_t cps[4] = { 0x0075, 0x0341, 0x031B, 0x0334 };
    uint32_t const ces[12] = { 0x1F1B, 0x0000, 0x0020, 0x004A, 0x003F, 0x0024, 0x0000, 0x0002, 0x0002, 0x0002, 0x0002, 0x0000 };

    auto collation = collate_for_tests(
        cps, cps + 4, boost::text::variable_weighting::non_ignorable);

    EXPECT_EQ(collation.size(), 12);
    EXPECT_TRUE(boost::algorithm::equal(collation.begin(), collation.end(), ces, ces + 12))
        << "from:     " << ce_dumper(cps)
        << "expected: " << ce_dumper(ces)
        << "got:      " << ce_dumper(collation);
}

TEST(collation, non_ignorable_121_365)
{
    // 0055 0301 0334 031B;	
    // (Ú̴) LATIN CAPITAL LETTER U, COMBINING ACUTE ACCENT, COMBINING TILDE OVERLAY	[1F1B | 0020 004A 003F 0024 | 0008 0002 0002 0002 |]

    uint32_t cps[4] = { 0x0055, 0x0301, 0x0334, 0x031B };
    uint32_t const ces[12] = { 0x1F1B, 0x0000, 0x0020, 0x004A, 0x003F, 0x0024, 0x0000, 0x0008, 0x0002, 0x0002, 0x0002, 0x0000 };

    auto collation = collate_for_tests(
        cps, cps + 4, boost::text::variable_weighting::non_ignorable);

    EXPECT_EQ(collation.size(), 12);
    EXPECT_TRUE(boost::algorithm::equal(collation.begin(), collation.end(), ces, ces + 12))
        << "from:     " << ce_dumper(cps)
        << "expected: " << ce_dumper(ces)
        << "got:      " << ce_dumper(collation);
}

TEST(collation, non_ignorable_121_366)
{
    // 0055 031B 0334 0301;	
    // (Ư̴) LATIN CAPITAL LETTER U, COMBINING HORN, COMBINING TILDE OVERLAY	[1F1B | 0020 004A 003F 0024 | 0008 0002 0002 0002 |]

    uint32_t cps[4] = { 0x0055, 0x031B, 0x0334, 0x0301 };
    uint32_t const ces[12] = { 0x1F1B, 0x0000, 0x0020, 0x004A, 0x003F, 0x0024, 0x0000, 0x0008, 0x0002, 0x0002, 0x0002, 0x0000 };

    auto collation = collate_for_tests(
        cps, cps + 4, boost::text::variable_weighting::non_ignorable);

    EXPECT_EQ(collation.size(), 12);
    EXPECT_TRUE(boost::algorithm::equal(collation.begin(), collation.end(), ces, ces + 12))
        << "from:     " << ce_dumper(cps)
        << "expected: " << ce_dumper(ces)
        << "got:      " << ce_dumper(collation);
}

TEST(collation, non_ignorable_121_367)
{
    // 0055 031B 0334 0341;	
    // (Ư̴) LATIN CAPITAL LETTER U, COMBINING HORN, COMBINING TILDE OVERLAY	[1F1B | 0020 004A 003F 0024 | 0008 0002 0002 0002 |]

    uint32_t cps[4] = { 0x0055, 0x031B, 0x0334, 0x0341 };
    uint32_t const ces[12] = { 0x1F1B, 0x0000, 0x0020, 0x004A, 0x003F, 0x0024, 0x0000, 0x0008, 0x0002, 0x0002, 0x0002, 0x0000 };

    auto collation = collate_for_tests(
        cps, cps + 4, boost::text::variable_weighting::non_ignorable);

    EXPECT_EQ(collation.size(), 12);
    EXPECT_TRUE(boost::algorithm::equal(collation.begin(), collation.end(), ces, ces + 12))
        << "from:     " << ce_dumper(cps)
        << "expected: " << ce_dumper(ces)
        << "got:      " << ce_dumper(collation);
}

TEST(collation, non_ignorable_121_368)
{
    // 0055 0341 0334 031B;	
    // (Ú̴) LATIN CAPITAL LETTER U, COMBINING ACUTE TONE MARK, COMBINING TILDE OVERLAY	[1F1B | 0020 004A 003F 0024 | 0008 0002 0002 0002 |]

    uint32_t cps[4] = { 0x0055, 0x0341, 0x0334, 0x031B };
    uint32_t const ces[12] = { 0x1F1B, 0x0000, 0x0020, 0x004A, 0x003F, 0x0024, 0x0000, 0x0008, 0x0002, 0x0002, 0x0002, 0x0000 };

    auto collation = collate_for_tests(
        cps, cps + 4, boost::text::variable_weighting::non_ignorable);

    EXPECT_EQ(collation.size(), 12);
    EXPECT_TRUE(boost::algorithm::equal(collation.begin(), collation.end(), ces, ces + 12))
        << "from:     " << ce_dumper(cps)
        << "expected: " << ce_dumper(ces)
        << "got:      " << ce_dumper(collation);
}

TEST(collation, non_ignorable_121_369)
{
    // 0075 0300 031B 0334;	
    // (ừ) LATIN SMALL LETTER U, COMBINING GRAVE ACCENT, COMBINING HORN	[1F1B | 0020 004A 003F 0025 | 0002 0002 0002 0002 |]

    uint32_t cps[4] = { 0x0075, 0x0300, 0x031B, 0x0334 };
    uint32_t const ces[12] = { 0x1F1B, 0x0000, 0x0020, 0x004A, 0x003F, 0x0025, 0x0000, 0x0002, 0x0002, 0x0002, 0x0002, 0x0000 };

    auto collation = collate_for_tests(
        cps, cps + 4, boost::text::variable_weighting::non_ignorable);

    EXPECT_EQ(collation.size(), 12);
    EXPECT_TRUE(boost::algorithm::equal(collation.begin(), collation.end(), ces, ces + 12))
        << "from:     " << ce_dumper(cps)
        << "expected: " << ce_dumper(ces)
        << "got:      " << ce_dumper(collation);
}

TEST(collation, non_ignorable_121_370)
{
    // 00F9 0334 031B;	
    // (ù̴) LATIN SMALL LETTER U WITH GRAVE, COMBINING TILDE OVERLAY	[1F1B | 0020 004A 003F 0025 | 0002 0002 0002 0002 |]

    uint32_t cps[3] = { 0x00F9, 0x0334, 0x031B };
    uint32_t const ces[12] = { 0x1F1B, 0x0000, 0x0020, 0x004A, 0x003F, 0x0025, 0x0000, 0x0002, 0x0002, 0x0002, 0x0002, 0x0000 };

    auto collation = collate_for_tests(
        cps, cps + 3, boost::text::variable_weighting::non_ignorable);

    EXPECT_EQ(collation.size(), 12);
    EXPECT_TRUE(boost::algorithm::equal(collation.begin(), collation.end(), ces, ces + 12))
        << "from:     " << ce_dumper(cps)
        << "expected: " << ce_dumper(ces)
        << "got:      " << ce_dumper(collation);
}

TEST(collation, non_ignorable_121_371)
{
    // 01B0 0300 0334;	
    // (ừ) LATIN SMALL LETTER U WITH HORN, COMBINING GRAVE ACCENT	[1F1B | 0020 004A 003F 0025 | 0002 0002 0002 0002 |]

    uint32_t cps[3] = { 0x01B0, 0x0300, 0x0334 };
    uint32_t const ces[12] = { 0x1F1B, 0x0000, 0x0020, 0x004A, 0x003F, 0x0025, 0x0000, 0x0002, 0x0002, 0x0002, 0x0002, 0x0000 };

    auto collation = collate_for_tests(
        cps, cps + 3, boost::text::variable_weighting::non_ignorable);

    EXPECT_EQ(collation.size(), 12);
    EXPECT_TRUE(boost::algorithm::equal(collation.begin(), collation.end(), ces, ces + 12))
        << "from:     " << ce_dumper(cps)
        << "expected: " << ce_dumper(ces)
        << "got:      " << ce_dumper(collation);
}

TEST(collation, non_ignorable_121_372)
{
    // 01B0 0340 0334;	
    // (ừ) LATIN SMALL LETTER U WITH HORN, COMBINING GRAVE TONE MARK	[1F1B | 0020 004A 003F 0025 | 0002 0002 0002 0002 |]

    uint32_t cps[3] = { 0x01B0, 0x0340, 0x0334 };
    uint32_t const ces[12] = { 0x1F1B, 0x0000, 0x0020, 0x004A, 0x003F, 0x0025, 0x0000, 0x0002, 0x0002, 0x0002, 0x0002, 0x0000 };

    auto collation = collate_for_tests(
        cps, cps + 3, boost::text::variable_weighting::non_ignorable);

    EXPECT_EQ(collation.size(), 12);
    EXPECT_TRUE(boost::algorithm::equal(collation.begin(), collation.end(), ces, ces + 12))
        << "from:     " << ce_dumper(cps)
        << "expected: " << ce_dumper(ces)
        << "got:      " << ce_dumper(collation);
}

TEST(collation, non_ignorable_121_373)
{
    // 0055 0300 0334 031B;	
    // (Ù̴) LATIN CAPITAL LETTER U, COMBINING GRAVE ACCENT, COMBINING TILDE OVERLAY	[1F1B | 0020 004A 003F 0025 | 0008 0002 0002 0002 |]

    uint32_t cps[4] = { 0x0055, 0x0300, 0x0334, 0x031B };
    uint32_t const ces[12] = { 0x1F1B, 0x0000, 0x0020, 0x004A, 0x003F, 0x0025, 0x0000, 0x0008, 0x0002, 0x0002, 0x0002, 0x0000 };

    auto collation = collate_for_tests(
        cps, cps + 4, boost::text::variable_weighting::non_ignorable);

    EXPECT_EQ(collation.size(), 12);
    EXPECT_TRUE(boost::algorithm::equal(collation.begin(), collation.end(), ces, ces + 12))
        << "from:     " << ce_dumper(cps)
        << "expected: " << ce_dumper(ces)
        << "got:      " << ce_dumper(collation);
}

TEST(collation, non_ignorable_121_374)
{
    // 0055 031B 0334 0300;	
    // (Ư̴) LATIN CAPITAL LETTER U, COMBINING HORN, COMBINING TILDE OVERLAY	[1F1B | 0020 004A 003F 0025 | 0008 0002 0002 0002 |]

    uint32_t cps[4] = { 0x0055, 0x031B, 0x0334, 0x0300 };
    uint32_t const ces[12] = { 0x1F1B, 0x0000, 0x0020, 0x004A, 0x003F, 0x0025, 0x0000, 0x0008, 0x0002, 0x0002, 0x0002, 0x0000 };

    auto collation = collate_for_tests(
        cps, cps + 4, boost::text::variable_weighting::non_ignorable);

    EXPECT_EQ(collation.size(), 12);
    EXPECT_TRUE(boost::algorithm::equal(collation.begin(), collation.end(), ces, ces + 12))
        << "from:     " << ce_dumper(cps)
        << "expected: " << ce_dumper(ces)
        << "got:      " << ce_dumper(collation);
}

TEST(collation, non_ignorable_121_375)
{
    // 0055 031B 0334 0340;	
    // (Ư̴) LATIN CAPITAL LETTER U, COMBINING HORN, COMBINING TILDE OVERLAY	[1F1B | 0020 004A 003F 0025 | 0008 0002 0002 0002 |]

    uint32_t cps[4] = { 0x0055, 0x031B, 0x0334, 0x0340 };
    uint32_t const ces[12] = { 0x1F1B, 0x0000, 0x0020, 0x004A, 0x003F, 0x0025, 0x0000, 0x0008, 0x0002, 0x0002, 0x0002, 0x0000 };

    auto collation = collate_for_tests(
        cps, cps + 4, boost::text::variable_weighting::non_ignorable);

    EXPECT_EQ(collation.size(), 12);
    EXPECT_TRUE(boost::algorithm::equal(collation.begin(), collation.end(), ces, ces + 12))
        << "from:     " << ce_dumper(cps)
        << "expected: " << ce_dumper(ces)
        << "got:      " << ce_dumper(collation);
}

TEST(collation, non_ignorable_121_376)
{
    // 0055 0340 0334 031B;	
    // (Ù̴) LATIN CAPITAL LETTER U, COMBINING GRAVE TONE MARK, COMBINING TILDE OVERLAY	[1F1B | 0020 004A 003F 0025 | 0008 0002 0002 0002 |]

    uint32_t cps[4] = { 0x0055, 0x0340, 0x0334, 0x031B };
    uint32_t const ces[12] = { 0x1F1B, 0x0000, 0x0020, 0x004A, 0x003F, 0x0025, 0x0000, 0x0008, 0x0002, 0x0002, 0x0002, 0x0000 };

    auto collation = collate_for_tests(
        cps, cps + 4, boost::text::variable_weighting::non_ignorable);

    EXPECT_EQ(collation.size(), 12);
    EXPECT_TRUE(boost::algorithm::equal(collation.begin(), collation.end(), ces, ces + 12))
        << "from:     " << ce_dumper(cps)
        << "expected: " << ce_dumper(ces)
        << "got:      " << ce_dumper(collation);
}

TEST(collation, non_ignorable_121_377)
{
    // 0075 0303 0334 031B;	
    // (ũ̴) LATIN SMALL LETTER U, COMBINING TILDE, COMBINING TILDE OVERLAY	[1F1B | 0020 004A 003F 002D | 0002 0002 0002 0002 |]

    uint32_t cps[4] = { 0x0075, 0x0303, 0x0334, 0x031B };
    uint32_t const ces[12] = { 0x1F1B, 0x0000, 0x0020, 0x004A, 0x003F, 0x002D, 0x0000, 0x0002, 0x0002, 0x0002, 0x0002, 0x0000 };

    auto collation = collate_for_tests(
        cps, cps + 4, boost::text::variable_weighting::non_ignorable);

    EXPECT_EQ(collation.size(), 12);
    EXPECT_TRUE(boost::algorithm::equal(collation.begin(), collation.end(), ces, ces + 12))
        << "from:     " << ce_dumper(cps)
        << "expected: " << ce_dumper(ces)
        << "got:      " << ce_dumper(collation);
}

TEST(collation, non_ignorable_121_378)
{
    // 0075 031B 0334 0303;	
    // (ư̴) LATIN SMALL LETTER U, COMBINING HORN, COMBINING TILDE OVERLAY	[1F1B | 0020 004A 003F 002D | 0002 0002 0002 0002 |]

    uint32_t cps[4] = { 0x0075, 0x031B, 0x0334, 0x0303 };
    uint32_t const ces[12] = { 0x1F1B, 0x0000, 0x0020, 0x004A, 0x003F, 0x002D, 0x0000, 0x0002, 0x0002, 0x0002, 0x0002, 0x0000 };

    auto collation = collate_for_tests(
        cps, cps + 4, boost::text::variable_weighting::non_ignorable);

    EXPECT_EQ(collation.size(), 12);
    EXPECT_TRUE(boost::algorithm::equal(collation.begin(), collation.end(), ces, ces + 12))
        << "from:     " << ce_dumper(cps)
        << "expected: " << ce_dumper(ces)
        << "got:      " << ce_dumper(collation);
}

TEST(collation, non_ignorable_121_379)
{
    // 0075 0334 031B 0303;	
    // (ư̴) LATIN SMALL LETTER U, COMBINING TILDE OVERLAY, COMBINING HORN	[1F1B | 0020 004A 003F 002D | 0002 0002 0002 0002 |]

    uint32_t cps[4] = { 0x0075, 0x0334, 0x031B, 0x0303 };
    uint32_t const ces[12] = { 0x1F1B, 0x0000, 0x0020, 0x004A, 0x003F, 0x002D, 0x0000, 0x0002, 0x0002, 0x0002, 0x0002, 0x0000 };

    auto collation = collate_for_tests(
        cps, cps + 4, boost::text::variable_weighting::non_ignorable);

    EXPECT_EQ(collation.size(), 12);
    EXPECT_TRUE(boost::algorithm::equal(collation.begin(), collation.end(), ces, ces + 12))
        << "from:     " << ce_dumper(cps)
        << "expected: " << ce_dumper(ces)
        << "got:      " << ce_dumper(collation);
}

TEST(collation, non_ignorable_121_380)
{
    // 0169 0334 031B;	
    // (ũ̴) LATIN SMALL LETTER U WITH TILDE, COMBINING TILDE OVERLAY	[1F1B | 0020 004A 003F 002D | 0002 0002 0002 0002 |]

    uint32_t cps[3] = { 0x0169, 0x0334, 0x031B };
    uint32_t const ces[12] = { 0x1F1B, 0x0000, 0x0020, 0x004A, 0x003F, 0x002D, 0x0000, 0x0002, 0x0002, 0x0002, 0x0002, 0x0000 };

    auto collation = collate_for_tests(
        cps, cps + 3, boost::text::variable_weighting::non_ignorable);

    EXPECT_EQ(collation.size(), 12);
    EXPECT_TRUE(boost::algorithm::equal(collation.begin(), collation.end(), ces, ces + 12))
        << "from:     " << ce_dumper(cps)
        << "expected: " << ce_dumper(ces)
        << "got:      " << ce_dumper(collation);
}

TEST(collation, non_ignorable_121_381)
{
    // 0055 031B 0303 0334;	
    // (Ữ) LATIN CAPITAL LETTER U, COMBINING HORN, COMBINING TILDE	[1F1B | 0020 004A 003F 002D | 0008 0002 0002 0002 |]

    uint32_t cps[4] = { 0x0055, 0x031B, 0x0303, 0x0334 };
    uint32_t const ces[12] = { 0x1F1B, 0x0000, 0x0020, 0x004A, 0x003F, 0x002D, 0x0000, 0x0008, 0x0002, 0x0002, 0x0002, 0x0000 };

    auto collation = collate_for_tests(
        cps, cps + 4, boost::text::variable_weighting::non_ignorable);

    EXPECT_EQ(collation.size(), 12);
    EXPECT_TRUE(boost::algorithm::equal(collation.begin(), collation.end(), ces, ces + 12))
        << "from:     " << ce_dumper(cps)
        << "expected: " << ce_dumper(ces)
        << "got:      " << ce_dumper(collation);
}

TEST(collation, non_ignorable_121_382)
{
    // 0055 0334 0303 031B;	
    // (Ũ̴) LATIN CAPITAL LETTER U, COMBINING TILDE OVERLAY, COMBINING TILDE	[1F1B | 0020 004A 003F 002D | 0008 0002 0002 0002 |]

    uint32_t cps[4] = { 0x0055, 0x0334, 0x0303, 0x031B };
    uint32_t const ces[12] = { 0x1F1B, 0x0000, 0x0020, 0x004A, 0x003F, 0x002D, 0x0000, 0x0008, 0x0002, 0x0002, 0x0002, 0x0000 };

    auto collation = collate_for_tests(
        cps, cps + 4, boost::text::variable_weighting::non_ignorable);

    EXPECT_EQ(collation.size(), 12);
    EXPECT_TRUE(boost::algorithm::equal(collation.begin(), collation.end(), ces, ces + 12))
        << "from:     " << ce_dumper(cps)
        << "expected: " << ce_dumper(ces)
        << "got:      " << ce_dumper(collation);
}

TEST(collation, non_ignorable_121_383)
{
    // 0055 0334 031B 0303;	
    // (Ư̴) LATIN CAPITAL LETTER U, COMBINING TILDE OVERLAY, COMBINING HORN	[1F1B | 0020 004A 003F 002D | 0008 0002 0002 0002 |]

    uint32_t cps[4] = { 0x0055, 0x0334, 0x031B, 0x0303 };
    uint32_t const ces[12] = { 0x1F1B, 0x0000, 0x0020, 0x004A, 0x003F, 0x002D, 0x0000, 0x0008, 0x0002, 0x0002, 0x0002, 0x0000 };

    auto collation = collate_for_tests(
        cps, cps + 4, boost::text::variable_weighting::non_ignorable);

    EXPECT_EQ(collation.size(), 12);
    EXPECT_TRUE(boost::algorithm::equal(collation.begin(), collation.end(), ces, ces + 12))
        << "from:     " << ce_dumper(cps)
        << "expected: " << ce_dumper(ces)
        << "got:      " << ce_dumper(collation);
}

TEST(collation, non_ignorable_121_384)
{
    // 0168 031B 0334;	
    // (Ữ) LATIN CAPITAL LETTER U WITH TILDE, COMBINING HORN	[1F1B | 0020 004A 003F 002D | 0008 0002 0002 0002 |]

    uint32_t cps[3] = { 0x0168, 0x031B, 0x0334 };
    uint32_t const ces[12] = { 0x1F1B, 0x0000, 0x0020, 0x004A, 0x003F, 0x002D, 0x0000, 0x0008, 0x0002, 0x0002, 0x0002, 0x0000 };

    auto collation = collate_for_tests(
        cps, cps + 3, boost::text::variable_weighting::non_ignorable);

    EXPECT_EQ(collation.size(), 12);
    EXPECT_TRUE(boost::algorithm::equal(collation.begin(), collation.end(), ces, ces + 12))
        << "from:     " << ce_dumper(cps)
        << "expected: " << ce_dumper(ces)
        << "got:      " << ce_dumper(collation);
}

TEST(collation, non_ignorable_121_385)
{
    // 0075 031B 0309 0334;	
    // (ử) LATIN SMALL LETTER U, COMBINING HORN, COMBINING HOOK ABOVE	[1F1B | 0020 004A 003F 003B | 0002 0002 0002 0002 |]

    uint32_t cps[4] = { 0x0075, 0x031B, 0x0309, 0x0334 };
    uint32_t const ces[12] = { 0x1F1B, 0x0000, 0x0020, 0x004A, 0x003F, 0x003B, 0x0000, 0x0002, 0x0002, 0x0002, 0x0002, 0x0000 };

    auto collation = collate_for_tests(
        cps, cps + 4, boost::text::variable_weighting::non_ignorable);

    EXPECT_EQ(collation.size(), 12);
    EXPECT_TRUE(boost::algorithm::equal(collation.begin(), collation.end(), ces, ces + 12))
        << "from:     " << ce_dumper(cps)
        << "expected: " << ce_dumper(ces)
        << "got:      " << ce_dumper(collation);
}

TEST(collation, non_ignorable_121_386)
{
    // 0075 0334 0309 031B;	
    // (ủ̴) LATIN SMALL LETTER U, COMBINING TILDE OVERLAY, COMBINING HOOK ABOVE	[1F1B | 0020 004A 003F 003B | 0002 0002 0002 0002 |]

    uint32_t cps[4] = { 0x0075, 0x0334, 0x0309, 0x031B };
    uint32_t const ces[12] = { 0x1F1B, 0x0000, 0x0020, 0x004A, 0x003F, 0x003B, 0x0000, 0x0002, 0x0002, 0x0002, 0x0002, 0x0000 };

    auto collation = collate_for_tests(
        cps, cps + 4, boost::text::variable_weighting::non_ignorable);

    EXPECT_EQ(collation.size(), 12);
    EXPECT_TRUE(boost::algorithm::equal(collation.begin(), collation.end(), ces, ces + 12))
        << "from:     " << ce_dumper(cps)
        << "expected: " << ce_dumper(ces)
        << "got:      " << ce_dumper(collation);
}

TEST(collation, non_ignorable_121_387)
{
    // 01B0 0334 0309;	
    // (ư̴) LATIN SMALL LETTER U WITH HORN, COMBINING TILDE OVERLAY	[1F1B | 0020 004A 003F 003B | 0002 0002 0002 0002 |]

    uint32_t cps[3] = { 0x01B0, 0x0334, 0x0309 };
    uint32_t const ces[12] = { 0x1F1B, 0x0000, 0x0020, 0x004A, 0x003F, 0x003B, 0x0000, 0x0002, 0x0002, 0x0002, 0x0002, 0x0000 };

    auto collation = collate_for_tests(
        cps, cps + 3, boost::text::variable_weighting::non_ignorable);

    EXPECT_EQ(collation.size(), 12);
    EXPECT_TRUE(boost::algorithm::equal(collation.begin(), collation.end(), ces, ces + 12))
        << "from:     " << ce_dumper(cps)
        << "expected: " << ce_dumper(ces)
        << "got:      " << ce_dumper(collation);
}

TEST(collation, non_ignorable_121_388)
{
    // 1EED 0334;	
    // (ử) LATIN SMALL LETTER U WITH HORN AND HOOK ABOVE	[1F1B | 0020 004A 003F 003B | 0002 0002 0002 0002 |]

    uint32_t cps[2] = { 0x1EED, 0x0334 };
    uint32_t const ces[12] = { 0x1F1B, 0x0000, 0x0020, 0x004A, 0x003F, 0x003B, 0x0000, 0x0002, 0x0002, 0x0002, 0x0002, 0x0000 };

    auto collation = collate_for_tests(
        cps, cps + 2, boost::text::variable_weighting::non_ignorable);

    EXPECT_EQ(collation.size(), 12);
    EXPECT_TRUE(boost::algorithm::equal(collation.begin(), collation.end(), ces, ces + 12))
        << "from:     " << ce_dumper(cps)
        << "expected: " << ce_dumper(ces)
        << "got:      " << ce_dumper(collation);
}

TEST(collation, non_ignorable_121_389)
{
    // 0055 031B 0309 0334;	
    // (Ử) LATIN CAPITAL LETTER U, COMBINING HORN, COMBINING HOOK ABOVE	[1F1B | 0020 004A 003F 003B | 0008 0002 0002 0002 |]

    uint32_t cps[4] = { 0x0055, 0x031B, 0x0309, 0x0334 };
    uint32_t const ces[12] = { 0x1F1B, 0x0000, 0x0020, 0x004A, 0x003F, 0x003B, 0x0000, 0x0008, 0x0002, 0x0002, 0x0002, 0x0000 };

    auto collation = collate_for_tests(
        cps, cps + 4, boost::text::variable_weighting::non_ignorable);

    EXPECT_EQ(collation.size(), 12);
    EXPECT_TRUE(boost::algorithm::equal(collation.begin(), collation.end(), ces, ces + 12))
        << "from:     " << ce_dumper(cps)
        << "expected: " << ce_dumper(ces)
        << "got:      " << ce_dumper(collation);
}

TEST(collation, non_ignorable_121_390)
{
    // 0055 0334 0309 031B;	
    // (Ủ̴) LATIN CAPITAL LETTER U, COMBINING TILDE OVERLAY, COMBINING HOOK ABOVE	[1F1B | 0020 004A 003F 003B | 0008 0002 0002 0002 |]

    uint32_t cps[4] = { 0x0055, 0x0334, 0x0309, 0x031B };
    uint32_t const ces[12] = { 0x1F1B, 0x0000, 0x0020, 0x004A, 0x003F, 0x003B, 0x0000, 0x0008, 0x0002, 0x0002, 0x0002, 0x0000 };

    auto collation = collate_for_tests(
        cps, cps + 4, boost::text::variable_weighting::non_ignorable);

    EXPECT_EQ(collation.size(), 12);
    EXPECT_TRUE(boost::algorithm::equal(collation.begin(), collation.end(), ces, ces + 12))
        << "from:     " << ce_dumper(cps)
        << "expected: " << ce_dumper(ces)
        << "got:      " << ce_dumper(collation);
}

TEST(collation, non_ignorable_121_391)
{
    // 01AF 0334 0309;	
    // (Ư̴) LATIN CAPITAL LETTER U WITH HORN, COMBINING TILDE OVERLAY	[1F1B | 0020 004A 003F 003B | 0008 0002 0002 0002 |]

    uint32_t cps[3] = { 0x01AF, 0x0334, 0x0309 };
    uint32_t const ces[12] = { 0x1F1B, 0x0000, 0x0020, 0x004A, 0x003F, 0x003B, 0x0000, 0x0008, 0x0002, 0x0002, 0x0002, 0x0000 };

    auto collation = collate_for_tests(
        cps, cps + 3, boost::text::variable_weighting::non_ignorable);

    EXPECT_EQ(collation.size(), 12);
    EXPECT_TRUE(boost::algorithm::equal(collation.begin(), collation.end(), ces, ces + 12))
        << "from:     " << ce_dumper(cps)
        << "expected: " << ce_dumper(ces)
        << "got:      " << ce_dumper(collation);
}

TEST(collation, non_ignorable_121_392)
{
    // 1EE6 0334 031B;	
    // (Ủ̴) LATIN CAPITAL LETTER U WITH HOOK ABOVE, COMBINING TILDE OVERLAY	[1F1B | 0020 004A 003F 003B | 0008 0002 0002 0002 |]

    uint32_t cps[3] = { 0x1EE6, 0x0334, 0x031B };
    uint32_t const ces[12] = { 0x1F1B, 0x0000, 0x0020, 0x004A, 0x003F, 0x003B, 0x0000, 0x0008, 0x0002, 0x0002, 0x0002, 0x0000 };

    auto collation = collate_for_tests(
        cps, cps + 3, boost::text::variable_weighting::non_ignorable);

    EXPECT_EQ(collation.size(), 12);
    EXPECT_TRUE(boost::algorithm::equal(collation.begin(), collation.end(), ces, ces + 12))
        << "from:     " << ce_dumper(cps)
        << "expected: " << ce_dumper(ces)
        << "got:      " << ce_dumper(collation);
}

TEST(collation, non_ignorable_121_393)
{
    // 0075 031B 0334 0323;	
    // (ư̴) LATIN SMALL LETTER U, COMBINING HORN, COMBINING TILDE OVERLAY	[1F1B | 0020 004A 003F 0042 | 0002 0002 0002 0002 |]

    uint32_t cps[4] = { 0x0075, 0x031B, 0x0334, 0x0323 };
    uint32_t const ces[12] = { 0x1F1B, 0x0000, 0x0020, 0x004A, 0x003F, 0x0042, 0x0000, 0x0002, 0x0002, 0x0002, 0x0002, 0x0000 };

    auto collation = collate_for_tests(
        cps, cps + 4, boost::text::variable_weighting::non_ignorable);

    EXPECT_EQ(collation.size(), 12);
    EXPECT_TRUE(boost::algorithm::equal(collation.begin(), collation.end(), ces, ces + 12))
        << "from:     " << ce_dumper(cps)
        << "expected: " << ce_dumper(ces)
        << "got:      " << ce_dumper(collation);
}

TEST(collation, non_ignorable_121_394)
{
    // 0075 0323 0334 031B;	
    // (ụ̴) LATIN SMALL LETTER U, COMBINING DOT BELOW, COMBINING TILDE OVERLAY	[1F1B | 0020 004A 003F 0042 | 0002 0002 0002 0002 |]

    uint32_t cps[4] = { 0x0075, 0x0323, 0x0334, 0x031B };
    uint32_t const ces[12] = { 0x1F1B, 0x0000, 0x0020, 0x004A, 0x003F, 0x0042, 0x0000, 0x0002, 0x0002, 0x0002, 0x0002, 0x0000 };

    auto collation = collate_for_tests(
        cps, cps + 4, boost::text::variable_weighting::non_ignorable);

    EXPECT_EQ(collation.size(), 12);
    EXPECT_TRUE(boost::algorithm::equal(collation.begin(), collation.end(), ces, ces + 12))
        << "from:     " << ce_dumper(cps)
        << "expected: " << ce_dumper(ces)
        << "got:      " << ce_dumper(collation);
}

TEST(collation, non_ignorable_121_395)
{
    // 0075 0334 031B 0323;	
    // (ư̴) LATIN SMALL LETTER U, COMBINING TILDE OVERLAY, COMBINING HORN	[1F1B | 0020 004A 003F 0042 | 0002 0002 0002 0002 |]

    uint32_t cps[4] = { 0x0075, 0x0334, 0x031B, 0x0323 };
    uint32_t const ces[12] = { 0x1F1B, 0x0000, 0x0020, 0x004A, 0x003F, 0x0042, 0x0000, 0x0002, 0x0002, 0x0002, 0x0002, 0x0000 };

    auto collation = collate_for_tests(
        cps, cps + 4, boost::text::variable_weighting::non_ignorable);

    EXPECT_EQ(collation.size(), 12);
    EXPECT_TRUE(boost::algorithm::equal(collation.begin(), collation.end(), ces, ces + 12))
        << "from:     " << ce_dumper(cps)
        << "expected: " << ce_dumper(ces)
        << "got:      " << ce_dumper(collation);
}

TEST(collation, non_ignorable_121_396)
{
    // 1EF1 0334;	
    // (ự) LATIN SMALL LETTER U WITH HORN AND DOT BELOW	[1F1B | 0020 004A 003F 0042 | 0002 0002 0002 0002 |]

    uint32_t cps[2] = { 0x1EF1, 0x0334 };
    uint32_t const ces[12] = { 0x1F1B, 0x0000, 0x0020, 0x004A, 0x003F, 0x0042, 0x0000, 0x0002, 0x0002, 0x0002, 0x0002, 0x0000 };

    auto collation = collate_for_tests(
        cps, cps + 2, boost::text::variable_weighting::non_ignorable);

    EXPECT_EQ(collation.size(), 12);
    EXPECT_TRUE(boost::algorithm::equal(collation.begin(), collation.end(), ces, ces + 12))
        << "from:     " << ce_dumper(cps)
        << "expected: " << ce_dumper(ces)
        << "got:      " << ce_dumper(collation);
}

TEST(collation, non_ignorable_121_397)
{
    // 0055 031B 0323 0334;	
    // (Ự) LATIN CAPITAL LETTER U, COMBINING HORN, COMBINING DOT BELOW	[1F1B | 0020 004A 003F 0042 | 0008 0002 0002 0002 |]

    uint32_t cps[4] = { 0x0055, 0x031B, 0x0323, 0x0334 };
    uint32_t const ces[12] = { 0x1F1B, 0x0000, 0x0020, 0x004A, 0x003F, 0x0042, 0x0000, 0x0008, 0x0002, 0x0002, 0x0002, 0x0000 };

    auto collation = collate_for_tests(
        cps, cps + 4, boost::text::variable_weighting::non_ignorable);

    EXPECT_EQ(collation.size(), 12);
    EXPECT_TRUE(boost::algorithm::equal(collation.begin(), collation.end(), ces, ces + 12))
        << "from:     " << ce_dumper(cps)
        << "expected: " << ce_dumper(ces)
        << "got:      " << ce_dumper(collation);
}

TEST(collation, non_ignorable_121_398)
{
    // 0055 0323 031B 0334;	
    // (Ự) LATIN CAPITAL LETTER U, COMBINING DOT BELOW, COMBINING HORN	[1F1B | 0020 004A 003F 0042 | 0008 0002 0002 0002 |]

    uint32_t cps[4] = { 0x0055, 0x0323, 0x031B, 0x0334 };
    uint32_t const ces[12] = { 0x1F1B, 0x0000, 0x0020, 0x004A, 0x003F, 0x0042, 0x0000, 0x0008, 0x0002, 0x0002, 0x0002, 0x0000 };

    auto collation = collate_for_tests(
        cps, cps + 4, boost::text::variable_weighting::non_ignorable);

    EXPECT_EQ(collation.size(), 12);
    EXPECT_TRUE(boost::algorithm::equal(collation.begin(), collation.end(), ces, ces + 12))
        << "from:     " << ce_dumper(cps)
        << "expected: " << ce_dumper(ces)
        << "got:      " << ce_dumper(collation);
}

TEST(collation, non_ignorable_121_399)
{
    // 0055 0334 031B 0323;	
    // (Ư̴) LATIN CAPITAL LETTER U, COMBINING TILDE OVERLAY, COMBINING HORN	[1F1B | 0020 004A 003F 0042 | 0008 0002 0002 0002 |]

    uint32_t cps[4] = { 0x0055, 0x0334, 0x031B, 0x0323 };
    uint32_t const ces[12] = { 0x1F1B, 0x0000, 0x0020, 0x004A, 0x003F, 0x0042, 0x0000, 0x0008, 0x0002, 0x0002, 0x0002, 0x0000 };

    auto collation = collate_for_tests(
        cps, cps + 4, boost::text::variable_weighting::non_ignorable);

    EXPECT_EQ(collation.size(), 12);
    EXPECT_TRUE(boost::algorithm::equal(collation.begin(), collation.end(), ces, ces + 12))
        << "from:     " << ce_dumper(cps)
        << "expected: " << ce_dumper(ces)
        << "got:      " << ce_dumper(collation);
}

TEST(collation, non_ignorable_121_400)
{
    // 0055 0334 0323 031B;	
    // (Ụ̴) LATIN CAPITAL LETTER U, COMBINING TILDE OVERLAY, COMBINING DOT BELOW	[1F1B | 0020 004A 003F 0042 | 0008 0002 0002 0002 |]

    uint32_t cps[4] = { 0x0055, 0x0334, 0x0323, 0x031B };
    uint32_t const ces[12] = { 0x1F1B, 0x0000, 0x0020, 0x004A, 0x003F, 0x0042, 0x0000, 0x0008, 0x0002, 0x0002, 0x0002, 0x0000 };

    auto collation = collate_for_tests(
        cps, cps + 4, boost::text::variable_weighting::non_ignorable);

    EXPECT_EQ(collation.size(), 12);
    EXPECT_TRUE(boost::algorithm::equal(collation.begin(), collation.end(), ces, ces + 12))
        << "from:     " << ce_dumper(cps)
        << "expected: " << ce_dumper(ces)
        << "got:      " << ce_dumper(collation);
}

TEST(collation, non_ignorable_121_401)
{
    // 0075 0323 0334;	
    // (ụ) LATIN SMALL LETTER U, COMBINING DOT BELOW	[1F1B | 0020 004A 0042 | 0002 0002 0002 |]

    uint32_t cps[3] = { 0x0075, 0x0323, 0x0334 };
    uint32_t const ces[10] = { 0x1F1B, 0x0000, 0x0020, 0x004A, 0x0042, 0x0000, 0x0002, 0x0002, 0x0002, 0x0000 };

    auto collation = collate_for_tests(
        cps, cps + 3, boost::text::variable_weighting::non_ignorable);

    EXPECT_EQ(collation.size(), 10);
    EXPECT_TRUE(boost::algorithm::equal(collation.begin(), collation.end(), ces, ces + 10))
        << "from:     " << ce_dumper(cps)
        << "expected: " << ce_dumper(ces)
        << "got:      " << ce_dumper(collation);
}

TEST(collation, non_ignorable_121_402)
{
    // 0075 0334 0323;	
    // (u̴) LATIN SMALL LETTER U, COMBINING TILDE OVERLAY	[1F1B | 0020 004A 0042 | 0002 0002 0002 |]

    uint32_t cps[3] = { 0x0075, 0x0334, 0x0323 };
    uint32_t const ces[10] = { 0x1F1B, 0x0000, 0x0020, 0x004A, 0x0042, 0x0000, 0x0002, 0x0002, 0x0002, 0x0000 };

    auto collation = collate_for_tests(
        cps, cps + 3, boost::text::variable_weighting::non_ignorable);

    EXPECT_EQ(collation.size(), 10);
    EXPECT_TRUE(boost::algorithm::equal(collation.begin(), collation.end(), ces, ces + 10))
        << "from:     " << ce_dumper(cps)
        << "expected: " << ce_dumper(ces)
        << "got:      " << ce_dumper(collation);
}

TEST(collation, non_ignorable_121_403)
{
    // 1EE5 0334;	
    // (ụ) LATIN SMALL LETTER U WITH DOT BELOW	[1F1B | 0020 004A 0042 | 0002 0002 0002 |]

    uint32_t cps[2] = { 0x1EE5, 0x0334 };
    uint32_t const ces[10] = { 0x1F1B, 0x0000, 0x0020, 0x004A, 0x0042, 0x0000, 0x0002, 0x0002, 0x0002, 0x0000 };

    auto collation = collate_for_tests(
        cps, cps + 2, boost::text::variable_weighting::non_ignorable);

    EXPECT_EQ(collation.size(), 10);
    EXPECT_TRUE(boost::algorithm::equal(collation.begin(), collation.end(), ces, ces + 10))
        << "from:     " << ce_dumper(cps)
        << "expected: " << ce_dumper(ces)
        << "got:      " << ce_dumper(collation);
}

TEST(collation, non_ignorable_121_404)
{
    // 0055 0323 0334;	
    // (Ụ) LATIN CAPITAL LETTER U, COMBINING DOT BELOW	[1F1B | 0020 004A 0042 | 0008 0002 0002 |]

    uint32_t cps[3] = { 0x0055, 0x0323, 0x0334 };
    uint32_t const ces[10] = { 0x1F1B, 0x0000, 0x0020, 0x004A, 0x0042, 0x0000, 0x0008, 0x0002, 0x0002, 0x0000 };

    auto collation = collate_for_tests(
        cps, cps + 3, boost::text::variable_weighting::non_ignorable);

    EXPECT_EQ(collation.size(), 10);
    EXPECT_TRUE(boost::algorithm::equal(collation.begin(), collation.end(), ces, ces + 10))
        << "from:     " << ce_dumper(cps)
        << "expected: " << ce_dumper(ces)
        << "got:      " << ce_dumper(collation);
}

TEST(collation, non_ignorable_121_405)
{
    // 0055 0334 0323;	
    // (U̴) LATIN CAPITAL LETTER U, COMBINING TILDE OVERLAY	[1F1B | 0020 004A 0042 | 0008 0002 0002 |]

    uint32_t cps[3] = { 0x0055, 0x0334, 0x0323 };
    uint32_t const ces[10] = { 0x1F1B, 0x0000, 0x0020, 0x004A, 0x0042, 0x0000, 0x0008, 0x0002, 0x0002, 0x0000 };

    auto collation = collate_for_tests(
        cps, cps + 3, boost::text::variable_weighting::non_ignorable);

    EXPECT_EQ(collation.size(), 10);
    EXPECT_TRUE(boost::algorithm::equal(collation.begin(), collation.end(), ces, ces + 10))
        << "from:     " << ce_dumper(cps)
        << "expected: " << ce_dumper(ces)
        << "got:      " << ce_dumper(collation);
}

TEST(collation, non_ignorable_121_406)
{
    // 1EE4 0334;	
    // (Ụ) LATIN CAPITAL LETTER U WITH DOT BELOW	[1F1B | 0020 004A 0042 | 0008 0002 0002 |]

    uint32_t cps[2] = { 0x1EE4, 0x0334 };
    uint32_t const ces[10] = { 0x1F1B, 0x0000, 0x0020, 0x004A, 0x0042, 0x0000, 0x0008, 0x0002, 0x0002, 0x0000 };

    auto collation = collate_for_tests(
        cps, cps + 2, boost::text::variable_weighting::non_ignorable);

    EXPECT_EQ(collation.size(), 10);
    EXPECT_TRUE(boost::algorithm::equal(collation.begin(), collation.end(), ces, ces + 10))
        << "from:     " << ce_dumper(cps)
        << "expected: " << ce_dumper(ces)
        << "got:      " << ce_dumper(collation);
}

TEST(collation, non_ignorable_121_407)
{
    // 0075 0324 0334;	
    // (ṳ) LATIN SMALL LETTER U, COMBINING DIAERESIS BELOW	[1F1B | 0020 004A 0043 | 0002 0002 0002 |]

    uint32_t cps[3] = { 0x0075, 0x0324, 0x0334 };
    uint32_t const ces[10] = { 0x1F1B, 0x0000, 0x0020, 0x004A, 0x0043, 0x0000, 0x0002, 0x0002, 0x0002, 0x0000 };

    auto collation = collate_for_tests(
        cps, cps + 3, boost::text::variable_weighting::non_ignorable);

    EXPECT_EQ(collation.size(), 10);
    EXPECT_TRUE(boost::algorithm::equal(collation.begin(), collation.end(), ces, ces + 10))
        << "from:     " << ce_dumper(cps)
        << "expected: " << ce_dumper(ces)
        << "got:      " << ce_dumper(collation);
}

TEST(collation, non_ignorable_121_408)
{
    // 0075 0334 0324;	
    // (u̴) LATIN SMALL LETTER U, COMBINING TILDE OVERLAY	[1F1B | 0020 004A 0043 | 0002 0002 0002 |]

    uint32_t cps[3] = { 0x0075, 0x0334, 0x0324 };
    uint32_t const ces[10] = { 0x1F1B, 0x0000, 0x0020, 0x004A, 0x0043, 0x0000, 0x0002, 0x0002, 0x0002, 0x0000 };

    auto collation = collate_for_tests(
        cps, cps + 3, boost::text::variable_weighting::non_ignorable);

    EXPECT_EQ(collation.size(), 10);
    EXPECT_TRUE(boost::algorithm::equal(collation.begin(), collation.end(), ces, ces + 10))
        << "from:     " << ce_dumper(cps)
        << "expected: " << ce_dumper(ces)
        << "got:      " << ce_dumper(collation);
}

TEST(collation, non_ignorable_121_409)
{
    // 1E73 0334;	
    // (ṳ) LATIN SMALL LETTER U WITH DIAERESIS BELOW	[1F1B | 0020 004A 0043 | 0002 0002 0002 |]

    uint32_t cps[2] = { 0x1E73, 0x0334 };
    uint32_t const ces[10] = { 0x1F1B, 0x0000, 0x0020, 0x004A, 0x0043, 0x0000, 0x0002, 0x0002, 0x0002, 0x0000 };

    auto collation = collate_for_tests(
        cps, cps + 2, boost::text::variable_weighting::non_ignorable);

    EXPECT_EQ(collation.size(), 10);
    EXPECT_TRUE(boost::algorithm::equal(collation.begin(), collation.end(), ces, ces + 10))
        << "from:     " << ce_dumper(cps)
        << "expected: " << ce_dumper(ces)
        << "got:      " << ce_dumper(collation);
}

TEST(collation, non_ignorable_121_410)
{
    // 0055 0324 0334;	
    // (Ṳ) LATIN CAPITAL LETTER U, COMBINING DIAERESIS BELOW	[1F1B | 0020 004A 0043 | 0008 0002 0002 |]

    uint32_t cps[3] = { 0x0055, 0x0324, 0x0334 };
    uint32_t const ces[10] = { 0x1F1B, 0x0000, 0x0020, 0x004A, 0x0043, 0x0000, 0x0008, 0x0002, 0x0002, 0x0000 };

    auto collation = collate_for_tests(
        cps, cps + 3, boost::text::variable_weighting::non_ignorable);

    EXPECT_EQ(collation.size(), 10);
    EXPECT_TRUE(boost::algorithm::equal(collation.begin(), collation.end(), ces, ces + 10))
        << "from:     " << ce_dumper(cps)
        << "expected: " << ce_dumper(ces)
        << "got:      " << ce_dumper(collation);
}

TEST(collation, non_ignorable_121_411)
{
    // 0055 0334 0324;	
    // (U̴) LATIN CAPITAL LETTER U, COMBINING TILDE OVERLAY	[1F1B | 0020 004A 0043 | 0008 0002 0002 |]

    uint32_t cps[3] = { 0x0055, 0x0334, 0x0324 };
    uint32_t const ces[10] = { 0x1F1B, 0x0000, 0x0020, 0x004A, 0x0043, 0x0000, 0x0008, 0x0002, 0x0002, 0x0000 };

    auto collation = collate_for_tests(
        cps, cps + 3, boost::text::variable_weighting::non_ignorable);

    EXPECT_EQ(collation.size(), 10);
    EXPECT_TRUE(boost::algorithm::equal(collation.begin(), collation.end(), ces, ces + 10))
        << "from:     " << ce_dumper(cps)
        << "expected: " << ce_dumper(ces)
        << "got:      " << ce_dumper(collation);
}

TEST(collation, non_ignorable_121_412)
{
    // 1E72 0334;	
    // (Ṳ) LATIN CAPITAL LETTER U WITH DIAERESIS BELOW	[1F1B | 0020 004A 0043 | 0008 0002 0002 |]

    uint32_t cps[2] = { 0x1E72, 0x0334 };
    uint32_t const ces[10] = { 0x1F1B, 0x0000, 0x0020, 0x004A, 0x0043, 0x0000, 0x0008, 0x0002, 0x0002, 0x0000 };

    auto collation = collate_for_tests(
        cps, cps + 2, boost::text::variable_weighting::non_ignorable);

    EXPECT_EQ(collation.size(), 10);
    EXPECT_TRUE(boost::algorithm::equal(collation.begin(), collation.end(), ces, ces + 10))
        << "from:     " << ce_dumper(cps)
        << "expected: " << ce_dumper(ces)
        << "got:      " << ce_dumper(collation);
}

TEST(collation, non_ignorable_121_413)
{
    // 0075 032D 0334;	
    // (ṷ) LATIN SMALL LETTER U, COMBINING CIRCUMFLEX ACCENT BELOW	[1F1B | 0020 004A 0046 | 0002 0002 0002 |]

    uint32_t cps[3] = { 0x0075, 0x032D, 0x0334 };
    uint32_t const ces[10] = { 0x1F1B, 0x0000, 0x0020, 0x004A, 0x0046, 0x0000, 0x0002, 0x0002, 0x0002, 0x0000 };

    auto collation = collate_for_tests(
        cps, cps + 3, boost::text::variable_weighting::non_ignorable);

    EXPECT_EQ(collation.size(), 10);
    EXPECT_TRUE(boost::algorithm::equal(collation.begin(), collation.end(), ces, ces + 10))
        << "from:     " << ce_dumper(cps)
        << "expected: " << ce_dumper(ces)
        << "got:      " << ce_dumper(collation);
}

TEST(collation, non_ignorable_121_414)
{
    // 0075 0334 032D;	
    // (u̴) LATIN SMALL LETTER U, COMBINING TILDE OVERLAY	[1F1B | 0020 004A 0046 | 0002 0002 0002 |]

    uint32_t cps[3] = { 0x0075, 0x0334, 0x032D };
    uint32_t const ces[10] = { 0x1F1B, 0x0000, 0x0020, 0x004A, 0x0046, 0x0000, 0x0002, 0x0002, 0x0002, 0x0000 };

    auto collation = collate_for_tests(
        cps, cps + 3, boost::text::variable_weighting::non_ignorable);

    EXPECT_EQ(collation.size(), 10);
    EXPECT_TRUE(boost::algorithm::equal(collation.begin(), collation.end(), ces, ces + 10))
        << "from:     " << ce_dumper(cps)
        << "expected: " << ce_dumper(ces)
        << "got:      " << ce_dumper(collation);
}

TEST(collation, non_ignorable_121_415)
{
    // 1E77 0334;	
    // (ṷ) LATIN SMALL LETTER U WITH CIRCUMFLEX BELOW	[1F1B | 0020 004A 0046 | 0002 0002 0002 |]

    uint32_t cps[2] = { 0x1E77, 0x0334 };
    uint32_t const ces[10] = { 0x1F1B, 0x0000, 0x0020, 0x004A, 0x0046, 0x0000, 0x0002, 0x0002, 0x0002, 0x0000 };

    auto collation = collate_for_tests(
        cps, cps + 2, boost::text::variable_weighting::non_ignorable);

    EXPECT_EQ(collation.size(), 10);
    EXPECT_TRUE(boost::algorithm::equal(collation.begin(), collation.end(), ces, ces + 10))
        << "from:     " << ce_dumper(cps)
        << "expected: " << ce_dumper(ces)
        << "got:      " << ce_dumper(collation);
}

TEST(collation, non_ignorable_121_416)
{
    // 0055 032D 0334;	
    // (Ṷ) LATIN CAPITAL LETTER U, COMBINING CIRCUMFLEX ACCENT BELOW	[1F1B | 0020 004A 0046 | 0008 0002 0002 |]

    uint32_t cps[3] = { 0x0055, 0x032D, 0x0334 };
    uint32_t const ces[10] = { 0x1F1B, 0x0000, 0x0020, 0x004A, 0x0046, 0x0000, 0x0008, 0x0002, 0x0002, 0x0000 };

    auto collation = collate_for_tests(
        cps, cps + 3, boost::text::variable_weighting::non_ignorable);

    EXPECT_EQ(collation.size(), 10);
    EXPECT_TRUE(boost::algorithm::equal(collation.begin(), collation.end(), ces, ces + 10))
        << "from:     " << ce_dumper(cps)
        << "expected: " << ce_dumper(ces)
        << "got:      " << ce_dumper(collation);
}

TEST(collation, non_ignorable_121_417)
{
    // 0055 0334 032D;	
    // (U̴) LATIN CAPITAL LETTER U, COMBINING TILDE OVERLAY	[1F1B | 0020 004A 0046 | 0008 0002 0002 |]

    uint32_t cps[3] = { 0x0055, 0x0334, 0x032D };
    uint32_t const ces[10] = { 0x1F1B, 0x0000, 0x0020, 0x004A, 0x0046, 0x0000, 0x0008, 0x0002, 0x0002, 0x0000 };

    auto collation = collate_for_tests(
        cps, cps + 3, boost::text::variable_weighting::non_ignorable);

    EXPECT_EQ(collation.size(), 10);
    EXPECT_TRUE(boost::algorithm::equal(collation.begin(), collation.end(), ces, ces + 10))
        << "from:     " << ce_dumper(cps)
        << "expected: " << ce_dumper(ces)
        << "got:      " << ce_dumper(collation);
}

TEST(collation, non_ignorable_121_418)
{
    // 1E76 0334;	
    // (Ṷ) LATIN CAPITAL LETTER U WITH CIRCUMFLEX BELOW	[1F1B | 0020 004A 0046 | 0008 0002 0002 |]

    uint32_t cps[2] = { 0x1E76, 0x0334 };
    uint32_t const ces[10] = { 0x1F1B, 0x0000, 0x0020, 0x004A, 0x0046, 0x0000, 0x0008, 0x0002, 0x0002, 0x0000 };

    auto collation = collate_for_tests(
        cps, cps + 2, boost::text::variable_weighting::non_ignorable);

    EXPECT_EQ(collation.size(), 10);
    EXPECT_TRUE(boost::algorithm::equal(collation.begin(), collation.end(), ces, ces + 10))
        << "from:     " << ce_dumper(cps)
        << "expected: " << ce_dumper(ces)
        << "got:      " << ce_dumper(collation);
}

TEST(collation, non_ignorable_121_419)
{
    // 0075 0330 0334;	
    // (ṵ) LATIN SMALL LETTER U, COMBINING TILDE BELOW	[1F1B | 0020 004A 0048 | 0002 0002 0002 |]

    uint32_t cps[3] = { 0x0075, 0x0330, 0x0334 };
    uint32_t const ces[10] = { 0x1F1B, 0x0000, 0x0020, 0x004A, 0x0048, 0x0000, 0x0002, 0x0002, 0x0002, 0x0000 };

    auto collation = collate_for_tests(
        cps, cps + 3, boost::text::variable_weighting::non_ignorable);

    EXPECT_EQ(collation.size(), 10);
    EXPECT_TRUE(boost::algorithm::equal(collation.begin(), collation.end(), ces, ces + 10))
        << "from:     " << ce_dumper(cps)
        << "expected: " << ce_dumper(ces)
        << "got:      " << ce_dumper(collation);
}

TEST(collation, non_ignorable_121_420)
{
    // 0075 0334 0330;	
    // (u̴) LATIN SMALL LETTER U, COMBINING TILDE OVERLAY	[1F1B | 0020 004A 0048 | 0002 0002 0002 |]

    uint32_t cps[3] = { 0x0075, 0x0334, 0x0330 };
    uint32_t const ces[10] = { 0x1F1B, 0x0000, 0x0020, 0x004A, 0x0048, 0x0000, 0x0002, 0x0002, 0x0002, 0x0000 };

    auto collation = collate_for_tests(
        cps, cps + 3, boost::text::variable_weighting::non_ignorable);

    EXPECT_EQ(collation.size(), 10);
    EXPECT_TRUE(boost::algorithm::equal(collation.begin(), collation.end(), ces, ces + 10))
        << "from:     " << ce_dumper(cps)
        << "expected: " << ce_dumper(ces)
        << "got:      " << ce_dumper(collation);
}

TEST(collation, non_ignorable_121_421)
{
    // 1E75 0334;	
    // (ṵ) LATIN SMALL LETTER U WITH TILDE BELOW	[1F1B | 0020 004A 0048 | 0002 0002 0002 |]

    uint32_t cps[2] = { 0x1E75, 0x0334 };
    uint32_t const ces[10] = { 0x1F1B, 0x0000, 0x0020, 0x004A, 0x0048, 0x0000, 0x0002, 0x0002, 0x0002, 0x0000 };

    auto collation = collate_for_tests(
        cps, cps + 2, boost::text::variable_weighting::non_ignorable);

    EXPECT_EQ(collation.size(), 10);
    EXPECT_TRUE(boost::algorithm::equal(collation.begin(), collation.end(), ces, ces + 10))
        << "from:     " << ce_dumper(cps)
        << "expected: " << ce_dumper(ces)
        << "got:      " << ce_dumper(collation);
}

TEST(collation, non_ignorable_121_422)
{
    // 0055 0330 0334;	
    // (Ṵ) LATIN CAPITAL LETTER U, COMBINING TILDE BELOW	[1F1B | 0020 004A 0048 | 0008 0002 0002 |]

    uint32_t cps[3] = { 0x0055, 0x0330, 0x0334 };
    uint32_t const ces[10] = { 0x1F1B, 0x0000, 0x0020, 0x004A, 0x0048, 0x0000, 0x0008, 0x0002, 0x0002, 0x0000 };

    auto collation = collate_for_tests(
        cps, cps + 3, boost::text::variable_weighting::non_ignorable);

    EXPECT_EQ(collation.size(), 10);
    EXPECT_TRUE(boost::algorithm::equal(collation.begin(), collation.end(), ces, ces + 10))
        << "from:     " << ce_dumper(cps)
        << "expected: " << ce_dumper(ces)
        << "got:      " << ce_dumper(collation);
}

TEST(collation, non_ignorable_121_423)
{
    // 0055 0334 0330;	
    // (U̴) LATIN CAPITAL LETTER U, COMBINING TILDE OVERLAY	[1F1B | 0020 004A 0048 | 0008 0002 0002 |]

    uint32_t cps[3] = { 0x0055, 0x0334, 0x0330 };
    uint32_t const ces[10] = { 0x1F1B, 0x0000, 0x0020, 0x004A, 0x0048, 0x0000, 0x0008, 0x0002, 0x0002, 0x0000 };

    auto collation = collate_for_tests(
        cps, cps + 3, boost::text::variable_weighting::non_ignorable);

    EXPECT_EQ(collation.size(), 10);
    EXPECT_TRUE(boost::algorithm::equal(collation.begin(), collation.end(), ces, ces + 10))
        << "from:     " << ce_dumper(cps)
        << "expected: " << ce_dumper(ces)
        << "got:      " << ce_dumper(collation);
}

TEST(collation, non_ignorable_121_424)
{
    // 1E74 0334;	
    // (Ṵ) LATIN CAPITAL LETTER U WITH TILDE BELOW	[1F1B | 0020 004A 0048 | 0008 0002 0002 |]

    uint32_t cps[2] = { 0x1E74, 0x0334 };
    uint32_t const ces[10] = { 0x1F1B, 0x0000, 0x0020, 0x004A, 0x0048, 0x0000, 0x0008, 0x0002, 0x0002, 0x0000 };

    auto collation = collate_for_tests(
        cps, cps + 2, boost::text::variable_weighting::non_ignorable);

    EXPECT_EQ(collation.size(), 10);
    EXPECT_TRUE(boost::algorithm::equal(collation.begin(), collation.end(), ces, ces + 10))
        << "from:     " << ce_dumper(cps)
        << "expected: " << ce_dumper(ces)
        << "got:      " << ce_dumper(collation);
}

TEST(collation, non_ignorable_121_425)
{
    // 0334 0367;	
    // (ͧ) COMBINING LATIN SMALL LETTER U	[1F1B | 004A 0020 | 0002 0004 |]

    uint32_t cps[2] = { 0x0334, 0x0367 };
    uint32_t const ces[8] = { 0x1F1B, 0x0000, 0x004A, 0x0020, 0x0000, 0x0002, 0x0004, 0x0000 };

    auto collation = collate_for_tests(
        cps, cps + 2, boost::text::variable_weighting::non_ignorable);

    EXPECT_EQ(collation.size(), 8);
    EXPECT_TRUE(boost::algorithm::equal(collation.begin(), collation.end(), ces, ces + 8))
        << "from:     " << ce_dumper(cps)
        << "expected: " << ce_dumper(ces)
        << "got:      " << ce_dumper(collation);
}

TEST(collation, non_ignorable_121_426)
{
    // 0367 0334;	
    // (ͧ) COMBINING LATIN SMALL LETTER U	[1F1B | 004A 0020 | 0002 0004 |]

    uint32_t cps[2] = { 0x0367, 0x0334 };
    uint32_t const ces[8] = { 0x1F1B, 0x0000, 0x004A, 0x0020, 0x0000, 0x0002, 0x0004, 0x0000 };

    auto collation = collate_for_tests(
        cps, cps + 2, boost::text::variable_weighting::non_ignorable);

    EXPECT_EQ(collation.size(), 8);
    EXPECT_TRUE(boost::algorithm::equal(collation.begin(), collation.end(), ces, ces + 8))
        << "from:     " << ce_dumper(cps)
        << "expected: " << ce_dumper(ces)
        << "got:      " << ce_dumper(collation);
}

TEST(collation, non_ignorable_121_427)
{
    // 0334 1DF4;	
    // (ᷴ) COMBINING LATIN SMALL LETTER U WITH DIAERESIS	[1F1B | 004A 0020 002B | 0002 0004 0004 |]

    uint32_t cps[2] = { 0x0334, 0x1DF4 };
    uint32_t const ces[10] = { 0x1F1B, 0x0000, 0x004A, 0x0020, 0x002B, 0x0000, 0x0002, 0x0004, 0x0004, 0x0000 };

    auto collation = collate_for_tests(
        cps, cps + 2, boost::text::variable_weighting::non_ignorable);

    EXPECT_EQ(collation.size(), 10);
    EXPECT_TRUE(boost::algorithm::equal(collation.begin(), collation.end(), ces, ces + 10))
        << "from:     " << ce_dumper(cps)
        << "expected: " << ce_dumper(ces)
        << "got:      " << ce_dumper(collation);
}

TEST(collation, non_ignorable_121_428)
{
    // 1DF4 0334;	
    // (ᷴ) COMBINING LATIN SMALL LETTER U WITH DIAERESIS	[1F1B | 004A 0020 002B | 0002 0004 0004 |]

    uint32_t cps[2] = { 0x1DF4, 0x0334 };
    uint32_t const ces[10] = { 0x1F1B, 0x0000, 0x004A, 0x0020, 0x002B, 0x0000, 0x0002, 0x0004, 0x0004, 0x0000 };

    auto collation = collate_for_tests(
        cps, cps + 2, boost::text::variable_weighting::non_ignorable);

    EXPECT_EQ(collation.size(), 10);
    EXPECT_TRUE(boost::algorithm::equal(collation.begin(), collation.end(), ces, ces + 10))
        << "from:     " << ce_dumper(cps)
        << "expected: " << ce_dumper(ces)
        << "got:      " << ce_dumper(collation);
}

TEST(collation, non_ignorable_121_429)
{
    // 0334 1DF0;	
    // (ᷰ) COMBINING LATIN SMALL LETTER U WITH LIGHT CENTRALIZATION STROKE	[1F1B | 004A 0020 0034 | 0002 0004 0004 |]

    uint32_t cps[2] = { 0x0334, 0x1DF0 };
    uint32_t const ces[10] = { 0x1F1B, 0x0000, 0x004A, 0x0020, 0x0034, 0x0000, 0x0002, 0x0004, 0x0004, 0x0000 };

    auto collation = collate_for_tests(
        cps, cps + 2, boost::text::variable_weighting::non_ignorable);

    EXPECT_EQ(collation.size(), 10);
    EXPECT_TRUE(boost::algorithm::equal(collation.begin(), collation.end(), ces, ces + 10))
        << "from:     " << ce_dumper(cps)
        << "expected: " << ce_dumper(ces)
        << "got:      " << ce_dumper(collation);
}

TEST(collation, non_ignorable_121_430)
{
    // 1DF0 0334;	
    // (ᷰ) COMBINING LATIN SMALL LETTER U WITH LIGHT CENTRALIZATION STROKE	[1F1B | 004A 0020 0034 | 0002 0004 0004 |]

    uint32_t cps[2] = { 0x1DF0, 0x0334 };
    uint32_t const ces[10] = { 0x1F1B, 0x0000, 0x004A, 0x0020, 0x0034, 0x0000, 0x0002, 0x0004, 0x0004, 0x0000 };

    auto collation = collate_for_tests(
        cps, cps + 2, boost::text::variable_weighting::non_ignorable);

    EXPECT_EQ(collation.size(), 10);
    EXPECT_TRUE(boost::algorithm::equal(collation.begin(), collation.end(), ces, ces + 10))
        << "from:     " << ce_dumper(cps)
        << "expected: " << ce_dumper(ces)
        << "got:      " << ce_dumper(collation);
}

TEST(collation, non_ignorable_121_431)
{
    // 0075 0021;	
    // (u) LATIN SMALL LETTER U	[1F1B 0261 | 0020 0020 | 0002 0002 |]

    uint32_t cps[2] = { 0x0075, 0x0021 };
    uint32_t const ces[9] = { 0x1F1B, 0x0261, 0x0000, 0x0020, 0x0020, 0x0000, 0x0002, 0x0002, 0x0000 };

    auto collation = collate_for_tests(
        cps, cps + 2, boost::text::variable_weighting::non_ignorable);

    EXPECT_EQ(collation.size(), 9);
    EXPECT_TRUE(boost::algorithm::equal(collation.begin(), collation.end(), ces, ces + 9))
        << "from:     " << ce_dumper(cps)
        << "expected: " << ce_dumper(ces)
        << "got:      " << ce_dumper(collation);
}

TEST(collation, non_ignorable_121_432)
{
    // FF55 0021;	
    // (ｕ) FULLWIDTH LATIN SMALL LETTER U	[1F1B 0261 | 0020 0020 | 0003 0002 |]

    uint32_t cps[2] = { 0xFF55, 0x0021 };
    uint32_t const ces[9] = { 0x1F1B, 0x0261, 0x0000, 0x0020, 0x0020, 0x0000, 0x0003, 0x0002, 0x0000 };

    auto collation = collate_for_tests(
        cps, cps + 2, boost::text::variable_weighting::non_ignorable);

    EXPECT_EQ(collation.size(), 9);
    EXPECT_TRUE(boost::algorithm::equal(collation.begin(), collation.end(), ces, ces + 9))
        << "from:     " << ce_dumper(cps)
        << "expected: " << ce_dumper(ces)
        << "got:      " << ce_dumper(collation);
}

TEST(collation, non_ignorable_121_433)
{
    // 0367 0021;	
    // (ͧ) COMBINING LATIN SMALL LETTER U	[1F1B 0261 | 0020 0020 | 0004 0002 |]

    uint32_t cps[2] = { 0x0367, 0x0021 };
    uint32_t const ces[9] = { 0x1F1B, 0x0261, 0x0000, 0x0020, 0x0020, 0x0000, 0x0004, 0x0002, 0x0000 };

    auto collation = collate_for_tests(
        cps, cps + 2, boost::text::variable_weighting::non_ignorable);

    EXPECT_EQ(collation.size(), 9);
    EXPECT_TRUE(boost::algorithm::equal(collation.begin(), collation.end(), ces, ces + 9))
        << "from:     " << ce_dumper(cps)
        << "expected: " << ce_dumper(ces)
        << "got:      " << ce_dumper(collation);
}

TEST(collation, non_ignorable_121_434)
{
    // 1D42E 0021;	
    // (𝐮) MATHEMATICAL BOLD SMALL U	[1F1B 0261 | 0020 0020 | 0005 0002 |]

    uint32_t cps[2] = { 0x1D42E, 0x0021 };
    uint32_t const ces[9] = { 0x1F1B, 0x0261, 0x0000, 0x0020, 0x0020, 0x0000, 0x0005, 0x0002, 0x0000 };

    auto collation = collate_for_tests(
        cps, cps + 2, boost::text::variable_weighting::non_ignorable);

    EXPECT_EQ(collation.size(), 9);
    EXPECT_TRUE(boost::algorithm::equal(collation.begin(), collation.end(), ces, ces + 9))
        << "from:     " << ce_dumper(cps)
        << "expected: " << ce_dumper(ces)
        << "got:      " << ce_dumper(collation);
}

TEST(collation, non_ignorable_121_435)
{
    // 1D462 0021;	
    // (𝑢) MATHEMATICAL ITALIC SMALL U	[1F1B 0261 | 0020 0020 | 0005 0002 |]

    uint32_t cps[2] = { 0x1D462, 0x0021 };
    uint32_t const ces[9] = { 0x1F1B, 0x0261, 0x0000, 0x0020, 0x0020, 0x0000, 0x0005, 0x0002, 0x0000 };

    auto collation = collate_for_tests(
        cps, cps + 2, boost::text::variable_weighting::non_ignorable);

    EXPECT_EQ(collation.size(), 9);
    EXPECT_TRUE(boost::algorithm::equal(collation.begin(), collation.end(), ces, ces + 9))
        << "from:     " << ce_dumper(cps)
        << "expected: " << ce_dumper(ces)
        << "got:      " << ce_dumper(collation);
}

TEST(collation, non_ignorable_121_436)
{
    // 1D496 0021;	
    // (𝒖) MATHEMATICAL BOLD ITALIC SMALL U	[1F1B 0261 | 0020 0020 | 0005 0002 |]

    uint32_t cps[2] = { 0x1D496, 0x0021 };
    uint32_t const ces[9] = { 0x1F1B, 0x0261, 0x0000, 0x0020, 0x0020, 0x0000, 0x0005, 0x0002, 0x0000 };

    auto collation = collate_for_tests(
        cps, cps + 2, boost::text::variable_weighting::non_ignorable);

    EXPECT_EQ(collation.size(), 9);
    EXPECT_TRUE(boost::algorithm::equal(collation.begin(), collation.end(), ces, ces + 9))
        << "from:     " << ce_dumper(cps)
        << "expected: " << ce_dumper(ces)
        << "got:      " << ce_dumper(collation);
}

TEST(collation, non_ignorable_121_437)
{
    // 1D4CA 0021;	
    // (𝓊) MATHEMATICAL SCRIPT SMALL U	[1F1B 0261 | 0020 0020 | 0005 0002 |]

    uint32_t cps[2] = { 0x1D4CA, 0x0021 };
    uint32_t const ces[9] = { 0x1F1B, 0x0261, 0x0000, 0x0020, 0x0020, 0x0000, 0x0005, 0x0002, 0x0000 };

    auto collation = collate_for_tests(
        cps, cps + 2, boost::text::variable_weighting::non_ignorable);

    EXPECT_EQ(collation.size(), 9);
    EXPECT_TRUE(boost::algorithm::equal(collation.begin(), collation.end(), ces, ces + 9))
        << "from:     " << ce_dumper(cps)
        << "expected: " << ce_dumper(ces)
        << "got:      " << ce_dumper(collation);
}

TEST(collation, non_ignorable_121_438)
{
    // 1D4FE 0021;	
    // (𝓾) MATHEMATICAL BOLD SCRIPT SMALL U	[1F1B 0261 | 0020 0020 | 0005 0002 |]

    uint32_t cps[2] = { 0x1D4FE, 0x0021 };
    uint32_t const ces[9] = { 0x1F1B, 0x0261, 0x0000, 0x0020, 0x0020, 0x0000, 0x0005, 0x0002, 0x0000 };

    auto collation = collate_for_tests(
        cps, cps + 2, boost::text::variable_weighting::non_ignorable);

    EXPECT_EQ(collation.size(), 9);
    EXPECT_TRUE(boost::algorithm::equal(collation.begin(), collation.end(), ces, ces + 9))
        << "from:     " << ce_dumper(cps)
        << "expected: " << ce_dumper(ces)
        << "got:      " << ce_dumper(collation);
}

TEST(collation, non_ignorable_121_439)
{
    // 1D532 0021;	
    // (𝔲) MATHEMATICAL FRAKTUR SMALL U	[1F1B 0261 | 0020 0020 | 0005 0002 |]

    uint32_t cps[2] = { 0x1D532, 0x0021 };
    uint32_t const ces[9] = { 0x1F1B, 0x0261, 0x0000, 0x0020, 0x0020, 0x0000, 0x0005, 0x0002, 0x0000 };

    auto collation = collate_for_tests(
        cps, cps + 2, boost::text::variable_weighting::non_ignorable);

    EXPECT_EQ(collation.size(), 9);
    EXPECT_TRUE(boost::algorithm::equal(collation.begin(), collation.end(), ces, ces + 9))
        << "from:     " << ce_dumper(cps)
        << "expected: " << ce_dumper(ces)
        << "got:      " << ce_dumper(collation);
}

TEST(collation, non_ignorable_121_440)
{
    // 1D566 0021;	
    // (𝕦) MATHEMATICAL DOUBLE-STRUCK SMALL U	[1F1B 0261 | 0020 0020 | 0005 0002 |]

    uint32_t cps[2] = { 0x1D566, 0x0021 };
    uint32_t const ces[9] = { 0x1F1B, 0x0261, 0x0000, 0x0020, 0x0020, 0x0000, 0x0005, 0x0002, 0x0000 };

    auto collation = collate_for_tests(
        cps, cps + 2, boost::text::variable_weighting::non_ignorable);

    EXPECT_EQ(collation.size(), 9);
    EXPECT_TRUE(boost::algorithm::equal(collation.begin(), collation.end(), ces, ces + 9))
        << "from:     " << ce_dumper(cps)
        << "expected: " << ce_dumper(ces)
        << "got:      " << ce_dumper(collation);
}

TEST(collation, non_ignorable_121_441)
{
    // 1D59A 0021;	
    // (𝖚) MATHEMATICAL BOLD FRAKTUR SMALL U	[1F1B 0261 | 0020 0020 | 0005 0002 |]

    uint32_t cps[2] = { 0x1D59A, 0x0021 };
    uint32_t const ces[9] = { 0x1F1B, 0x0261, 0x0000, 0x0020, 0x0020, 0x0000, 0x0005, 0x0002, 0x0000 };

    auto collation = collate_for_tests(
        cps, cps + 2, boost::text::variable_weighting::non_ignorable);

    EXPECT_EQ(collation.size(), 9);
    EXPECT_TRUE(boost::algorithm::equal(collation.begin(), collation.end(), ces, ces + 9))
        << "from:     " << ce_dumper(cps)
        << "expected: " << ce_dumper(ces)
        << "got:      " << ce_dumper(collation);
}

TEST(collation, non_ignorable_121_442)
{
    // 1D5CE 0021;	
    // (𝗎) MATHEMATICAL SANS-SERIF SMALL U	[1F1B 0261 | 0020 0020 | 0005 0002 |]

    uint32_t cps[2] = { 0x1D5CE, 0x0021 };
    uint32_t const ces[9] = { 0x1F1B, 0x0261, 0x0000, 0x0020, 0x0020, 0x0000, 0x0005, 0x0002, 0x0000 };

    auto collation = collate_for_tests(
        cps, cps + 2, boost::text::variable_weighting::non_ignorable);

    EXPECT_EQ(collation.size(), 9);
    EXPECT_TRUE(boost::algorithm::equal(collation.begin(), collation.end(), ces, ces + 9))
        << "from:     " << ce_dumper(cps)
        << "expected: " << ce_dumper(ces)
        << "got:      " << ce_dumper(collation);
}

TEST(collation, non_ignorable_121_443)
{
    // 1D602 0021;	
    // (𝘂) MATHEMATICAL SANS-SERIF BOLD SMALL U	[1F1B 0261 | 0020 0020 | 0005 0002 |]

    uint32_t cps[2] = { 0x1D602, 0x0021 };
    uint32_t const ces[9] = { 0x1F1B, 0x0261, 0x0000, 0x0020, 0x0020, 0x0000, 0x0005, 0x0002, 0x0000 };

    auto collation = collate_for_tests(
        cps, cps + 2, boost::text::variable_weighting::non_ignorable);

    EXPECT_EQ(collation.size(), 9);
    EXPECT_TRUE(boost::algorithm::equal(collation.begin(), collation.end(), ces, ces + 9))
        << "from:     " << ce_dumper(cps)
        << "expected: " << ce_dumper(ces)
        << "got:      " << ce_dumper(collation);
}

TEST(collation, non_ignorable_121_444)
{
    // 1D636 0021;	
    // (𝘶) MATHEMATICAL SANS-SERIF ITALIC SMALL U	[1F1B 0261 | 0020 0020 | 0005 0002 |]

    uint32_t cps[2] = { 0x1D636, 0x0021 };
    uint32_t const ces[9] = { 0x1F1B, 0x0261, 0x0000, 0x0020, 0x0020, 0x0000, 0x0005, 0x0002, 0x0000 };

    auto collation = collate_for_tests(
        cps, cps + 2, boost::text::variable_weighting::non_ignorable);

    EXPECT_EQ(collation.size(), 9);
    EXPECT_TRUE(boost::algorithm::equal(collation.begin(), collation.end(), ces, ces + 9))
        << "from:     " << ce_dumper(cps)
        << "expected: " << ce_dumper(ces)
        << "got:      " << ce_dumper(collation);
}

TEST(collation, non_ignorable_121_445)
{
    // 1D66A 0021;	
    // (𝙪) MATHEMATICAL SANS-SERIF BOLD ITALIC SMALL U	[1F1B 0261 | 0020 0020 | 0005 0002 |]

    uint32_t cps[2] = { 0x1D66A, 0x0021 };
    uint32_t const ces[9] = { 0x1F1B, 0x0261, 0x0000, 0x0020, 0x0020, 0x0000, 0x0005, 0x0002, 0x0000 };

    auto collation = collate_for_tests(
        cps, cps + 2, boost::text::variable_weighting::non_ignorable);

    EXPECT_EQ(collation.size(), 9);
    EXPECT_TRUE(boost::algorithm::equal(collation.begin(), collation.end(), ces, ces + 9))
        << "from:     " << ce_dumper(cps)
        << "expected: " << ce_dumper(ces)
        << "got:      " << ce_dumper(collation);
}

TEST(collation, non_ignorable_121_446)
{
    // 1D69E 0021;	
    // (𝚞) MATHEMATICAL MONOSPACE SMALL U	[1F1B 0261 | 0020 0020 | 0005 0002 |]

    uint32_t cps[2] = { 0x1D69E, 0x0021 };
    uint32_t const ces[9] = { 0x1F1B, 0x0261, 0x0000, 0x0020, 0x0020, 0x0000, 0x0005, 0x0002, 0x0000 };

    auto collation = collate_for_tests(
        cps, cps + 2, boost::text::variable_weighting::non_ignorable);

    EXPECT_EQ(collation.size(), 9);
    EXPECT_TRUE(boost::algorithm::equal(collation.begin(), collation.end(), ces, ces + 9))
        << "from:     " << ce_dumper(cps)
        << "expected: " << ce_dumper(ces)
        << "got:      " << ce_dumper(collation);
}

TEST(collation, non_ignorable_121_447)
{
    // 24E4 0021;	
    // (ⓤ) CIRCLED LATIN SMALL LETTER U	[1F1B 0261 | 0020 0020 | 0006 0002 |]

    uint32_t cps[2] = { 0x24E4, 0x0021 };
    uint32_t const ces[9] = { 0x1F1B, 0x0261, 0x0000, 0x0020, 0x0020, 0x0000, 0x0006, 0x0002, 0x0000 };

    auto collation = collate_for_tests(
        cps, cps + 2, boost::text::variable_weighting::non_ignorable);

    EXPECT_EQ(collation.size(), 9);
    EXPECT_TRUE(boost::algorithm::equal(collation.begin(), collation.end(), ces, ces + 9))
        << "from:     " << ce_dumper(cps)
        << "expected: " << ce_dumper(ces)
        << "got:      " << ce_dumper(collation);
}

TEST(collation, non_ignorable_121_448)
{
    // 0055 0021;	
    // (U) LATIN CAPITAL LETTER U	[1F1B 0261 | 0020 0020 | 0008 0002 |]

    uint32_t cps[2] = { 0x0055, 0x0021 };
    uint32_t const ces[9] = { 0x1F1B, 0x0261, 0x0000, 0x0020, 0x0020, 0x0000, 0x0008, 0x0002, 0x0000 };

    auto collation = collate_for_tests(
        cps, cps + 2, boost::text::variable_weighting::non_ignorable);

    EXPECT_EQ(collation.size(), 9);
    EXPECT_TRUE(boost::algorithm::equal(collation.begin(), collation.end(), ces, ces + 9))
        << "from:     " << ce_dumper(cps)
        << "expected: " << ce_dumper(ces)
        << "got:      " << ce_dumper(collation);
}

TEST(collation, non_ignorable_121_449)
{
    // FF35 0021;	
    // (Ｕ) FULLWIDTH LATIN CAPITAL LETTER U	[1F1B 0261 | 0020 0020 | 0009 0002 |]

    uint32_t cps[2] = { 0xFF35, 0x0021 };
    uint32_t const ces[9] = { 0x1F1B, 0x0261, 0x0000, 0x0020, 0x0020, 0x0000, 0x0009, 0x0002, 0x0000 };

    auto collation = collate_for_tests(
        cps, cps + 2, boost::text::variable_weighting::non_ignorable);

    EXPECT_EQ(collation.size(), 9);
    EXPECT_TRUE(boost::algorithm::equal(collation.begin(), collation.end(), ces, ces + 9))
        << "from:     " << ce_dumper(cps)
        << "expected: " << ce_dumper(ces)
        << "got:      " << ce_dumper(collation);
}

TEST(collation, non_ignorable_121_450)
{
    // 1D414 0021;	
    // (𝐔) MATHEMATICAL BOLD CAPITAL U	[1F1B 0261 | 0020 0020 | 000B 0002 |]

    uint32_t cps[2] = { 0x1D414, 0x0021 };
    uint32_t const ces[9] = { 0x1F1B, 0x0261, 0x0000, 0x0020, 0x0020, 0x0000, 0x000B, 0x0002, 0x0000 };

    auto collation = collate_for_tests(
        cps, cps + 2, boost::text::variable_weighting::non_ignorable);

    EXPECT_EQ(collation.size(), 9);
    EXPECT_TRUE(boost::algorithm::equal(collation.begin(), collation.end(), ces, ces + 9))
        << "from:     " << ce_dumper(cps)
        << "expected: " << ce_dumper(ces)
        << "got:      " << ce_dumper(collation);
}

TEST(collation, non_ignorable_121_451)
{
    // 1D448 0021;	
    // (𝑈) MATHEMATICAL ITALIC CAPITAL U	[1F1B 0261 | 0020 0020 | 000B 0002 |]

    uint32_t cps[2] = { 0x1D448, 0x0021 };
    uint32_t const ces[9] = { 0x1F1B, 0x0261, 0x0000, 0x0020, 0x0020, 0x0000, 0x000B, 0x0002, 0x0000 };

    auto collation = collate_for_tests(
        cps, cps + 2, boost::text::variable_weighting::non_ignorable);

    EXPECT_EQ(collation.size(), 9);
    EXPECT_TRUE(boost::algorithm::equal(collation.begin(), collation.end(), ces, ces + 9))
        << "from:     " << ce_dumper(cps)
        << "expected: " << ce_dumper(ces)
        << "got:      " << ce_dumper(collation);
}

TEST(collation, non_ignorable_121_452)
{
    // 1D47C 0021;	
    // (𝑼) MATHEMATICAL BOLD ITALIC CAPITAL U	[1F1B 0261 | 0020 0020 | 000B 0002 |]

    uint32_t cps[2] = { 0x1D47C, 0x0021 };
    uint32_t const ces[9] = { 0x1F1B, 0x0261, 0x0000, 0x0020, 0x0020, 0x0000, 0x000B, 0x0002, 0x0000 };

    auto collation = collate_for_tests(
        cps, cps + 2, boost::text::variable_weighting::non_ignorable);

    EXPECT_EQ(collation.size(), 9);
    EXPECT_TRUE(boost::algorithm::equal(collation.begin(), collation.end(), ces, ces + 9))
        << "from:     " << ce_dumper(cps)
        << "expected: " << ce_dumper(ces)
        << "got:      " << ce_dumper(collation);
}

TEST(collation, non_ignorable_121_453)
{
    // 1D4B0 0021;	
    // (𝒰) MATHEMATICAL SCRIPT CAPITAL U	[1F1B 0261 | 0020 0020 | 000B 0002 |]

    uint32_t cps[2] = { 0x1D4B0, 0x0021 };
    uint32_t const ces[9] = { 0x1F1B, 0x0261, 0x0000, 0x0020, 0x0020, 0x0000, 0x000B, 0x0002, 0x0000 };

    auto collation = collate_for_tests(
        cps, cps + 2, boost::text::variable_weighting::non_ignorable);

    EXPECT_EQ(collation.size(), 9);
    EXPECT_TRUE(boost::algorithm::equal(collation.begin(), collation.end(), ces, ces + 9))
        << "from:     " << ce_dumper(cps)
        << "expected: " << ce_dumper(ces)
        << "got:      " << ce_dumper(collation);
}

TEST(collation, non_ignorable_121_454)
{
    // 1D4E4 0021;	
    // (𝓤) MATHEMATICAL BOLD SCRIPT CAPITAL U	[1F1B 0261 | 0020 0020 | 000B 0002 |]

    uint32_t cps[2] = { 0x1D4E4, 0x0021 };
    uint32_t const ces[9] = { 0x1F1B, 0x0261, 0x0000, 0x0020, 0x0020, 0x0000, 0x000B, 0x0002, 0x0000 };

    auto collation = collate_for_tests(
        cps, cps + 2, boost::text::variable_weighting::non_ignorable);

    EXPECT_EQ(collation.size(), 9);
    EXPECT_TRUE(boost::algorithm::equal(collation.begin(), collation.end(), ces, ces + 9))
        << "from:     " << ce_dumper(cps)
        << "expected: " << ce_dumper(ces)
        << "got:      " << ce_dumper(collation);
}

TEST(collation, non_ignorable_121_455)
{
    // 1D518 0021;	
    // (𝔘) MATHEMATICAL FRAKTUR CAPITAL U	[1F1B 0261 | 0020 0020 | 000B 0002 |]

    uint32_t cps[2] = { 0x1D518, 0x0021 };
    uint32_t const ces[9] = { 0x1F1B, 0x0261, 0x0000, 0x0020, 0x0020, 0x0000, 0x000B, 0x0002, 0x0000 };

    auto collation = collate_for_tests(
        cps, cps + 2, boost::text::variable_weighting::non_ignorable);

    EXPECT_EQ(collation.size(), 9);
    EXPECT_TRUE(boost::algorithm::equal(collation.begin(), collation.end(), ces, ces + 9))
        << "from:     " << ce_dumper(cps)
        << "expected: " << ce_dumper(ces)
        << "got:      " << ce_dumper(collation);
}

TEST(collation, non_ignorable_121_456)
{
    // 1D54C 0021;	
    // (𝕌) MATHEMATICAL DOUBLE-STRUCK CAPITAL U	[1F1B 0261 | 0020 0020 | 000B 0002 |]

    uint32_t cps[2] = { 0x1D54C, 0x0021 };
    uint32_t const ces[9] = { 0x1F1B, 0x0261, 0x0000, 0x0020, 0x0020, 0x0000, 0x000B, 0x0002, 0x0000 };

    auto collation = collate_for_tests(
        cps, cps + 2, boost::text::variable_weighting::non_ignorable);

    EXPECT_EQ(collation.size(), 9);
    EXPECT_TRUE(boost::algorithm::equal(collation.begin(), collation.end(), ces, ces + 9))
        << "from:     " << ce_dumper(cps)
        << "expected: " << ce_dumper(ces)
        << "got:      " << ce_dumper(collation);
}

TEST(collation, non_ignorable_121_457)
{
    // 1D580 0021;	
    // (𝖀) MATHEMATICAL BOLD FRAKTUR CAPITAL U	[1F1B 0261 | 0020 0020 | 000B 0002 |]

    uint32_t cps[2] = { 0x1D580, 0x0021 };
    uint32_t const ces[9] = { 0x1F1B, 0x0261, 0x0000, 0x0020, 0x0020, 0x0000, 0x000B, 0x0002, 0x0000 };

    auto collation = collate_for_tests(
        cps, cps + 2, boost::text::variable_weighting::non_ignorable);

    EXPECT_EQ(collation.size(), 9);
    EXPECT_TRUE(boost::algorithm::equal(collation.begin(), collation.end(), ces, ces + 9))
        << "from:     " << ce_dumper(cps)
        << "expected: " << ce_dumper(ces)
        << "got:      " << ce_dumper(collation);
}

TEST(collation, non_ignorable_121_458)
{
    // 1D5B4 0021;	
    // (𝖴) MATHEMATICAL SANS-SERIF CAPITAL U	[1F1B 0261 | 0020 0020 | 000B 0002 |]

    uint32_t cps[2] = { 0x1D5B4, 0x0021 };
    uint32_t const ces[9] = { 0x1F1B, 0x0261, 0x0000, 0x0020, 0x0020, 0x0000, 0x000B, 0x0002, 0x0000 };

    auto collation = collate_for_tests(
        cps, cps + 2, boost::text::variable_weighting::non_ignorable);

    EXPECT_EQ(collation.size(), 9);
    EXPECT_TRUE(boost::algorithm::equal(collation.begin(), collation.end(), ces, ces + 9))
        << "from:     " << ce_dumper(cps)
        << "expected: " << ce_dumper(ces)
        << "got:      " << ce_dumper(collation);
}

TEST(collation, non_ignorable_121_459)
{
    // 1D5E8 0021;	
    // (𝗨) MATHEMATICAL SANS-SERIF BOLD CAPITAL U	[1F1B 0261 | 0020 0020 | 000B 0002 |]

    uint32_t cps[2] = { 0x1D5E8, 0x0021 };
    uint32_t const ces[9] = { 0x1F1B, 0x0261, 0x0000, 0x0020, 0x0020, 0x0000, 0x000B, 0x0002, 0x0000 };

    auto collation = collate_for_tests(
        cps, cps + 2, boost::text::variable_weighting::non_ignorable);

    EXPECT_EQ(collation.size(), 9);
    EXPECT_TRUE(boost::algorithm::equal(collation.begin(), collation.end(), ces, ces + 9))
        << "from:     " << ce_dumper(cps)
        << "expected: " << ce_dumper(ces)
        << "got:      " << ce_dumper(collation);
}

TEST(collation, non_ignorable_121_460)
{
    // 1D61C 0021;	
    // (𝘜) MATHEMATICAL SANS-SERIF ITALIC CAPITAL U	[1F1B 0261 | 0020 0020 | 000B 0002 |]

    uint32_t cps[2] = { 0x1D61C, 0x0021 };
    uint32_t const ces[9] = { 0x1F1B, 0x0261, 0x0000, 0x0020, 0x0020, 0x0000, 0x000B, 0x0002, 0x0000 };

    auto collation = collate_for_tests(
        cps, cps + 2, boost::text::variable_weighting::non_ignorable);

    EXPECT_EQ(collation.size(), 9);
    EXPECT_TRUE(boost::algorithm::equal(collation.begin(), collation.end(), ces, ces + 9))
        << "from:     " << ce_dumper(cps)
        << "expected: " << ce_dumper(ces)
        << "got:      " << ce_dumper(collation);
}

TEST(collation, non_ignorable_121_461)
{
    // 1D650 0021;	
    // (𝙐) MATHEMATICAL SANS-SERIF BOLD ITALIC CAPITAL U	[1F1B 0261 | 0020 0020 | 000B 0002 |]

    uint32_t cps[2] = { 0x1D650, 0x0021 };
    uint32_t const ces[9] = { 0x1F1B, 0x0261, 0x0000, 0x0020, 0x0020, 0x0000, 0x000B, 0x0002, 0x0000 };

    auto collation = collate_for_tests(
        cps, cps + 2, boost::text::variable_weighting::non_ignorable);

    EXPECT_EQ(collation.size(), 9);
    EXPECT_TRUE(boost::algorithm::equal(collation.begin(), collation.end(), ces, ces + 9))
        << "from:     " << ce_dumper(cps)
        << "expected: " << ce_dumper(ces)
        << "got:      " << ce_dumper(collation);
}

TEST(collation, non_ignorable_121_462)
{
    // 1D684 0021;	
    // (𝚄) MATHEMATICAL MONOSPACE CAPITAL U	[1F1B 0261 | 0020 0020 | 000B 0002 |]

    uint32_t cps[2] = { 0x1D684, 0x0021 };
    uint32_t const ces[9] = { 0x1F1B, 0x0261, 0x0000, 0x0020, 0x0020, 0x0000, 0x000B, 0x0002, 0x0000 };

    auto collation = collate_for_tests(
        cps, cps + 2, boost::text::variable_weighting::non_ignorable);

    EXPECT_EQ(collation.size(), 9);
    EXPECT_TRUE(boost::algorithm::equal(collation.begin(), collation.end(), ces, ces + 9))
        << "from:     " << ce_dumper(cps)
        << "expected: " << ce_dumper(ces)
        << "got:      " << ce_dumper(collation);
}

TEST(collation, non_ignorable_121_463)
{
    // 24CA 0021;	
    // (Ⓤ) CIRCLED LATIN CAPITAL LETTER U	[1F1B 0261 | 0020 0020 | 000C 0002 |]

    uint32_t cps[2] = { 0x24CA, 0x0021 };
    uint32_t const ces[9] = { 0x1F1B, 0x0261, 0x0000, 0x0020, 0x0020, 0x0000, 0x000C, 0x0002, 0x0000 };

    auto collation = collate_for_tests(
        cps, cps + 2, boost::text::variable_weighting::non_ignorable);

    EXPECT_EQ(collation.size(), 9);
    EXPECT_TRUE(boost::algorithm::equal(collation.begin(), collation.end(), ces, ces + 9))
        << "from:     " << ce_dumper(cps)
        << "expected: " << ce_dumper(ces)
        << "got:      " << ce_dumper(collation);
}

TEST(collation, non_ignorable_121_464)
{
    // 1F164 0021;	
    // (🅤) NEGATIVE CIRCLED LATIN CAPITAL LETTER U	[1F1B 0261 | 0020 0020 | 000C 0002 |]

    uint32_t cps[2] = { 0x1F164, 0x0021 };
    uint32_t const ces[9] = { 0x1F1B, 0x0261, 0x0000, 0x0020, 0x0020, 0x0000, 0x000C, 0x0002, 0x0000 };

    auto collation = collate_for_tests(
        cps, cps + 2, boost::text::variable_weighting::non_ignorable);

    EXPECT_EQ(collation.size(), 9);
    EXPECT_TRUE(boost::algorithm::equal(collation.begin(), collation.end(), ces, ces + 9))
        << "from:     " << ce_dumper(cps)
        << "expected: " << ce_dumper(ces)
        << "got:      " << ce_dumper(collation);
}

TEST(collation, non_ignorable_121_465)
{
    // 1D58 0021;	
    // (ᵘ) MODIFIER LETTER SMALL U	[1F1B 0261 | 0020 0020 | 0014 0002 |]

    uint32_t cps[2] = { 0x1D58, 0x0021 };
    uint32_t const ces[9] = { 0x1F1B, 0x0261, 0x0000, 0x0020, 0x0020, 0x0000, 0x0014, 0x0002, 0x0000 };

    auto collation = collate_for_tests(
        cps, cps + 2, boost::text::variable_weighting::non_ignorable);

    EXPECT_EQ(collation.size(), 9);
    EXPECT_TRUE(boost::algorithm::equal(collation.begin(), collation.end(), ces, ces + 9))
        << "from:     " << ce_dumper(cps)
        << "expected: " << ce_dumper(ces)
        << "got:      " << ce_dumper(collation);
}

TEST(collation, non_ignorable_121_466)
{
    // 1D64 0021;	
    // (ᵤ) LATIN SUBSCRIPT SMALL LETTER U	[1F1B 0261 | 0020 0020 | 0015 0002 |]

    uint32_t cps[2] = { 0x1D64, 0x0021 };
    uint32_t const ces[9] = { 0x1F1B, 0x0261, 0x0000, 0x0020, 0x0020, 0x0000, 0x0015, 0x0002, 0x0000 };

    auto collation = collate_for_tests(
        cps, cps + 2, boost::text::variable_weighting::non_ignorable);

    EXPECT_EQ(collation.size(), 9);
    EXPECT_TRUE(boost::algorithm::equal(collation.begin(), collation.end(), ces, ces + 9))
        << "from:     " << ce_dumper(cps)
        << "expected: " << ce_dumper(ces)
        << "got:      " << ce_dumper(collation);
}

TEST(collation, non_ignorable_121_467)
{
    // 1D41 0021;	
    // (ᵁ) MODIFIER LETTER CAPITAL U	[1F1B 0261 | 0020 0020 | 001D 0002 |]

    uint32_t cps[2] = { 0x1D41, 0x0021 };
    uint32_t const ces[9] = { 0x1F1B, 0x0261, 0x0000, 0x0020, 0x0020, 0x0000, 0x001D, 0x0002, 0x0000 };

    auto collation = collate_for_tests(
        cps, cps + 2, boost::text::variable_weighting::non_ignorable);

    EXPECT_EQ(collation.size(), 9);
    EXPECT_TRUE(boost::algorithm::equal(collation.begin(), collation.end(), ces, ces + 9))
        << "from:     " << ce_dumper(cps)
        << "expected: " << ce_dumper(ces)
        << "got:      " << ce_dumper(collation);
}

TEST(collation, non_ignorable_121_468)
{
    // 1F144 0021;	
    // (🅄) SQUARED LATIN CAPITAL LETTER U	[1F1B 0261 | 0020 0020 | 001D 0002 |]

    uint32_t cps[2] = { 0x1F144, 0x0021 };
    uint32_t const ces[9] = { 0x1F1B, 0x0261, 0x0000, 0x0020, 0x0020, 0x0000, 0x001D, 0x0002, 0x0000 };

    auto collation = collate_for_tests(
        cps, cps + 2, boost::text::variable_weighting::non_ignorable);

    EXPECT_EQ(collation.size(), 9);
    EXPECT_TRUE(boost::algorithm::equal(collation.begin(), collation.end(), ces, ces + 9))
        << "from:     " << ce_dumper(cps)
        << "expected: " << ce_dumper(ces)
        << "got:      " << ce_dumper(collation);
}

TEST(collation, non_ignorable_121_469)
{
    // 1F184 0021;	
    // (🆄) NEGATIVE SQUARED LATIN CAPITAL LETTER U	[1F1B 0261 | 0020 0020 | 001D 0002 |]

    uint32_t cps[2] = { 0x1F184, 0x0021 };
    uint32_t const ces[9] = { 0x1F1B, 0x0261, 0x0000, 0x0020, 0x0020, 0x0000, 0x001D, 0x0002, 0x0000 };

    auto collation = collate_for_tests(
        cps, cps + 2, boost::text::variable_weighting::non_ignorable);

    EXPECT_EQ(collation.size(), 9);
    EXPECT_TRUE(boost::algorithm::equal(collation.begin(), collation.end(), ces, ces + 9))
        << "from:     " << ce_dumper(cps)
        << "expected: " << ce_dumper(ces)
        << "got:      " << ce_dumper(collation);
}

TEST(collation, non_ignorable_121_470)
{
    // 00FA 0021;	
    // (ú) LATIN SMALL LETTER U WITH ACUTE	[1F1B 0261 | 0020 0024 0020 | 0002 0002 0002 |]

    uint32_t cps[2] = { 0x00FA, 0x0021 };
    uint32_t const ces[11] = { 0x1F1B, 0x0261, 0x0000, 0x0020, 0x0024, 0x0020, 0x0000, 0x0002, 0x0002, 0x0002, 0x0000 };

    auto collation = collate_for_tests(
        cps, cps + 2, boost::text::variable_weighting::non_ignorable);

    EXPECT_EQ(collation.size(), 11);
    EXPECT_TRUE(boost::algorithm::equal(collation.begin(), collation.end(), ces, ces + 11))
        << "from:     " << ce_dumper(cps)
        << "expected: " << ce_dumper(ces)
        << "got:      " << ce_dumper(collation);
}

TEST(collation, non_ignorable_121_471)
{
    // 00DA 0021;	
    // (Ú) LATIN CAPITAL LETTER U WITH ACUTE	[1F1B 0261 | 0020 0024 0020 | 0008 0002 0002 |]

    uint32_t cps[2] = { 0x00DA, 0x0021 };
    uint32_t const ces[11] = { 0x1F1B, 0x0261, 0x0000, 0x0020, 0x0024, 0x0020, 0x0000, 0x0008, 0x0002, 0x0002, 0x0000 };

    auto collation = collate_for_tests(
        cps, cps + 2, boost::text::variable_weighting::non_ignorable);

    EXPECT_EQ(collation.size(), 11);
    EXPECT_TRUE(boost::algorithm::equal(collation.begin(), collation.end(), ces, ces + 11))
        << "from:     " << ce_dumper(cps)
        << "expected: " << ce_dumper(ces)
        << "got:      " << ce_dumper(collation);
}

TEST(collation, non_ignorable_121_472)
{
    // 00F9 0021;	
    // (ù) LATIN SMALL LETTER U WITH GRAVE	[1F1B 0261 | 0020 0025 0020 | 0002 0002 0002 |]

    uint32_t cps[2] = { 0x00F9, 0x0021 };
    uint32_t const ces[11] = { 0x1F1B, 0x0261, 0x0000, 0x0020, 0x0025, 0x0020, 0x0000, 0x0002, 0x0002, 0x0002, 0x0000 };

    auto collation = collate_for_tests(
        cps, cps + 2, boost::text::variable_weighting::non_ignorable);

    EXPECT_EQ(collation.size(), 11);
    EXPECT_TRUE(boost::algorithm::equal(collation.begin(), collation.end(), ces, ces + 11))
        << "from:     " << ce_dumper(cps)
        << "expected: " << ce_dumper(ces)
        << "got:      " << ce_dumper(collation);
}

TEST(collation, non_ignorable_121_473)
{
    // 00D9 0021;	
    // (Ù) LATIN CAPITAL LETTER U WITH GRAVE	[1F1B 0261 | 0020 0025 0020 | 0008 0002 0002 |]

    uint32_t cps[2] = { 0x00D9, 0x0021 };
    uint32_t const ces[11] = { 0x1F1B, 0x0261, 0x0000, 0x0020, 0x0025, 0x0020, 0x0000, 0x0008, 0x0002, 0x0002, 0x0000 };

    auto collation = collate_for_tests(
        cps, cps + 2, boost::text::variable_weighting::non_ignorable);

    EXPECT_EQ(collation.size(), 11);
    EXPECT_TRUE(boost::algorithm::equal(collation.begin(), collation.end(), ces, ces + 11))
        << "from:     " << ce_dumper(cps)
        << "expected: " << ce_dumper(ces)
        << "got:      " << ce_dumper(collation);
}

TEST(collation, non_ignorable_121_474)
{
    // 016D 0021;	
    // (ŭ) LATIN SMALL LETTER U WITH BREVE	[1F1B 0261 | 0020 0026 0020 | 0002 0002 0002 |]

    uint32_t cps[2] = { 0x016D, 0x0021 };
    uint32_t const ces[11] = { 0x1F1B, 0x0261, 0x0000, 0x0020, 0x0026, 0x0020, 0x0000, 0x0002, 0x0002, 0x0002, 0x0000 };

    auto collation = collate_for_tests(
        cps, cps + 2, boost::text::variable_weighting::non_ignorable);

    EXPECT_EQ(collation.size(), 11);
    EXPECT_TRUE(boost::algorithm::equal(collation.begin(), collation.end(), ces, ces + 11))
        << "from:     " << ce_dumper(cps)
        << "expected: " << ce_dumper(ces)
        << "got:      " << ce_dumper(collation);
}

TEST(collation, non_ignorable_121_475)
{
    // 016C 0021;	
    // (Ŭ) LATIN CAPITAL LETTER U WITH BREVE	[1F1B 0261 | 0020 0026 0020 | 0008 0002 0002 |]

    uint32_t cps[2] = { 0x016C, 0x0021 };
    uint32_t const ces[11] = { 0x1F1B, 0x0261, 0x0000, 0x0020, 0x0026, 0x0020, 0x0000, 0x0008, 0x0002, 0x0002, 0x0000 };

    auto collation = collate_for_tests(
        cps, cps + 2, boost::text::variable_weighting::non_ignorable);

    EXPECT_EQ(collation.size(), 11);
    EXPECT_TRUE(boost::algorithm::equal(collation.begin(), collation.end(), ces, ces + 11))
        << "from:     " << ce_dumper(cps)
        << "expected: " << ce_dumper(ces)
        << "got:      " << ce_dumper(collation);
}

TEST(collation, non_ignorable_121_476)
{
    // 00FB 0021;	
    // (û) LATIN SMALL LETTER U WITH CIRCUMFLEX	[1F1B 0261 | 0020 0027 0020 | 0002 0002 0002 |]

    uint32_t cps[2] = { 0x00FB, 0x0021 };
    uint32_t const ces[11] = { 0x1F1B, 0x0261, 0x0000, 0x0020, 0x0027, 0x0020, 0x0000, 0x0002, 0x0002, 0x0002, 0x0000 };

    auto collation = collate_for_tests(
        cps, cps + 2, boost::text::variable_weighting::non_ignorable);

    EXPECT_EQ(collation.size(), 11);
    EXPECT_TRUE(boost::algorithm::equal(collation.begin(), collation.end(), ces, ces + 11))
        << "from:     " << ce_dumper(cps)
        << "expected: " << ce_dumper(ces)
        << "got:      " << ce_dumper(collation);
}

TEST(collation, non_ignorable_121_477)
{
    // 00DB 0021;	
    // (Û) LATIN CAPITAL LETTER U WITH CIRCUMFLEX	[1F1B 0261 | 0020 0027 0020 | 0008 0002 0002 |]

    uint32_t cps[2] = { 0x00DB, 0x0021 };
    uint32_t const ces[11] = { 0x1F1B, 0x0261, 0x0000, 0x0020, 0x0027, 0x0020, 0x0000, 0x0008, 0x0002, 0x0002, 0x0000 };

    auto collation = collate_for_tests(
        cps, cps + 2, boost::text::variable_weighting::non_ignorable);

    EXPECT_EQ(collation.size(), 11);
    EXPECT_TRUE(boost::algorithm::equal(collation.begin(), collation.end(), ces, ces + 11))
        << "from:     " << ce_dumper(cps)
        << "expected: " << ce_dumper(ces)
        << "got:      " << ce_dumper(collation);
}

TEST(collation, non_ignorable_121_478)
{
    // 01D4 0021;	
    // (ǔ) LATIN SMALL LETTER U WITH CARON	[1F1B 0261 | 0020 0028 0020 | 0002 0002 0002 |]

    uint32_t cps[2] = { 0x01D4, 0x0021 };
    uint32_t const ces[11] = { 0x1F1B, 0x0261, 0x0000, 0x0020, 0x0028, 0x0020, 0x0000, 0x0002, 0x0002, 0x0002, 0x0000 };

    auto collation = collate_for_tests(
        cps, cps + 2, boost::text::variable_weighting::non_ignorable);

    EXPECT_EQ(collation.size(), 11);
    EXPECT_TRUE(boost::algorithm::equal(collation.begin(), collation.end(), ces, ces + 11))
        << "from:     " << ce_dumper(cps)
        << "expected: " << ce_dumper(ces)
        << "got:      " << ce_dumper(collation);
}

TEST(collation, non_ignorable_121_479)
{
    // 01D3 0021;	
    // (Ǔ) LATIN CAPITAL LETTER U WITH CARON	[1F1B 0261 | 0020 0028 0020 | 0008 0002 0002 |]

    uint32_t cps[2] = { 0x01D3, 0x0021 };
    uint32_t const ces[11] = { 0x1F1B, 0x0261, 0x0000, 0x0020, 0x0028, 0x0020, 0x0000, 0x0008, 0x0002, 0x0002, 0x0000 };

    auto collation = collate_for_tests(
        cps, cps + 2, boost::text::variable_weighting::non_ignorable);

    EXPECT_EQ(collation.size(), 11);
    EXPECT_TRUE(boost::algorithm::equal(collation.begin(), collation.end(), ces, ces + 11))
        << "from:     " << ce_dumper(cps)
        << "expected: " << ce_dumper(ces)
        << "got:      " << ce_dumper(collation);
}

TEST(collation, non_ignorable_121_480)
{
    // 016F 0021;	
    // (ů) LATIN SMALL LETTER U WITH RING ABOVE	[1F1B 0261 | 0020 0029 0020 | 0002 0002 0002 |]

    uint32_t cps[2] = { 0x016F, 0x0021 };
    uint32_t const ces[11] = { 0x1F1B, 0x0261, 0x0000, 0x0020, 0x0029, 0x0020, 0x0000, 0x0002, 0x0002, 0x0002, 0x0000 };

    auto collation = collate_for_tests(
        cps, cps + 2, boost::text::variable_weighting::non_ignorable);

    EXPECT_EQ(collation.size(), 11);
    EXPECT_TRUE(boost::algorithm::equal(collation.begin(), collation.end(), ces, ces + 11))
        << "from:     " << ce_dumper(cps)
        << "expected: " << ce_dumper(ces)
        << "got:      " << ce_dumper(collation);
}

TEST(collation, non_ignorable_121_481)
{
    // 016E 0021;	
    // (Ů) LATIN CAPITAL LETTER U WITH RING ABOVE	[1F1B 0261 | 0020 0029 0020 | 0008 0002 0002 |]

    uint32_t cps[2] = { 0x016E, 0x0021 };
    uint32_t const ces[11] = { 0x1F1B, 0x0261, 0x0000, 0x0020, 0x0029, 0x0020, 0x0000, 0x0008, 0x0002, 0x0002, 0x0000 };

    auto collation = collate_for_tests(
        cps, cps + 2, boost::text::variable_weighting::non_ignorable);

    EXPECT_EQ(collation.size(), 11);
    EXPECT_TRUE(boost::algorithm::equal(collation.begin(), collation.end(), ces, ces + 11))
        << "from:     " << ce_dumper(cps)
        << "expected: " << ce_dumper(ces)
        << "got:      " << ce_dumper(collation);
}

TEST(collation, non_ignorable_121_482)
{
    // 00FC 0021;	
    // (ü) LATIN SMALL LETTER U WITH DIAERESIS	[1F1B 0261 | 0020 002B 0020 | 0002 0002 0002 |]

    uint32_t cps[2] = { 0x00FC, 0x0021 };
    uint32_t const ces[11] = { 0x1F1B, 0x0261, 0x0000, 0x0020, 0x002B, 0x0020, 0x0000, 0x0002, 0x0002, 0x0002, 0x0000 };

    auto collation = collate_for_tests(
        cps, cps + 2, boost::text::variable_weighting::non_ignorable);

    EXPECT_EQ(collation.size(), 11);
    EXPECT_TRUE(boost::algorithm::equal(collation.begin(), collation.end(), ces, ces + 11))
        << "from:     " << ce_dumper(cps)
        << "expected: " << ce_dumper(ces)
        << "got:      " << ce_dumper(collation);
}

TEST(collation, non_ignorable_121_483)
{
    // 1DF4 0021;	
    // (ᷴ) COMBINING LATIN SMALL LETTER U WITH DIAERESIS	[1F1B 0261 | 0020 002B 0020 | 0004 0004 0002 |]

    uint32_t cps[2] = { 0x1DF4, 0x0021 };
    uint32_t const ces[11] = { 0x1F1B, 0x0261, 0x0000, 0x0020, 0x002B, 0x0020, 0x0000, 0x0004, 0x0004, 0x0002, 0x0000 };

    auto collation = collate_for_tests(
        cps, cps + 2, boost::text::variable_weighting::non_ignorable);

    EXPECT_EQ(collation.size(), 11);
    EXPECT_TRUE(boost::algorithm::equal(collation.begin(), collation.end(), ces, ces + 11))
        << "from:     " << ce_dumper(cps)
        << "expected: " << ce_dumper(ces)
        << "got:      " << ce_dumper(collation);
}

TEST(collation, non_ignorable_121_484)
{
    // A79F 0021;	
    // (ꞟ) LATIN SMALL LETTER VOLAPUK UE	[1F1B 0261 | 0020 002B 0020 | 0004 0004 0002 |]

    uint32_t cps[2] = { 0xA79F, 0x0021 };
    uint32_t const ces[11] = { 0x1F1B, 0x0261, 0x0000, 0x0020, 0x002B, 0x0020, 0x0000, 0x0004, 0x0004, 0x0002, 0x0000 };

    auto collation = collate_for_tests(
        cps, cps + 2, boost::text::variable_weighting::non_ignorable);

    EXPECT_EQ(collation.size(), 11);
    EXPECT_TRUE(boost::algorithm::equal(collation.begin(), collation.end(), ces, ces + 11))
        << "from:     " << ce_dumper(cps)
        << "expected: " << ce_dumper(ces)
        << "got:      " << ce_dumper(collation);
}

TEST(collation, non_ignorable_121_485)
{
    // 00DC 0021;	
    // (Ü) LATIN CAPITAL LETTER U WITH DIAERESIS	[1F1B 0261 | 0020 002B 0020 | 0008 0002 0002 |]

    uint32_t cps[2] = { 0x00DC, 0x0021 };
    uint32_t const ces[11] = { 0x1F1B, 0x0261, 0x0000, 0x0020, 0x002B, 0x0020, 0x0000, 0x0008, 0x0002, 0x0002, 0x0000 };

    auto collation = collate_for_tests(
        cps, cps + 2, boost::text::variable_weighting::non_ignorable);

    EXPECT_EQ(collation.size(), 11);
    EXPECT_TRUE(boost::algorithm::equal(collation.begin(), collation.end(), ces, ces + 11))
        << "from:     " << ce_dumper(cps)
        << "expected: " << ce_dumper(ces)
        << "got:      " << ce_dumper(collation);
}

TEST(collation, non_ignorable_121_486)
{
    // A79E 0021;	
    // (Ꞟ) LATIN CAPITAL LETTER VOLAPUK UE	[1F1B 0261 | 0020 002B 0020 | 000A 0004 0002 |]

    uint32_t cps[2] = { 0xA79E, 0x0021 };
    uint32_t const ces[11] = { 0x1F1B, 0x0261, 0x0000, 0x0020, 0x002B, 0x0020, 0x0000, 0x000A, 0x0004, 0x0002, 0x0000 };

    auto collation = collate_for_tests(
        cps, cps + 2, boost::text::variable_weighting::non_ignorable);

    EXPECT_EQ(collation.size(), 11);
    EXPECT_TRUE(boost::algorithm::equal(collation.begin(), collation.end(), ces, ces + 11))
        << "from:     " << ce_dumper(cps)
        << "expected: " << ce_dumper(ces)
        << "got:      " << ce_dumper(collation);
}

TEST(collation, non_ignorable_121_487)
{
    // 01D8 0021;	
    // (ǘ) LATIN SMALL LETTER U WITH DIAERESIS AND ACUTE	[1F1B 0261 | 0020 002B 0024 0020 | 0002 0002 0002 0002 |]

    uint32_t cps[2] = { 0x01D8, 0x0021 };
    uint32_t const ces[13] = { 0x1F1B, 0x0261, 0x0000, 0x0020, 0x002B, 0x0024, 0x0020, 0x0000, 0x0002, 0x0002, 0x0002, 0x0002, 0x0000 };

    auto collation = collate_for_tests(
        cps, cps + 2, boost::text::variable_weighting::non_ignorable);

    EXPECT_EQ(collation.size(), 13);
    EXPECT_TRUE(boost::algorithm::equal(collation.begin(), collation.end(), ces, ces + 13))
        << "from:     " << ce_dumper(cps)
        << "expected: " << ce_dumper(ces)
        << "got:      " << ce_dumper(collation);
}

TEST(collation, non_ignorable_121_488)
{
    // 01D7 0021;	
    // (Ǘ) LATIN CAPITAL LETTER U WITH DIAERESIS AND ACUTE	[1F1B 0261 | 0020 002B 0024 0020 | 0008 0002 0002 0002 |]

    uint32_t cps[2] = { 0x01D7, 0x0021 };
    uint32_t const ces[13] = { 0x1F1B, 0x0261, 0x0000, 0x0020, 0x002B, 0x0024, 0x0020, 0x0000, 0x0008, 0x0002, 0x0002, 0x0002, 0x0000 };

    auto collation = collate_for_tests(
        cps, cps + 2, boost::text::variable_weighting::non_ignorable);

    EXPECT_EQ(collation.size(), 13);
    EXPECT_TRUE(boost::algorithm::equal(collation.begin(), collation.end(), ces, ces + 13))
        << "from:     " << ce_dumper(cps)
        << "expected: " << ce_dumper(ces)
        << "got:      " << ce_dumper(collation);
}

TEST(collation, non_ignorable_121_489)
{
    // 01DC 0021;	
    // (ǜ) LATIN SMALL LETTER U WITH DIAERESIS AND GRAVE	[1F1B 0261 | 0020 002B 0025 0020 | 0002 0002 0002 0002 |]

    uint32_t cps[2] = { 0x01DC, 0x0021 };
    uint32_t const ces[13] = { 0x1F1B, 0x0261, 0x0000, 0x0020, 0x002B, 0x0025, 0x0020, 0x0000, 0x0002, 0x0002, 0x0002, 0x0002, 0x0000 };

    auto collation = collate_for_tests(
        cps, cps + 2, boost::text::variable_weighting::non_ignorable);

    EXPECT_EQ(collation.size(), 13);
    EXPECT_TRUE(boost::algorithm::equal(collation.begin(), collation.end(), ces, ces + 13))
        << "from:     " << ce_dumper(cps)
        << "expected: " << ce_dumper(ces)
        << "got:      " << ce_dumper(collation);
}

TEST(collation, non_ignorable_121_490)
{
    // 01DB 0021;	
    // (Ǜ) LATIN CAPITAL LETTER U WITH DIAERESIS AND GRAVE	[1F1B 0261 | 0020 002B 0025 0020 | 0008 0002 0002 0002 |]

    uint32_t cps[2] = { 0x01DB, 0x0021 };
    uint32_t const ces[13] = { 0x1F1B, 0x0261, 0x0000, 0x0020, 0x002B, 0x0025, 0x0020, 0x0000, 0x0008, 0x0002, 0x0002, 0x0002, 0x0000 };

    auto collation = collate_for_tests(
        cps, cps + 2, boost::text::variable_weighting::non_ignorable);

    EXPECT_EQ(collation.size(), 13);
    EXPECT_TRUE(boost::algorithm::equal(collation.begin(), collation.end(), ces, ces + 13))
        << "from:     " << ce_dumper(cps)
        << "expected: " << ce_dumper(ces)
        << "got:      " << ce_dumper(collation);
}

TEST(collation, non_ignorable_121_491)
{
    // 01DA 0021;	
    // (ǚ) LATIN SMALL LETTER U WITH DIAERESIS AND CARON	[1F1B 0261 | 0020 002B 0028 0020 | 0002 0002 0002 0002 |]

    uint32_t cps[2] = { 0x01DA, 0x0021 };
    uint32_t const ces[13] = { 0x1F1B, 0x0261, 0x0000, 0x0020, 0x002B, 0x0028, 0x0020, 0x0000, 0x0002, 0x0002, 0x0002, 0x0002, 0x0000 };

    auto collation = collate_for_tests(
        cps, cps + 2, boost::text::variable_weighting::non_ignorable);

    EXPECT_EQ(collation.size(), 13);
    EXPECT_TRUE(boost::algorithm::equal(collation.begin(), collation.end(), ces, ces + 13))
        << "from:     " << ce_dumper(cps)
        << "expected: " << ce_dumper(ces)
        << "got:      " << ce_dumper(collation);
}

TEST(collation, non_ignorable_121_492)
{
    // 01D9 0021;	
    // (Ǚ) LATIN CAPITAL LETTER U WITH DIAERESIS AND CARON	[1F1B 0261 | 0020 002B 0028 0020 | 0008 0002 0002 0002 |]

    uint32_t cps[2] = { 0x01D9, 0x0021 };
    uint32_t const ces[13] = { 0x1F1B, 0x0261, 0x0000, 0x0020, 0x002B, 0x0028, 0x0020, 0x0000, 0x0008, 0x0002, 0x0002, 0x0002, 0x0000 };

    auto collation = collate_for_tests(
        cps, cps + 2, boost::text::variable_weighting::non_ignorable);

    EXPECT_EQ(collation.size(), 13);
    EXPECT_TRUE(boost::algorithm::equal(collation.begin(), collation.end(), ces, ces + 13))
        << "from:     " << ce_dumper(cps)
        << "expected: " << ce_dumper(ces)
        << "got:      " << ce_dumper(collation);
}

TEST(collation, non_ignorable_121_493)
{
    // 01D6 0021;	
    // (ǖ) LATIN SMALL LETTER U WITH DIAERESIS AND MACRON	[1F1B 0261 | 0020 002B 0032 0020 | 0002 0002 0002 0002 |]

    uint32_t cps[2] = { 0x01D6, 0x0021 };
    uint32_t const ces[13] = { 0x1F1B, 0x0261, 0x0000, 0x0020, 0x002B, 0x0032, 0x0020, 0x0000, 0x0002, 0x0002, 0x0002, 0x0002, 0x0000 };

    auto collation = collate_for_tests(
        cps, cps + 2, boost::text::variable_weighting::non_ignorable);

    EXPECT_EQ(collation.size(), 13);
    EXPECT_TRUE(boost::algorithm::equal(collation.begin(), collation.end(), ces, ces + 13))
        << "from:     " << ce_dumper(cps)
        << "expected: " << ce_dumper(ces)
        << "got:      " << ce_dumper(collation);
}

TEST(collation, non_ignorable_121_494)
{
    // 01D5 0021;	
    // (Ǖ) LATIN CAPITAL LETTER U WITH DIAERESIS AND MACRON	[1F1B 0261 | 0020 002B 0032 0020 | 0008 0002 0002 0002 |]

    uint32_t cps[2] = { 0x01D5, 0x0021 };
    uint32_t const ces[13] = { 0x1F1B, 0x0261, 0x0000, 0x0020, 0x002B, 0x0032, 0x0020, 0x0000, 0x0008, 0x0002, 0x0002, 0x0002, 0x0000 };

    auto collation = collate_for_tests(
        cps, cps + 2, boost::text::variable_weighting::non_ignorable);

    EXPECT_EQ(collation.size(), 13);
    EXPECT_TRUE(boost::algorithm::equal(collation.begin(), collation.end(), ces, ces + 13))
        << "from:     " << ce_dumper(cps)
        << "expected: " << ce_dumper(ces)
        << "got:      " << ce_dumper(collation);
}

TEST(collation, non_ignorable_121_495)
{
    // 0171 0021;	
    // (ű) LATIN SMALL LETTER U WITH DOUBLE ACUTE	[1F1B 0261 | 0020 002C 0020 | 0002 0002 0002 |]

    uint32_t cps[2] = { 0x0171, 0x0021 };
    uint32_t const ces[11] = { 0x1F1B, 0x0261, 0x0000, 0x0020, 0x002C, 0x0020, 0x0000, 0x0002, 0x0002, 0x0002, 0x0000 };

    auto collation = collate_for_tests(
        cps, cps + 2, boost::text::variable_weighting::non_ignorable);

    EXPECT_EQ(collation.size(), 11);
    EXPECT_TRUE(boost::algorithm::equal(collation.begin(), collation.end(), ces, ces + 11))
        << "from:     " << ce_dumper(cps)
        << "expected: " << ce_dumper(ces)
        << "got:      " << ce_dumper(collation);
}

TEST(collation, non_ignorable_121_496)
{
    // 0170 0021;	
    // (Ű) LATIN CAPITAL LETTER U WITH DOUBLE ACUTE	[1F1B 0261 | 0020 002C 0020 | 0008 0002 0002 |]

    uint32_t cps[2] = { 0x0170, 0x0021 };
    uint32_t const ces[11] = { 0x1F1B, 0x0261, 0x0000, 0x0020, 0x002C, 0x0020, 0x0000, 0x0008, 0x0002, 0x0002, 0x0000 };

    auto collation = collate_for_tests(
        cps, cps + 2, boost::text::variable_weighting::non_ignorable);

    EXPECT_EQ(collation.size(), 11);
    EXPECT_TRUE(boost::algorithm::equal(collation.begin(), collation.end(), ces, ces + 11))
        << "from:     " << ce_dumper(cps)
        << "expected: " << ce_dumper(ces)
        << "got:      " << ce_dumper(collation);
}

TEST(collation, non_ignorable_121_497)
{
    // 0169 0021;	
    // (ũ) LATIN SMALL LETTER U WITH TILDE	[1F1B 0261 | 0020 002D 0020 | 0002 0002 0002 |]

    uint32_t cps[2] = { 0x0169, 0x0021 };
    uint32_t const ces[11] = { 0x1F1B, 0x0261, 0x0000, 0x0020, 0x002D, 0x0020, 0x0000, 0x0002, 0x0002, 0x0002, 0x0000 };

    auto collation = collate_for_tests(
        cps, cps + 2, boost::text::variable_weighting::non_ignorable);

    EXPECT_EQ(collation.size(), 11);
    EXPECT_TRUE(boost::algorithm::equal(collation.begin(), collation.end(), ces, ces + 11))
        << "from:     " << ce_dumper(cps)
        << "expected: " << ce_dumper(ces)
        << "got:      " << ce_dumper(collation);
}

TEST(collation, non_ignorable_121_498)
{
    // 0168 0021;	
    // (Ũ) LATIN CAPITAL LETTER U WITH TILDE	[1F1B 0261 | 0020 002D 0020 | 0008 0002 0002 |]

    uint32_t cps[2] = { 0x0168, 0x0021 };
    uint32_t const ces[11] = { 0x1F1B, 0x0261, 0x0000, 0x0020, 0x002D, 0x0020, 0x0000, 0x0008, 0x0002, 0x0002, 0x0000 };

    auto collation = collate_for_tests(
        cps, cps + 2, boost::text::variable_weighting::non_ignorable);

    EXPECT_EQ(collation.size(), 11);
    EXPECT_TRUE(boost::algorithm::equal(collation.begin(), collation.end(), ces, ces + 11))
        << "from:     " << ce_dumper(cps)
        << "expected: " << ce_dumper(ces)
        << "got:      " << ce_dumper(collation);
}

TEST(collation, non_ignorable_121_499)
{
    // 1E79 0021;	
    // (ṹ) LATIN SMALL LETTER U WITH TILDE AND ACUTE	[1F1B 0261 | 0020 002D 0024 0020 | 0002 0002 0002 0002 |]

    uint32_t cps[2] = { 0x1E79, 0x0021 };
    uint32_t const ces[13] = { 0x1F1B, 0x0261, 0x0000, 0x0020, 0x002D, 0x0024, 0x0020, 0x0000, 0x0002, 0x0002, 0x0002, 0x0002, 0x0000 };

    auto collation = collate_for_tests(
        cps, cps + 2, boost::text::variable_weighting::non_ignorable);

    EXPECT_EQ(collation.size(), 13);
    EXPECT_TRUE(boost::algorithm::equal(collation.begin(), collation.end(), ces, ces + 13))
        << "from:     " << ce_dumper(cps)
        << "expected: " << ce_dumper(ces)
        << "got:      " << ce_dumper(collation);
}

