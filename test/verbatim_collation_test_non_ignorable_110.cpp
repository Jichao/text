// Warning! This file is autogenerated.
#include "collation_tests.hpp"

#include <boost/algorithm/cxx14/equal.hpp>

#include <gtest/gtest.h>



TEST(collation, non_ignorable_110_000)
{
    // 33CC 0061;	
    // (㏌) SQUARE IN	[1D98 1E1F 1CAD | 0020 0020 0020 | 001C 001C 0002 |]

    uint32_t cps[2] = { 0x33CC, 0x0061 };
    uint32_t const ces[12] = { 0x1D98, 0x1E1F, 0x1CAD, 0x0000, 0x0020, 0x0020, 0x0020, 0x0000, 0x001C, 0x001C, 0x0002, 0x0000 };

    auto collation = collate_for_tests(
        cps, cps + 2, boost::text::variable_weighting::non_ignorable);

    EXPECT_EQ(collation.size(), 12);
    EXPECT_TRUE(boost::algorithm::equal(collation.begin(), collation.end(), ces, ces + 12))
        << "from:     " << ce_dumper(cps)
        << "expected: " << ce_dumper(ces)
        << "got:      " << ce_dumper(collation);
}

TEST(collation, non_ignorable_110_001)
{
    // 33CC 0041;	
    // (㏌) SQUARE IN	[1D98 1E1F 1CAD | 0020 0020 0020 | 001C 001C 0008 |]

    uint32_t cps[2] = { 0x33CC, 0x0041 };
    uint32_t const ces[12] = { 0x1D98, 0x1E1F, 0x1CAD, 0x0000, 0x0020, 0x0020, 0x0020, 0x0000, 0x001C, 0x001C, 0x0008, 0x0000 };

    auto collation = collate_for_tests(
        cps, cps + 2, boost::text::variable_weighting::non_ignorable);

    EXPECT_EQ(collation.size(), 12);
    EXPECT_TRUE(boost::algorithm::equal(collation.begin(), collation.end(), ces, ces + 12))
        << "from:     " << ce_dumper(cps)
        << "expected: " << ce_dumper(ces)
        << "got:      " << ce_dumper(collation);
}

TEST(collation, non_ignorable_110_002)
{
    // 33CC 0062;	
    // (㏌) SQUARE IN	[1D98 1E1F 1CC6 | 0020 0020 0020 | 001C 001C 0002 |]

    uint32_t cps[2] = { 0x33CC, 0x0062 };
    uint32_t const ces[12] = { 0x1D98, 0x1E1F, 0x1CC6, 0x0000, 0x0020, 0x0020, 0x0020, 0x0000, 0x001C, 0x001C, 0x0002, 0x0000 };

    auto collation = collate_for_tests(
        cps, cps + 2, boost::text::variable_weighting::non_ignorable);

    EXPECT_EQ(collation.size(), 12);
    EXPECT_TRUE(boost::algorithm::equal(collation.begin(), collation.end(), ces, ces + 12))
        << "from:     " << ce_dumper(cps)
        << "expected: " << ce_dumper(ces)
        << "got:      " << ce_dumper(collation);
}

TEST(collation, non_ignorable_110_003)
{
    // 337A 0021;	
    // (㍺) SQUARE IU	[1D98 1F1B 0261 | 0020 0020 0020 | 001D 001D 0002 |]

    uint32_t cps[2] = { 0x337A, 0x0021 };
    uint32_t const ces[12] = { 0x1D98, 0x1F1B, 0x0261, 0x0000, 0x0020, 0x0020, 0x0020, 0x0000, 0x001D, 0x001D, 0x0002, 0x0000 };

    auto collation = collate_for_tests(
        cps, cps + 2, boost::text::variable_weighting::non_ignorable);

    EXPECT_EQ(collation.size(), 12);
    EXPECT_TRUE(boost::algorithm::equal(collation.begin(), collation.end(), ces, ces + 12))
        << "from:     " << ce_dumper(cps)
        << "expected: " << ce_dumper(ces)
        << "got:      " << ce_dumper(collation);
}

TEST(collation, non_ignorable_110_004)
{
    // 337A 003F;	
    // (㍺) SQUARE IU	[1D98 1F1B 0267 | 0020 0020 0020 | 001D 001D 0002 |]

    uint32_t cps[2] = { 0x337A, 0x003F };
    uint32_t const ces[12] = { 0x1D98, 0x1F1B, 0x0267, 0x0000, 0x0020, 0x0020, 0x0020, 0x0000, 0x001D, 0x001D, 0x0002, 0x0000 };

    auto collation = collate_for_tests(
        cps, cps + 2, boost::text::variable_weighting::non_ignorable);

    EXPECT_EQ(collation.size(), 12);
    EXPECT_TRUE(boost::algorithm::equal(collation.begin(), collation.end(), ces, ces + 12))
        << "from:     " << ce_dumper(cps)
        << "expected: " << ce_dumper(ces)
        << "got:      " << ce_dumper(collation);
}

TEST(collation, non_ignorable_110_005)
{
    // 337A 0061;	
    // (㍺) SQUARE IU	[1D98 1F1B 1CAD | 0020 0020 0020 | 001D 001D 0002 |]

    uint32_t cps[2] = { 0x337A, 0x0061 };
    uint32_t const ces[12] = { 0x1D98, 0x1F1B, 0x1CAD, 0x0000, 0x0020, 0x0020, 0x0020, 0x0000, 0x001D, 0x001D, 0x0002, 0x0000 };

    auto collation = collate_for_tests(
        cps, cps + 2, boost::text::variable_weighting::non_ignorable);

    EXPECT_EQ(collation.size(), 12);
    EXPECT_TRUE(boost::algorithm::equal(collation.begin(), collation.end(), ces, ces + 12))
        << "from:     " << ce_dumper(cps)
        << "expected: " << ce_dumper(ces)
        << "got:      " << ce_dumper(collation);
}

TEST(collation, non_ignorable_110_006)
{
    // 337A 0041;	
    // (㍺) SQUARE IU	[1D98 1F1B 1CAD | 0020 0020 0020 | 001D 001D 0008 |]

    uint32_t cps[2] = { 0x337A, 0x0041 };
    uint32_t const ces[12] = { 0x1D98, 0x1F1B, 0x1CAD, 0x0000, 0x0020, 0x0020, 0x0020, 0x0000, 0x001D, 0x001D, 0x0008, 0x0000 };

    auto collation = collate_for_tests(
        cps, cps + 2, boost::text::variable_weighting::non_ignorable);

    EXPECT_EQ(collation.size(), 12);
    EXPECT_TRUE(boost::algorithm::equal(collation.begin(), collation.end(), ces, ces + 12))
        << "from:     " << ce_dumper(cps)
        << "expected: " << ce_dumper(ces)
        << "got:      " << ce_dumper(collation);
}

TEST(collation, non_ignorable_110_007)
{
    // 337A 0062;	
    // (㍺) SQUARE IU	[1D98 1F1B 1CC6 | 0020 0020 0020 | 001D 001D 0002 |]

    uint32_t cps[2] = { 0x337A, 0x0062 };
    uint32_t const ces[12] = { 0x1D98, 0x1F1B, 0x1CC6, 0x0000, 0x0020, 0x0020, 0x0020, 0x0000, 0x001D, 0x001D, 0x0002, 0x0000 };

    auto collation = collate_for_tests(
        cps, cps + 2, boost::text::variable_weighting::non_ignorable);

    EXPECT_EQ(collation.size(), 12);
    EXPECT_TRUE(boost::algorithm::equal(collation.begin(), collation.end(), ces, ces + 12))
        << "from:     " << ce_dumper(cps)
        << "expected: " << ce_dumper(ces)
        << "got:      " << ce_dumper(collation);
}

TEST(collation, non_ignorable_110_008)
{
    // 2173 0021;	
    // (ⅳ) SMALL ROMAN NUMERAL FOUR	[1D98 1F49 0261 | 0020 0020 0020 | 0004 0004 0002 |]

    uint32_t cps[2] = { 0x2173, 0x0021 };
    uint32_t const ces[12] = { 0x1D98, 0x1F49, 0x0261, 0x0000, 0x0020, 0x0020, 0x0020, 0x0000, 0x0004, 0x0004, 0x0002, 0x0000 };

    auto collation = collate_for_tests(
        cps, cps + 2, boost::text::variable_weighting::non_ignorable);

    EXPECT_EQ(collation.size(), 12);
    EXPECT_TRUE(boost::algorithm::equal(collation.begin(), collation.end(), ces, ces + 12))
        << "from:     " << ce_dumper(cps)
        << "expected: " << ce_dumper(ces)
        << "got:      " << ce_dumper(collation);
}

TEST(collation, non_ignorable_110_009)
{
    // 2163 0021;	
    // (Ⅳ) ROMAN NUMERAL FOUR	[1D98 1F49 0261 | 0020 0020 0020 | 000A 000A 0002 |]

    uint32_t cps[2] = { 0x2163, 0x0021 };
    uint32_t const ces[12] = { 0x1D98, 0x1F49, 0x0261, 0x0000, 0x0020, 0x0020, 0x0020, 0x0000, 0x000A, 0x000A, 0x0002, 0x0000 };

    auto collation = collate_for_tests(
        cps, cps + 2, boost::text::variable_weighting::non_ignorable);

    EXPECT_EQ(collation.size(), 12);
    EXPECT_TRUE(boost::algorithm::equal(collation.begin(), collation.end(), ces, ces + 12))
        << "from:     " << ce_dumper(cps)
        << "expected: " << ce_dumper(ces)
        << "got:      " << ce_dumper(collation);
}

TEST(collation, non_ignorable_110_010)
{
    // 2173 003F;	
    // (ⅳ) SMALL ROMAN NUMERAL FOUR	[1D98 1F49 0267 | 0020 0020 0020 | 0004 0004 0002 |]

    uint32_t cps[2] = { 0x2173, 0x003F };
    uint32_t const ces[12] = { 0x1D98, 0x1F49, 0x0267, 0x0000, 0x0020, 0x0020, 0x0020, 0x0000, 0x0004, 0x0004, 0x0002, 0x0000 };

    auto collation = collate_for_tests(
        cps, cps + 2, boost::text::variable_weighting::non_ignorable);

    EXPECT_EQ(collation.size(), 12);
    EXPECT_TRUE(boost::algorithm::equal(collation.begin(), collation.end(), ces, ces + 12))
        << "from:     " << ce_dumper(cps)
        << "expected: " << ce_dumper(ces)
        << "got:      " << ce_dumper(collation);
}

TEST(collation, non_ignorable_110_011)
{
    // 2163 003F;	
    // (Ⅳ) ROMAN NUMERAL FOUR	[1D98 1F49 0267 | 0020 0020 0020 | 000A 000A 0002 |]

    uint32_t cps[2] = { 0x2163, 0x003F };
    uint32_t const ces[12] = { 0x1D98, 0x1F49, 0x0267, 0x0000, 0x0020, 0x0020, 0x0020, 0x0000, 0x000A, 0x000A, 0x0002, 0x0000 };

    auto collation = collate_for_tests(
        cps, cps + 2, boost::text::variable_weighting::non_ignorable);

    EXPECT_EQ(collation.size(), 12);
    EXPECT_TRUE(boost::algorithm::equal(collation.begin(), collation.end(), ces, ces + 12))
        << "from:     " << ce_dumper(cps)
        << "expected: " << ce_dumper(ces)
        << "got:      " << ce_dumper(collation);
}

TEST(collation, non_ignorable_110_012)
{
    // 2173 0061;	
    // (ⅳ) SMALL ROMAN NUMERAL FOUR	[1D98 1F49 1CAD | 0020 0020 0020 | 0004 0004 0002 |]

    uint32_t cps[2] = { 0x2173, 0x0061 };
    uint32_t const ces[12] = { 0x1D98, 0x1F49, 0x1CAD, 0x0000, 0x0020, 0x0020, 0x0020, 0x0000, 0x0004, 0x0004, 0x0002, 0x0000 };

    auto collation = collate_for_tests(
        cps, cps + 2, boost::text::variable_weighting::non_ignorable);

    EXPECT_EQ(collation.size(), 12);
    EXPECT_TRUE(boost::algorithm::equal(collation.begin(), collation.end(), ces, ces + 12))
        << "from:     " << ce_dumper(cps)
        << "expected: " << ce_dumper(ces)
        << "got:      " << ce_dumper(collation);
}

TEST(collation, non_ignorable_110_013)
{
    // 2173 0041;	
    // (ⅳ) SMALL ROMAN NUMERAL FOUR	[1D98 1F49 1CAD | 0020 0020 0020 | 0004 0004 0008 |]

    uint32_t cps[2] = { 0x2173, 0x0041 };
    uint32_t const ces[12] = { 0x1D98, 0x1F49, 0x1CAD, 0x0000, 0x0020, 0x0020, 0x0020, 0x0000, 0x0004, 0x0004, 0x0008, 0x0000 };

    auto collation = collate_for_tests(
        cps, cps + 2, boost::text::variable_weighting::non_ignorable);

    EXPECT_EQ(collation.size(), 12);
    EXPECT_TRUE(boost::algorithm::equal(collation.begin(), collation.end(), ces, ces + 12))
        << "from:     " << ce_dumper(cps)
        << "expected: " << ce_dumper(ces)
        << "got:      " << ce_dumper(collation);
}

TEST(collation, non_ignorable_110_014)
{
    // 2163 0061;	
    // (Ⅳ) ROMAN NUMERAL FOUR	[1D98 1F49 1CAD | 0020 0020 0020 | 000A 000A 0002 |]

    uint32_t cps[2] = { 0x2163, 0x0061 };
    uint32_t const ces[12] = { 0x1D98, 0x1F49, 0x1CAD, 0x0000, 0x0020, 0x0020, 0x0020, 0x0000, 0x000A, 0x000A, 0x0002, 0x0000 };

    auto collation = collate_for_tests(
        cps, cps + 2, boost::text::variable_weighting::non_ignorable);

    EXPECT_EQ(collation.size(), 12);
    EXPECT_TRUE(boost::algorithm::equal(collation.begin(), collation.end(), ces, ces + 12))
        << "from:     " << ce_dumper(cps)
        << "expected: " << ce_dumper(ces)
        << "got:      " << ce_dumper(collation);
}

TEST(collation, non_ignorable_110_015)
{
    // 2163 0041;	
    // (Ⅳ) ROMAN NUMERAL FOUR	[1D98 1F49 1CAD | 0020 0020 0020 | 000A 000A 0008 |]

    uint32_t cps[2] = { 0x2163, 0x0041 };
    uint32_t const ces[12] = { 0x1D98, 0x1F49, 0x1CAD, 0x0000, 0x0020, 0x0020, 0x0020, 0x0000, 0x000A, 0x000A, 0x0008, 0x0000 };

    auto collation = collate_for_tests(
        cps, cps + 2, boost::text::variable_weighting::non_ignorable);

    EXPECT_EQ(collation.size(), 12);
    EXPECT_TRUE(boost::algorithm::equal(collation.begin(), collation.end(), ces, ces + 12))
        << "from:     " << ce_dumper(cps)
        << "expected: " << ce_dumper(ces)
        << "got:      " << ce_dumper(collation);
}

TEST(collation, non_ignorable_110_016)
{
    // 2173 0062;	
    // (ⅳ) SMALL ROMAN NUMERAL FOUR	[1D98 1F49 1CC6 | 0020 0020 0020 | 0004 0004 0002 |]

    uint32_t cps[2] = { 0x2173, 0x0062 };
    uint32_t const ces[12] = { 0x1D98, 0x1F49, 0x1CC6, 0x0000, 0x0020, 0x0020, 0x0020, 0x0000, 0x0004, 0x0004, 0x0002, 0x0000 };

    auto collation = collate_for_tests(
        cps, cps + 2, boost::text::variable_weighting::non_ignorable);

    EXPECT_EQ(collation.size(), 12);
    EXPECT_TRUE(boost::algorithm::equal(collation.begin(), collation.end(), ces, ces + 12))
        << "from:     " << ce_dumper(cps)
        << "expected: " << ce_dumper(ces)
        << "got:      " << ce_dumper(collation);
}

TEST(collation, non_ignorable_110_017)
{
    // 2163 0062;	
    // (Ⅳ) ROMAN NUMERAL FOUR	[1D98 1F49 1CC6 | 0020 0020 0020 | 000A 000A 0002 |]

    uint32_t cps[2] = { 0x2163, 0x0062 };
    uint32_t const ces[12] = { 0x1D98, 0x1F49, 0x1CC6, 0x0000, 0x0020, 0x0020, 0x0020, 0x0000, 0x000A, 0x000A, 0x0002, 0x0000 };

    auto collation = collate_for_tests(
        cps, cps + 2, boost::text::variable_weighting::non_ignorable);

    EXPECT_EQ(collation.size(), 12);
    EXPECT_TRUE(boost::algorithm::equal(collation.begin(), collation.end(), ces, ces + 12))
        << "from:     " << ce_dumper(cps)
        << "expected: " << ce_dumper(ces)
        << "got:      " << ce_dumper(collation);
}

TEST(collation, non_ignorable_110_018)
{
    // 2178 0021;	
    // (ⅸ) SMALL ROMAN NUMERAL NINE	[1D98 1F65 0261 | 0020 0020 0020 | 0004 0004 0002 |]

    uint32_t cps[2] = { 0x2178, 0x0021 };
    uint32_t const ces[12] = { 0x1D98, 0x1F65, 0x0261, 0x0000, 0x0020, 0x0020, 0x0020, 0x0000, 0x0004, 0x0004, 0x0002, 0x0000 };

    auto collation = collate_for_tests(
        cps, cps + 2, boost::text::variable_weighting::non_ignorable);

    EXPECT_EQ(collation.size(), 12);
    EXPECT_TRUE(boost::algorithm::equal(collation.begin(), collation.end(), ces, ces + 12))
        << "from:     " << ce_dumper(cps)
        << "expected: " << ce_dumper(ces)
        << "got:      " << ce_dumper(collation);
}

TEST(collation, non_ignorable_110_019)
{
    // 2168 0021;	
    // (Ⅸ) ROMAN NUMERAL NINE	[1D98 1F65 0261 | 0020 0020 0020 | 000A 000A 0002 |]

    uint32_t cps[2] = { 0x2168, 0x0021 };
    uint32_t const ces[12] = { 0x1D98, 0x1F65, 0x0261, 0x0000, 0x0020, 0x0020, 0x0020, 0x0000, 0x000A, 0x000A, 0x0002, 0x0000 };

    auto collation = collate_for_tests(
        cps, cps + 2, boost::text::variable_weighting::non_ignorable);

    EXPECT_EQ(collation.size(), 12);
    EXPECT_TRUE(boost::algorithm::equal(collation.begin(), collation.end(), ces, ces + 12))
        << "from:     " << ce_dumper(cps)
        << "expected: " << ce_dumper(ces)
        << "got:      " << ce_dumper(collation);
}

TEST(collation, non_ignorable_110_020)
{
    // 2178 003F;	
    // (ⅸ) SMALL ROMAN NUMERAL NINE	[1D98 1F65 0267 | 0020 0020 0020 | 0004 0004 0002 |]

    uint32_t cps[2] = { 0x2178, 0x003F };
    uint32_t const ces[12] = { 0x1D98, 0x1F65, 0x0267, 0x0000, 0x0020, 0x0020, 0x0020, 0x0000, 0x0004, 0x0004, 0x0002, 0x0000 };

    auto collation = collate_for_tests(
        cps, cps + 2, boost::text::variable_weighting::non_ignorable);

    EXPECT_EQ(collation.size(), 12);
    EXPECT_TRUE(boost::algorithm::equal(collation.begin(), collation.end(), ces, ces + 12))
        << "from:     " << ce_dumper(cps)
        << "expected: " << ce_dumper(ces)
        << "got:      " << ce_dumper(collation);
}

TEST(collation, non_ignorable_110_021)
{
    // 2168 003F;	
    // (Ⅸ) ROMAN NUMERAL NINE	[1D98 1F65 0267 | 0020 0020 0020 | 000A 000A 0002 |]

    uint32_t cps[2] = { 0x2168, 0x003F };
    uint32_t const ces[12] = { 0x1D98, 0x1F65, 0x0267, 0x0000, 0x0020, 0x0020, 0x0020, 0x0000, 0x000A, 0x000A, 0x0002, 0x0000 };

    auto collation = collate_for_tests(
        cps, cps + 2, boost::text::variable_weighting::non_ignorable);

    EXPECT_EQ(collation.size(), 12);
    EXPECT_TRUE(boost::algorithm::equal(collation.begin(), collation.end(), ces, ces + 12))
        << "from:     " << ce_dumper(cps)
        << "expected: " << ce_dumper(ces)
        << "got:      " << ce_dumper(collation);
}

TEST(collation, non_ignorable_110_022)
{
    // 2178 0061;	
    // (ⅸ) SMALL ROMAN NUMERAL NINE	[1D98 1F65 1CAD | 0020 0020 0020 | 0004 0004 0002 |]

    uint32_t cps[2] = { 0x2178, 0x0061 };
    uint32_t const ces[12] = { 0x1D98, 0x1F65, 0x1CAD, 0x0000, 0x0020, 0x0020, 0x0020, 0x0000, 0x0004, 0x0004, 0x0002, 0x0000 };

    auto collation = collate_for_tests(
        cps, cps + 2, boost::text::variable_weighting::non_ignorable);

    EXPECT_EQ(collation.size(), 12);
    EXPECT_TRUE(boost::algorithm::equal(collation.begin(), collation.end(), ces, ces + 12))
        << "from:     " << ce_dumper(cps)
        << "expected: " << ce_dumper(ces)
        << "got:      " << ce_dumper(collation);
}

TEST(collation, non_ignorable_110_023)
{
    // 2178 0041;	
    // (ⅸ) SMALL ROMAN NUMERAL NINE	[1D98 1F65 1CAD | 0020 0020 0020 | 0004 0004 0008 |]

    uint32_t cps[2] = { 0x2178, 0x0041 };
    uint32_t const ces[12] = { 0x1D98, 0x1F65, 0x1CAD, 0x0000, 0x0020, 0x0020, 0x0020, 0x0000, 0x0004, 0x0004, 0x0008, 0x0000 };

    auto collation = collate_for_tests(
        cps, cps + 2, boost::text::variable_weighting::non_ignorable);

    EXPECT_EQ(collation.size(), 12);
    EXPECT_TRUE(boost::algorithm::equal(collation.begin(), collation.end(), ces, ces + 12))
        << "from:     " << ce_dumper(cps)
        << "expected: " << ce_dumper(ces)
        << "got:      " << ce_dumper(collation);
}

TEST(collation, non_ignorable_110_024)
{
    // 2168 0061;	
    // (Ⅸ) ROMAN NUMERAL NINE	[1D98 1F65 1CAD | 0020 0020 0020 | 000A 000A 0002 |]

    uint32_t cps[2] = { 0x2168, 0x0061 };
    uint32_t const ces[12] = { 0x1D98, 0x1F65, 0x1CAD, 0x0000, 0x0020, 0x0020, 0x0020, 0x0000, 0x000A, 0x000A, 0x0002, 0x0000 };

    auto collation = collate_for_tests(
        cps, cps + 2, boost::text::variable_weighting::non_ignorable);

    EXPECT_EQ(collation.size(), 12);
    EXPECT_TRUE(boost::algorithm::equal(collation.begin(), collation.end(), ces, ces + 12))
        << "from:     " << ce_dumper(cps)
        << "expected: " << ce_dumper(ces)
        << "got:      " << ce_dumper(collation);
}

TEST(collation, non_ignorable_110_025)
{
    // 2168 0041;	
    // (Ⅸ) ROMAN NUMERAL NINE	[1D98 1F65 1CAD | 0020 0020 0020 | 000A 000A 0008 |]

    uint32_t cps[2] = { 0x2168, 0x0041 };
    uint32_t const ces[12] = { 0x1D98, 0x1F65, 0x1CAD, 0x0000, 0x0020, 0x0020, 0x0020, 0x0000, 0x000A, 0x000A, 0x0008, 0x0000 };

    auto collation = collate_for_tests(
        cps, cps + 2, boost::text::variable_weighting::non_ignorable);

    EXPECT_EQ(collation.size(), 12);
    EXPECT_TRUE(boost::algorithm::equal(collation.begin(), collation.end(), ces, ces + 12))
        << "from:     " << ce_dumper(cps)
        << "expected: " << ce_dumper(ces)
        << "got:      " << ce_dumper(collation);
}

TEST(collation, non_ignorable_110_026)
{
    // 2178 0062;	
    // (ⅸ) SMALL ROMAN NUMERAL NINE	[1D98 1F65 1CC6 | 0020 0020 0020 | 0004 0004 0002 |]

    uint32_t cps[2] = { 0x2178, 0x0062 };
    uint32_t const ces[12] = { 0x1D98, 0x1F65, 0x1CC6, 0x0000, 0x0020, 0x0020, 0x0020, 0x0000, 0x0004, 0x0004, 0x0002, 0x0000 };

    auto collation = collate_for_tests(
        cps, cps + 2, boost::text::variable_weighting::non_ignorable);

    EXPECT_EQ(collation.size(), 12);
    EXPECT_TRUE(boost::algorithm::equal(collation.begin(), collation.end(), ces, ces + 12))
        << "from:     " << ce_dumper(cps)
        << "expected: " << ce_dumper(ces)
        << "got:      " << ce_dumper(collation);
}

TEST(collation, non_ignorable_110_027)
{
    // 2168 0062;	
    // (Ⅸ) ROMAN NUMERAL NINE	[1D98 1F65 1CC6 | 0020 0020 0020 | 000A 000A 0002 |]

    uint32_t cps[2] = { 0x2168, 0x0062 };
    uint32_t const ces[12] = { 0x1D98, 0x1F65, 0x1CC6, 0x0000, 0x0020, 0x0020, 0x0020, 0x0000, 0x000A, 0x000A, 0x0002, 0x0000 };

    auto collation = collate_for_tests(
        cps, cps + 2, boost::text::variable_weighting::non_ignorable);

    EXPECT_EQ(collation.size(), 12);
    EXPECT_TRUE(boost::algorithm::equal(collation.begin(), collation.end(), ces, ces + 12))
        << "from:     " << ce_dumper(cps)
        << "expected: " << ce_dumper(ces)
        << "got:      " << ce_dumper(collation);
}

TEST(collation, non_ignorable_110_028)
{
    // 0131 0021;	
    // (ı) LATIN SMALL LETTER DOTLESS I	[1D9C 0261 | 0020 0020 | 0002 0002 |]

    uint32_t cps[2] = { 0x0131, 0x0021 };
    uint32_t const ces[9] = { 0x1D9C, 0x0261, 0x0000, 0x0020, 0x0020, 0x0000, 0x0002, 0x0002, 0x0000 };

    auto collation = collate_for_tests(
        cps, cps + 2, boost::text::variable_weighting::non_ignorable);

    EXPECT_EQ(collation.size(), 9);
    EXPECT_TRUE(boost::algorithm::equal(collation.begin(), collation.end(), ces, ces + 9))
        << "from:     " << ce_dumper(cps)
        << "expected: " << ce_dumper(ces)
        << "got:      " << ce_dumper(collation);
}

TEST(collation, non_ignorable_110_029)
{
    // 1D6A4 0021;	
    // (𝚤) MATHEMATICAL ITALIC SMALL DOTLESS I	[1D9C 0261 | 0020 0020 | 0005 0002 |]

    uint32_t cps[2] = { 0x1D6A4, 0x0021 };
    uint32_t const ces[9] = { 0x1D9C, 0x0261, 0x0000, 0x0020, 0x0020, 0x0000, 0x0005, 0x0002, 0x0000 };

    auto collation = collate_for_tests(
        cps, cps + 2, boost::text::variable_weighting::non_ignorable);

    EXPECT_EQ(collation.size(), 9);
    EXPECT_TRUE(boost::algorithm::equal(collation.begin(), collation.end(), ces, ces + 9))
        << "from:     " << ce_dumper(cps)
        << "expected: " << ce_dumper(ces)
        << "got:      " << ce_dumper(collation);
}

TEST(collation, non_ignorable_110_030)
{
    // 0131 003F;	
    // (ı) LATIN SMALL LETTER DOTLESS I	[1D9C 0267 | 0020 0020 | 0002 0002 |]

    uint32_t cps[2] = { 0x0131, 0x003F };
    uint32_t const ces[9] = { 0x1D9C, 0x0267, 0x0000, 0x0020, 0x0020, 0x0000, 0x0002, 0x0002, 0x0000 };

    auto collation = collate_for_tests(
        cps, cps + 2, boost::text::variable_weighting::non_ignorable);

    EXPECT_EQ(collation.size(), 9);
    EXPECT_TRUE(boost::algorithm::equal(collation.begin(), collation.end(), ces, ces + 9))
        << "from:     " << ce_dumper(cps)
        << "expected: " << ce_dumper(ces)
        << "got:      " << ce_dumper(collation);
}

TEST(collation, non_ignorable_110_031)
{
    // 1D6A4 003F;	
    // (𝚤) MATHEMATICAL ITALIC SMALL DOTLESS I	[1D9C 0267 | 0020 0020 | 0005 0002 |]

    uint32_t cps[2] = { 0x1D6A4, 0x003F };
    uint32_t const ces[9] = { 0x1D9C, 0x0267, 0x0000, 0x0020, 0x0020, 0x0000, 0x0005, 0x0002, 0x0000 };

    auto collation = collate_for_tests(
        cps, cps + 2, boost::text::variable_weighting::non_ignorable);

    EXPECT_EQ(collation.size(), 9);
    EXPECT_TRUE(boost::algorithm::equal(collation.begin(), collation.end(), ces, ces + 9))
        << "from:     " << ce_dumper(cps)
        << "expected: " << ce_dumper(ces)
        << "got:      " << ce_dumper(collation);
}

TEST(collation, non_ignorable_110_032)
{
    // 0131 0061;	
    // (ı) LATIN SMALL LETTER DOTLESS I	[1D9C 1CAD | 0020 0020 | 0002 0002 |]

    uint32_t cps[2] = { 0x0131, 0x0061 };
    uint32_t const ces[9] = { 0x1D9C, 0x1CAD, 0x0000, 0x0020, 0x0020, 0x0000, 0x0002, 0x0002, 0x0000 };

    auto collation = collate_for_tests(
        cps, cps + 2, boost::text::variable_weighting::non_ignorable);

    EXPECT_EQ(collation.size(), 9);
    EXPECT_TRUE(boost::algorithm::equal(collation.begin(), collation.end(), ces, ces + 9))
        << "from:     " << ce_dumper(cps)
        << "expected: " << ce_dumper(ces)
        << "got:      " << ce_dumper(collation);
}

TEST(collation, non_ignorable_110_033)
{
    // 0131 0041;	
    // (ı) LATIN SMALL LETTER DOTLESS I	[1D9C 1CAD | 0020 0020 | 0002 0008 |]

    uint32_t cps[2] = { 0x0131, 0x0041 };
    uint32_t const ces[9] = { 0x1D9C, 0x1CAD, 0x0000, 0x0020, 0x0020, 0x0000, 0x0002, 0x0008, 0x0000 };

    auto collation = collate_for_tests(
        cps, cps + 2, boost::text::variable_weighting::non_ignorable);

    EXPECT_EQ(collation.size(), 9);
    EXPECT_TRUE(boost::algorithm::equal(collation.begin(), collation.end(), ces, ces + 9))
        << "from:     " << ce_dumper(cps)
        << "expected: " << ce_dumper(ces)
        << "got:      " << ce_dumper(collation);
}

TEST(collation, non_ignorable_110_034)
{
    // 1D6A4 0061;	
    // (𝚤) MATHEMATICAL ITALIC SMALL DOTLESS I	[1D9C 1CAD | 0020 0020 | 0005 0002 |]

    uint32_t cps[2] = { 0x1D6A4, 0x0061 };
    uint32_t const ces[9] = { 0x1D9C, 0x1CAD, 0x0000, 0x0020, 0x0020, 0x0000, 0x0005, 0x0002, 0x0000 };

    auto collation = collate_for_tests(
        cps, cps + 2, boost::text::variable_weighting::non_ignorable);

    EXPECT_EQ(collation.size(), 9);
    EXPECT_TRUE(boost::algorithm::equal(collation.begin(), collation.end(), ces, ces + 9))
        << "from:     " << ce_dumper(cps)
        << "expected: " << ce_dumper(ces)
        << "got:      " << ce_dumper(collation);
}

TEST(collation, non_ignorable_110_035)
{
    // 1D6A4 0041;	
    // (𝚤) MATHEMATICAL ITALIC SMALL DOTLESS I	[1D9C 1CAD | 0020 0020 | 0005 0008 |]

    uint32_t cps[2] = { 0x1D6A4, 0x0041 };
    uint32_t const ces[9] = { 0x1D9C, 0x1CAD, 0x0000, 0x0020, 0x0020, 0x0000, 0x0005, 0x0008, 0x0000 };

    auto collation = collate_for_tests(
        cps, cps + 2, boost::text::variable_weighting::non_ignorable);

    EXPECT_EQ(collation.size(), 9);
    EXPECT_TRUE(boost::algorithm::equal(collation.begin(), collation.end(), ces, ces + 9))
        << "from:     " << ce_dumper(cps)
        << "expected: " << ce_dumper(ces)
        << "got:      " << ce_dumper(collation);
}

TEST(collation, non_ignorable_110_036)
{
    // 0131 0062;	
    // (ı) LATIN SMALL LETTER DOTLESS I	[1D9C 1CC6 | 0020 0020 | 0002 0002 |]

    uint32_t cps[2] = { 0x0131, 0x0062 };
    uint32_t const ces[9] = { 0x1D9C, 0x1CC6, 0x0000, 0x0020, 0x0020, 0x0000, 0x0002, 0x0002, 0x0000 };

    auto collation = collate_for_tests(
        cps, cps + 2, boost::text::variable_weighting::non_ignorable);

    EXPECT_EQ(collation.size(), 9);
    EXPECT_TRUE(boost::algorithm::equal(collation.begin(), collation.end(), ces, ces + 9))
        << "from:     " << ce_dumper(cps)
        << "expected: " << ce_dumper(ces)
        << "got:      " << ce_dumper(collation);
}

TEST(collation, non_ignorable_110_037)
{
    // 1D6A4 0062;	
    // (𝚤) MATHEMATICAL ITALIC SMALL DOTLESS I	[1D9C 1CC6 | 0020 0020 | 0005 0002 |]

    uint32_t cps[2] = { 0x1D6A4, 0x0062 };
    uint32_t const ces[9] = { 0x1D9C, 0x1CC6, 0x0000, 0x0020, 0x0020, 0x0000, 0x0005, 0x0002, 0x0000 };

    auto collation = collate_for_tests(
        cps, cps + 2, boost::text::variable_weighting::non_ignorable);

    EXPECT_EQ(collation.size(), 9);
    EXPECT_TRUE(boost::algorithm::equal(collation.begin(), collation.end(), ces, ces + 9))
        << "from:     " << ce_dumper(cps)
        << "expected: " << ce_dumper(ces)
        << "got:      " << ce_dumper(collation);
}

TEST(collation, non_ignorable_110_038)
{
    // 026A 0021;	
    // (ɪ) LATIN LETTER SMALL CAPITAL I	[1DA0 0261 | 0020 0020 | 0002 0002 |]

    uint32_t cps[2] = { 0x026A, 0x0021 };
    uint32_t const ces[9] = { 0x1DA0, 0x0261, 0x0000, 0x0020, 0x0020, 0x0000, 0x0002, 0x0002, 0x0000 };

    auto collation = collate_for_tests(
        cps, cps + 2, boost::text::variable_weighting::non_ignorable);

    EXPECT_EQ(collation.size(), 9);
    EXPECT_TRUE(boost::algorithm::equal(collation.begin(), collation.end(), ces, ces + 9))
        << "from:     " << ce_dumper(cps)
        << "expected: " << ce_dumper(ces)
        << "got:      " << ce_dumper(collation);
}

TEST(collation, non_ignorable_110_039)
{
    // A7AE 0021;	
    // (Ɪ) LATIN CAPITAL LETTER SMALL CAPITAL I	[1DA0 0261 | 0020 0020 | 0008 0002 |]

    uint32_t cps[2] = { 0xA7AE, 0x0021 };
    uint32_t const ces[9] = { 0x1DA0, 0x0261, 0x0000, 0x0020, 0x0020, 0x0000, 0x0008, 0x0002, 0x0000 };

    auto collation = collate_for_tests(
        cps, cps + 2, boost::text::variable_weighting::non_ignorable);

    EXPECT_EQ(collation.size(), 9);
    EXPECT_TRUE(boost::algorithm::equal(collation.begin(), collation.end(), ces, ces + 9))
        << "from:     " << ce_dumper(cps)
        << "expected: " << ce_dumper(ces)
        << "got:      " << ce_dumper(collation);
}

TEST(collation, non_ignorable_110_040)
{
    // 1DA6 0021;	
    // (ᶦ) MODIFIER LETTER SMALL CAPITAL I	[1DA0 0261 | 0020 0020 | 0014 0002 |]

    uint32_t cps[2] = { 0x1DA6, 0x0021 };
    uint32_t const ces[9] = { 0x1DA0, 0x0261, 0x0000, 0x0020, 0x0020, 0x0000, 0x0014, 0x0002, 0x0000 };

    auto collation = collate_for_tests(
        cps, cps + 2, boost::text::variable_weighting::non_ignorable);

    EXPECT_EQ(collation.size(), 9);
    EXPECT_TRUE(boost::algorithm::equal(collation.begin(), collation.end(), ces, ces + 9))
        << "from:     " << ce_dumper(cps)
        << "expected: " << ce_dumper(ces)
        << "got:      " << ce_dumper(collation);
}

TEST(collation, non_ignorable_110_041)
{
    // 026A 003F;	
    // (ɪ) LATIN LETTER SMALL CAPITAL I	[1DA0 0267 | 0020 0020 | 0002 0002 |]

    uint32_t cps[2] = { 0x026A, 0x003F };
    uint32_t const ces[9] = { 0x1DA0, 0x0267, 0x0000, 0x0020, 0x0020, 0x0000, 0x0002, 0x0002, 0x0000 };

    auto collation = collate_for_tests(
        cps, cps + 2, boost::text::variable_weighting::non_ignorable);

    EXPECT_EQ(collation.size(), 9);
    EXPECT_TRUE(boost::algorithm::equal(collation.begin(), collation.end(), ces, ces + 9))
        << "from:     " << ce_dumper(cps)
        << "expected: " << ce_dumper(ces)
        << "got:      " << ce_dumper(collation);
}

TEST(collation, non_ignorable_110_042)
{
    // A7AE 003F;	
    // (Ɪ) LATIN CAPITAL LETTER SMALL CAPITAL I	[1DA0 0267 | 0020 0020 | 0008 0002 |]

    uint32_t cps[2] = { 0xA7AE, 0x003F };
    uint32_t const ces[9] = { 0x1DA0, 0x0267, 0x0000, 0x0020, 0x0020, 0x0000, 0x0008, 0x0002, 0x0000 };

    auto collation = collate_for_tests(
        cps, cps + 2, boost::text::variable_weighting::non_ignorable);

    EXPECT_EQ(collation.size(), 9);
    EXPECT_TRUE(boost::algorithm::equal(collation.begin(), collation.end(), ces, ces + 9))
        << "from:     " << ce_dumper(cps)
        << "expected: " << ce_dumper(ces)
        << "got:      " << ce_dumper(collation);
}

TEST(collation, non_ignorable_110_043)
{
    // 1DA6 003F;	
    // (ᶦ) MODIFIER LETTER SMALL CAPITAL I	[1DA0 0267 | 0020 0020 | 0014 0002 |]

    uint32_t cps[2] = { 0x1DA6, 0x003F };
    uint32_t const ces[9] = { 0x1DA0, 0x0267, 0x0000, 0x0020, 0x0020, 0x0000, 0x0014, 0x0002, 0x0000 };

    auto collation = collate_for_tests(
        cps, cps + 2, boost::text::variable_weighting::non_ignorable);

    EXPECT_EQ(collation.size(), 9);
    EXPECT_TRUE(boost::algorithm::equal(collation.begin(), collation.end(), ces, ces + 9))
        << "from:     " << ce_dumper(cps)
        << "expected: " << ce_dumper(ces)
        << "got:      " << ce_dumper(collation);
}

TEST(collation, non_ignorable_110_044)
{
    // 026A 0061;	
    // (ɪ) LATIN LETTER SMALL CAPITAL I	[1DA0 1CAD | 0020 0020 | 0002 0002 |]

    uint32_t cps[2] = { 0x026A, 0x0061 };
    uint32_t const ces[9] = { 0x1DA0, 0x1CAD, 0x0000, 0x0020, 0x0020, 0x0000, 0x0002, 0x0002, 0x0000 };

    auto collation = collate_for_tests(
        cps, cps + 2, boost::text::variable_weighting::non_ignorable);

    EXPECT_EQ(collation.size(), 9);
    EXPECT_TRUE(boost::algorithm::equal(collation.begin(), collation.end(), ces, ces + 9))
        << "from:     " << ce_dumper(cps)
        << "expected: " << ce_dumper(ces)
        << "got:      " << ce_dumper(collation);
}

TEST(collation, non_ignorable_110_045)
{
    // 026A 0041;	
    // (ɪ) LATIN LETTER SMALL CAPITAL I	[1DA0 1CAD | 0020 0020 | 0002 0008 |]

    uint32_t cps[2] = { 0x026A, 0x0041 };
    uint32_t const ces[9] = { 0x1DA0, 0x1CAD, 0x0000, 0x0020, 0x0020, 0x0000, 0x0002, 0x0008, 0x0000 };

    auto collation = collate_for_tests(
        cps, cps + 2, boost::text::variable_weighting::non_ignorable);

    EXPECT_EQ(collation.size(), 9);
    EXPECT_TRUE(boost::algorithm::equal(collation.begin(), collation.end(), ces, ces + 9))
        << "from:     " << ce_dumper(cps)
        << "expected: " << ce_dumper(ces)
        << "got:      " << ce_dumper(collation);
}

TEST(collation, non_ignorable_110_046)
{
    // A7AE 0061;	
    // (Ɪ) LATIN CAPITAL LETTER SMALL CAPITAL I	[1DA0 1CAD | 0020 0020 | 0008 0002 |]

    uint32_t cps[2] = { 0xA7AE, 0x0061 };
    uint32_t const ces[9] = { 0x1DA0, 0x1CAD, 0x0000, 0x0020, 0x0020, 0x0000, 0x0008, 0x0002, 0x0000 };

    auto collation = collate_for_tests(
        cps, cps + 2, boost::text::variable_weighting::non_ignorable);

    EXPECT_EQ(collation.size(), 9);
    EXPECT_TRUE(boost::algorithm::equal(collation.begin(), collation.end(), ces, ces + 9))
        << "from:     " << ce_dumper(cps)
        << "expected: " << ce_dumper(ces)
        << "got:      " << ce_dumper(collation);
}

TEST(collation, non_ignorable_110_047)
{
    // A7AE 0041;	
    // (Ɪ) LATIN CAPITAL LETTER SMALL CAPITAL I	[1DA0 1CAD | 0020 0020 | 0008 0008 |]

    uint32_t cps[2] = { 0xA7AE, 0x0041 };
    uint32_t const ces[9] = { 0x1DA0, 0x1CAD, 0x0000, 0x0020, 0x0020, 0x0000, 0x0008, 0x0008, 0x0000 };

    auto collation = collate_for_tests(
        cps, cps + 2, boost::text::variable_weighting::non_ignorable);

    EXPECT_EQ(collation.size(), 9);
    EXPECT_TRUE(boost::algorithm::equal(collation.begin(), collation.end(), ces, ces + 9))
        << "from:     " << ce_dumper(cps)
        << "expected: " << ce_dumper(ces)
        << "got:      " << ce_dumper(collation);
}

TEST(collation, non_ignorable_110_048)
{
    // 1DA6 0061;	
    // (ᶦ) MODIFIER LETTER SMALL CAPITAL I	[1DA0 1CAD | 0020 0020 | 0014 0002 |]

    uint32_t cps[2] = { 0x1DA6, 0x0061 };
    uint32_t const ces[9] = { 0x1DA0, 0x1CAD, 0x0000, 0x0020, 0x0020, 0x0000, 0x0014, 0x0002, 0x0000 };

    auto collation = collate_for_tests(
        cps, cps + 2, boost::text::variable_weighting::non_ignorable);

    EXPECT_EQ(collation.size(), 9);
    EXPECT_TRUE(boost::algorithm::equal(collation.begin(), collation.end(), ces, ces + 9))
        << "from:     " << ce_dumper(cps)
        << "expected: " << ce_dumper(ces)
        << "got:      " << ce_dumper(collation);
}

TEST(collation, non_ignorable_110_049)
{
    // 1DA6 0041;	
    // (ᶦ) MODIFIER LETTER SMALL CAPITAL I	[1DA0 1CAD | 0020 0020 | 0014 0008 |]

    uint32_t cps[2] = { 0x1DA6, 0x0041 };
    uint32_t const ces[9] = { 0x1DA0, 0x1CAD, 0x0000, 0x0020, 0x0020, 0x0000, 0x0014, 0x0008, 0x0000 };

    auto collation = collate_for_tests(
        cps, cps + 2, boost::text::variable_weighting::non_ignorable);

    EXPECT_EQ(collation.size(), 9);
    EXPECT_TRUE(boost::algorithm::equal(collation.begin(), collation.end(), ces, ces + 9))
        << "from:     " << ce_dumper(cps)
        << "expected: " << ce_dumper(ces)
        << "got:      " << ce_dumper(collation);
}

TEST(collation, non_ignorable_110_050)
{
    // 026A 0062;	
    // (ɪ) LATIN LETTER SMALL CAPITAL I	[1DA0 1CC6 | 0020 0020 | 0002 0002 |]

    uint32_t cps[2] = { 0x026A, 0x0062 };
    uint32_t const ces[9] = { 0x1DA0, 0x1CC6, 0x0000, 0x0020, 0x0020, 0x0000, 0x0002, 0x0002, 0x0000 };

    auto collation = collate_for_tests(
        cps, cps + 2, boost::text::variable_weighting::non_ignorable);

    EXPECT_EQ(collation.size(), 9);
    EXPECT_TRUE(boost::algorithm::equal(collation.begin(), collation.end(), ces, ces + 9))
        << "from:     " << ce_dumper(cps)
        << "expected: " << ce_dumper(ces)
        << "got:      " << ce_dumper(collation);
}

TEST(collation, non_ignorable_110_051)
{
    // A7AE 0062;	
    // (Ɪ) LATIN CAPITAL LETTER SMALL CAPITAL I	[1DA0 1CC6 | 0020 0020 | 0008 0002 |]

    uint32_t cps[2] = { 0xA7AE, 0x0062 };
    uint32_t const ces[9] = { 0x1DA0, 0x1CC6, 0x0000, 0x0020, 0x0020, 0x0000, 0x0008, 0x0002, 0x0000 };

    auto collation = collate_for_tests(
        cps, cps + 2, boost::text::variable_weighting::non_ignorable);

    EXPECT_EQ(collation.size(), 9);
    EXPECT_TRUE(boost::algorithm::equal(collation.begin(), collation.end(), ces, ces + 9))
        << "from:     " << ce_dumper(cps)
        << "expected: " << ce_dumper(ces)
        << "got:      " << ce_dumper(collation);
}

TEST(collation, non_ignorable_110_052)
{
    // 1DA6 0062;	
    // (ᶦ) MODIFIER LETTER SMALL CAPITAL I	[1DA0 1CC6 | 0020 0020 | 0014 0002 |]

    uint32_t cps[2] = { 0x1DA6, 0x0062 };
    uint32_t const ces[9] = { 0x1DA0, 0x1CC6, 0x0000, 0x0020, 0x0020, 0x0000, 0x0014, 0x0002, 0x0000 };

    auto collation = collate_for_tests(
        cps, cps + 2, boost::text::variable_weighting::non_ignorable);

    EXPECT_EQ(collation.size(), 9);
    EXPECT_TRUE(boost::algorithm::equal(collation.begin(), collation.end(), ces, ces + 9))
        << "from:     " << ce_dumper(cps)
        << "expected: " << ce_dumper(ces)
        << "got:      " << ce_dumper(collation);
}

TEST(collation, non_ignorable_110_053)
{
    // A7FE 0021;	
    // (ꟾ) LATIN EPIGRAPHIC LETTER I LONGA	[1DA4 0261 | 0020 0020 | 0002 0002 |]

    uint32_t cps[2] = { 0xA7FE, 0x0021 };
    uint32_t const ces[9] = { 0x1DA4, 0x0261, 0x0000, 0x0020, 0x0020, 0x0000, 0x0002, 0x0002, 0x0000 };

    auto collation = collate_for_tests(
        cps, cps + 2, boost::text::variable_weighting::non_ignorable);

    EXPECT_EQ(collation.size(), 9);
    EXPECT_TRUE(boost::algorithm::equal(collation.begin(), collation.end(), ces, ces + 9))
        << "from:     " << ce_dumper(cps)
        << "expected: " << ce_dumper(ces)
        << "got:      " << ce_dumper(collation);
}

TEST(collation, non_ignorable_110_054)
{
    // A7FE 003F;	
    // (ꟾ) LATIN EPIGRAPHIC LETTER I LONGA	[1DA4 0267 | 0020 0020 | 0002 0002 |]

    uint32_t cps[2] = { 0xA7FE, 0x003F };
    uint32_t const ces[9] = { 0x1DA4, 0x0267, 0x0000, 0x0020, 0x0020, 0x0000, 0x0002, 0x0002, 0x0000 };

    auto collation = collate_for_tests(
        cps, cps + 2, boost::text::variable_weighting::non_ignorable);

    EXPECT_EQ(collation.size(), 9);
    EXPECT_TRUE(boost::algorithm::equal(collation.begin(), collation.end(), ces, ces + 9))
        << "from:     " << ce_dumper(cps)
        << "expected: " << ce_dumper(ces)
        << "got:      " << ce_dumper(collation);
}

TEST(collation, non_ignorable_110_055)
{
    // A7FE 0061;	
    // (ꟾ) LATIN EPIGRAPHIC LETTER I LONGA	[1DA4 1CAD | 0020 0020 | 0002 0002 |]

    uint32_t cps[2] = { 0xA7FE, 0x0061 };
    uint32_t const ces[9] = { 0x1DA4, 0x1CAD, 0x0000, 0x0020, 0x0020, 0x0000, 0x0002, 0x0002, 0x0000 };

    auto collation = collate_for_tests(
        cps, cps + 2, boost::text::variable_weighting::non_ignorable);

    EXPECT_EQ(collation.size(), 9);
    EXPECT_TRUE(boost::algorithm::equal(collation.begin(), collation.end(), ces, ces + 9))
        << "from:     " << ce_dumper(cps)
        << "expected: " << ce_dumper(ces)
        << "got:      " << ce_dumper(collation);
}

TEST(collation, non_ignorable_110_056)
{
    // A7FE 0041;	
    // (ꟾ) LATIN EPIGRAPHIC LETTER I LONGA	[1DA4 1CAD | 0020 0020 | 0002 0008 |]

    uint32_t cps[2] = { 0xA7FE, 0x0041 };
    uint32_t const ces[9] = { 0x1DA4, 0x1CAD, 0x0000, 0x0020, 0x0020, 0x0000, 0x0002, 0x0008, 0x0000 };

    auto collation = collate_for_tests(
        cps, cps + 2, boost::text::variable_weighting::non_ignorable);

    EXPECT_EQ(collation.size(), 9);
    EXPECT_TRUE(boost::algorithm::equal(collation.begin(), collation.end(), ces, ces + 9))
        << "from:     " << ce_dumper(cps)
        << "expected: " << ce_dumper(ces)
        << "got:      " << ce_dumper(collation);
}

TEST(collation, non_ignorable_110_057)
{
    // A7FE 0062;	
    // (ꟾ) LATIN EPIGRAPHIC LETTER I LONGA	[1DA4 1CC6 | 0020 0020 | 0002 0002 |]

    uint32_t cps[2] = { 0xA7FE, 0x0062 };
    uint32_t const ces[9] = { 0x1DA4, 0x1CC6, 0x0000, 0x0020, 0x0020, 0x0000, 0x0002, 0x0002, 0x0000 };

    auto collation = collate_for_tests(
        cps, cps + 2, boost::text::variable_weighting::non_ignorable);

    EXPECT_EQ(collation.size(), 9);
    EXPECT_TRUE(boost::algorithm::equal(collation.begin(), collation.end(), ces, ces + 9))
        << "from:     " << ce_dumper(cps)
        << "expected: " << ce_dumper(ces)
        << "got:      " << ce_dumper(collation);
}

TEST(collation, non_ignorable_110_058)
{
    // A7F7 0021;	
    // (ꟷ) LATIN EPIGRAPHIC LETTER SIDEWAYS I	[1DA5 0261 | 0020 0020 | 0002 0002 |]

    uint32_t cps[2] = { 0xA7F7, 0x0021 };
    uint32_t const ces[9] = { 0x1DA5, 0x0261, 0x0000, 0x0020, 0x0020, 0x0000, 0x0002, 0x0002, 0x0000 };

    auto collation = collate_for_tests(
        cps, cps + 2, boost::text::variable_weighting::non_ignorable);

    EXPECT_EQ(collation.size(), 9);
    EXPECT_TRUE(boost::algorithm::equal(collation.begin(), collation.end(), ces, ces + 9))
        << "from:     " << ce_dumper(cps)
        << "expected: " << ce_dumper(ces)
        << "got:      " << ce_dumper(collation);
}

TEST(collation, non_ignorable_110_059)
{
    // A7F7 003F;	
    // (ꟷ) LATIN EPIGRAPHIC LETTER SIDEWAYS I	[1DA5 0267 | 0020 0020 | 0002 0002 |]

    uint32_t cps[2] = { 0xA7F7, 0x003F };
    uint32_t const ces[9] = { 0x1DA5, 0x0267, 0x0000, 0x0020, 0x0020, 0x0000, 0x0002, 0x0002, 0x0000 };

    auto collation = collate_for_tests(
        cps, cps + 2, boost::text::variable_weighting::non_ignorable);

    EXPECT_EQ(collation.size(), 9);
    EXPECT_TRUE(boost::algorithm::equal(collation.begin(), collation.end(), ces, ces + 9))
        << "from:     " << ce_dumper(cps)
        << "expected: " << ce_dumper(ces)
        << "got:      " << ce_dumper(collation);
}

TEST(collation, non_ignorable_110_060)
{
    // A7F7 0061;	
    // (ꟷ) LATIN EPIGRAPHIC LETTER SIDEWAYS I	[1DA5 1CAD | 0020 0020 | 0002 0002 |]

    uint32_t cps[2] = { 0xA7F7, 0x0061 };
    uint32_t const ces[9] = { 0x1DA5, 0x1CAD, 0x0000, 0x0020, 0x0020, 0x0000, 0x0002, 0x0002, 0x0000 };

    auto collation = collate_for_tests(
        cps, cps + 2, boost::text::variable_weighting::non_ignorable);

    EXPECT_EQ(collation.size(), 9);
    EXPECT_TRUE(boost::algorithm::equal(collation.begin(), collation.end(), ces, ces + 9))
        << "from:     " << ce_dumper(cps)
        << "expected: " << ce_dumper(ces)
        << "got:      " << ce_dumper(collation);
}

TEST(collation, non_ignorable_110_061)
{
    // A7F7 0041;	
    // (ꟷ) LATIN EPIGRAPHIC LETTER SIDEWAYS I	[1DA5 1CAD | 0020 0020 | 0002 0008 |]

    uint32_t cps[2] = { 0xA7F7, 0x0041 };
    uint32_t const ces[9] = { 0x1DA5, 0x1CAD, 0x0000, 0x0020, 0x0020, 0x0000, 0x0002, 0x0008, 0x0000 };

    auto collation = collate_for_tests(
        cps, cps + 2, boost::text::variable_weighting::non_ignorable);

    EXPECT_EQ(collation.size(), 9);
    EXPECT_TRUE(boost::algorithm::equal(collation.begin(), collation.end(), ces, ces + 9))
        << "from:     " << ce_dumper(cps)
        << "expected: " << ce_dumper(ces)
        << "got:      " << ce_dumper(collation);
}

TEST(collation, non_ignorable_110_062)
{
    // A7F7 0062;	
    // (ꟷ) LATIN EPIGRAPHIC LETTER SIDEWAYS I	[1DA5 1CC6 | 0020 0020 | 0002 0002 |]

    uint32_t cps[2] = { 0xA7F7, 0x0062 };
    uint32_t const ces[9] = { 0x1DA5, 0x1CC6, 0x0000, 0x0020, 0x0020, 0x0000, 0x0002, 0x0002, 0x0000 };

    auto collation = collate_for_tests(
        cps, cps + 2, boost::text::variable_weighting::non_ignorable);

    EXPECT_EQ(collation.size(), 9);
    EXPECT_TRUE(boost::algorithm::equal(collation.begin(), collation.end(), ces, ces + 9))
        << "from:     " << ce_dumper(cps)
        << "expected: " << ce_dumper(ces)
        << "got:      " << ce_dumper(collation);
}

TEST(collation, non_ignorable_110_063)
{
    // 1D09 0021;	
    // (ᴉ) LATIN SMALL LETTER TURNED I	[1DA6 0261 | 0020 0020 | 0002 0002 |]

    uint32_t cps[2] = { 0x1D09, 0x0021 };
    uint32_t const ces[9] = { 0x1DA6, 0x0261, 0x0000, 0x0020, 0x0020, 0x0000, 0x0002, 0x0002, 0x0000 };

    auto collation = collate_for_tests(
        cps, cps + 2, boost::text::variable_weighting::non_ignorable);

    EXPECT_EQ(collation.size(), 9);
    EXPECT_TRUE(boost::algorithm::equal(collation.begin(), collation.end(), ces, ces + 9))
        << "from:     " << ce_dumper(cps)
        << "expected: " << ce_dumper(ces)
        << "got:      " << ce_dumper(collation);
}

TEST(collation, non_ignorable_110_064)
{
    // 1D4E 0021;	
    // (ᵎ) MODIFIER LETTER SMALL TURNED I	[1DA6 0261 | 0020 0020 | 0014 0002 |]

    uint32_t cps[2] = { 0x1D4E, 0x0021 };
    uint32_t const ces[9] = { 0x1DA6, 0x0261, 0x0000, 0x0020, 0x0020, 0x0000, 0x0014, 0x0002, 0x0000 };

    auto collation = collate_for_tests(
        cps, cps + 2, boost::text::variable_weighting::non_ignorable);

    EXPECT_EQ(collation.size(), 9);
    EXPECT_TRUE(boost::algorithm::equal(collation.begin(), collation.end(), ces, ces + 9))
        << "from:     " << ce_dumper(cps)
        << "expected: " << ce_dumper(ces)
        << "got:      " << ce_dumper(collation);
}

TEST(collation, non_ignorable_110_065)
{
    // 1D09 003F;	
    // (ᴉ) LATIN SMALL LETTER TURNED I	[1DA6 0267 | 0020 0020 | 0002 0002 |]

    uint32_t cps[2] = { 0x1D09, 0x003F };
    uint32_t const ces[9] = { 0x1DA6, 0x0267, 0x0000, 0x0020, 0x0020, 0x0000, 0x0002, 0x0002, 0x0000 };

    auto collation = collate_for_tests(
        cps, cps + 2, boost::text::variable_weighting::non_ignorable);

    EXPECT_EQ(collation.size(), 9);
    EXPECT_TRUE(boost::algorithm::equal(collation.begin(), collation.end(), ces, ces + 9))
        << "from:     " << ce_dumper(cps)
        << "expected: " << ce_dumper(ces)
        << "got:      " << ce_dumper(collation);
}

TEST(collation, non_ignorable_110_066)
{
    // 1D4E 003F;	
    // (ᵎ) MODIFIER LETTER SMALL TURNED I	[1DA6 0267 | 0020 0020 | 0014 0002 |]

    uint32_t cps[2] = { 0x1D4E, 0x003F };
    uint32_t const ces[9] = { 0x1DA6, 0x0267, 0x0000, 0x0020, 0x0020, 0x0000, 0x0014, 0x0002, 0x0000 };

    auto collation = collate_for_tests(
        cps, cps + 2, boost::text::variable_weighting::non_ignorable);

    EXPECT_EQ(collation.size(), 9);
    EXPECT_TRUE(boost::algorithm::equal(collation.begin(), collation.end(), ces, ces + 9))
        << "from:     " << ce_dumper(cps)
        << "expected: " << ce_dumper(ces)
        << "got:      " << ce_dumper(collation);
}

TEST(collation, non_ignorable_110_067)
{
    // 1D09 0061;	
    // (ᴉ) LATIN SMALL LETTER TURNED I	[1DA6 1CAD | 0020 0020 | 0002 0002 |]

    uint32_t cps[2] = { 0x1D09, 0x0061 };
    uint32_t const ces[9] = { 0x1DA6, 0x1CAD, 0x0000, 0x0020, 0x0020, 0x0000, 0x0002, 0x0002, 0x0000 };

    auto collation = collate_for_tests(
        cps, cps + 2, boost::text::variable_weighting::non_ignorable);

    EXPECT_EQ(collation.size(), 9);
    EXPECT_TRUE(boost::algorithm::equal(collation.begin(), collation.end(), ces, ces + 9))
        << "from:     " << ce_dumper(cps)
        << "expected: " << ce_dumper(ces)
        << "got:      " << ce_dumper(collation);
}

TEST(collation, non_ignorable_110_068)
{
    // 1D09 0041;	
    // (ᴉ) LATIN SMALL LETTER TURNED I	[1DA6 1CAD | 0020 0020 | 0002 0008 |]

    uint32_t cps[2] = { 0x1D09, 0x0041 };
    uint32_t const ces[9] = { 0x1DA6, 0x1CAD, 0x0000, 0x0020, 0x0020, 0x0000, 0x0002, 0x0008, 0x0000 };

    auto collation = collate_for_tests(
        cps, cps + 2, boost::text::variable_weighting::non_ignorable);

    EXPECT_EQ(collation.size(), 9);
    EXPECT_TRUE(boost::algorithm::equal(collation.begin(), collation.end(), ces, ces + 9))
        << "from:     " << ce_dumper(cps)
        << "expected: " << ce_dumper(ces)
        << "got:      " << ce_dumper(collation);
}

TEST(collation, non_ignorable_110_069)
{
    // 1D4E 0061;	
    // (ᵎ) MODIFIER LETTER SMALL TURNED I	[1DA6 1CAD | 0020 0020 | 0014 0002 |]

    uint32_t cps[2] = { 0x1D4E, 0x0061 };
    uint32_t const ces[9] = { 0x1DA6, 0x1CAD, 0x0000, 0x0020, 0x0020, 0x0000, 0x0014, 0x0002, 0x0000 };

    auto collation = collate_for_tests(
        cps, cps + 2, boost::text::variable_weighting::non_ignorable);

    EXPECT_EQ(collation.size(), 9);
    EXPECT_TRUE(boost::algorithm::equal(collation.begin(), collation.end(), ces, ces + 9))
        << "from:     " << ce_dumper(cps)
        << "expected: " << ce_dumper(ces)
        << "got:      " << ce_dumper(collation);
}

TEST(collation, non_ignorable_110_070)
{
    // 1D4E 0041;	
    // (ᵎ) MODIFIER LETTER SMALL TURNED I	[1DA6 1CAD | 0020 0020 | 0014 0008 |]

    uint32_t cps[2] = { 0x1D4E, 0x0041 };
    uint32_t const ces[9] = { 0x1DA6, 0x1CAD, 0x0000, 0x0020, 0x0020, 0x0000, 0x0014, 0x0008, 0x0000 };

    auto collation = collate_for_tests(
        cps, cps + 2, boost::text::variable_weighting::non_ignorable);

    EXPECT_EQ(collation.size(), 9);
    EXPECT_TRUE(boost::algorithm::equal(collation.begin(), collation.end(), ces, ces + 9))
        << "from:     " << ce_dumper(cps)
        << "expected: " << ce_dumper(ces)
        << "got:      " << ce_dumper(collation);
}

TEST(collation, non_ignorable_110_071)
{
    // 1D09 0062;	
    // (ᴉ) LATIN SMALL LETTER TURNED I	[1DA6 1CC6 | 0020 0020 | 0002 0002 |]

    uint32_t cps[2] = { 0x1D09, 0x0062 };
    uint32_t const ces[9] = { 0x1DA6, 0x1CC6, 0x0000, 0x0020, 0x0020, 0x0000, 0x0002, 0x0002, 0x0000 };

    auto collation = collate_for_tests(
        cps, cps + 2, boost::text::variable_weighting::non_ignorable);

    EXPECT_EQ(collation.size(), 9);
    EXPECT_TRUE(boost::algorithm::equal(collation.begin(), collation.end(), ces, ces + 9))
        << "from:     " << ce_dumper(cps)
        << "expected: " << ce_dumper(ces)
        << "got:      " << ce_dumper(collation);
}

TEST(collation, non_ignorable_110_072)
{
    // 1D4E 0062;	
    // (ᵎ) MODIFIER LETTER SMALL TURNED I	[1DA6 1CC6 | 0020 0020 | 0014 0002 |]

    uint32_t cps[2] = { 0x1D4E, 0x0062 };
    uint32_t const ces[9] = { 0x1DA6, 0x1CC6, 0x0000, 0x0020, 0x0020, 0x0000, 0x0014, 0x0002, 0x0000 };

    auto collation = collate_for_tests(
        cps, cps + 2, boost::text::variable_weighting::non_ignorable);

    EXPECT_EQ(collation.size(), 9);
    EXPECT_TRUE(boost::algorithm::equal(collation.begin(), collation.end(), ces, ces + 9))
        << "from:     " << ce_dumper(cps)
        << "expected: " << ce_dumper(ces)
        << "got:      " << ce_dumper(collation);
}

TEST(collation, non_ignorable_110_073)
{
    // 0268 0021;	
    // (ɨ) LATIN SMALL LETTER I WITH STROKE	[1DA7 0261 | 0020 0020 | 0002 0002 |]

    uint32_t cps[2] = { 0x0268, 0x0021 };
    uint32_t const ces[9] = { 0x1DA7, 0x0261, 0x0000, 0x0020, 0x0020, 0x0000, 0x0002, 0x0002, 0x0000 };

    auto collation = collate_for_tests(
        cps, cps + 2, boost::text::variable_weighting::non_ignorable);

    EXPECT_EQ(collation.size(), 9);
    EXPECT_TRUE(boost::algorithm::equal(collation.begin(), collation.end(), ces, ces + 9))
        << "from:     " << ce_dumper(cps)
        << "expected: " << ce_dumper(ces)
        << "got:      " << ce_dumper(collation);
}

TEST(collation, non_ignorable_110_074)
{
    // 0197 0021;	
    // (Ɨ) LATIN CAPITAL LETTER I WITH STROKE	[1DA7 0261 | 0020 0020 | 0008 0002 |]

    uint32_t cps[2] = { 0x0197, 0x0021 };
    uint32_t const ces[9] = { 0x1DA7, 0x0261, 0x0000, 0x0020, 0x0020, 0x0000, 0x0008, 0x0002, 0x0000 };

    auto collation = collate_for_tests(
        cps, cps + 2, boost::text::variable_weighting::non_ignorable);

    EXPECT_EQ(collation.size(), 9);
    EXPECT_TRUE(boost::algorithm::equal(collation.begin(), collation.end(), ces, ces + 9))
        << "from:     " << ce_dumper(cps)
        << "expected: " << ce_dumper(ces)
        << "got:      " << ce_dumper(collation);
}

TEST(collation, non_ignorable_110_075)
{
    // 1DA4 0021;	
    // (ᶤ) MODIFIER LETTER SMALL I WITH STROKE	[1DA7 0261 | 0020 0020 | 0014 0002 |]

    uint32_t cps[2] = { 0x1DA4, 0x0021 };
    uint32_t const ces[9] = { 0x1DA7, 0x0261, 0x0000, 0x0020, 0x0020, 0x0000, 0x0014, 0x0002, 0x0000 };

    auto collation = collate_for_tests(
        cps, cps + 2, boost::text::variable_weighting::non_ignorable);

    EXPECT_EQ(collation.size(), 9);
    EXPECT_TRUE(boost::algorithm::equal(collation.begin(), collation.end(), ces, ces + 9))
        << "from:     " << ce_dumper(cps)
        << "expected: " << ce_dumper(ces)
        << "got:      " << ce_dumper(collation);
}

TEST(collation, non_ignorable_110_076)
{
    // 0268 003F;	
    // (ɨ) LATIN SMALL LETTER I WITH STROKE	[1DA7 0267 | 0020 0020 | 0002 0002 |]

    uint32_t cps[2] = { 0x0268, 0x003F };
    uint32_t const ces[9] = { 0x1DA7, 0x0267, 0x0000, 0x0020, 0x0020, 0x0000, 0x0002, 0x0002, 0x0000 };

    auto collation = collate_for_tests(
        cps, cps + 2, boost::text::variable_weighting::non_ignorable);

    EXPECT_EQ(collation.size(), 9);
    EXPECT_TRUE(boost::algorithm::equal(collation.begin(), collation.end(), ces, ces + 9))
        << "from:     " << ce_dumper(cps)
        << "expected: " << ce_dumper(ces)
        << "got:      " << ce_dumper(collation);
}

TEST(collation, non_ignorable_110_077)
{
    // 0197 003F;	
    // (Ɨ) LATIN CAPITAL LETTER I WITH STROKE	[1DA7 0267 | 0020 0020 | 0008 0002 |]

    uint32_t cps[2] = { 0x0197, 0x003F };
    uint32_t const ces[9] = { 0x1DA7, 0x0267, 0x0000, 0x0020, 0x0020, 0x0000, 0x0008, 0x0002, 0x0000 };

    auto collation = collate_for_tests(
        cps, cps + 2, boost::text::variable_weighting::non_ignorable);

    EXPECT_EQ(collation.size(), 9);
    EXPECT_TRUE(boost::algorithm::equal(collation.begin(), collation.end(), ces, ces + 9))
        << "from:     " << ce_dumper(cps)
        << "expected: " << ce_dumper(ces)
        << "got:      " << ce_dumper(collation);
}

TEST(collation, non_ignorable_110_078)
{
    // 1DA4 003F;	
    // (ᶤ) MODIFIER LETTER SMALL I WITH STROKE	[1DA7 0267 | 0020 0020 | 0014 0002 |]

    uint32_t cps[2] = { 0x1DA4, 0x003F };
    uint32_t const ces[9] = { 0x1DA7, 0x0267, 0x0000, 0x0020, 0x0020, 0x0000, 0x0014, 0x0002, 0x0000 };

    auto collation = collate_for_tests(
        cps, cps + 2, boost::text::variable_weighting::non_ignorable);

    EXPECT_EQ(collation.size(), 9);
    EXPECT_TRUE(boost::algorithm::equal(collation.begin(), collation.end(), ces, ces + 9))
        << "from:     " << ce_dumper(cps)
        << "expected: " << ce_dumper(ces)
        << "got:      " << ce_dumper(collation);
}

TEST(collation, non_ignorable_110_079)
{
    // 0268 0061;	
    // (ɨ) LATIN SMALL LETTER I WITH STROKE	[1DA7 1CAD | 0020 0020 | 0002 0002 |]

    uint32_t cps[2] = { 0x0268, 0x0061 };
    uint32_t const ces[9] = { 0x1DA7, 0x1CAD, 0x0000, 0x0020, 0x0020, 0x0000, 0x0002, 0x0002, 0x0000 };

    auto collation = collate_for_tests(
        cps, cps + 2, boost::text::variable_weighting::non_ignorable);

    EXPECT_EQ(collation.size(), 9);
    EXPECT_TRUE(boost::algorithm::equal(collation.begin(), collation.end(), ces, ces + 9))
        << "from:     " << ce_dumper(cps)
        << "expected: " << ce_dumper(ces)
        << "got:      " << ce_dumper(collation);
}

TEST(collation, non_ignorable_110_080)
{
    // 0268 0041;	
    // (ɨ) LATIN SMALL LETTER I WITH STROKE	[1DA7 1CAD | 0020 0020 | 0002 0008 |]

    uint32_t cps[2] = { 0x0268, 0x0041 };
    uint32_t const ces[9] = { 0x1DA7, 0x1CAD, 0x0000, 0x0020, 0x0020, 0x0000, 0x0002, 0x0008, 0x0000 };

    auto collation = collate_for_tests(
        cps, cps + 2, boost::text::variable_weighting::non_ignorable);

    EXPECT_EQ(collation.size(), 9);
    EXPECT_TRUE(boost::algorithm::equal(collation.begin(), collation.end(), ces, ces + 9))
        << "from:     " << ce_dumper(cps)
        << "expected: " << ce_dumper(ces)
        << "got:      " << ce_dumper(collation);
}

TEST(collation, non_ignorable_110_081)
{
    // 0197 0061;	
    // (Ɨ) LATIN CAPITAL LETTER I WITH STROKE	[1DA7 1CAD | 0020 0020 | 0008 0002 |]

    uint32_t cps[2] = { 0x0197, 0x0061 };
    uint32_t const ces[9] = { 0x1DA7, 0x1CAD, 0x0000, 0x0020, 0x0020, 0x0000, 0x0008, 0x0002, 0x0000 };

    auto collation = collate_for_tests(
        cps, cps + 2, boost::text::variable_weighting::non_ignorable);

    EXPECT_EQ(collation.size(), 9);
    EXPECT_TRUE(boost::algorithm::equal(collation.begin(), collation.end(), ces, ces + 9))
        << "from:     " << ce_dumper(cps)
        << "expected: " << ce_dumper(ces)
        << "got:      " << ce_dumper(collation);
}

TEST(collation, non_ignorable_110_082)
{
    // 0197 0041;	
    // (Ɨ) LATIN CAPITAL LETTER I WITH STROKE	[1DA7 1CAD | 0020 0020 | 0008 0008 |]

    uint32_t cps[2] = { 0x0197, 0x0041 };
    uint32_t const ces[9] = { 0x1DA7, 0x1CAD, 0x0000, 0x0020, 0x0020, 0x0000, 0x0008, 0x0008, 0x0000 };

    auto collation = collate_for_tests(
        cps, cps + 2, boost::text::variable_weighting::non_ignorable);

    EXPECT_EQ(collation.size(), 9);
    EXPECT_TRUE(boost::algorithm::equal(collation.begin(), collation.end(), ces, ces + 9))
        << "from:     " << ce_dumper(cps)
        << "expected: " << ce_dumper(ces)
        << "got:      " << ce_dumper(collation);
}

TEST(collation, non_ignorable_110_083)
{
    // 1DA4 0061;	
    // (ᶤ) MODIFIER LETTER SMALL I WITH STROKE	[1DA7 1CAD | 0020 0020 | 0014 0002 |]

    uint32_t cps[2] = { 0x1DA4, 0x0061 };
    uint32_t const ces[9] = { 0x1DA7, 0x1CAD, 0x0000, 0x0020, 0x0020, 0x0000, 0x0014, 0x0002, 0x0000 };

    auto collation = collate_for_tests(
        cps, cps + 2, boost::text::variable_weighting::non_ignorable);

    EXPECT_EQ(collation.size(), 9);
    EXPECT_TRUE(boost::algorithm::equal(collation.begin(), collation.end(), ces, ces + 9))
        << "from:     " << ce_dumper(cps)
        << "expected: " << ce_dumper(ces)
        << "got:      " << ce_dumper(collation);
}

TEST(collation, non_ignorable_110_084)
{
    // 1DA4 0041;	
    // (ᶤ) MODIFIER LETTER SMALL I WITH STROKE	[1DA7 1CAD | 0020 0020 | 0014 0008 |]

    uint32_t cps[2] = { 0x1DA4, 0x0041 };
    uint32_t const ces[9] = { 0x1DA7, 0x1CAD, 0x0000, 0x0020, 0x0020, 0x0000, 0x0014, 0x0008, 0x0000 };

    auto collation = collate_for_tests(
        cps, cps + 2, boost::text::variable_weighting::non_ignorable);

    EXPECT_EQ(collation.size(), 9);
    EXPECT_TRUE(boost::algorithm::equal(collation.begin(), collation.end(), ces, ces + 9))
        << "from:     " << ce_dumper(cps)
        << "expected: " << ce_dumper(ces)
        << "got:      " << ce_dumper(collation);
}

TEST(collation, non_ignorable_110_085)
{
    // 0268 0062;	
    // (ɨ) LATIN SMALL LETTER I WITH STROKE	[1DA7 1CC6 | 0020 0020 | 0002 0002 |]

    uint32_t cps[2] = { 0x0268, 0x0062 };
    uint32_t const ces[9] = { 0x1DA7, 0x1CC6, 0x0000, 0x0020, 0x0020, 0x0000, 0x0002, 0x0002, 0x0000 };

    auto collation = collate_for_tests(
        cps, cps + 2, boost::text::variable_weighting::non_ignorable);

    EXPECT_EQ(collation.size(), 9);
    EXPECT_TRUE(boost::algorithm::equal(collation.begin(), collation.end(), ces, ces + 9))
        << "from:     " << ce_dumper(cps)
        << "expected: " << ce_dumper(ces)
        << "got:      " << ce_dumper(collation);
}

TEST(collation, non_ignorable_110_086)
{
    // 0197 0062;	
    // (Ɨ) LATIN CAPITAL LETTER I WITH STROKE	[1DA7 1CC6 | 0020 0020 | 0008 0002 |]

    uint32_t cps[2] = { 0x0197, 0x0062 };
    uint32_t const ces[9] = { 0x1DA7, 0x1CC6, 0x0000, 0x0020, 0x0020, 0x0000, 0x0008, 0x0002, 0x0000 };

    auto collation = collate_for_tests(
        cps, cps + 2, boost::text::variable_weighting::non_ignorable);

    EXPECT_EQ(collation.size(), 9);
    EXPECT_TRUE(boost::algorithm::equal(collation.begin(), collation.end(), ces, ces + 9))
        << "from:     " << ce_dumper(cps)
        << "expected: " << ce_dumper(ces)
        << "got:      " << ce_dumper(collation);
}

TEST(collation, non_ignorable_110_087)
{
    // 1DA4 0062;	
    // (ᶤ) MODIFIER LETTER SMALL I WITH STROKE	[1DA7 1CC6 | 0020 0020 | 0014 0002 |]

    uint32_t cps[2] = { 0x1DA4, 0x0062 };
    uint32_t const ces[9] = { 0x1DA7, 0x1CC6, 0x0000, 0x0020, 0x0020, 0x0000, 0x0014, 0x0002, 0x0000 };

    auto collation = collate_for_tests(
        cps, cps + 2, boost::text::variable_weighting::non_ignorable);

    EXPECT_EQ(collation.size(), 9);
    EXPECT_TRUE(boost::algorithm::equal(collation.begin(), collation.end(), ces, ces + 9))
        << "from:     " << ce_dumper(cps)
        << "expected: " << ce_dumper(ces)
        << "got:      " << ce_dumper(collation);
}

TEST(collation, non_ignorable_110_088)
{
    // 1D7B 0021;	
    // (ᵻ) LATIN SMALL CAPITAL LETTER I WITH STROKE	[1DAB 0261 | 0020 0020 | 0002 0002 |]

    uint32_t cps[2] = { 0x1D7B, 0x0021 };
    uint32_t const ces[9] = { 0x1DAB, 0x0261, 0x0000, 0x0020, 0x0020, 0x0000, 0x0002, 0x0002, 0x0000 };

    auto collation = collate_for_tests(
        cps, cps + 2, boost::text::variable_weighting::non_ignorable);

    EXPECT_EQ(collation.size(), 9);
    EXPECT_TRUE(boost::algorithm::equal(collation.begin(), collation.end(), ces, ces + 9))
        << "from:     " << ce_dumper(cps)
        << "expected: " << ce_dumper(ces)
        << "got:      " << ce_dumper(collation);
}

TEST(collation, non_ignorable_110_089)
{
    // 1DA7 0021;	
    // (ᶧ) MODIFIER LETTER SMALL CAPITAL I WITH STROKE	[1DAB 0261 | 0020 0020 | 0014 0002 |]

    uint32_t cps[2] = { 0x1DA7, 0x0021 };
    uint32_t const ces[9] = { 0x1DAB, 0x0261, 0x0000, 0x0020, 0x0020, 0x0000, 0x0014, 0x0002, 0x0000 };

    auto collation = collate_for_tests(
        cps, cps + 2, boost::text::variable_weighting::non_ignorable);

    EXPECT_EQ(collation.size(), 9);
    EXPECT_TRUE(boost::algorithm::equal(collation.begin(), collation.end(), ces, ces + 9))
        << "from:     " << ce_dumper(cps)
        << "expected: " << ce_dumper(ces)
        << "got:      " << ce_dumper(collation);
}

TEST(collation, non_ignorable_110_090)
{
    // 1D7B 003F;	
    // (ᵻ) LATIN SMALL CAPITAL LETTER I WITH STROKE	[1DAB 0267 | 0020 0020 | 0002 0002 |]

    uint32_t cps[2] = { 0x1D7B, 0x003F };
    uint32_t const ces[9] = { 0x1DAB, 0x0267, 0x0000, 0x0020, 0x0020, 0x0000, 0x0002, 0x0002, 0x0000 };

    auto collation = collate_for_tests(
        cps, cps + 2, boost::text::variable_weighting::non_ignorable);

    EXPECT_EQ(collation.size(), 9);
    EXPECT_TRUE(boost::algorithm::equal(collation.begin(), collation.end(), ces, ces + 9))
        << "from:     " << ce_dumper(cps)
        << "expected: " << ce_dumper(ces)
        << "got:      " << ce_dumper(collation);
}

TEST(collation, non_ignorable_110_091)
{
    // 1DA7 003F;	
    // (ᶧ) MODIFIER LETTER SMALL CAPITAL I WITH STROKE	[1DAB 0267 | 0020 0020 | 0014 0002 |]

    uint32_t cps[2] = { 0x1DA7, 0x003F };
    uint32_t const ces[9] = { 0x1DAB, 0x0267, 0x0000, 0x0020, 0x0020, 0x0000, 0x0014, 0x0002, 0x0000 };

    auto collation = collate_for_tests(
        cps, cps + 2, boost::text::variable_weighting::non_ignorable);

    EXPECT_EQ(collation.size(), 9);
    EXPECT_TRUE(boost::algorithm::equal(collation.begin(), collation.end(), ces, ces + 9))
        << "from:     " << ce_dumper(cps)
        << "expected: " << ce_dumper(ces)
        << "got:      " << ce_dumper(collation);
}

TEST(collation, non_ignorable_110_092)
{
    // 1D7B 0061;	
    // (ᵻ) LATIN SMALL CAPITAL LETTER I WITH STROKE	[1DAB 1CAD | 0020 0020 | 0002 0002 |]

    uint32_t cps[2] = { 0x1D7B, 0x0061 };
    uint32_t const ces[9] = { 0x1DAB, 0x1CAD, 0x0000, 0x0020, 0x0020, 0x0000, 0x0002, 0x0002, 0x0000 };

    auto collation = collate_for_tests(
        cps, cps + 2, boost::text::variable_weighting::non_ignorable);

    EXPECT_EQ(collation.size(), 9);
    EXPECT_TRUE(boost::algorithm::equal(collation.begin(), collation.end(), ces, ces + 9))
        << "from:     " << ce_dumper(cps)
        << "expected: " << ce_dumper(ces)
        << "got:      " << ce_dumper(collation);
}

TEST(collation, non_ignorable_110_093)
{
    // 1D7B 0041;	
    // (ᵻ) LATIN SMALL CAPITAL LETTER I WITH STROKE	[1DAB 1CAD | 0020 0020 | 0002 0008 |]

    uint32_t cps[2] = { 0x1D7B, 0x0041 };
    uint32_t const ces[9] = { 0x1DAB, 0x1CAD, 0x0000, 0x0020, 0x0020, 0x0000, 0x0002, 0x0008, 0x0000 };

    auto collation = collate_for_tests(
        cps, cps + 2, boost::text::variable_weighting::non_ignorable);

    EXPECT_EQ(collation.size(), 9);
    EXPECT_TRUE(boost::algorithm::equal(collation.begin(), collation.end(), ces, ces + 9))
        << "from:     " << ce_dumper(cps)
        << "expected: " << ce_dumper(ces)
        << "got:      " << ce_dumper(collation);
}

TEST(collation, non_ignorable_110_094)
{
    // 1DA7 0061;	
    // (ᶧ) MODIFIER LETTER SMALL CAPITAL I WITH STROKE	[1DAB 1CAD | 0020 0020 | 0014 0002 |]

    uint32_t cps[2] = { 0x1DA7, 0x0061 };
    uint32_t const ces[9] = { 0x1DAB, 0x1CAD, 0x0000, 0x0020, 0x0020, 0x0000, 0x0014, 0x0002, 0x0000 };

    auto collation = collate_for_tests(
        cps, cps + 2, boost::text::variable_weighting::non_ignorable);

    EXPECT_EQ(collation.size(), 9);
    EXPECT_TRUE(boost::algorithm::equal(collation.begin(), collation.end(), ces, ces + 9))
        << "from:     " << ce_dumper(cps)
        << "expected: " << ce_dumper(ces)
        << "got:      " << ce_dumper(collation);
}

TEST(collation, non_ignorable_110_095)
{
    // 1DA7 0041;	
    // (ᶧ) MODIFIER LETTER SMALL CAPITAL I WITH STROKE	[1DAB 1CAD | 0020 0020 | 0014 0008 |]

    uint32_t cps[2] = { 0x1DA7, 0x0041 };
    uint32_t const ces[9] = { 0x1DAB, 0x1CAD, 0x0000, 0x0020, 0x0020, 0x0000, 0x0014, 0x0008, 0x0000 };

    auto collation = collate_for_tests(
        cps, cps + 2, boost::text::variable_weighting::non_ignorable);

    EXPECT_EQ(collation.size(), 9);
    EXPECT_TRUE(boost::algorithm::equal(collation.begin(), collation.end(), ces, ces + 9))
        << "from:     " << ce_dumper(cps)
        << "expected: " << ce_dumper(ces)
        << "got:      " << ce_dumper(collation);
}

TEST(collation, non_ignorable_110_096)
{
    // 1D7B 0062;	
    // (ᵻ) LATIN SMALL CAPITAL LETTER I WITH STROKE	[1DAB 1CC6 | 0020 0020 | 0002 0002 |]

    uint32_t cps[2] = { 0x1D7B, 0x0062 };
    uint32_t const ces[9] = { 0x1DAB, 0x1CC6, 0x0000, 0x0020, 0x0020, 0x0000, 0x0002, 0x0002, 0x0000 };

    auto collation = collate_for_tests(
        cps, cps + 2, boost::text::variable_weighting::non_ignorable);

    EXPECT_EQ(collation.size(), 9);
    EXPECT_TRUE(boost::algorithm::equal(collation.begin(), collation.end(), ces, ces + 9))
        << "from:     " << ce_dumper(cps)
        << "expected: " << ce_dumper(ces)
        << "got:      " << ce_dumper(collation);
}

TEST(collation, non_ignorable_110_097)
{
    // 1DA7 0062;	
    // (ᶧ) MODIFIER LETTER SMALL CAPITAL I WITH STROKE	[1DAB 1CC6 | 0020 0020 | 0014 0002 |]

    uint32_t cps[2] = { 0x1DA7, 0x0062 };
    uint32_t const ces[9] = { 0x1DAB, 0x1CC6, 0x0000, 0x0020, 0x0020, 0x0000, 0x0014, 0x0002, 0x0000 };

    auto collation = collate_for_tests(
        cps, cps + 2, boost::text::variable_weighting::non_ignorable);

    EXPECT_EQ(collation.size(), 9);
    EXPECT_TRUE(boost::algorithm::equal(collation.begin(), collation.end(), ces, ces + 9))
        << "from:     " << ce_dumper(cps)
        << "expected: " << ce_dumper(ces)
        << "got:      " << ce_dumper(collation);
}

TEST(collation, non_ignorable_110_098)
{
    // 1D96 0021;	
    // (ᶖ) LATIN SMALL LETTER I WITH RETROFLEX HOOK	[1DAC 0261 | 0020 0020 | 0002 0002 |]

    uint32_t cps[2] = { 0x1D96, 0x0021 };
    uint32_t const ces[9] = { 0x1DAC, 0x0261, 0x0000, 0x0020, 0x0020, 0x0000, 0x0002, 0x0002, 0x0000 };

    auto collation = collate_for_tests(
        cps, cps + 2, boost::text::variable_weighting::non_ignorable);

    EXPECT_EQ(collation.size(), 9);
    EXPECT_TRUE(boost::algorithm::equal(collation.begin(), collation.end(), ces, ces + 9))
        << "from:     " << ce_dumper(cps)
        << "expected: " << ce_dumper(ces)
        << "got:      " << ce_dumper(collation);
}

TEST(collation, non_ignorable_110_099)
{
    // 1D96 003F;	
    // (ᶖ) LATIN SMALL LETTER I WITH RETROFLEX HOOK	[1DAC 0267 | 0020 0020 | 0002 0002 |]

    uint32_t cps[2] = { 0x1D96, 0x003F };
    uint32_t const ces[9] = { 0x1DAC, 0x0267, 0x0000, 0x0020, 0x0020, 0x0000, 0x0002, 0x0002, 0x0000 };

    auto collation = collate_for_tests(
        cps, cps + 2, boost::text::variable_weighting::non_ignorable);

    EXPECT_EQ(collation.size(), 9);
    EXPECT_TRUE(boost::algorithm::equal(collation.begin(), collation.end(), ces, ces + 9))
        << "from:     " << ce_dumper(cps)
        << "expected: " << ce_dumper(ces)
        << "got:      " << ce_dumper(collation);
}

TEST(collation, non_ignorable_110_100)
{
    // 1D96 0061;	
    // (ᶖ) LATIN SMALL LETTER I WITH RETROFLEX HOOK	[1DAC 1CAD | 0020 0020 | 0002 0002 |]

    uint32_t cps[2] = { 0x1D96, 0x0061 };
    uint32_t const ces[9] = { 0x1DAC, 0x1CAD, 0x0000, 0x0020, 0x0020, 0x0000, 0x0002, 0x0002, 0x0000 };

    auto collation = collate_for_tests(
        cps, cps + 2, boost::text::variable_weighting::non_ignorable);

    EXPECT_EQ(collation.size(), 9);
    EXPECT_TRUE(boost::algorithm::equal(collation.begin(), collation.end(), ces, ces + 9))
        << "from:     " << ce_dumper(cps)
        << "expected: " << ce_dumper(ces)
        << "got:      " << ce_dumper(collation);
}

TEST(collation, non_ignorable_110_101)
{
    // 1D96 0041;	
    // (ᶖ) LATIN SMALL LETTER I WITH RETROFLEX HOOK	[1DAC 1CAD | 0020 0020 | 0002 0008 |]

    uint32_t cps[2] = { 0x1D96, 0x0041 };
    uint32_t const ces[9] = { 0x1DAC, 0x1CAD, 0x0000, 0x0020, 0x0020, 0x0000, 0x0002, 0x0008, 0x0000 };

    auto collation = collate_for_tests(
        cps, cps + 2, boost::text::variable_weighting::non_ignorable);

    EXPECT_EQ(collation.size(), 9);
    EXPECT_TRUE(boost::algorithm::equal(collation.begin(), collation.end(), ces, ces + 9))
        << "from:     " << ce_dumper(cps)
        << "expected: " << ce_dumper(ces)
        << "got:      " << ce_dumper(collation);
}

TEST(collation, non_ignorable_110_102)
{
    // 1D96 0062;	
    // (ᶖ) LATIN SMALL LETTER I WITH RETROFLEX HOOK	[1DAC 1CC6 | 0020 0020 | 0002 0002 |]

    uint32_t cps[2] = { 0x1D96, 0x0062 };
    uint32_t const ces[9] = { 0x1DAC, 0x1CC6, 0x0000, 0x0020, 0x0020, 0x0000, 0x0002, 0x0002, 0x0000 };

    auto collation = collate_for_tests(
        cps, cps + 2, boost::text::variable_weighting::non_ignorable);

    EXPECT_EQ(collation.size(), 9);
    EXPECT_TRUE(boost::algorithm::equal(collation.begin(), collation.end(), ces, ces + 9))
        << "from:     " << ce_dumper(cps)
        << "expected: " << ce_dumper(ces)
        << "got:      " << ce_dumper(collation);
}

TEST(collation, non_ignorable_110_103)
{
    // 0269 0021;	
    // (ɩ) LATIN SMALL LETTER IOTA	[1DAD 0261 | 0020 0020 | 0002 0002 |]

    uint32_t cps[2] = { 0x0269, 0x0021 };
    uint32_t const ces[9] = { 0x1DAD, 0x0261, 0x0000, 0x0020, 0x0020, 0x0000, 0x0002, 0x0002, 0x0000 };

    auto collation = collate_for_tests(
        cps, cps + 2, boost::text::variable_weighting::non_ignorable);

    EXPECT_EQ(collation.size(), 9);
    EXPECT_TRUE(boost::algorithm::equal(collation.begin(), collation.end(), ces, ces + 9))
        << "from:     " << ce_dumper(cps)
        << "expected: " << ce_dumper(ces)
        << "got:      " << ce_dumper(collation);
}

TEST(collation, non_ignorable_110_104)
{
    // 0196 0021;	
    // (Ɩ) LATIN CAPITAL LETTER IOTA	[1DAD 0261 | 0020 0020 | 0008 0002 |]

    uint32_t cps[2] = { 0x0196, 0x0021 };
    uint32_t const ces[9] = { 0x1DAD, 0x0261, 0x0000, 0x0020, 0x0020, 0x0000, 0x0008, 0x0002, 0x0000 };

    auto collation = collate_for_tests(
        cps, cps + 2, boost::text::variable_weighting::non_ignorable);

    EXPECT_EQ(collation.size(), 9);
    EXPECT_TRUE(boost::algorithm::equal(collation.begin(), collation.end(), ces, ces + 9))
        << "from:     " << ce_dumper(cps)
        << "expected: " << ce_dumper(ces)
        << "got:      " << ce_dumper(collation);
}

TEST(collation, non_ignorable_110_105)
{
    // 1DA5 0021;	
    // (ᶥ) MODIFIER LETTER SMALL IOTA	[1DAD 0261 | 0020 0020 | 0014 0002 |]

    uint32_t cps[2] = { 0x1DA5, 0x0021 };
    uint32_t const ces[9] = { 0x1DAD, 0x0261, 0x0000, 0x0020, 0x0020, 0x0000, 0x0014, 0x0002, 0x0000 };

    auto collation = collate_for_tests(
        cps, cps + 2, boost::text::variable_weighting::non_ignorable);

    EXPECT_EQ(collation.size(), 9);
    EXPECT_TRUE(boost::algorithm::equal(collation.begin(), collation.end(), ces, ces + 9))
        << "from:     " << ce_dumper(cps)
        << "expected: " << ce_dumper(ces)
        << "got:      " << ce_dumper(collation);
}

TEST(collation, non_ignorable_110_106)
{
    // 0269 003F;	
    // (ɩ) LATIN SMALL LETTER IOTA	[1DAD 0267 | 0020 0020 | 0002 0002 |]

    uint32_t cps[2] = { 0x0269, 0x003F };
    uint32_t const ces[9] = { 0x1DAD, 0x0267, 0x0000, 0x0020, 0x0020, 0x0000, 0x0002, 0x0002, 0x0000 };

    auto collation = collate_for_tests(
        cps, cps + 2, boost::text::variable_weighting::non_ignorable);

    EXPECT_EQ(collation.size(), 9);
    EXPECT_TRUE(boost::algorithm::equal(collation.begin(), collation.end(), ces, ces + 9))
        << "from:     " << ce_dumper(cps)
        << "expected: " << ce_dumper(ces)
        << "got:      " << ce_dumper(collation);
}

TEST(collation, non_ignorable_110_107)
{
    // 0196 003F;	
    // (Ɩ) LATIN CAPITAL LETTER IOTA	[1DAD 0267 | 0020 0020 | 0008 0002 |]

    uint32_t cps[2] = { 0x0196, 0x003F };
    uint32_t const ces[9] = { 0x1DAD, 0x0267, 0x0000, 0x0020, 0x0020, 0x0000, 0x0008, 0x0002, 0x0000 };

    auto collation = collate_for_tests(
        cps, cps + 2, boost::text::variable_weighting::non_ignorable);

    EXPECT_EQ(collation.size(), 9);
    EXPECT_TRUE(boost::algorithm::equal(collation.begin(), collation.end(), ces, ces + 9))
        << "from:     " << ce_dumper(cps)
        << "expected: " << ce_dumper(ces)
        << "got:      " << ce_dumper(collation);
}

TEST(collation, non_ignorable_110_108)
{
    // 1DA5 003F;	
    // (ᶥ) MODIFIER LETTER SMALL IOTA	[1DAD 0267 | 0020 0020 | 0014 0002 |]

    uint32_t cps[2] = { 0x1DA5, 0x003F };
    uint32_t const ces[9] = { 0x1DAD, 0x0267, 0x0000, 0x0020, 0x0020, 0x0000, 0x0014, 0x0002, 0x0000 };

    auto collation = collate_for_tests(
        cps, cps + 2, boost::text::variable_weighting::non_ignorable);

    EXPECT_EQ(collation.size(), 9);
    EXPECT_TRUE(boost::algorithm::equal(collation.begin(), collation.end(), ces, ces + 9))
        << "from:     " << ce_dumper(cps)
        << "expected: " << ce_dumper(ces)
        << "got:      " << ce_dumper(collation);
}

TEST(collation, non_ignorable_110_109)
{
    // 0269 0061;	
    // (ɩ) LATIN SMALL LETTER IOTA	[1DAD 1CAD | 0020 0020 | 0002 0002 |]

    uint32_t cps[2] = { 0x0269, 0x0061 };
    uint32_t const ces[9] = { 0x1DAD, 0x1CAD, 0x0000, 0x0020, 0x0020, 0x0000, 0x0002, 0x0002, 0x0000 };

    auto collation = collate_for_tests(
        cps, cps + 2, boost::text::variable_weighting::non_ignorable);

    EXPECT_EQ(collation.size(), 9);
    EXPECT_TRUE(boost::algorithm::equal(collation.begin(), collation.end(), ces, ces + 9))
        << "from:     " << ce_dumper(cps)
        << "expected: " << ce_dumper(ces)
        << "got:      " << ce_dumper(collation);
}

TEST(collation, non_ignorable_110_110)
{
    // 0269 0041;	
    // (ɩ) LATIN SMALL LETTER IOTA	[1DAD 1CAD | 0020 0020 | 0002 0008 |]

    uint32_t cps[2] = { 0x0269, 0x0041 };
    uint32_t const ces[9] = { 0x1DAD, 0x1CAD, 0x0000, 0x0020, 0x0020, 0x0000, 0x0002, 0x0008, 0x0000 };

    auto collation = collate_for_tests(
        cps, cps + 2, boost::text::variable_weighting::non_ignorable);

    EXPECT_EQ(collation.size(), 9);
    EXPECT_TRUE(boost::algorithm::equal(collation.begin(), collation.end(), ces, ces + 9))
        << "from:     " << ce_dumper(cps)
        << "expected: " << ce_dumper(ces)
        << "got:      " << ce_dumper(collation);
}

TEST(collation, non_ignorable_110_111)
{
    // 0196 0061;	
    // (Ɩ) LATIN CAPITAL LETTER IOTA	[1DAD 1CAD | 0020 0020 | 0008 0002 |]

    uint32_t cps[2] = { 0x0196, 0x0061 };
    uint32_t const ces[9] = { 0x1DAD, 0x1CAD, 0x0000, 0x0020, 0x0020, 0x0000, 0x0008, 0x0002, 0x0000 };

    auto collation = collate_for_tests(
        cps, cps + 2, boost::text::variable_weighting::non_ignorable);

    EXPECT_EQ(collation.size(), 9);
    EXPECT_TRUE(boost::algorithm::equal(collation.begin(), collation.end(), ces, ces + 9))
        << "from:     " << ce_dumper(cps)
        << "expected: " << ce_dumper(ces)
        << "got:      " << ce_dumper(collation);
}

TEST(collation, non_ignorable_110_112)
{
    // 0196 0041;	
    // (Ɩ) LATIN CAPITAL LETTER IOTA	[1DAD 1CAD | 0020 0020 | 0008 0008 |]

    uint32_t cps[2] = { 0x0196, 0x0041 };
    uint32_t const ces[9] = { 0x1DAD, 0x1CAD, 0x0000, 0x0020, 0x0020, 0x0000, 0x0008, 0x0008, 0x0000 };

    auto collation = collate_for_tests(
        cps, cps + 2, boost::text::variable_weighting::non_ignorable);

    EXPECT_EQ(collation.size(), 9);
    EXPECT_TRUE(boost::algorithm::equal(collation.begin(), collation.end(), ces, ces + 9))
        << "from:     " << ce_dumper(cps)
        << "expected: " << ce_dumper(ces)
        << "got:      " << ce_dumper(collation);
}

TEST(collation, non_ignorable_110_113)
{
    // 1DA5 0061;	
    // (ᶥ) MODIFIER LETTER SMALL IOTA	[1DAD 1CAD | 0020 0020 | 0014 0002 |]

    uint32_t cps[2] = { 0x1DA5, 0x0061 };
    uint32_t const ces[9] = { 0x1DAD, 0x1CAD, 0x0000, 0x0020, 0x0020, 0x0000, 0x0014, 0x0002, 0x0000 };

    auto collation = collate_for_tests(
        cps, cps + 2, boost::text::variable_weighting::non_ignorable);

    EXPECT_EQ(collation.size(), 9);
    EXPECT_TRUE(boost::algorithm::equal(collation.begin(), collation.end(), ces, ces + 9))
        << "from:     " << ce_dumper(cps)
        << "expected: " << ce_dumper(ces)
        << "got:      " << ce_dumper(collation);
}

TEST(collation, non_ignorable_110_114)
{
    // 1DA5 0041;	
    // (ᶥ) MODIFIER LETTER SMALL IOTA	[1DAD 1CAD | 0020 0020 | 0014 0008 |]

    uint32_t cps[2] = { 0x1DA5, 0x0041 };
    uint32_t const ces[9] = { 0x1DAD, 0x1CAD, 0x0000, 0x0020, 0x0020, 0x0000, 0x0014, 0x0008, 0x0000 };

    auto collation = collate_for_tests(
        cps, cps + 2, boost::text::variable_weighting::non_ignorable);

    EXPECT_EQ(collation.size(), 9);
    EXPECT_TRUE(boost::algorithm::equal(collation.begin(), collation.end(), ces, ces + 9))
        << "from:     " << ce_dumper(cps)
        << "expected: " << ce_dumper(ces)
        << "got:      " << ce_dumper(collation);
}

TEST(collation, non_ignorable_110_115)
{
    // 0269 0062;	
    // (ɩ) LATIN SMALL LETTER IOTA	[1DAD 1CC6 | 0020 0020 | 0002 0002 |]

    uint32_t cps[2] = { 0x0269, 0x0062 };
    uint32_t const ces[9] = { 0x1DAD, 0x1CC6, 0x0000, 0x0020, 0x0020, 0x0000, 0x0002, 0x0002, 0x0000 };

    auto collation = collate_for_tests(
        cps, cps + 2, boost::text::variable_weighting::non_ignorable);

    EXPECT_EQ(collation.size(), 9);
    EXPECT_TRUE(boost::algorithm::equal(collation.begin(), collation.end(), ces, ces + 9))
        << "from:     " << ce_dumper(cps)
        << "expected: " << ce_dumper(ces)
        << "got:      " << ce_dumper(collation);
}

TEST(collation, non_ignorable_110_116)
{
    // 0196 0062;	
    // (Ɩ) LATIN CAPITAL LETTER IOTA	[1DAD 1CC6 | 0020 0020 | 0008 0002 |]

    uint32_t cps[2] = { 0x0196, 0x0062 };
    uint32_t const ces[9] = { 0x1DAD, 0x1CC6, 0x0000, 0x0020, 0x0020, 0x0000, 0x0008, 0x0002, 0x0000 };

    auto collation = collate_for_tests(
        cps, cps + 2, boost::text::variable_weighting::non_ignorable);

    EXPECT_EQ(collation.size(), 9);
    EXPECT_TRUE(boost::algorithm::equal(collation.begin(), collation.end(), ces, ces + 9))
        << "from:     " << ce_dumper(cps)
        << "expected: " << ce_dumper(ces)
        << "got:      " << ce_dumper(collation);
}

TEST(collation, non_ignorable_110_117)
{
    // 1DA5 0062;	
    // (ᶥ) MODIFIER LETTER SMALL IOTA	[1DAD 1CC6 | 0020 0020 | 0014 0002 |]

    uint32_t cps[2] = { 0x1DA5, 0x0062 };
    uint32_t const ces[9] = { 0x1DAD, 0x1CC6, 0x0000, 0x0020, 0x0020, 0x0000, 0x0014, 0x0002, 0x0000 };

    auto collation = collate_for_tests(
        cps, cps + 2, boost::text::variable_weighting::non_ignorable);

    EXPECT_EQ(collation.size(), 9);
    EXPECT_TRUE(boost::algorithm::equal(collation.begin(), collation.end(), ces, ces + 9))
        << "from:     " << ce_dumper(cps)
        << "expected: " << ce_dumper(ces)
        << "got:      " << ce_dumper(collation);
}

TEST(collation, non_ignorable_110_118)
{
    // 1D7C 0021;	
    // (ᵼ) LATIN SMALL LETTER IOTA WITH STROKE	[1DB1 0261 | 0020 0020 | 0002 0002 |]

    uint32_t cps[2] = { 0x1D7C, 0x0021 };
    uint32_t const ces[9] = { 0x1DB1, 0x0261, 0x0000, 0x0020, 0x0020, 0x0000, 0x0002, 0x0002, 0x0000 };

    auto collation = collate_for_tests(
        cps, cps + 2, boost::text::variable_weighting::non_ignorable);

    EXPECT_EQ(collation.size(), 9);
    EXPECT_TRUE(boost::algorithm::equal(collation.begin(), collation.end(), ces, ces + 9))
        << "from:     " << ce_dumper(cps)
        << "expected: " << ce_dumper(ces)
        << "got:      " << ce_dumper(collation);
}

TEST(collation, non_ignorable_110_119)
{
    // 1D7C 003F;	
    // (ᵼ) LATIN SMALL LETTER IOTA WITH STROKE	[1DB1 0267 | 0020 0020 | 0002 0002 |]

    uint32_t cps[2] = { 0x1D7C, 0x003F };
    uint32_t const ces[9] = { 0x1DB1, 0x0267, 0x0000, 0x0020, 0x0020, 0x0000, 0x0002, 0x0002, 0x0000 };

    auto collation = collate_for_tests(
        cps, cps + 2, boost::text::variable_weighting::non_ignorable);

    EXPECT_EQ(collation.size(), 9);
    EXPECT_TRUE(boost::algorithm::equal(collation.begin(), collation.end(), ces, ces + 9))
        << "from:     " << ce_dumper(cps)
        << "expected: " << ce_dumper(ces)
        << "got:      " << ce_dumper(collation);
}

TEST(collation, non_ignorable_110_120)
{
    // 1D7C 0061;	
    // (ᵼ) LATIN SMALL LETTER IOTA WITH STROKE	[1DB1 1CAD | 0020 0020 | 0002 0002 |]

    uint32_t cps[2] = { 0x1D7C, 0x0061 };
    uint32_t const ces[9] = { 0x1DB1, 0x1CAD, 0x0000, 0x0020, 0x0020, 0x0000, 0x0002, 0x0002, 0x0000 };

    auto collation = collate_for_tests(
        cps, cps + 2, boost::text::variable_weighting::non_ignorable);

    EXPECT_EQ(collation.size(), 9);
    EXPECT_TRUE(boost::algorithm::equal(collation.begin(), collation.end(), ces, ces + 9))
        << "from:     " << ce_dumper(cps)
        << "expected: " << ce_dumper(ces)
        << "got:      " << ce_dumper(collation);
}

TEST(collation, non_ignorable_110_121)
{
    // 1D7C 0041;	
    // (ᵼ) LATIN SMALL LETTER IOTA WITH STROKE	[1DB1 1CAD | 0020 0020 | 0002 0008 |]

    uint32_t cps[2] = { 0x1D7C, 0x0041 };
    uint32_t const ces[9] = { 0x1DB1, 0x1CAD, 0x0000, 0x0020, 0x0020, 0x0000, 0x0002, 0x0008, 0x0000 };

    auto collation = collate_for_tests(
        cps, cps + 2, boost::text::variable_weighting::non_ignorable);

    EXPECT_EQ(collation.size(), 9);
    EXPECT_TRUE(boost::algorithm::equal(collation.begin(), collation.end(), ces, ces + 9))
        << "from:     " << ce_dumper(cps)
        << "expected: " << ce_dumper(ces)
        << "got:      " << ce_dumper(collation);
}

TEST(collation, non_ignorable_110_122)
{
    // 1D7C 0062;	
    // (ᵼ) LATIN SMALL LETTER IOTA WITH STROKE	[1DB1 1CC6 | 0020 0020 | 0002 0002 |]

    uint32_t cps[2] = { 0x1D7C, 0x0062 };
    uint32_t const ces[9] = { 0x1DB1, 0x1CC6, 0x0000, 0x0020, 0x0020, 0x0000, 0x0002, 0x0002, 0x0000 };

    auto collation = collate_for_tests(
        cps, cps + 2, boost::text::variable_weighting::non_ignorable);

    EXPECT_EQ(collation.size(), 9);
    EXPECT_TRUE(boost::algorithm::equal(collation.begin(), collation.end(), ces, ces + 9))
        << "from:     " << ce_dumper(cps)
        << "expected: " << ce_dumper(ces)
        << "got:      " << ce_dumper(collation);
}

TEST(collation, non_ignorable_110_123)
{
    // 006A 0302 0334;	
    // (ĵ) LATIN SMALL LETTER J, COMBINING CIRCUMFLEX ACCENT	[1DB2 | 0020 004A 0027 | 0002 0002 0002 |]

    uint32_t cps[3] = { 0x006A, 0x0302, 0x0334 };
    uint32_t const ces[10] = { 0x1DB2, 0x0000, 0x0020, 0x004A, 0x0027, 0x0000, 0x0002, 0x0002, 0x0002, 0x0000 };

    auto collation = collate_for_tests(
        cps, cps + 3, boost::text::variable_weighting::non_ignorable);

    EXPECT_EQ(collation.size(), 10);
    EXPECT_TRUE(boost::algorithm::equal(collation.begin(), collation.end(), ces, ces + 10))
        << "from:     " << ce_dumper(cps)
        << "expected: " << ce_dumper(ces)
        << "got:      " << ce_dumper(collation);
}

TEST(collation, non_ignorable_110_124)
{
    // 006A 0334 0302;	
    // (j̴) LATIN SMALL LETTER J, COMBINING TILDE OVERLAY	[1DB2 | 0020 004A 0027 | 0002 0002 0002 |]

    uint32_t cps[3] = { 0x006A, 0x0334, 0x0302 };
    uint32_t const ces[10] = { 0x1DB2, 0x0000, 0x0020, 0x004A, 0x0027, 0x0000, 0x0002, 0x0002, 0x0002, 0x0000 };

    auto collation = collate_for_tests(
        cps, cps + 3, boost::text::variable_weighting::non_ignorable);

    EXPECT_EQ(collation.size(), 10);
    EXPECT_TRUE(boost::algorithm::equal(collation.begin(), collation.end(), ces, ces + 10))
        << "from:     " << ce_dumper(cps)
        << "expected: " << ce_dumper(ces)
        << "got:      " << ce_dumper(collation);
}

TEST(collation, non_ignorable_110_125)
{
    // 0135 0334;	
    // (ĵ) LATIN SMALL LETTER J WITH CIRCUMFLEX	[1DB2 | 0020 004A 0027 | 0002 0002 0002 |]

    uint32_t cps[2] = { 0x0135, 0x0334 };
    uint32_t const ces[10] = { 0x1DB2, 0x0000, 0x0020, 0x004A, 0x0027, 0x0000, 0x0002, 0x0002, 0x0002, 0x0000 };

    auto collation = collate_for_tests(
        cps, cps + 2, boost::text::variable_weighting::non_ignorable);

    EXPECT_EQ(collation.size(), 10);
    EXPECT_TRUE(boost::algorithm::equal(collation.begin(), collation.end(), ces, ces + 10))
        << "from:     " << ce_dumper(cps)
        << "expected: " << ce_dumper(ces)
        << "got:      " << ce_dumper(collation);
}

TEST(collation, non_ignorable_110_126)
{
    // 004A 0302 0334;	
    // (Ĵ) LATIN CAPITAL LETTER J, COMBINING CIRCUMFLEX ACCENT	[1DB2 | 0020 004A 0027 | 0008 0002 0002 |]

    uint32_t cps[3] = { 0x004A, 0x0302, 0x0334 };
    uint32_t const ces[10] = { 0x1DB2, 0x0000, 0x0020, 0x004A, 0x0027, 0x0000, 0x0008, 0x0002, 0x0002, 0x0000 };

    auto collation = collate_for_tests(
        cps, cps + 3, boost::text::variable_weighting::non_ignorable);

    EXPECT_EQ(collation.size(), 10);
    EXPECT_TRUE(boost::algorithm::equal(collation.begin(), collation.end(), ces, ces + 10))
        << "from:     " << ce_dumper(cps)
        << "expected: " << ce_dumper(ces)
        << "got:      " << ce_dumper(collation);
}

TEST(collation, non_ignorable_110_127)
{
    // 004A 0334 0302;	
    // (J̴) LATIN CAPITAL LETTER J, COMBINING TILDE OVERLAY	[1DB2 | 0020 004A 0027 | 0008 0002 0002 |]

    uint32_t cps[3] = { 0x004A, 0x0334, 0x0302 };
    uint32_t const ces[10] = { 0x1DB2, 0x0000, 0x0020, 0x004A, 0x0027, 0x0000, 0x0008, 0x0002, 0x0002, 0x0000 };

    auto collation = collate_for_tests(
        cps, cps + 3, boost::text::variable_weighting::non_ignorable);

    EXPECT_EQ(collation.size(), 10);
    EXPECT_TRUE(boost::algorithm::equal(collation.begin(), collation.end(), ces, ces + 10))
        << "from:     " << ce_dumper(cps)
        << "expected: " << ce_dumper(ces)
        << "got:      " << ce_dumper(collation);
}

TEST(collation, non_ignorable_110_128)
{
    // 0134 0334;	
    // (Ĵ) LATIN CAPITAL LETTER J WITH CIRCUMFLEX	[1DB2 | 0020 004A 0027 | 0008 0002 0002 |]

    uint32_t cps[2] = { 0x0134, 0x0334 };
    uint32_t const ces[10] = { 0x1DB2, 0x0000, 0x0020, 0x004A, 0x0027, 0x0000, 0x0008, 0x0002, 0x0002, 0x0000 };

    auto collation = collate_for_tests(
        cps, cps + 2, boost::text::variable_weighting::non_ignorable);

    EXPECT_EQ(collation.size(), 10);
    EXPECT_TRUE(boost::algorithm::equal(collation.begin(), collation.end(), ces, ces + 10))
        << "from:     " << ce_dumper(cps)
        << "expected: " << ce_dumper(ces)
        << "got:      " << ce_dumper(collation);
}

TEST(collation, non_ignorable_110_129)
{
    // 006A 030C 0334;	
    // (ǰ) LATIN SMALL LETTER J, COMBINING CARON	[1DB2 | 0020 004A 0028 | 0002 0002 0002 |]

    uint32_t cps[3] = { 0x006A, 0x030C, 0x0334 };
    uint32_t const ces[10] = { 0x1DB2, 0x0000, 0x0020, 0x004A, 0x0028, 0x0000, 0x0002, 0x0002, 0x0002, 0x0000 };

    auto collation = collate_for_tests(
        cps, cps + 3, boost::text::variable_weighting::non_ignorable);

    EXPECT_EQ(collation.size(), 10);
    EXPECT_TRUE(boost::algorithm::equal(collation.begin(), collation.end(), ces, ces + 10))
        << "from:     " << ce_dumper(cps)
        << "expected: " << ce_dumper(ces)
        << "got:      " << ce_dumper(collation);
}

TEST(collation, non_ignorable_110_130)
{
    // 006A 0334 030C;	
    // (j̴) LATIN SMALL LETTER J, COMBINING TILDE OVERLAY	[1DB2 | 0020 004A 0028 | 0002 0002 0002 |]

    uint32_t cps[3] = { 0x006A, 0x0334, 0x030C };
    uint32_t const ces[10] = { 0x1DB2, 0x0000, 0x0020, 0x004A, 0x0028, 0x0000, 0x0002, 0x0002, 0x0002, 0x0000 };

    auto collation = collate_for_tests(
        cps, cps + 3, boost::text::variable_weighting::non_ignorable);

    EXPECT_EQ(collation.size(), 10);
    EXPECT_TRUE(boost::algorithm::equal(collation.begin(), collation.end(), ces, ces + 10))
        << "from:     " << ce_dumper(cps)
        << "expected: " << ce_dumper(ces)
        << "got:      " << ce_dumper(collation);
}

TEST(collation, non_ignorable_110_131)
{
    // 01F0 0334;	
    // (ǰ) LATIN SMALL LETTER J WITH CARON	[1DB2 | 0020 004A 0028 | 0002 0002 0002 |]

    uint32_t cps[2] = { 0x01F0, 0x0334 };
    uint32_t const ces[10] = { 0x1DB2, 0x0000, 0x0020, 0x004A, 0x0028, 0x0000, 0x0002, 0x0002, 0x0002, 0x0000 };

    auto collation = collate_for_tests(
        cps, cps + 2, boost::text::variable_weighting::non_ignorable);

    EXPECT_EQ(collation.size(), 10);
    EXPECT_TRUE(boost::algorithm::equal(collation.begin(), collation.end(), ces, ces + 10))
        << "from:     " << ce_dumper(cps)
        << "expected: " << ce_dumper(ces)
        << "got:      " << ce_dumper(collation);
}

TEST(collation, non_ignorable_110_132)
{
    // 006A 0021;	
    // (j) LATIN SMALL LETTER J	[1DB2 0261 | 0020 0020 | 0002 0002 |]

    uint32_t cps[2] = { 0x006A, 0x0021 };
    uint32_t const ces[9] = { 0x1DB2, 0x0261, 0x0000, 0x0020, 0x0020, 0x0000, 0x0002, 0x0002, 0x0000 };

    auto collation = collate_for_tests(
        cps, cps + 2, boost::text::variable_weighting::non_ignorable);

    EXPECT_EQ(collation.size(), 9);
    EXPECT_TRUE(boost::algorithm::equal(collation.begin(), collation.end(), ces, ces + 9))
        << "from:     " << ce_dumper(cps)
        << "expected: " << ce_dumper(ces)
        << "got:      " << ce_dumper(collation);
}

TEST(collation, non_ignorable_110_133)
{
    // FF4A 0021;	
    // (ｊ) FULLWIDTH LATIN SMALL LETTER J	[1DB2 0261 | 0020 0020 | 0003 0002 |]

    uint32_t cps[2] = { 0xFF4A, 0x0021 };
    uint32_t const ces[9] = { 0x1DB2, 0x0261, 0x0000, 0x0020, 0x0020, 0x0000, 0x0003, 0x0002, 0x0000 };

    auto collation = collate_for_tests(
        cps, cps + 2, boost::text::variable_weighting::non_ignorable);

    EXPECT_EQ(collation.size(), 9);
    EXPECT_TRUE(boost::algorithm::equal(collation.begin(), collation.end(), ces, ces + 9))
        << "from:     " << ce_dumper(cps)
        << "expected: " << ce_dumper(ces)
        << "got:      " << ce_dumper(collation);
}

TEST(collation, non_ignorable_110_134)
{
    // 2149 0021;	
    // (ⅉ) DOUBLE-STRUCK ITALIC SMALL J	[1DB2 0261 | 0020 0020 | 0005 0002 |]

    uint32_t cps[2] = { 0x2149, 0x0021 };
    uint32_t const ces[9] = { 0x1DB2, 0x0261, 0x0000, 0x0020, 0x0020, 0x0000, 0x0005, 0x0002, 0x0000 };

    auto collation = collate_for_tests(
        cps, cps + 2, boost::text::variable_weighting::non_ignorable);

    EXPECT_EQ(collation.size(), 9);
    EXPECT_TRUE(boost::algorithm::equal(collation.begin(), collation.end(), ces, ces + 9))
        << "from:     " << ce_dumper(cps)
        << "expected: " << ce_dumper(ces)
        << "got:      " << ce_dumper(collation);
}

TEST(collation, non_ignorable_110_135)
{
    // 1D423 0021;	
    // (𝐣) MATHEMATICAL BOLD SMALL J	[1DB2 0261 | 0020 0020 | 0005 0002 |]

    uint32_t cps[2] = { 0x1D423, 0x0021 };
    uint32_t const ces[9] = { 0x1DB2, 0x0261, 0x0000, 0x0020, 0x0020, 0x0000, 0x0005, 0x0002, 0x0000 };

    auto collation = collate_for_tests(
        cps, cps + 2, boost::text::variable_weighting::non_ignorable);

    EXPECT_EQ(collation.size(), 9);
    EXPECT_TRUE(boost::algorithm::equal(collation.begin(), collation.end(), ces, ces + 9))
        << "from:     " << ce_dumper(cps)
        << "expected: " << ce_dumper(ces)
        << "got:      " << ce_dumper(collation);
}

TEST(collation, non_ignorable_110_136)
{
    // 1D457 0021;	
    // (𝑗) MATHEMATICAL ITALIC SMALL J	[1DB2 0261 | 0020 0020 | 0005 0002 |]

    uint32_t cps[2] = { 0x1D457, 0x0021 };
    uint32_t const ces[9] = { 0x1DB2, 0x0261, 0x0000, 0x0020, 0x0020, 0x0000, 0x0005, 0x0002, 0x0000 };

    auto collation = collate_for_tests(
        cps, cps + 2, boost::text::variable_weighting::non_ignorable);

    EXPECT_EQ(collation.size(), 9);
    EXPECT_TRUE(boost::algorithm::equal(collation.begin(), collation.end(), ces, ces + 9))
        << "from:     " << ce_dumper(cps)
        << "expected: " << ce_dumper(ces)
        << "got:      " << ce_dumper(collation);
}

TEST(collation, non_ignorable_110_137)
{
    // 1D48B 0021;	
    // (𝒋) MATHEMATICAL BOLD ITALIC SMALL J	[1DB2 0261 | 0020 0020 | 0005 0002 |]

    uint32_t cps[2] = { 0x1D48B, 0x0021 };
    uint32_t const ces[9] = { 0x1DB2, 0x0261, 0x0000, 0x0020, 0x0020, 0x0000, 0x0005, 0x0002, 0x0000 };

    auto collation = collate_for_tests(
        cps, cps + 2, boost::text::variable_weighting::non_ignorable);

    EXPECT_EQ(collation.size(), 9);
    EXPECT_TRUE(boost::algorithm::equal(collation.begin(), collation.end(), ces, ces + 9))
        << "from:     " << ce_dumper(cps)
        << "expected: " << ce_dumper(ces)
        << "got:      " << ce_dumper(collation);
}

TEST(collation, non_ignorable_110_138)
{
    // 1D4BF 0021;	
    // (𝒿) MATHEMATICAL SCRIPT SMALL J	[1DB2 0261 | 0020 0020 | 0005 0002 |]

    uint32_t cps[2] = { 0x1D4BF, 0x0021 };
    uint32_t const ces[9] = { 0x1DB2, 0x0261, 0x0000, 0x0020, 0x0020, 0x0000, 0x0005, 0x0002, 0x0000 };

    auto collation = collate_for_tests(
        cps, cps + 2, boost::text::variable_weighting::non_ignorable);

    EXPECT_EQ(collation.size(), 9);
    EXPECT_TRUE(boost::algorithm::equal(collation.begin(), collation.end(), ces, ces + 9))
        << "from:     " << ce_dumper(cps)
        << "expected: " << ce_dumper(ces)
        << "got:      " << ce_dumper(collation);
}

TEST(collation, non_ignorable_110_139)
{
    // 1D4F3 0021;	
    // (𝓳) MATHEMATICAL BOLD SCRIPT SMALL J	[1DB2 0261 | 0020 0020 | 0005 0002 |]

    uint32_t cps[2] = { 0x1D4F3, 0x0021 };
    uint32_t const ces[9] = { 0x1DB2, 0x0261, 0x0000, 0x0020, 0x0020, 0x0000, 0x0005, 0x0002, 0x0000 };

    auto collation = collate_for_tests(
        cps, cps + 2, boost::text::variable_weighting::non_ignorable);

    EXPECT_EQ(collation.size(), 9);
    EXPECT_TRUE(boost::algorithm::equal(collation.begin(), collation.end(), ces, ces + 9))
        << "from:     " << ce_dumper(cps)
        << "expected: " << ce_dumper(ces)
        << "got:      " << ce_dumper(collation);
}

TEST(collation, non_ignorable_110_140)
{
    // 1D527 0021;	
    // (𝔧) MATHEMATICAL FRAKTUR SMALL J	[1DB2 0261 | 0020 0020 | 0005 0002 |]

    uint32_t cps[2] = { 0x1D527, 0x0021 };
    uint32_t const ces[9] = { 0x1DB2, 0x0261, 0x0000, 0x0020, 0x0020, 0x0000, 0x0005, 0x0002, 0x0000 };

    auto collation = collate_for_tests(
        cps, cps + 2, boost::text::variable_weighting::non_ignorable);

    EXPECT_EQ(collation.size(), 9);
    EXPECT_TRUE(boost::algorithm::equal(collation.begin(), collation.end(), ces, ces + 9))
        << "from:     " << ce_dumper(cps)
        << "expected: " << ce_dumper(ces)
        << "got:      " << ce_dumper(collation);
}

TEST(collation, non_ignorable_110_141)
{
    // 1D55B 0021;	
    // (𝕛) MATHEMATICAL DOUBLE-STRUCK SMALL J	[1DB2 0261 | 0020 0020 | 0005 0002 |]

    uint32_t cps[2] = { 0x1D55B, 0x0021 };
    uint32_t const ces[9] = { 0x1DB2, 0x0261, 0x0000, 0x0020, 0x0020, 0x0000, 0x0005, 0x0002, 0x0000 };

    auto collation = collate_for_tests(
        cps, cps + 2, boost::text::variable_weighting::non_ignorable);

    EXPECT_EQ(collation.size(), 9);
    EXPECT_TRUE(boost::algorithm::equal(collation.begin(), collation.end(), ces, ces + 9))
        << "from:     " << ce_dumper(cps)
        << "expected: " << ce_dumper(ces)
        << "got:      " << ce_dumper(collation);
}

TEST(collation, non_ignorable_110_142)
{
    // 1D58F 0021;	
    // (𝖏) MATHEMATICAL BOLD FRAKTUR SMALL J	[1DB2 0261 | 0020 0020 | 0005 0002 |]

    uint32_t cps[2] = { 0x1D58F, 0x0021 };
    uint32_t const ces[9] = { 0x1DB2, 0x0261, 0x0000, 0x0020, 0x0020, 0x0000, 0x0005, 0x0002, 0x0000 };

    auto collation = collate_for_tests(
        cps, cps + 2, boost::text::variable_weighting::non_ignorable);

    EXPECT_EQ(collation.size(), 9);
    EXPECT_TRUE(boost::algorithm::equal(collation.begin(), collation.end(), ces, ces + 9))
        << "from:     " << ce_dumper(cps)
        << "expected: " << ce_dumper(ces)
        << "got:      " << ce_dumper(collation);
}

TEST(collation, non_ignorable_110_143)
{
    // 1D5C3 0021;	
    // (𝗃) MATHEMATICAL SANS-SERIF SMALL J	[1DB2 0261 | 0020 0020 | 0005 0002 |]

    uint32_t cps[2] = { 0x1D5C3, 0x0021 };
    uint32_t const ces[9] = { 0x1DB2, 0x0261, 0x0000, 0x0020, 0x0020, 0x0000, 0x0005, 0x0002, 0x0000 };

    auto collation = collate_for_tests(
        cps, cps + 2, boost::text::variable_weighting::non_ignorable);

    EXPECT_EQ(collation.size(), 9);
    EXPECT_TRUE(boost::algorithm::equal(collation.begin(), collation.end(), ces, ces + 9))
        << "from:     " << ce_dumper(cps)
        << "expected: " << ce_dumper(ces)
        << "got:      " << ce_dumper(collation);
}

TEST(collation, non_ignorable_110_144)
{
    // 1D5F7 0021;	
    // (𝗷) MATHEMATICAL SANS-SERIF BOLD SMALL J	[1DB2 0261 | 0020 0020 | 0005 0002 |]

    uint32_t cps[2] = { 0x1D5F7, 0x0021 };
    uint32_t const ces[9] = { 0x1DB2, 0x0261, 0x0000, 0x0020, 0x0020, 0x0000, 0x0005, 0x0002, 0x0000 };

    auto collation = collate_for_tests(
        cps, cps + 2, boost::text::variable_weighting::non_ignorable);

    EXPECT_EQ(collation.size(), 9);
    EXPECT_TRUE(boost::algorithm::equal(collation.begin(), collation.end(), ces, ces + 9))
        << "from:     " << ce_dumper(cps)
        << "expected: " << ce_dumper(ces)
        << "got:      " << ce_dumper(collation);
}

TEST(collation, non_ignorable_110_145)
{
    // 1D62B 0021;	
    // (𝘫) MATHEMATICAL SANS-SERIF ITALIC SMALL J	[1DB2 0261 | 0020 0020 | 0005 0002 |]

    uint32_t cps[2] = { 0x1D62B, 0x0021 };
    uint32_t const ces[9] = { 0x1DB2, 0x0261, 0x0000, 0x0020, 0x0020, 0x0000, 0x0005, 0x0002, 0x0000 };

    auto collation = collate_for_tests(
        cps, cps + 2, boost::text::variable_weighting::non_ignorable);

    EXPECT_EQ(collation.size(), 9);
    EXPECT_TRUE(boost::algorithm::equal(collation.begin(), collation.end(), ces, ces + 9))
        << "from:     " << ce_dumper(cps)
        << "expected: " << ce_dumper(ces)
        << "got:      " << ce_dumper(collation);
}

TEST(collation, non_ignorable_110_146)
{
    // 1D65F 0021;	
    // (𝙟) MATHEMATICAL SANS-SERIF BOLD ITALIC SMALL J	[1DB2 0261 | 0020 0020 | 0005 0002 |]

    uint32_t cps[2] = { 0x1D65F, 0x0021 };
    uint32_t const ces[9] = { 0x1DB2, 0x0261, 0x0000, 0x0020, 0x0020, 0x0000, 0x0005, 0x0002, 0x0000 };

    auto collation = collate_for_tests(
        cps, cps + 2, boost::text::variable_weighting::non_ignorable);

    EXPECT_EQ(collation.size(), 9);
    EXPECT_TRUE(boost::algorithm::equal(collation.begin(), collation.end(), ces, ces + 9))
        << "from:     " << ce_dumper(cps)
        << "expected: " << ce_dumper(ces)
        << "got:      " << ce_dumper(collation);
}

TEST(collation, non_ignorable_110_147)
{
    // 1D693 0021;	
    // (𝚓) MATHEMATICAL MONOSPACE SMALL J	[1DB2 0261 | 0020 0020 | 0005 0002 |]

    uint32_t cps[2] = { 0x1D693, 0x0021 };
    uint32_t const ces[9] = { 0x1DB2, 0x0261, 0x0000, 0x0020, 0x0020, 0x0000, 0x0005, 0x0002, 0x0000 };

    auto collation = collate_for_tests(
        cps, cps + 2, boost::text::variable_weighting::non_ignorable);

    EXPECT_EQ(collation.size(), 9);
    EXPECT_TRUE(boost::algorithm::equal(collation.begin(), collation.end(), ces, ces + 9))
        << "from:     " << ce_dumper(cps)
        << "expected: " << ce_dumper(ces)
        << "got:      " << ce_dumper(collation);
}

TEST(collation, non_ignorable_110_148)
{
    // 24D9 0021;	
    // (ⓙ) CIRCLED LATIN SMALL LETTER J	[1DB2 0261 | 0020 0020 | 0006 0002 |]

    uint32_t cps[2] = { 0x24D9, 0x0021 };
    uint32_t const ces[9] = { 0x1DB2, 0x0261, 0x0000, 0x0020, 0x0020, 0x0000, 0x0006, 0x0002, 0x0000 };

    auto collation = collate_for_tests(
        cps, cps + 2, boost::text::variable_weighting::non_ignorable);

    EXPECT_EQ(collation.size(), 9);
    EXPECT_TRUE(boost::algorithm::equal(collation.begin(), collation.end(), ces, ces + 9))
        << "from:     " << ce_dumper(cps)
        << "expected: " << ce_dumper(ces)
        << "got:      " << ce_dumper(collation);
}

TEST(collation, non_ignorable_110_149)
{
    // 004A 0021;	
    // (J) LATIN CAPITAL LETTER J	[1DB2 0261 | 0020 0020 | 0008 0002 |]

    uint32_t cps[2] = { 0x004A, 0x0021 };
    uint32_t const ces[9] = { 0x1DB2, 0x0261, 0x0000, 0x0020, 0x0020, 0x0000, 0x0008, 0x0002, 0x0000 };

    auto collation = collate_for_tests(
        cps, cps + 2, boost::text::variable_weighting::non_ignorable);

    EXPECT_EQ(collation.size(), 9);
    EXPECT_TRUE(boost::algorithm::equal(collation.begin(), collation.end(), ces, ces + 9))
        << "from:     " << ce_dumper(cps)
        << "expected: " << ce_dumper(ces)
        << "got:      " << ce_dumper(collation);
}

TEST(collation, non_ignorable_110_150)
{
    // FF2A 0021;	
    // (Ｊ) FULLWIDTH LATIN CAPITAL LETTER J	[1DB2 0261 | 0020 0020 | 0009 0002 |]

    uint32_t cps[2] = { 0xFF2A, 0x0021 };
    uint32_t const ces[9] = { 0x1DB2, 0x0261, 0x0000, 0x0020, 0x0020, 0x0000, 0x0009, 0x0002, 0x0000 };

    auto collation = collate_for_tests(
        cps, cps + 2, boost::text::variable_weighting::non_ignorable);

    EXPECT_EQ(collation.size(), 9);
    EXPECT_TRUE(boost::algorithm::equal(collation.begin(), collation.end(), ces, ces + 9))
        << "from:     " << ce_dumper(cps)
        << "expected: " << ce_dumper(ces)
        << "got:      " << ce_dumper(collation);
}

TEST(collation, non_ignorable_110_151)
{
    // 1D409 0021;	
    // (𝐉) MATHEMATICAL BOLD CAPITAL J	[1DB2 0261 | 0020 0020 | 000B 0002 |]

    uint32_t cps[2] = { 0x1D409, 0x0021 };
    uint32_t const ces[9] = { 0x1DB2, 0x0261, 0x0000, 0x0020, 0x0020, 0x0000, 0x000B, 0x0002, 0x0000 };

    auto collation = collate_for_tests(
        cps, cps + 2, boost::text::variable_weighting::non_ignorable);

    EXPECT_EQ(collation.size(), 9);
    EXPECT_TRUE(boost::algorithm::equal(collation.begin(), collation.end(), ces, ces + 9))
        << "from:     " << ce_dumper(cps)
        << "expected: " << ce_dumper(ces)
        << "got:      " << ce_dumper(collation);
}

TEST(collation, non_ignorable_110_152)
{
    // 1D43D 0021;	
    // (𝐽) MATHEMATICAL ITALIC CAPITAL J	[1DB2 0261 | 0020 0020 | 000B 0002 |]

    uint32_t cps[2] = { 0x1D43D, 0x0021 };
    uint32_t const ces[9] = { 0x1DB2, 0x0261, 0x0000, 0x0020, 0x0020, 0x0000, 0x000B, 0x0002, 0x0000 };

    auto collation = collate_for_tests(
        cps, cps + 2, boost::text::variable_weighting::non_ignorable);

    EXPECT_EQ(collation.size(), 9);
    EXPECT_TRUE(boost::algorithm::equal(collation.begin(), collation.end(), ces, ces + 9))
        << "from:     " << ce_dumper(cps)
        << "expected: " << ce_dumper(ces)
        << "got:      " << ce_dumper(collation);
}

TEST(collation, non_ignorable_110_153)
{
    // 1D471 0021;	
    // (𝑱) MATHEMATICAL BOLD ITALIC CAPITAL J	[1DB2 0261 | 0020 0020 | 000B 0002 |]

    uint32_t cps[2] = { 0x1D471, 0x0021 };
    uint32_t const ces[9] = { 0x1DB2, 0x0261, 0x0000, 0x0020, 0x0020, 0x0000, 0x000B, 0x0002, 0x0000 };

    auto collation = collate_for_tests(
        cps, cps + 2, boost::text::variable_weighting::non_ignorable);

    EXPECT_EQ(collation.size(), 9);
    EXPECT_TRUE(boost::algorithm::equal(collation.begin(), collation.end(), ces, ces + 9))
        << "from:     " << ce_dumper(cps)
        << "expected: " << ce_dumper(ces)
        << "got:      " << ce_dumper(collation);
}

TEST(collation, non_ignorable_110_154)
{
    // 1D4A5 0021;	
    // (𝒥) MATHEMATICAL SCRIPT CAPITAL J	[1DB2 0261 | 0020 0020 | 000B 0002 |]

    uint32_t cps[2] = { 0x1D4A5, 0x0021 };
    uint32_t const ces[9] = { 0x1DB2, 0x0261, 0x0000, 0x0020, 0x0020, 0x0000, 0x000B, 0x0002, 0x0000 };

    auto collation = collate_for_tests(
        cps, cps + 2, boost::text::variable_weighting::non_ignorable);

    EXPECT_EQ(collation.size(), 9);
    EXPECT_TRUE(boost::algorithm::equal(collation.begin(), collation.end(), ces, ces + 9))
        << "from:     " << ce_dumper(cps)
        << "expected: " << ce_dumper(ces)
        << "got:      " << ce_dumper(collation);
}

TEST(collation, non_ignorable_110_155)
{
    // 1D4D9 0021;	
    // (𝓙) MATHEMATICAL BOLD SCRIPT CAPITAL J	[1DB2 0261 | 0020 0020 | 000B 0002 |]

    uint32_t cps[2] = { 0x1D4D9, 0x0021 };
    uint32_t const ces[9] = { 0x1DB2, 0x0261, 0x0000, 0x0020, 0x0020, 0x0000, 0x000B, 0x0002, 0x0000 };

    auto collation = collate_for_tests(
        cps, cps + 2, boost::text::variable_weighting::non_ignorable);

    EXPECT_EQ(collation.size(), 9);
    EXPECT_TRUE(boost::algorithm::equal(collation.begin(), collation.end(), ces, ces + 9))
        << "from:     " << ce_dumper(cps)
        << "expected: " << ce_dumper(ces)
        << "got:      " << ce_dumper(collation);
}

TEST(collation, non_ignorable_110_156)
{
    // 1D50D 0021;	
    // (𝔍) MATHEMATICAL FRAKTUR CAPITAL J	[1DB2 0261 | 0020 0020 | 000B 0002 |]

    uint32_t cps[2] = { 0x1D50D, 0x0021 };
    uint32_t const ces[9] = { 0x1DB2, 0x0261, 0x0000, 0x0020, 0x0020, 0x0000, 0x000B, 0x0002, 0x0000 };

    auto collation = collate_for_tests(
        cps, cps + 2, boost::text::variable_weighting::non_ignorable);

    EXPECT_EQ(collation.size(), 9);
    EXPECT_TRUE(boost::algorithm::equal(collation.begin(), collation.end(), ces, ces + 9))
        << "from:     " << ce_dumper(cps)
        << "expected: " << ce_dumper(ces)
        << "got:      " << ce_dumper(collation);
}

TEST(collation, non_ignorable_110_157)
{
    // 1D541 0021;	
    // (𝕁) MATHEMATICAL DOUBLE-STRUCK CAPITAL J	[1DB2 0261 | 0020 0020 | 000B 0002 |]

    uint32_t cps[2] = { 0x1D541, 0x0021 };
    uint32_t const ces[9] = { 0x1DB2, 0x0261, 0x0000, 0x0020, 0x0020, 0x0000, 0x000B, 0x0002, 0x0000 };

    auto collation = collate_for_tests(
        cps, cps + 2, boost::text::variable_weighting::non_ignorable);

    EXPECT_EQ(collation.size(), 9);
    EXPECT_TRUE(boost::algorithm::equal(collation.begin(), collation.end(), ces, ces + 9))
        << "from:     " << ce_dumper(cps)
        << "expected: " << ce_dumper(ces)
        << "got:      " << ce_dumper(collation);
}

TEST(collation, non_ignorable_110_158)
{
    // 1D575 0021;	
    // (𝕵) MATHEMATICAL BOLD FRAKTUR CAPITAL J	[1DB2 0261 | 0020 0020 | 000B 0002 |]

    uint32_t cps[2] = { 0x1D575, 0x0021 };
    uint32_t const ces[9] = { 0x1DB2, 0x0261, 0x0000, 0x0020, 0x0020, 0x0000, 0x000B, 0x0002, 0x0000 };

    auto collation = collate_for_tests(
        cps, cps + 2, boost::text::variable_weighting::non_ignorable);

    EXPECT_EQ(collation.size(), 9);
    EXPECT_TRUE(boost::algorithm::equal(collation.begin(), collation.end(), ces, ces + 9))
        << "from:     " << ce_dumper(cps)
        << "expected: " << ce_dumper(ces)
        << "got:      " << ce_dumper(collation);
}

TEST(collation, non_ignorable_110_159)
{
    // 1D5A9 0021;	
    // (𝖩) MATHEMATICAL SANS-SERIF CAPITAL J	[1DB2 0261 | 0020 0020 | 000B 0002 |]

    uint32_t cps[2] = { 0x1D5A9, 0x0021 };
    uint32_t const ces[9] = { 0x1DB2, 0x0261, 0x0000, 0x0020, 0x0020, 0x0000, 0x000B, 0x0002, 0x0000 };

    auto collation = collate_for_tests(
        cps, cps + 2, boost::text::variable_weighting::non_ignorable);

    EXPECT_EQ(collation.size(), 9);
    EXPECT_TRUE(boost::algorithm::equal(collation.begin(), collation.end(), ces, ces + 9))
        << "from:     " << ce_dumper(cps)
        << "expected: " << ce_dumper(ces)
        << "got:      " << ce_dumper(collation);
}

TEST(collation, non_ignorable_110_160)
{
    // 1D5DD 0021;	
    // (𝗝) MATHEMATICAL SANS-SERIF BOLD CAPITAL J	[1DB2 0261 | 0020 0020 | 000B 0002 |]

    uint32_t cps[2] = { 0x1D5DD, 0x0021 };
    uint32_t const ces[9] = { 0x1DB2, 0x0261, 0x0000, 0x0020, 0x0020, 0x0000, 0x000B, 0x0002, 0x0000 };

    auto collation = collate_for_tests(
        cps, cps + 2, boost::text::variable_weighting::non_ignorable);

    EXPECT_EQ(collation.size(), 9);
    EXPECT_TRUE(boost::algorithm::equal(collation.begin(), collation.end(), ces, ces + 9))
        << "from:     " << ce_dumper(cps)
        << "expected: " << ce_dumper(ces)
        << "got:      " << ce_dumper(collation);
}

TEST(collation, non_ignorable_110_161)
{
    // 1D611 0021;	
    // (𝘑) MATHEMATICAL SANS-SERIF ITALIC CAPITAL J	[1DB2 0261 | 0020 0020 | 000B 0002 |]

    uint32_t cps[2] = { 0x1D611, 0x0021 };
    uint32_t const ces[9] = { 0x1DB2, 0x0261, 0x0000, 0x0020, 0x0020, 0x0000, 0x000B, 0x0002, 0x0000 };

    auto collation = collate_for_tests(
        cps, cps + 2, boost::text::variable_weighting::non_ignorable);

    EXPECT_EQ(collation.size(), 9);
    EXPECT_TRUE(boost::algorithm::equal(collation.begin(), collation.end(), ces, ces + 9))
        << "from:     " << ce_dumper(cps)
        << "expected: " << ce_dumper(ces)
        << "got:      " << ce_dumper(collation);
}

TEST(collation, non_ignorable_110_162)
{
    // 1D645 0021;	
    // (𝙅) MATHEMATICAL SANS-SERIF BOLD ITALIC CAPITAL J	[1DB2 0261 | 0020 0020 | 000B 0002 |]

    uint32_t cps[2] = { 0x1D645, 0x0021 };
    uint32_t const ces[9] = { 0x1DB2, 0x0261, 0x0000, 0x0020, 0x0020, 0x0000, 0x000B, 0x0002, 0x0000 };

    auto collation = collate_for_tests(
        cps, cps + 2, boost::text::variable_weighting::non_ignorable);

    EXPECT_EQ(collation.size(), 9);
    EXPECT_TRUE(boost::algorithm::equal(collation.begin(), collation.end(), ces, ces + 9))
        << "from:     " << ce_dumper(cps)
        << "expected: " << ce_dumper(ces)
        << "got:      " << ce_dumper(collation);
}

TEST(collation, non_ignorable_110_163)
{
    // 1D679 0021;	
    // (𝙹) MATHEMATICAL MONOSPACE CAPITAL J	[1DB2 0261 | 0020 0020 | 000B 0002 |]

    uint32_t cps[2] = { 0x1D679, 0x0021 };
    uint32_t const ces[9] = { 0x1DB2, 0x0261, 0x0000, 0x0020, 0x0020, 0x0000, 0x000B, 0x0002, 0x0000 };

    auto collation = collate_for_tests(
        cps, cps + 2, boost::text::variable_weighting::non_ignorable);

    EXPECT_EQ(collation.size(), 9);
    EXPECT_TRUE(boost::algorithm::equal(collation.begin(), collation.end(), ces, ces + 9))
        << "from:     " << ce_dumper(cps)
        << "expected: " << ce_dumper(ces)
        << "got:      " << ce_dumper(collation);
}

TEST(collation, non_ignorable_110_164)
{
    // 24BF 0021;	
    // (Ⓙ) CIRCLED LATIN CAPITAL LETTER J	[1DB2 0261 | 0020 0020 | 000C 0002 |]

    uint32_t cps[2] = { 0x24BF, 0x0021 };
    uint32_t const ces[9] = { 0x1DB2, 0x0261, 0x0000, 0x0020, 0x0020, 0x0000, 0x000C, 0x0002, 0x0000 };

    auto collation = collate_for_tests(
        cps, cps + 2, boost::text::variable_weighting::non_ignorable);

    EXPECT_EQ(collation.size(), 9);
    EXPECT_TRUE(boost::algorithm::equal(collation.begin(), collation.end(), ces, ces + 9))
        << "from:     " << ce_dumper(cps)
        << "expected: " << ce_dumper(ces)
        << "got:      " << ce_dumper(collation);
}

TEST(collation, non_ignorable_110_165)
{
    // 1F159 0021;	
    // (🅙) NEGATIVE CIRCLED LATIN CAPITAL LETTER J	[1DB2 0261 | 0020 0020 | 000C 0002 |]

    uint32_t cps[2] = { 0x1F159, 0x0021 };
    uint32_t const ces[9] = { 0x1DB2, 0x0261, 0x0000, 0x0020, 0x0020, 0x0000, 0x000C, 0x0002, 0x0000 };

    auto collation = collate_for_tests(
        cps, cps + 2, boost::text::variable_weighting::non_ignorable);

    EXPECT_EQ(collation.size(), 9);
    EXPECT_TRUE(boost::algorithm::equal(collation.begin(), collation.end(), ces, ces + 9))
        << "from:     " << ce_dumper(cps)
        << "expected: " << ce_dumper(ces)
        << "got:      " << ce_dumper(collation);
}

TEST(collation, non_ignorable_110_166)
{
    // 02B2 0021;	
    // (ʲ) MODIFIER LETTER SMALL J	[1DB2 0261 | 0020 0020 | 0014 0002 |]

    uint32_t cps[2] = { 0x02B2, 0x0021 };
    uint32_t const ces[9] = { 0x1DB2, 0x0261, 0x0000, 0x0020, 0x0020, 0x0000, 0x0014, 0x0002, 0x0000 };

    auto collation = collate_for_tests(
        cps, cps + 2, boost::text::variable_weighting::non_ignorable);

    EXPECT_EQ(collation.size(), 9);
    EXPECT_TRUE(boost::algorithm::equal(collation.begin(), collation.end(), ces, ces + 9))
        << "from:     " << ce_dumper(cps)
        << "expected: " << ce_dumper(ces)
        << "got:      " << ce_dumper(collation);
}

TEST(collation, non_ignorable_110_167)
{
    // 2C7C 0021;	
    // (ⱼ) LATIN SUBSCRIPT SMALL LETTER J	[1DB2 0261 | 0020 0020 | 0015 0002 |]

    uint32_t cps[2] = { 0x2C7C, 0x0021 };
    uint32_t const ces[9] = { 0x1DB2, 0x0261, 0x0000, 0x0020, 0x0020, 0x0000, 0x0015, 0x0002, 0x0000 };

    auto collation = collate_for_tests(
        cps, cps + 2, boost::text::variable_weighting::non_ignorable);

    EXPECT_EQ(collation.size(), 9);
    EXPECT_TRUE(boost::algorithm::equal(collation.begin(), collation.end(), ces, ces + 9))
        << "from:     " << ce_dumper(cps)
        << "expected: " << ce_dumper(ces)
        << "got:      " << ce_dumper(collation);
}

TEST(collation, non_ignorable_110_168)
{
    // 1D36 0021;	
    // (ᴶ) MODIFIER LETTER CAPITAL J	[1DB2 0261 | 0020 0020 | 001D 0002 |]

    uint32_t cps[2] = { 0x1D36, 0x0021 };
    uint32_t const ces[9] = { 0x1DB2, 0x0261, 0x0000, 0x0020, 0x0020, 0x0000, 0x001D, 0x0002, 0x0000 };

    auto collation = collate_for_tests(
        cps, cps + 2, boost::text::variable_weighting::non_ignorable);

    EXPECT_EQ(collation.size(), 9);
    EXPECT_TRUE(boost::algorithm::equal(collation.begin(), collation.end(), ces, ces + 9))
        << "from:     " << ce_dumper(cps)
        << "expected: " << ce_dumper(ces)
        << "got:      " << ce_dumper(collation);
}

TEST(collation, non_ignorable_110_169)
{
    // 1F139 0021;	
    // (🄹) SQUARED LATIN CAPITAL LETTER J	[1DB2 0261 | 0020 0020 | 001D 0002 |]

    uint32_t cps[2] = { 0x1F139, 0x0021 };
    uint32_t const ces[9] = { 0x1DB2, 0x0261, 0x0000, 0x0020, 0x0020, 0x0000, 0x001D, 0x0002, 0x0000 };

    auto collation = collate_for_tests(
        cps, cps + 2, boost::text::variable_weighting::non_ignorable);

    EXPECT_EQ(collation.size(), 9);
    EXPECT_TRUE(boost::algorithm::equal(collation.begin(), collation.end(), ces, ces + 9))
        << "from:     " << ce_dumper(cps)
        << "expected: " << ce_dumper(ces)
        << "got:      " << ce_dumper(collation);
}

TEST(collation, non_ignorable_110_170)
{
    // 1F179 0021;	
    // (🅹) NEGATIVE SQUARED LATIN CAPITAL LETTER J	[1DB2 0261 | 0020 0020 | 001D 0002 |]

    uint32_t cps[2] = { 0x1F179, 0x0021 };
    uint32_t const ces[9] = { 0x1DB2, 0x0261, 0x0000, 0x0020, 0x0020, 0x0000, 0x001D, 0x0002, 0x0000 };

    auto collation = collate_for_tests(
        cps, cps + 2, boost::text::variable_weighting::non_ignorable);

    EXPECT_EQ(collation.size(), 9);
    EXPECT_TRUE(boost::algorithm::equal(collation.begin(), collation.end(), ces, ces + 9))
        << "from:     " << ce_dumper(cps)
        << "expected: " << ce_dumper(ces)
        << "got:      " << ce_dumper(collation);
}

TEST(collation, non_ignorable_110_171)
{
    // 0135 0021;	
    // (ĵ) LATIN SMALL LETTER J WITH CIRCUMFLEX	[1DB2 0261 | 0020 0027 0020 | 0002 0002 0002 |]

    uint32_t cps[2] = { 0x0135, 0x0021 };
    uint32_t const ces[11] = { 0x1DB2, 0x0261, 0x0000, 0x0020, 0x0027, 0x0020, 0x0000, 0x0002, 0x0002, 0x0002, 0x0000 };

    auto collation = collate_for_tests(
        cps, cps + 2, boost::text::variable_weighting::non_ignorable);

    EXPECT_EQ(collation.size(), 11);
    EXPECT_TRUE(boost::algorithm::equal(collation.begin(), collation.end(), ces, ces + 11))
        << "from:     " << ce_dumper(cps)
        << "expected: " << ce_dumper(ces)
        << "got:      " << ce_dumper(collation);
}

TEST(collation, non_ignorable_110_172)
{
    // 0134 0021;	
    // (Ĵ) LATIN CAPITAL LETTER J WITH CIRCUMFLEX	[1DB2 0261 | 0020 0027 0020 | 0008 0002 0002 |]

    uint32_t cps[2] = { 0x0134, 0x0021 };
    uint32_t const ces[11] = { 0x1DB2, 0x0261, 0x0000, 0x0020, 0x0027, 0x0020, 0x0000, 0x0008, 0x0002, 0x0002, 0x0000 };

    auto collation = collate_for_tests(
        cps, cps + 2, boost::text::variable_weighting::non_ignorable);

    EXPECT_EQ(collation.size(), 11);
    EXPECT_TRUE(boost::algorithm::equal(collation.begin(), collation.end(), ces, ces + 11))
        << "from:     " << ce_dumper(cps)
        << "expected: " << ce_dumper(ces)
        << "got:      " << ce_dumper(collation);
}

TEST(collation, non_ignorable_110_173)
{
    // 01F0 0021;	
    // (ǰ) LATIN SMALL LETTER J WITH CARON	[1DB2 0261 | 0020 0028 0020 | 0002 0002 0002 |]

    uint32_t cps[2] = { 0x01F0, 0x0021 };
    uint32_t const ces[11] = { 0x1DB2, 0x0261, 0x0000, 0x0020, 0x0028, 0x0020, 0x0000, 0x0002, 0x0002, 0x0002, 0x0000 };

    auto collation = collate_for_tests(
        cps, cps + 2, boost::text::variable_weighting::non_ignorable);

    EXPECT_EQ(collation.size(), 11);
    EXPECT_TRUE(boost::algorithm::equal(collation.begin(), collation.end(), ces, ces + 11))
        << "from:     " << ce_dumper(cps)
        << "expected: " << ce_dumper(ces)
        << "got:      " << ce_dumper(collation);
}

TEST(collation, non_ignorable_110_174)
{
    // 006A 003F;	
    // (j) LATIN SMALL LETTER J	[1DB2 0267 | 0020 0020 | 0002 0002 |]

    uint32_t cps[2] = { 0x006A, 0x003F };
    uint32_t const ces[9] = { 0x1DB2, 0x0267, 0x0000, 0x0020, 0x0020, 0x0000, 0x0002, 0x0002, 0x0000 };

    auto collation = collate_for_tests(
        cps, cps + 2, boost::text::variable_weighting::non_ignorable);

    EXPECT_EQ(collation.size(), 9);
    EXPECT_TRUE(boost::algorithm::equal(collation.begin(), collation.end(), ces, ces + 9))
        << "from:     " << ce_dumper(cps)
        << "expected: " << ce_dumper(ces)
        << "got:      " << ce_dumper(collation);
}

TEST(collation, non_ignorable_110_175)
{
    // FF4A 003F;	
    // (ｊ) FULLWIDTH LATIN SMALL LETTER J	[1DB2 0267 | 0020 0020 | 0003 0002 |]

    uint32_t cps[2] = { 0xFF4A, 0x003F };
    uint32_t const ces[9] = { 0x1DB2, 0x0267, 0x0000, 0x0020, 0x0020, 0x0000, 0x0003, 0x0002, 0x0000 };

    auto collation = collate_for_tests(
        cps, cps + 2, boost::text::variable_weighting::non_ignorable);

    EXPECT_EQ(collation.size(), 9);
    EXPECT_TRUE(boost::algorithm::equal(collation.begin(), collation.end(), ces, ces + 9))
        << "from:     " << ce_dumper(cps)
        << "expected: " << ce_dumper(ces)
        << "got:      " << ce_dumper(collation);
}

TEST(collation, non_ignorable_110_176)
{
    // 2149 003F;	
    // (ⅉ) DOUBLE-STRUCK ITALIC SMALL J	[1DB2 0267 | 0020 0020 | 0005 0002 |]

    uint32_t cps[2] = { 0x2149, 0x003F };
    uint32_t const ces[9] = { 0x1DB2, 0x0267, 0x0000, 0x0020, 0x0020, 0x0000, 0x0005, 0x0002, 0x0000 };

    auto collation = collate_for_tests(
        cps, cps + 2, boost::text::variable_weighting::non_ignorable);

    EXPECT_EQ(collation.size(), 9);
    EXPECT_TRUE(boost::algorithm::equal(collation.begin(), collation.end(), ces, ces + 9))
        << "from:     " << ce_dumper(cps)
        << "expected: " << ce_dumper(ces)
        << "got:      " << ce_dumper(collation);
}

TEST(collation, non_ignorable_110_177)
{
    // 1D423 003F;	
    // (𝐣) MATHEMATICAL BOLD SMALL J	[1DB2 0267 | 0020 0020 | 0005 0002 |]

    uint32_t cps[2] = { 0x1D423, 0x003F };
    uint32_t const ces[9] = { 0x1DB2, 0x0267, 0x0000, 0x0020, 0x0020, 0x0000, 0x0005, 0x0002, 0x0000 };

    auto collation = collate_for_tests(
        cps, cps + 2, boost::text::variable_weighting::non_ignorable);

    EXPECT_EQ(collation.size(), 9);
    EXPECT_TRUE(boost::algorithm::equal(collation.begin(), collation.end(), ces, ces + 9))
        << "from:     " << ce_dumper(cps)
        << "expected: " << ce_dumper(ces)
        << "got:      " << ce_dumper(collation);
}

TEST(collation, non_ignorable_110_178)
{
    // 1D457 003F;	
    // (𝑗) MATHEMATICAL ITALIC SMALL J	[1DB2 0267 | 0020 0020 | 0005 0002 |]

    uint32_t cps[2] = { 0x1D457, 0x003F };
    uint32_t const ces[9] = { 0x1DB2, 0x0267, 0x0000, 0x0020, 0x0020, 0x0000, 0x0005, 0x0002, 0x0000 };

    auto collation = collate_for_tests(
        cps, cps + 2, boost::text::variable_weighting::non_ignorable);

    EXPECT_EQ(collation.size(), 9);
    EXPECT_TRUE(boost::algorithm::equal(collation.begin(), collation.end(), ces, ces + 9))
        << "from:     " << ce_dumper(cps)
        << "expected: " << ce_dumper(ces)
        << "got:      " << ce_dumper(collation);
}

TEST(collation, non_ignorable_110_179)
{
    // 1D48B 003F;	
    // (𝒋) MATHEMATICAL BOLD ITALIC SMALL J	[1DB2 0267 | 0020 0020 | 0005 0002 |]

    uint32_t cps[2] = { 0x1D48B, 0x003F };
    uint32_t const ces[9] = { 0x1DB2, 0x0267, 0x0000, 0x0020, 0x0020, 0x0000, 0x0005, 0x0002, 0x0000 };

    auto collation = collate_for_tests(
        cps, cps + 2, boost::text::variable_weighting::non_ignorable);

    EXPECT_EQ(collation.size(), 9);
    EXPECT_TRUE(boost::algorithm::equal(collation.begin(), collation.end(), ces, ces + 9))
        << "from:     " << ce_dumper(cps)
        << "expected: " << ce_dumper(ces)
        << "got:      " << ce_dumper(collation);
}

TEST(collation, non_ignorable_110_180)
{
    // 1D4BF 003F;	
    // (𝒿) MATHEMATICAL SCRIPT SMALL J	[1DB2 0267 | 0020 0020 | 0005 0002 |]

    uint32_t cps[2] = { 0x1D4BF, 0x003F };
    uint32_t const ces[9] = { 0x1DB2, 0x0267, 0x0000, 0x0020, 0x0020, 0x0000, 0x0005, 0x0002, 0x0000 };

    auto collation = collate_for_tests(
        cps, cps + 2, boost::text::variable_weighting::non_ignorable);

    EXPECT_EQ(collation.size(), 9);
    EXPECT_TRUE(boost::algorithm::equal(collation.begin(), collation.end(), ces, ces + 9))
        << "from:     " << ce_dumper(cps)
        << "expected: " << ce_dumper(ces)
        << "got:      " << ce_dumper(collation);
}

TEST(collation, non_ignorable_110_181)
{
    // 1D4F3 003F;	
    // (𝓳) MATHEMATICAL BOLD SCRIPT SMALL J	[1DB2 0267 | 0020 0020 | 0005 0002 |]

    uint32_t cps[2] = { 0x1D4F3, 0x003F };
    uint32_t const ces[9] = { 0x1DB2, 0x0267, 0x0000, 0x0020, 0x0020, 0x0000, 0x0005, 0x0002, 0x0000 };

    auto collation = collate_for_tests(
        cps, cps + 2, boost::text::variable_weighting::non_ignorable);

    EXPECT_EQ(collation.size(), 9);
    EXPECT_TRUE(boost::algorithm::equal(collation.begin(), collation.end(), ces, ces + 9))
        << "from:     " << ce_dumper(cps)
        << "expected: " << ce_dumper(ces)
        << "got:      " << ce_dumper(collation);
}

TEST(collation, non_ignorable_110_182)
{
    // 1D527 003F;	
    // (𝔧) MATHEMATICAL FRAKTUR SMALL J	[1DB2 0267 | 0020 0020 | 0005 0002 |]

    uint32_t cps[2] = { 0x1D527, 0x003F };
    uint32_t const ces[9] = { 0x1DB2, 0x0267, 0x0000, 0x0020, 0x0020, 0x0000, 0x0005, 0x0002, 0x0000 };

    auto collation = collate_for_tests(
        cps, cps + 2, boost::text::variable_weighting::non_ignorable);

    EXPECT_EQ(collation.size(), 9);
    EXPECT_TRUE(boost::algorithm::equal(collation.begin(), collation.end(), ces, ces + 9))
        << "from:     " << ce_dumper(cps)
        << "expected: " << ce_dumper(ces)
        << "got:      " << ce_dumper(collation);
}

TEST(collation, non_ignorable_110_183)
{
    // 1D55B 003F;	
    // (𝕛) MATHEMATICAL DOUBLE-STRUCK SMALL J	[1DB2 0267 | 0020 0020 | 0005 0002 |]

    uint32_t cps[2] = { 0x1D55B, 0x003F };
    uint32_t const ces[9] = { 0x1DB2, 0x0267, 0x0000, 0x0020, 0x0020, 0x0000, 0x0005, 0x0002, 0x0000 };

    auto collation = collate_for_tests(
        cps, cps + 2, boost::text::variable_weighting::non_ignorable);

    EXPECT_EQ(collation.size(), 9);
    EXPECT_TRUE(boost::algorithm::equal(collation.begin(), collation.end(), ces, ces + 9))
        << "from:     " << ce_dumper(cps)
        << "expected: " << ce_dumper(ces)
        << "got:      " << ce_dumper(collation);
}

TEST(collation, non_ignorable_110_184)
{
    // 1D58F 003F;	
    // (𝖏) MATHEMATICAL BOLD FRAKTUR SMALL J	[1DB2 0267 | 0020 0020 | 0005 0002 |]

    uint32_t cps[2] = { 0x1D58F, 0x003F };
    uint32_t const ces[9] = { 0x1DB2, 0x0267, 0x0000, 0x0020, 0x0020, 0x0000, 0x0005, 0x0002, 0x0000 };

    auto collation = collate_for_tests(
        cps, cps + 2, boost::text::variable_weighting::non_ignorable);

    EXPECT_EQ(collation.size(), 9);
    EXPECT_TRUE(boost::algorithm::equal(collation.begin(), collation.end(), ces, ces + 9))
        << "from:     " << ce_dumper(cps)
        << "expected: " << ce_dumper(ces)
        << "got:      " << ce_dumper(collation);
}

TEST(collation, non_ignorable_110_185)
{
    // 1D5C3 003F;	
    // (𝗃) MATHEMATICAL SANS-SERIF SMALL J	[1DB2 0267 | 0020 0020 | 0005 0002 |]

    uint32_t cps[2] = { 0x1D5C3, 0x003F };
    uint32_t const ces[9] = { 0x1DB2, 0x0267, 0x0000, 0x0020, 0x0020, 0x0000, 0x0005, 0x0002, 0x0000 };

    auto collation = collate_for_tests(
        cps, cps + 2, boost::text::variable_weighting::non_ignorable);

    EXPECT_EQ(collation.size(), 9);
    EXPECT_TRUE(boost::algorithm::equal(collation.begin(), collation.end(), ces, ces + 9))
        << "from:     " << ce_dumper(cps)
        << "expected: " << ce_dumper(ces)
        << "got:      " << ce_dumper(collation);
}

TEST(collation, non_ignorable_110_186)
{
    // 1D5F7 003F;	
    // (𝗷) MATHEMATICAL SANS-SERIF BOLD SMALL J	[1DB2 0267 | 0020 0020 | 0005 0002 |]

    uint32_t cps[2] = { 0x1D5F7, 0x003F };
    uint32_t const ces[9] = { 0x1DB2, 0x0267, 0x0000, 0x0020, 0x0020, 0x0000, 0x0005, 0x0002, 0x0000 };

    auto collation = collate_for_tests(
        cps, cps + 2, boost::text::variable_weighting::non_ignorable);

    EXPECT_EQ(collation.size(), 9);
    EXPECT_TRUE(boost::algorithm::equal(collation.begin(), collation.end(), ces, ces + 9))
        << "from:     " << ce_dumper(cps)
        << "expected: " << ce_dumper(ces)
        << "got:      " << ce_dumper(collation);
}

TEST(collation, non_ignorable_110_187)
{
    // 1D62B 003F;	
    // (𝘫) MATHEMATICAL SANS-SERIF ITALIC SMALL J	[1DB2 0267 | 0020 0020 | 0005 0002 |]

    uint32_t cps[2] = { 0x1D62B, 0x003F };
    uint32_t const ces[9] = { 0x1DB2, 0x0267, 0x0000, 0x0020, 0x0020, 0x0000, 0x0005, 0x0002, 0x0000 };

    auto collation = collate_for_tests(
        cps, cps + 2, boost::text::variable_weighting::non_ignorable);

    EXPECT_EQ(collation.size(), 9);
    EXPECT_TRUE(boost::algorithm::equal(collation.begin(), collation.end(), ces, ces + 9))
        << "from:     " << ce_dumper(cps)
        << "expected: " << ce_dumper(ces)
        << "got:      " << ce_dumper(collation);
}

TEST(collation, non_ignorable_110_188)
{
    // 1D65F 003F;	
    // (𝙟) MATHEMATICAL SANS-SERIF BOLD ITALIC SMALL J	[1DB2 0267 | 0020 0020 | 0005 0002 |]

    uint32_t cps[2] = { 0x1D65F, 0x003F };
    uint32_t const ces[9] = { 0x1DB2, 0x0267, 0x0000, 0x0020, 0x0020, 0x0000, 0x0005, 0x0002, 0x0000 };

    auto collation = collate_for_tests(
        cps, cps + 2, boost::text::variable_weighting::non_ignorable);

    EXPECT_EQ(collation.size(), 9);
    EXPECT_TRUE(boost::algorithm::equal(collation.begin(), collation.end(), ces, ces + 9))
        << "from:     " << ce_dumper(cps)
        << "expected: " << ce_dumper(ces)
        << "got:      " << ce_dumper(collation);
}

TEST(collation, non_ignorable_110_189)
{
    // 1D693 003F;	
    // (𝚓) MATHEMATICAL MONOSPACE SMALL J	[1DB2 0267 | 0020 0020 | 0005 0002 |]

    uint32_t cps[2] = { 0x1D693, 0x003F };
    uint32_t const ces[9] = { 0x1DB2, 0x0267, 0x0000, 0x0020, 0x0020, 0x0000, 0x0005, 0x0002, 0x0000 };

    auto collation = collate_for_tests(
        cps, cps + 2, boost::text::variable_weighting::non_ignorable);

    EXPECT_EQ(collation.size(), 9);
    EXPECT_TRUE(boost::algorithm::equal(collation.begin(), collation.end(), ces, ces + 9))
        << "from:     " << ce_dumper(cps)
        << "expected: " << ce_dumper(ces)
        << "got:      " << ce_dumper(collation);
}

TEST(collation, non_ignorable_110_190)
{
    // 24D9 003F;	
    // (ⓙ) CIRCLED LATIN SMALL LETTER J	[1DB2 0267 | 0020 0020 | 0006 0002 |]

    uint32_t cps[2] = { 0x24D9, 0x003F };
    uint32_t const ces[9] = { 0x1DB2, 0x0267, 0x0000, 0x0020, 0x0020, 0x0000, 0x0006, 0x0002, 0x0000 };

    auto collation = collate_for_tests(
        cps, cps + 2, boost::text::variable_weighting::non_ignorable);

    EXPECT_EQ(collation.size(), 9);
    EXPECT_TRUE(boost::algorithm::equal(collation.begin(), collation.end(), ces, ces + 9))
        << "from:     " << ce_dumper(cps)
        << "expected: " << ce_dumper(ces)
        << "got:      " << ce_dumper(collation);
}

TEST(collation, non_ignorable_110_191)
{
    // 004A 003F;	
    // (J) LATIN CAPITAL LETTER J	[1DB2 0267 | 0020 0020 | 0008 0002 |]

    uint32_t cps[2] = { 0x004A, 0x003F };
    uint32_t const ces[9] = { 0x1DB2, 0x0267, 0x0000, 0x0020, 0x0020, 0x0000, 0x0008, 0x0002, 0x0000 };

    auto collation = collate_for_tests(
        cps, cps + 2, boost::text::variable_weighting::non_ignorable);

    EXPECT_EQ(collation.size(), 9);
    EXPECT_TRUE(boost::algorithm::equal(collation.begin(), collation.end(), ces, ces + 9))
        << "from:     " << ce_dumper(cps)
        << "expected: " << ce_dumper(ces)
        << "got:      " << ce_dumper(collation);
}

TEST(collation, non_ignorable_110_192)
{
    // FF2A 003F;	
    // (Ｊ) FULLWIDTH LATIN CAPITAL LETTER J	[1DB2 0267 | 0020 0020 | 0009 0002 |]

    uint32_t cps[2] = { 0xFF2A, 0x003F };
    uint32_t const ces[9] = { 0x1DB2, 0x0267, 0x0000, 0x0020, 0x0020, 0x0000, 0x0009, 0x0002, 0x0000 };

    auto collation = collate_for_tests(
        cps, cps + 2, boost::text::variable_weighting::non_ignorable);

    EXPECT_EQ(collation.size(), 9);
    EXPECT_TRUE(boost::algorithm::equal(collation.begin(), collation.end(), ces, ces + 9))
        << "from:     " << ce_dumper(cps)
        << "expected: " << ce_dumper(ces)
        << "got:      " << ce_dumper(collation);
}

TEST(collation, non_ignorable_110_193)
{
    // 1D409 003F;	
    // (𝐉) MATHEMATICAL BOLD CAPITAL J	[1DB2 0267 | 0020 0020 | 000B 0002 |]

    uint32_t cps[2] = { 0x1D409, 0x003F };
    uint32_t const ces[9] = { 0x1DB2, 0x0267, 0x0000, 0x0020, 0x0020, 0x0000, 0x000B, 0x0002, 0x0000 };

    auto collation = collate_for_tests(
        cps, cps + 2, boost::text::variable_weighting::non_ignorable);

    EXPECT_EQ(collation.size(), 9);
    EXPECT_TRUE(boost::algorithm::equal(collation.begin(), collation.end(), ces, ces + 9))
        << "from:     " << ce_dumper(cps)
        << "expected: " << ce_dumper(ces)
        << "got:      " << ce_dumper(collation);
}

TEST(collation, non_ignorable_110_194)
{
    // 1D43D 003F;	
    // (𝐽) MATHEMATICAL ITALIC CAPITAL J	[1DB2 0267 | 0020 0020 | 000B 0002 |]

    uint32_t cps[2] = { 0x1D43D, 0x003F };
    uint32_t const ces[9] = { 0x1DB2, 0x0267, 0x0000, 0x0020, 0x0020, 0x0000, 0x000B, 0x0002, 0x0000 };

    auto collation = collate_for_tests(
        cps, cps + 2, boost::text::variable_weighting::non_ignorable);

    EXPECT_EQ(collation.size(), 9);
    EXPECT_TRUE(boost::algorithm::equal(collation.begin(), collation.end(), ces, ces + 9))
        << "from:     " << ce_dumper(cps)
        << "expected: " << ce_dumper(ces)
        << "got:      " << ce_dumper(collation);
}

TEST(collation, non_ignorable_110_195)
{
    // 1D471 003F;	
    // (𝑱) MATHEMATICAL BOLD ITALIC CAPITAL J	[1DB2 0267 | 0020 0020 | 000B 0002 |]

    uint32_t cps[2] = { 0x1D471, 0x003F };
    uint32_t const ces[9] = { 0x1DB2, 0x0267, 0x0000, 0x0020, 0x0020, 0x0000, 0x000B, 0x0002, 0x0000 };

    auto collation = collate_for_tests(
        cps, cps + 2, boost::text::variable_weighting::non_ignorable);

    EXPECT_EQ(collation.size(), 9);
    EXPECT_TRUE(boost::algorithm::equal(collation.begin(), collation.end(), ces, ces + 9))
        << "from:     " << ce_dumper(cps)
        << "expected: " << ce_dumper(ces)
        << "got:      " << ce_dumper(collation);
}

TEST(collation, non_ignorable_110_196)
{
    // 1D4A5 003F;	
    // (𝒥) MATHEMATICAL SCRIPT CAPITAL J	[1DB2 0267 | 0020 0020 | 000B 0002 |]

    uint32_t cps[2] = { 0x1D4A5, 0x003F };
    uint32_t const ces[9] = { 0x1DB2, 0x0267, 0x0000, 0x0020, 0x0020, 0x0000, 0x000B, 0x0002, 0x0000 };

    auto collation = collate_for_tests(
        cps, cps + 2, boost::text::variable_weighting::non_ignorable);

    EXPECT_EQ(collation.size(), 9);
    EXPECT_TRUE(boost::algorithm::equal(collation.begin(), collation.end(), ces, ces + 9))
        << "from:     " << ce_dumper(cps)
        << "expected: " << ce_dumper(ces)
        << "got:      " << ce_dumper(collation);
}

TEST(collation, non_ignorable_110_197)
{
    // 1D4D9 003F;	
    // (𝓙) MATHEMATICAL BOLD SCRIPT CAPITAL J	[1DB2 0267 | 0020 0020 | 000B 0002 |]

    uint32_t cps[2] = { 0x1D4D9, 0x003F };
    uint32_t const ces[9] = { 0x1DB2, 0x0267, 0x0000, 0x0020, 0x0020, 0x0000, 0x000B, 0x0002, 0x0000 };

    auto collation = collate_for_tests(
        cps, cps + 2, boost::text::variable_weighting::non_ignorable);

    EXPECT_EQ(collation.size(), 9);
    EXPECT_TRUE(boost::algorithm::equal(collation.begin(), collation.end(), ces, ces + 9))
        << "from:     " << ce_dumper(cps)
        << "expected: " << ce_dumper(ces)
        << "got:      " << ce_dumper(collation);
}

TEST(collation, non_ignorable_110_198)
{
    // 1D50D 003F;	
    // (𝔍) MATHEMATICAL FRAKTUR CAPITAL J	[1DB2 0267 | 0020 0020 | 000B 0002 |]

    uint32_t cps[2] = { 0x1D50D, 0x003F };
    uint32_t const ces[9] = { 0x1DB2, 0x0267, 0x0000, 0x0020, 0x0020, 0x0000, 0x000B, 0x0002, 0x0000 };

    auto collation = collate_for_tests(
        cps, cps + 2, boost::text::variable_weighting::non_ignorable);

    EXPECT_EQ(collation.size(), 9);
    EXPECT_TRUE(boost::algorithm::equal(collation.begin(), collation.end(), ces, ces + 9))
        << "from:     " << ce_dumper(cps)
        << "expected: " << ce_dumper(ces)
        << "got:      " << ce_dumper(collation);
}

TEST(collation, non_ignorable_110_199)
{
    // 1D541 003F;	
    // (𝕁) MATHEMATICAL DOUBLE-STRUCK CAPITAL J	[1DB2 0267 | 0020 0020 | 000B 0002 |]

    uint32_t cps[2] = { 0x1D541, 0x003F };
    uint32_t const ces[9] = { 0x1DB2, 0x0267, 0x0000, 0x0020, 0x0020, 0x0000, 0x000B, 0x0002, 0x0000 };

    auto collation = collate_for_tests(
        cps, cps + 2, boost::text::variable_weighting::non_ignorable);

    EXPECT_EQ(collation.size(), 9);
    EXPECT_TRUE(boost::algorithm::equal(collation.begin(), collation.end(), ces, ces + 9))
        << "from:     " << ce_dumper(cps)
        << "expected: " << ce_dumper(ces)
        << "got:      " << ce_dumper(collation);
}

TEST(collation, non_ignorable_110_200)
{
    // 1D575 003F;	
    // (𝕵) MATHEMATICAL BOLD FRAKTUR CAPITAL J	[1DB2 0267 | 0020 0020 | 000B 0002 |]

    uint32_t cps[2] = { 0x1D575, 0x003F };
    uint32_t const ces[9] = { 0x1DB2, 0x0267, 0x0000, 0x0020, 0x0020, 0x0000, 0x000B, 0x0002, 0x0000 };

    auto collation = collate_for_tests(
        cps, cps + 2, boost::text::variable_weighting::non_ignorable);

    EXPECT_EQ(collation.size(), 9);
    EXPECT_TRUE(boost::algorithm::equal(collation.begin(), collation.end(), ces, ces + 9))
        << "from:     " << ce_dumper(cps)
        << "expected: " << ce_dumper(ces)
        << "got:      " << ce_dumper(collation);
}

TEST(collation, non_ignorable_110_201)
{
    // 1D5A9 003F;	
    // (𝖩) MATHEMATICAL SANS-SERIF CAPITAL J	[1DB2 0267 | 0020 0020 | 000B 0002 |]

    uint32_t cps[2] = { 0x1D5A9, 0x003F };
    uint32_t const ces[9] = { 0x1DB2, 0x0267, 0x0000, 0x0020, 0x0020, 0x0000, 0x000B, 0x0002, 0x0000 };

    auto collation = collate_for_tests(
        cps, cps + 2, boost::text::variable_weighting::non_ignorable);

    EXPECT_EQ(collation.size(), 9);
    EXPECT_TRUE(boost::algorithm::equal(collation.begin(), collation.end(), ces, ces + 9))
        << "from:     " << ce_dumper(cps)
        << "expected: " << ce_dumper(ces)
        << "got:      " << ce_dumper(collation);
}

TEST(collation, non_ignorable_110_202)
{
    // 1D5DD 003F;	
    // (𝗝) MATHEMATICAL SANS-SERIF BOLD CAPITAL J	[1DB2 0267 | 0020 0020 | 000B 0002 |]

    uint32_t cps[2] = { 0x1D5DD, 0x003F };
    uint32_t const ces[9] = { 0x1DB2, 0x0267, 0x0000, 0x0020, 0x0020, 0x0000, 0x000B, 0x0002, 0x0000 };

    auto collation = collate_for_tests(
        cps, cps + 2, boost::text::variable_weighting::non_ignorable);

    EXPECT_EQ(collation.size(), 9);
    EXPECT_TRUE(boost::algorithm::equal(collation.begin(), collation.end(), ces, ces + 9))
        << "from:     " << ce_dumper(cps)
        << "expected: " << ce_dumper(ces)
        << "got:      " << ce_dumper(collation);
}

TEST(collation, non_ignorable_110_203)
{
    // 1D611 003F;	
    // (𝘑) MATHEMATICAL SANS-SERIF ITALIC CAPITAL J	[1DB2 0267 | 0020 0020 | 000B 0002 |]

    uint32_t cps[2] = { 0x1D611, 0x003F };
    uint32_t const ces[9] = { 0x1DB2, 0x0267, 0x0000, 0x0020, 0x0020, 0x0000, 0x000B, 0x0002, 0x0000 };

    auto collation = collate_for_tests(
        cps, cps + 2, boost::text::variable_weighting::non_ignorable);

    EXPECT_EQ(collation.size(), 9);
    EXPECT_TRUE(boost::algorithm::equal(collation.begin(), collation.end(), ces, ces + 9))
        << "from:     " << ce_dumper(cps)
        << "expected: " << ce_dumper(ces)
        << "got:      " << ce_dumper(collation);
}

TEST(collation, non_ignorable_110_204)
{
    // 1D645 003F;	
    // (𝙅) MATHEMATICAL SANS-SERIF BOLD ITALIC CAPITAL J	[1DB2 0267 | 0020 0020 | 000B 0002 |]

    uint32_t cps[2] = { 0x1D645, 0x003F };
    uint32_t const ces[9] = { 0x1DB2, 0x0267, 0x0000, 0x0020, 0x0020, 0x0000, 0x000B, 0x0002, 0x0000 };

    auto collation = collate_for_tests(
        cps, cps + 2, boost::text::variable_weighting::non_ignorable);

    EXPECT_EQ(collation.size(), 9);
    EXPECT_TRUE(boost::algorithm::equal(collation.begin(), collation.end(), ces, ces + 9))
        << "from:     " << ce_dumper(cps)
        << "expected: " << ce_dumper(ces)
        << "got:      " << ce_dumper(collation);
}

TEST(collation, non_ignorable_110_205)
{
    // 1D679 003F;	
    // (𝙹) MATHEMATICAL MONOSPACE CAPITAL J	[1DB2 0267 | 0020 0020 | 000B 0002 |]

    uint32_t cps[2] = { 0x1D679, 0x003F };
    uint32_t const ces[9] = { 0x1DB2, 0x0267, 0x0000, 0x0020, 0x0020, 0x0000, 0x000B, 0x0002, 0x0000 };

    auto collation = collate_for_tests(
        cps, cps + 2, boost::text::variable_weighting::non_ignorable);

    EXPECT_EQ(collation.size(), 9);
    EXPECT_TRUE(boost::algorithm::equal(collation.begin(), collation.end(), ces, ces + 9))
        << "from:     " << ce_dumper(cps)
        << "expected: " << ce_dumper(ces)
        << "got:      " << ce_dumper(collation);
}

TEST(collation, non_ignorable_110_206)
{
    // 24BF 003F;	
    // (Ⓙ) CIRCLED LATIN CAPITAL LETTER J	[1DB2 0267 | 0020 0020 | 000C 0002 |]

    uint32_t cps[2] = { 0x24BF, 0x003F };
    uint32_t const ces[9] = { 0x1DB2, 0x0267, 0x0000, 0x0020, 0x0020, 0x0000, 0x000C, 0x0002, 0x0000 };

    auto collation = collate_for_tests(
        cps, cps + 2, boost::text::variable_weighting::non_ignorable);

    EXPECT_EQ(collation.size(), 9);
    EXPECT_TRUE(boost::algorithm::equal(collation.begin(), collation.end(), ces, ces + 9))
        << "from:     " << ce_dumper(cps)
        << "expected: " << ce_dumper(ces)
        << "got:      " << ce_dumper(collation);
}

TEST(collation, non_ignorable_110_207)
{
    // 1F159 003F;	
    // (🅙) NEGATIVE CIRCLED LATIN CAPITAL LETTER J	[1DB2 0267 | 0020 0020 | 000C 0002 |]

    uint32_t cps[2] = { 0x1F159, 0x003F };
    uint32_t const ces[9] = { 0x1DB2, 0x0267, 0x0000, 0x0020, 0x0020, 0x0000, 0x000C, 0x0002, 0x0000 };

    auto collation = collate_for_tests(
        cps, cps + 2, boost::text::variable_weighting::non_ignorable);

    EXPECT_EQ(collation.size(), 9);
    EXPECT_TRUE(boost::algorithm::equal(collation.begin(), collation.end(), ces, ces + 9))
        << "from:     " << ce_dumper(cps)
        << "expected: " << ce_dumper(ces)
        << "got:      " << ce_dumper(collation);
}

TEST(collation, non_ignorable_110_208)
{
    // 02B2 003F;	
    // (ʲ) MODIFIER LETTER SMALL J	[1DB2 0267 | 0020 0020 | 0014 0002 |]

    uint32_t cps[2] = { 0x02B2, 0x003F };
    uint32_t const ces[9] = { 0x1DB2, 0x0267, 0x0000, 0x0020, 0x0020, 0x0000, 0x0014, 0x0002, 0x0000 };

    auto collation = collate_for_tests(
        cps, cps + 2, boost::text::variable_weighting::non_ignorable);

    EXPECT_EQ(collation.size(), 9);
    EXPECT_TRUE(boost::algorithm::equal(collation.begin(), collation.end(), ces, ces + 9))
        << "from:     " << ce_dumper(cps)
        << "expected: " << ce_dumper(ces)
        << "got:      " << ce_dumper(collation);
}

TEST(collation, non_ignorable_110_209)
{
    // 2C7C 003F;	
    // (ⱼ) LATIN SUBSCRIPT SMALL LETTER J	[1DB2 0267 | 0020 0020 | 0015 0002 |]

    uint32_t cps[2] = { 0x2C7C, 0x003F };
    uint32_t const ces[9] = { 0x1DB2, 0x0267, 0x0000, 0x0020, 0x0020, 0x0000, 0x0015, 0x0002, 0x0000 };

    auto collation = collate_for_tests(
        cps, cps + 2, boost::text::variable_weighting::non_ignorable);

    EXPECT_EQ(collation.size(), 9);
    EXPECT_TRUE(boost::algorithm::equal(collation.begin(), collation.end(), ces, ces + 9))
        << "from:     " << ce_dumper(cps)
        << "expected: " << ce_dumper(ces)
        << "got:      " << ce_dumper(collation);
}

TEST(collation, non_ignorable_110_210)
{
    // 1D36 003F;	
    // (ᴶ) MODIFIER LETTER CAPITAL J	[1DB2 0267 | 0020 0020 | 001D 0002 |]

    uint32_t cps[2] = { 0x1D36, 0x003F };
    uint32_t const ces[9] = { 0x1DB2, 0x0267, 0x0000, 0x0020, 0x0020, 0x0000, 0x001D, 0x0002, 0x0000 };

    auto collation = collate_for_tests(
        cps, cps + 2, boost::text::variable_weighting::non_ignorable);

    EXPECT_EQ(collation.size(), 9);
    EXPECT_TRUE(boost::algorithm::equal(collation.begin(), collation.end(), ces, ces + 9))
        << "from:     " << ce_dumper(cps)
        << "expected: " << ce_dumper(ces)
        << "got:      " << ce_dumper(collation);
}

TEST(collation, non_ignorable_110_211)
{
    // 1F139 003F;	
    // (🄹) SQUARED LATIN CAPITAL LETTER J	[1DB2 0267 | 0020 0020 | 001D 0002 |]

    uint32_t cps[2] = { 0x1F139, 0x003F };
    uint32_t const ces[9] = { 0x1DB2, 0x0267, 0x0000, 0x0020, 0x0020, 0x0000, 0x001D, 0x0002, 0x0000 };

    auto collation = collate_for_tests(
        cps, cps + 2, boost::text::variable_weighting::non_ignorable);

    EXPECT_EQ(collation.size(), 9);
    EXPECT_TRUE(boost::algorithm::equal(collation.begin(), collation.end(), ces, ces + 9))
        << "from:     " << ce_dumper(cps)
        << "expected: " << ce_dumper(ces)
        << "got:      " << ce_dumper(collation);
}

TEST(collation, non_ignorable_110_212)
{
    // 1F179 003F;	
    // (🅹) NEGATIVE SQUARED LATIN CAPITAL LETTER J	[1DB2 0267 | 0020 0020 | 001D 0002 |]

    uint32_t cps[2] = { 0x1F179, 0x003F };
    uint32_t const ces[9] = { 0x1DB2, 0x0267, 0x0000, 0x0020, 0x0020, 0x0000, 0x001D, 0x0002, 0x0000 };

    auto collation = collate_for_tests(
        cps, cps + 2, boost::text::variable_weighting::non_ignorable);

    EXPECT_EQ(collation.size(), 9);
    EXPECT_TRUE(boost::algorithm::equal(collation.begin(), collation.end(), ces, ces + 9))
        << "from:     " << ce_dumper(cps)
        << "expected: " << ce_dumper(ces)
        << "got:      " << ce_dumper(collation);
}

TEST(collation, non_ignorable_110_213)
{
    // 0135 003F;	
    // (ĵ) LATIN SMALL LETTER J WITH CIRCUMFLEX	[1DB2 0267 | 0020 0027 0020 | 0002 0002 0002 |]

    uint32_t cps[2] = { 0x0135, 0x003F };
    uint32_t const ces[11] = { 0x1DB2, 0x0267, 0x0000, 0x0020, 0x0027, 0x0020, 0x0000, 0x0002, 0x0002, 0x0002, 0x0000 };

    auto collation = collate_for_tests(
        cps, cps + 2, boost::text::variable_weighting::non_ignorable);

    EXPECT_EQ(collation.size(), 11);
    EXPECT_TRUE(boost::algorithm::equal(collation.begin(), collation.end(), ces, ces + 11))
        << "from:     " << ce_dumper(cps)
        << "expected: " << ce_dumper(ces)
        << "got:      " << ce_dumper(collation);
}

TEST(collation, non_ignorable_110_214)
{
    // 0134 003F;	
    // (Ĵ) LATIN CAPITAL LETTER J WITH CIRCUMFLEX	[1DB2 0267 | 0020 0027 0020 | 0008 0002 0002 |]

    uint32_t cps[2] = { 0x0134, 0x003F };
    uint32_t const ces[11] = { 0x1DB2, 0x0267, 0x0000, 0x0020, 0x0027, 0x0020, 0x0000, 0x0008, 0x0002, 0x0002, 0x0000 };

    auto collation = collate_for_tests(
        cps, cps + 2, boost::text::variable_weighting::non_ignorable);

    EXPECT_EQ(collation.size(), 11);
    EXPECT_TRUE(boost::algorithm::equal(collation.begin(), collation.end(), ces, ces + 11))
        << "from:     " << ce_dumper(cps)
        << "expected: " << ce_dumper(ces)
        << "got:      " << ce_dumper(collation);
}

TEST(collation, non_ignorable_110_215)
{
    // 01F0 003F;	
    // (ǰ) LATIN SMALL LETTER J WITH CARON	[1DB2 0267 | 0020 0028 0020 | 0002 0002 0002 |]

    uint32_t cps[2] = { 0x01F0, 0x003F };
    uint32_t const ces[11] = { 0x1DB2, 0x0267, 0x0000, 0x0020, 0x0028, 0x0020, 0x0000, 0x0002, 0x0002, 0x0002, 0x0000 };

    auto collation = collate_for_tests(
        cps, cps + 2, boost::text::variable_weighting::non_ignorable);

    EXPECT_EQ(collation.size(), 11);
    EXPECT_TRUE(boost::algorithm::equal(collation.begin(), collation.end(), ces, ces + 11))
        << "from:     " << ce_dumper(cps)
        << "expected: " << ce_dumper(ces)
        << "got:      " << ce_dumper(collation);
}

TEST(collation, non_ignorable_110_216)
{
    // 006A 0061;	
    // (j) LATIN SMALL LETTER J	[1DB2 1CAD | 0020 0020 | 0002 0002 |]

    uint32_t cps[2] = { 0x006A, 0x0061 };
    uint32_t const ces[9] = { 0x1DB2, 0x1CAD, 0x0000, 0x0020, 0x0020, 0x0000, 0x0002, 0x0002, 0x0000 };

    auto collation = collate_for_tests(
        cps, cps + 2, boost::text::variable_weighting::non_ignorable);

    EXPECT_EQ(collation.size(), 9);
    EXPECT_TRUE(boost::algorithm::equal(collation.begin(), collation.end(), ces, ces + 9))
        << "from:     " << ce_dumper(cps)
        << "expected: " << ce_dumper(ces)
        << "got:      " << ce_dumper(collation);
}

TEST(collation, non_ignorable_110_217)
{
    // 006A 0041;	
    // (j) LATIN SMALL LETTER J	[1DB2 1CAD | 0020 0020 | 0002 0008 |]

    uint32_t cps[2] = { 0x006A, 0x0041 };
    uint32_t const ces[9] = { 0x1DB2, 0x1CAD, 0x0000, 0x0020, 0x0020, 0x0000, 0x0002, 0x0008, 0x0000 };

    auto collation = collate_for_tests(
        cps, cps + 2, boost::text::variable_weighting::non_ignorable);

    EXPECT_EQ(collation.size(), 9);
    EXPECT_TRUE(boost::algorithm::equal(collation.begin(), collation.end(), ces, ces + 9))
        << "from:     " << ce_dumper(cps)
        << "expected: " << ce_dumper(ces)
        << "got:      " << ce_dumper(collation);
}

TEST(collation, non_ignorable_110_218)
{
    // FF4A 0061;	
    // (ｊ) FULLWIDTH LATIN SMALL LETTER J	[1DB2 1CAD | 0020 0020 | 0003 0002 |]

    uint32_t cps[2] = { 0xFF4A, 0x0061 };
    uint32_t const ces[9] = { 0x1DB2, 0x1CAD, 0x0000, 0x0020, 0x0020, 0x0000, 0x0003, 0x0002, 0x0000 };

    auto collation = collate_for_tests(
        cps, cps + 2, boost::text::variable_weighting::non_ignorable);

    EXPECT_EQ(collation.size(), 9);
    EXPECT_TRUE(boost::algorithm::equal(collation.begin(), collation.end(), ces, ces + 9))
        << "from:     " << ce_dumper(cps)
        << "expected: " << ce_dumper(ces)
        << "got:      " << ce_dumper(collation);
}

TEST(collation, non_ignorable_110_219)
{
    // FF4A 0041;	
    // (ｊ) FULLWIDTH LATIN SMALL LETTER J	[1DB2 1CAD | 0020 0020 | 0003 0008 |]

    uint32_t cps[2] = { 0xFF4A, 0x0041 };
    uint32_t const ces[9] = { 0x1DB2, 0x1CAD, 0x0000, 0x0020, 0x0020, 0x0000, 0x0003, 0x0008, 0x0000 };

    auto collation = collate_for_tests(
        cps, cps + 2, boost::text::variable_weighting::non_ignorable);

    EXPECT_EQ(collation.size(), 9);
    EXPECT_TRUE(boost::algorithm::equal(collation.begin(), collation.end(), ces, ces + 9))
        << "from:     " << ce_dumper(cps)
        << "expected: " << ce_dumper(ces)
        << "got:      " << ce_dumper(collation);
}

TEST(collation, non_ignorable_110_220)
{
    // 2149 0061;	
    // (ⅉ) DOUBLE-STRUCK ITALIC SMALL J	[1DB2 1CAD | 0020 0020 | 0005 0002 |]

    uint32_t cps[2] = { 0x2149, 0x0061 };
    uint32_t const ces[9] = { 0x1DB2, 0x1CAD, 0x0000, 0x0020, 0x0020, 0x0000, 0x0005, 0x0002, 0x0000 };

    auto collation = collate_for_tests(
        cps, cps + 2, boost::text::variable_weighting::non_ignorable);

    EXPECT_EQ(collation.size(), 9);
    EXPECT_TRUE(boost::algorithm::equal(collation.begin(), collation.end(), ces, ces + 9))
        << "from:     " << ce_dumper(cps)
        << "expected: " << ce_dumper(ces)
        << "got:      " << ce_dumper(collation);
}

TEST(collation, non_ignorable_110_221)
{
    // 1D423 0061;	
    // (𝐣) MATHEMATICAL BOLD SMALL J	[1DB2 1CAD | 0020 0020 | 0005 0002 |]

    uint32_t cps[2] = { 0x1D423, 0x0061 };
    uint32_t const ces[9] = { 0x1DB2, 0x1CAD, 0x0000, 0x0020, 0x0020, 0x0000, 0x0005, 0x0002, 0x0000 };

    auto collation = collate_for_tests(
        cps, cps + 2, boost::text::variable_weighting::non_ignorable);

    EXPECT_EQ(collation.size(), 9);
    EXPECT_TRUE(boost::algorithm::equal(collation.begin(), collation.end(), ces, ces + 9))
        << "from:     " << ce_dumper(cps)
        << "expected: " << ce_dumper(ces)
        << "got:      " << ce_dumper(collation);
}

TEST(collation, non_ignorable_110_222)
{
    // 1D457 0061;	
    // (𝑗) MATHEMATICAL ITALIC SMALL J	[1DB2 1CAD | 0020 0020 | 0005 0002 |]

    uint32_t cps[2] = { 0x1D457, 0x0061 };
    uint32_t const ces[9] = { 0x1DB2, 0x1CAD, 0x0000, 0x0020, 0x0020, 0x0000, 0x0005, 0x0002, 0x0000 };

    auto collation = collate_for_tests(
        cps, cps + 2, boost::text::variable_weighting::non_ignorable);

    EXPECT_EQ(collation.size(), 9);
    EXPECT_TRUE(boost::algorithm::equal(collation.begin(), collation.end(), ces, ces + 9))
        << "from:     " << ce_dumper(cps)
        << "expected: " << ce_dumper(ces)
        << "got:      " << ce_dumper(collation);
}

TEST(collation, non_ignorable_110_223)
{
    // 1D48B 0061;	
    // (𝒋) MATHEMATICAL BOLD ITALIC SMALL J	[1DB2 1CAD | 0020 0020 | 0005 0002 |]

    uint32_t cps[2] = { 0x1D48B, 0x0061 };
    uint32_t const ces[9] = { 0x1DB2, 0x1CAD, 0x0000, 0x0020, 0x0020, 0x0000, 0x0005, 0x0002, 0x0000 };

    auto collation = collate_for_tests(
        cps, cps + 2, boost::text::variable_weighting::non_ignorable);

    EXPECT_EQ(collation.size(), 9);
    EXPECT_TRUE(boost::algorithm::equal(collation.begin(), collation.end(), ces, ces + 9))
        << "from:     " << ce_dumper(cps)
        << "expected: " << ce_dumper(ces)
        << "got:      " << ce_dumper(collation);
}

TEST(collation, non_ignorable_110_224)
{
    // 1D4BF 0061;	
    // (𝒿) MATHEMATICAL SCRIPT SMALL J	[1DB2 1CAD | 0020 0020 | 0005 0002 |]

    uint32_t cps[2] = { 0x1D4BF, 0x0061 };
    uint32_t const ces[9] = { 0x1DB2, 0x1CAD, 0x0000, 0x0020, 0x0020, 0x0000, 0x0005, 0x0002, 0x0000 };

    auto collation = collate_for_tests(
        cps, cps + 2, boost::text::variable_weighting::non_ignorable);

    EXPECT_EQ(collation.size(), 9);
    EXPECT_TRUE(boost::algorithm::equal(collation.begin(), collation.end(), ces, ces + 9))
        << "from:     " << ce_dumper(cps)
        << "expected: " << ce_dumper(ces)
        << "got:      " << ce_dumper(collation);
}

TEST(collation, non_ignorable_110_225)
{
    // 1D4F3 0061;	
    // (𝓳) MATHEMATICAL BOLD SCRIPT SMALL J	[1DB2 1CAD | 0020 0020 | 0005 0002 |]

    uint32_t cps[2] = { 0x1D4F3, 0x0061 };
    uint32_t const ces[9] = { 0x1DB2, 0x1CAD, 0x0000, 0x0020, 0x0020, 0x0000, 0x0005, 0x0002, 0x0000 };

    auto collation = collate_for_tests(
        cps, cps + 2, boost::text::variable_weighting::non_ignorable);

    EXPECT_EQ(collation.size(), 9);
    EXPECT_TRUE(boost::algorithm::equal(collation.begin(), collation.end(), ces, ces + 9))
        << "from:     " << ce_dumper(cps)
        << "expected: " << ce_dumper(ces)
        << "got:      " << ce_dumper(collation);
}

TEST(collation, non_ignorable_110_226)
{
    // 1D527 0061;	
    // (𝔧) MATHEMATICAL FRAKTUR SMALL J	[1DB2 1CAD | 0020 0020 | 0005 0002 |]

    uint32_t cps[2] = { 0x1D527, 0x0061 };
    uint32_t const ces[9] = { 0x1DB2, 0x1CAD, 0x0000, 0x0020, 0x0020, 0x0000, 0x0005, 0x0002, 0x0000 };

    auto collation = collate_for_tests(
        cps, cps + 2, boost::text::variable_weighting::non_ignorable);

    EXPECT_EQ(collation.size(), 9);
    EXPECT_TRUE(boost::algorithm::equal(collation.begin(), collation.end(), ces, ces + 9))
        << "from:     " << ce_dumper(cps)
        << "expected: " << ce_dumper(ces)
        << "got:      " << ce_dumper(collation);
}

TEST(collation, non_ignorable_110_227)
{
    // 1D55B 0061;	
    // (𝕛) MATHEMATICAL DOUBLE-STRUCK SMALL J	[1DB2 1CAD | 0020 0020 | 0005 0002 |]

    uint32_t cps[2] = { 0x1D55B, 0x0061 };
    uint32_t const ces[9] = { 0x1DB2, 0x1CAD, 0x0000, 0x0020, 0x0020, 0x0000, 0x0005, 0x0002, 0x0000 };

    auto collation = collate_for_tests(
        cps, cps + 2, boost::text::variable_weighting::non_ignorable);

    EXPECT_EQ(collation.size(), 9);
    EXPECT_TRUE(boost::algorithm::equal(collation.begin(), collation.end(), ces, ces + 9))
        << "from:     " << ce_dumper(cps)
        << "expected: " << ce_dumper(ces)
        << "got:      " << ce_dumper(collation);
}

TEST(collation, non_ignorable_110_228)
{
    // 1D58F 0061;	
    // (𝖏) MATHEMATICAL BOLD FRAKTUR SMALL J	[1DB2 1CAD | 0020 0020 | 0005 0002 |]

    uint32_t cps[2] = { 0x1D58F, 0x0061 };
    uint32_t const ces[9] = { 0x1DB2, 0x1CAD, 0x0000, 0x0020, 0x0020, 0x0000, 0x0005, 0x0002, 0x0000 };

    auto collation = collate_for_tests(
        cps, cps + 2, boost::text::variable_weighting::non_ignorable);

    EXPECT_EQ(collation.size(), 9);
    EXPECT_TRUE(boost::algorithm::equal(collation.begin(), collation.end(), ces, ces + 9))
        << "from:     " << ce_dumper(cps)
        << "expected: " << ce_dumper(ces)
        << "got:      " << ce_dumper(collation);
}

TEST(collation, non_ignorable_110_229)
{
    // 1D5C3 0061;	
    // (𝗃) MATHEMATICAL SANS-SERIF SMALL J	[1DB2 1CAD | 0020 0020 | 0005 0002 |]

    uint32_t cps[2] = { 0x1D5C3, 0x0061 };
    uint32_t const ces[9] = { 0x1DB2, 0x1CAD, 0x0000, 0x0020, 0x0020, 0x0000, 0x0005, 0x0002, 0x0000 };

    auto collation = collate_for_tests(
        cps, cps + 2, boost::text::variable_weighting::non_ignorable);

    EXPECT_EQ(collation.size(), 9);
    EXPECT_TRUE(boost::algorithm::equal(collation.begin(), collation.end(), ces, ces + 9))
        << "from:     " << ce_dumper(cps)
        << "expected: " << ce_dumper(ces)
        << "got:      " << ce_dumper(collation);
}

TEST(collation, non_ignorable_110_230)
{
    // 1D5F7 0061;	
    // (𝗷) MATHEMATICAL SANS-SERIF BOLD SMALL J	[1DB2 1CAD | 0020 0020 | 0005 0002 |]

    uint32_t cps[2] = { 0x1D5F7, 0x0061 };
    uint32_t const ces[9] = { 0x1DB2, 0x1CAD, 0x0000, 0x0020, 0x0020, 0x0000, 0x0005, 0x0002, 0x0000 };

    auto collation = collate_for_tests(
        cps, cps + 2, boost::text::variable_weighting::non_ignorable);

    EXPECT_EQ(collation.size(), 9);
    EXPECT_TRUE(boost::algorithm::equal(collation.begin(), collation.end(), ces, ces + 9))
        << "from:     " << ce_dumper(cps)
        << "expected: " << ce_dumper(ces)
        << "got:      " << ce_dumper(collation);
}

TEST(collation, non_ignorable_110_231)
{
    // 1D62B 0061;	
    // (𝘫) MATHEMATICAL SANS-SERIF ITALIC SMALL J	[1DB2 1CAD | 0020 0020 | 0005 0002 |]

    uint32_t cps[2] = { 0x1D62B, 0x0061 };
    uint32_t const ces[9] = { 0x1DB2, 0x1CAD, 0x0000, 0x0020, 0x0020, 0x0000, 0x0005, 0x0002, 0x0000 };

    auto collation = collate_for_tests(
        cps, cps + 2, boost::text::variable_weighting::non_ignorable);

    EXPECT_EQ(collation.size(), 9);
    EXPECT_TRUE(boost::algorithm::equal(collation.begin(), collation.end(), ces, ces + 9))
        << "from:     " << ce_dumper(cps)
        << "expected: " << ce_dumper(ces)
        << "got:      " << ce_dumper(collation);
}

TEST(collation, non_ignorable_110_232)
{
    // 1D65F 0061;	
    // (𝙟) MATHEMATICAL SANS-SERIF BOLD ITALIC SMALL J	[1DB2 1CAD | 0020 0020 | 0005 0002 |]

    uint32_t cps[2] = { 0x1D65F, 0x0061 };
    uint32_t const ces[9] = { 0x1DB2, 0x1CAD, 0x0000, 0x0020, 0x0020, 0x0000, 0x0005, 0x0002, 0x0000 };

    auto collation = collate_for_tests(
        cps, cps + 2, boost::text::variable_weighting::non_ignorable);

    EXPECT_EQ(collation.size(), 9);
    EXPECT_TRUE(boost::algorithm::equal(collation.begin(), collation.end(), ces, ces + 9))
        << "from:     " << ce_dumper(cps)
        << "expected: " << ce_dumper(ces)
        << "got:      " << ce_dumper(collation);
}

TEST(collation, non_ignorable_110_233)
{
    // 1D693 0061;	
    // (𝚓) MATHEMATICAL MONOSPACE SMALL J	[1DB2 1CAD | 0020 0020 | 0005 0002 |]

    uint32_t cps[2] = { 0x1D693, 0x0061 };
    uint32_t const ces[9] = { 0x1DB2, 0x1CAD, 0x0000, 0x0020, 0x0020, 0x0000, 0x0005, 0x0002, 0x0000 };

    auto collation = collate_for_tests(
        cps, cps + 2, boost::text::variable_weighting::non_ignorable);

    EXPECT_EQ(collation.size(), 9);
    EXPECT_TRUE(boost::algorithm::equal(collation.begin(), collation.end(), ces, ces + 9))
        << "from:     " << ce_dumper(cps)
        << "expected: " << ce_dumper(ces)
        << "got:      " << ce_dumper(collation);
}

TEST(collation, non_ignorable_110_234)
{
    // 2149 0041;	
    // (ⅉ) DOUBLE-STRUCK ITALIC SMALL J	[1DB2 1CAD | 0020 0020 | 0005 0008 |]

    uint32_t cps[2] = { 0x2149, 0x0041 };
    uint32_t const ces[9] = { 0x1DB2, 0x1CAD, 0x0000, 0x0020, 0x0020, 0x0000, 0x0005, 0x0008, 0x0000 };

    auto collation = collate_for_tests(
        cps, cps + 2, boost::text::variable_weighting::non_ignorable);

    EXPECT_EQ(collation.size(), 9);
    EXPECT_TRUE(boost::algorithm::equal(collation.begin(), collation.end(), ces, ces + 9))
        << "from:     " << ce_dumper(cps)
        << "expected: " << ce_dumper(ces)
        << "got:      " << ce_dumper(collation);
}

TEST(collation, non_ignorable_110_235)
{
    // 1D423 0041;	
    // (𝐣) MATHEMATICAL BOLD SMALL J	[1DB2 1CAD | 0020 0020 | 0005 0008 |]

    uint32_t cps[2] = { 0x1D423, 0x0041 };
    uint32_t const ces[9] = { 0x1DB2, 0x1CAD, 0x0000, 0x0020, 0x0020, 0x0000, 0x0005, 0x0008, 0x0000 };

    auto collation = collate_for_tests(
        cps, cps + 2, boost::text::variable_weighting::non_ignorable);

    EXPECT_EQ(collation.size(), 9);
    EXPECT_TRUE(boost::algorithm::equal(collation.begin(), collation.end(), ces, ces + 9))
        << "from:     " << ce_dumper(cps)
        << "expected: " << ce_dumper(ces)
        << "got:      " << ce_dumper(collation);
}

TEST(collation, non_ignorable_110_236)
{
    // 1D457 0041;	
    // (𝑗) MATHEMATICAL ITALIC SMALL J	[1DB2 1CAD | 0020 0020 | 0005 0008 |]

    uint32_t cps[2] = { 0x1D457, 0x0041 };
    uint32_t const ces[9] = { 0x1DB2, 0x1CAD, 0x0000, 0x0020, 0x0020, 0x0000, 0x0005, 0x0008, 0x0000 };

    auto collation = collate_for_tests(
        cps, cps + 2, boost::text::variable_weighting::non_ignorable);

    EXPECT_EQ(collation.size(), 9);
    EXPECT_TRUE(boost::algorithm::equal(collation.begin(), collation.end(), ces, ces + 9))
        << "from:     " << ce_dumper(cps)
        << "expected: " << ce_dumper(ces)
        << "got:      " << ce_dumper(collation);
}

TEST(collation, non_ignorable_110_237)
{
    // 1D48B 0041;	
    // (𝒋) MATHEMATICAL BOLD ITALIC SMALL J	[1DB2 1CAD | 0020 0020 | 0005 0008 |]

    uint32_t cps[2] = { 0x1D48B, 0x0041 };
    uint32_t const ces[9] = { 0x1DB2, 0x1CAD, 0x0000, 0x0020, 0x0020, 0x0000, 0x0005, 0x0008, 0x0000 };

    auto collation = collate_for_tests(
        cps, cps + 2, boost::text::variable_weighting::non_ignorable);

    EXPECT_EQ(collation.size(), 9);
    EXPECT_TRUE(boost::algorithm::equal(collation.begin(), collation.end(), ces, ces + 9))
        << "from:     " << ce_dumper(cps)
        << "expected: " << ce_dumper(ces)
        << "got:      " << ce_dumper(collation);
}

TEST(collation, non_ignorable_110_238)
{
    // 1D4BF 0041;	
    // (𝒿) MATHEMATICAL SCRIPT SMALL J	[1DB2 1CAD | 0020 0020 | 0005 0008 |]

    uint32_t cps[2] = { 0x1D4BF, 0x0041 };
    uint32_t const ces[9] = { 0x1DB2, 0x1CAD, 0x0000, 0x0020, 0x0020, 0x0000, 0x0005, 0x0008, 0x0000 };

    auto collation = collate_for_tests(
        cps, cps + 2, boost::text::variable_weighting::non_ignorable);

    EXPECT_EQ(collation.size(), 9);
    EXPECT_TRUE(boost::algorithm::equal(collation.begin(), collation.end(), ces, ces + 9))
        << "from:     " << ce_dumper(cps)
        << "expected: " << ce_dumper(ces)
        << "got:      " << ce_dumper(collation);
}

TEST(collation, non_ignorable_110_239)
{
    // 1D4F3 0041;	
    // (𝓳) MATHEMATICAL BOLD SCRIPT SMALL J	[1DB2 1CAD | 0020 0020 | 0005 0008 |]

    uint32_t cps[2] = { 0x1D4F3, 0x0041 };
    uint32_t const ces[9] = { 0x1DB2, 0x1CAD, 0x0000, 0x0020, 0x0020, 0x0000, 0x0005, 0x0008, 0x0000 };

    auto collation = collate_for_tests(
        cps, cps + 2, boost::text::variable_weighting::non_ignorable);

    EXPECT_EQ(collation.size(), 9);
    EXPECT_TRUE(boost::algorithm::equal(collation.begin(), collation.end(), ces, ces + 9))
        << "from:     " << ce_dumper(cps)
        << "expected: " << ce_dumper(ces)
        << "got:      " << ce_dumper(collation);
}

TEST(collation, non_ignorable_110_240)
{
    // 1D527 0041;	
    // (𝔧) MATHEMATICAL FRAKTUR SMALL J	[1DB2 1CAD | 0020 0020 | 0005 0008 |]

    uint32_t cps[2] = { 0x1D527, 0x0041 };
    uint32_t const ces[9] = { 0x1DB2, 0x1CAD, 0x0000, 0x0020, 0x0020, 0x0000, 0x0005, 0x0008, 0x0000 };

    auto collation = collate_for_tests(
        cps, cps + 2, boost::text::variable_weighting::non_ignorable);

    EXPECT_EQ(collation.size(), 9);
    EXPECT_TRUE(boost::algorithm::equal(collation.begin(), collation.end(), ces, ces + 9))
        << "from:     " << ce_dumper(cps)
        << "expected: " << ce_dumper(ces)
        << "got:      " << ce_dumper(collation);
}

TEST(collation, non_ignorable_110_241)
{
    // 1D55B 0041;	
    // (𝕛) MATHEMATICAL DOUBLE-STRUCK SMALL J	[1DB2 1CAD | 0020 0020 | 0005 0008 |]

    uint32_t cps[2] = { 0x1D55B, 0x0041 };
    uint32_t const ces[9] = { 0x1DB2, 0x1CAD, 0x0000, 0x0020, 0x0020, 0x0000, 0x0005, 0x0008, 0x0000 };

    auto collation = collate_for_tests(
        cps, cps + 2, boost::text::variable_weighting::non_ignorable);

    EXPECT_EQ(collation.size(), 9);
    EXPECT_TRUE(boost::algorithm::equal(collation.begin(), collation.end(), ces, ces + 9))
        << "from:     " << ce_dumper(cps)
        << "expected: " << ce_dumper(ces)
        << "got:      " << ce_dumper(collation);
}

TEST(collation, non_ignorable_110_242)
{
    // 1D58F 0041;	
    // (𝖏) MATHEMATICAL BOLD FRAKTUR SMALL J	[1DB2 1CAD | 0020 0020 | 0005 0008 |]

    uint32_t cps[2] = { 0x1D58F, 0x0041 };
    uint32_t const ces[9] = { 0x1DB2, 0x1CAD, 0x0000, 0x0020, 0x0020, 0x0000, 0x0005, 0x0008, 0x0000 };

    auto collation = collate_for_tests(
        cps, cps + 2, boost::text::variable_weighting::non_ignorable);

    EXPECT_EQ(collation.size(), 9);
    EXPECT_TRUE(boost::algorithm::equal(collation.begin(), collation.end(), ces, ces + 9))
        << "from:     " << ce_dumper(cps)
        << "expected: " << ce_dumper(ces)
        << "got:      " << ce_dumper(collation);
}

TEST(collation, non_ignorable_110_243)
{
    // 1D5C3 0041;	
    // (𝗃) MATHEMATICAL SANS-SERIF SMALL J	[1DB2 1CAD | 0020 0020 | 0005 0008 |]

    uint32_t cps[2] = { 0x1D5C3, 0x0041 };
    uint32_t const ces[9] = { 0x1DB2, 0x1CAD, 0x0000, 0x0020, 0x0020, 0x0000, 0x0005, 0x0008, 0x0000 };

    auto collation = collate_for_tests(
        cps, cps + 2, boost::text::variable_weighting::non_ignorable);

    EXPECT_EQ(collation.size(), 9);
    EXPECT_TRUE(boost::algorithm::equal(collation.begin(), collation.end(), ces, ces + 9))
        << "from:     " << ce_dumper(cps)
        << "expected: " << ce_dumper(ces)
        << "got:      " << ce_dumper(collation);
}

TEST(collation, non_ignorable_110_244)
{
    // 1D5F7 0041;	
    // (𝗷) MATHEMATICAL SANS-SERIF BOLD SMALL J	[1DB2 1CAD | 0020 0020 | 0005 0008 |]

    uint32_t cps[2] = { 0x1D5F7, 0x0041 };
    uint32_t const ces[9] = { 0x1DB2, 0x1CAD, 0x0000, 0x0020, 0x0020, 0x0000, 0x0005, 0x0008, 0x0000 };

    auto collation = collate_for_tests(
        cps, cps + 2, boost::text::variable_weighting::non_ignorable);

    EXPECT_EQ(collation.size(), 9);
    EXPECT_TRUE(boost::algorithm::equal(collation.begin(), collation.end(), ces, ces + 9))
        << "from:     " << ce_dumper(cps)
        << "expected: " << ce_dumper(ces)
        << "got:      " << ce_dumper(collation);
}

TEST(collation, non_ignorable_110_245)
{
    // 1D62B 0041;	
    // (𝘫) MATHEMATICAL SANS-SERIF ITALIC SMALL J	[1DB2 1CAD | 0020 0020 | 0005 0008 |]

    uint32_t cps[2] = { 0x1D62B, 0x0041 };
    uint32_t const ces[9] = { 0x1DB2, 0x1CAD, 0x0000, 0x0020, 0x0020, 0x0000, 0x0005, 0x0008, 0x0000 };

    auto collation = collate_for_tests(
        cps, cps + 2, boost::text::variable_weighting::non_ignorable);

    EXPECT_EQ(collation.size(), 9);
    EXPECT_TRUE(boost::algorithm::equal(collation.begin(), collation.end(), ces, ces + 9))
        << "from:     " << ce_dumper(cps)
        << "expected: " << ce_dumper(ces)
        << "got:      " << ce_dumper(collation);
}

TEST(collation, non_ignorable_110_246)
{
    // 1D65F 0041;	
    // (𝙟) MATHEMATICAL SANS-SERIF BOLD ITALIC SMALL J	[1DB2 1CAD | 0020 0020 | 0005 0008 |]

    uint32_t cps[2] = { 0x1D65F, 0x0041 };
    uint32_t const ces[9] = { 0x1DB2, 0x1CAD, 0x0000, 0x0020, 0x0020, 0x0000, 0x0005, 0x0008, 0x0000 };

    auto collation = collate_for_tests(
        cps, cps + 2, boost::text::variable_weighting::non_ignorable);

    EXPECT_EQ(collation.size(), 9);
    EXPECT_TRUE(boost::algorithm::equal(collation.begin(), collation.end(), ces, ces + 9))
        << "from:     " << ce_dumper(cps)
        << "expected: " << ce_dumper(ces)
        << "got:      " << ce_dumper(collation);
}

TEST(collation, non_ignorable_110_247)
{
    // 1D693 0041;	
    // (𝚓) MATHEMATICAL MONOSPACE SMALL J	[1DB2 1CAD | 0020 0020 | 0005 0008 |]

    uint32_t cps[2] = { 0x1D693, 0x0041 };
    uint32_t const ces[9] = { 0x1DB2, 0x1CAD, 0x0000, 0x0020, 0x0020, 0x0000, 0x0005, 0x0008, 0x0000 };

    auto collation = collate_for_tests(
        cps, cps + 2, boost::text::variable_weighting::non_ignorable);

    EXPECT_EQ(collation.size(), 9);
    EXPECT_TRUE(boost::algorithm::equal(collation.begin(), collation.end(), ces, ces + 9))
        << "from:     " << ce_dumper(cps)
        << "expected: " << ce_dumper(ces)
        << "got:      " << ce_dumper(collation);
}

TEST(collation, non_ignorable_110_248)
{
    // 24D9 0061;	
    // (ⓙ) CIRCLED LATIN SMALL LETTER J	[1DB2 1CAD | 0020 0020 | 0006 0002 |]

    uint32_t cps[2] = { 0x24D9, 0x0061 };
    uint32_t const ces[9] = { 0x1DB2, 0x1CAD, 0x0000, 0x0020, 0x0020, 0x0000, 0x0006, 0x0002, 0x0000 };

    auto collation = collate_for_tests(
        cps, cps + 2, boost::text::variable_weighting::non_ignorable);

    EXPECT_EQ(collation.size(), 9);
    EXPECT_TRUE(boost::algorithm::equal(collation.begin(), collation.end(), ces, ces + 9))
        << "from:     " << ce_dumper(cps)
        << "expected: " << ce_dumper(ces)
        << "got:      " << ce_dumper(collation);
}

TEST(collation, non_ignorable_110_249)
{
    // 24D9 0041;	
    // (ⓙ) CIRCLED LATIN SMALL LETTER J	[1DB2 1CAD | 0020 0020 | 0006 0008 |]

    uint32_t cps[2] = { 0x24D9, 0x0041 };
    uint32_t const ces[9] = { 0x1DB2, 0x1CAD, 0x0000, 0x0020, 0x0020, 0x0000, 0x0006, 0x0008, 0x0000 };

    auto collation = collate_for_tests(
        cps, cps + 2, boost::text::variable_weighting::non_ignorable);

    EXPECT_EQ(collation.size(), 9);
    EXPECT_TRUE(boost::algorithm::equal(collation.begin(), collation.end(), ces, ces + 9))
        << "from:     " << ce_dumper(cps)
        << "expected: " << ce_dumper(ces)
        << "got:      " << ce_dumper(collation);
}

TEST(collation, non_ignorable_110_250)
{
    // 004A 0061;	
    // (J) LATIN CAPITAL LETTER J	[1DB2 1CAD | 0020 0020 | 0008 0002 |]

    uint32_t cps[2] = { 0x004A, 0x0061 };
    uint32_t const ces[9] = { 0x1DB2, 0x1CAD, 0x0000, 0x0020, 0x0020, 0x0000, 0x0008, 0x0002, 0x0000 };

    auto collation = collate_for_tests(
        cps, cps + 2, boost::text::variable_weighting::non_ignorable);

    EXPECT_EQ(collation.size(), 9);
    EXPECT_TRUE(boost::algorithm::equal(collation.begin(), collation.end(), ces, ces + 9))
        << "from:     " << ce_dumper(cps)
        << "expected: " << ce_dumper(ces)
        << "got:      " << ce_dumper(collation);
}

TEST(collation, non_ignorable_110_251)
{
    // 004A 0041;	
    // (J) LATIN CAPITAL LETTER J	[1DB2 1CAD | 0020 0020 | 0008 0008 |]

    uint32_t cps[2] = { 0x004A, 0x0041 };
    uint32_t const ces[9] = { 0x1DB2, 0x1CAD, 0x0000, 0x0020, 0x0020, 0x0000, 0x0008, 0x0008, 0x0000 };

    auto collation = collate_for_tests(
        cps, cps + 2, boost::text::variable_weighting::non_ignorable);

    EXPECT_EQ(collation.size(), 9);
    EXPECT_TRUE(boost::algorithm::equal(collation.begin(), collation.end(), ces, ces + 9))
        << "from:     " << ce_dumper(cps)
        << "expected: " << ce_dumper(ces)
        << "got:      " << ce_dumper(collation);
}

TEST(collation, non_ignorable_110_252)
{
    // FF2A 0061;	
    // (Ｊ) FULLWIDTH LATIN CAPITAL LETTER J	[1DB2 1CAD | 0020 0020 | 0009 0002 |]

    uint32_t cps[2] = { 0xFF2A, 0x0061 };
    uint32_t const ces[9] = { 0x1DB2, 0x1CAD, 0x0000, 0x0020, 0x0020, 0x0000, 0x0009, 0x0002, 0x0000 };

    auto collation = collate_for_tests(
        cps, cps + 2, boost::text::variable_weighting::non_ignorable);

    EXPECT_EQ(collation.size(), 9);
    EXPECT_TRUE(boost::algorithm::equal(collation.begin(), collation.end(), ces, ces + 9))
        << "from:     " << ce_dumper(cps)
        << "expected: " << ce_dumper(ces)
        << "got:      " << ce_dumper(collation);
}

TEST(collation, non_ignorable_110_253)
{
    // FF2A 0041;	
    // (Ｊ) FULLWIDTH LATIN CAPITAL LETTER J	[1DB2 1CAD | 0020 0020 | 0009 0008 |]

    uint32_t cps[2] = { 0xFF2A, 0x0041 };
    uint32_t const ces[9] = { 0x1DB2, 0x1CAD, 0x0000, 0x0020, 0x0020, 0x0000, 0x0009, 0x0008, 0x0000 };

    auto collation = collate_for_tests(
        cps, cps + 2, boost::text::variable_weighting::non_ignorable);

    EXPECT_EQ(collation.size(), 9);
    EXPECT_TRUE(boost::algorithm::equal(collation.begin(), collation.end(), ces, ces + 9))
        << "from:     " << ce_dumper(cps)
        << "expected: " << ce_dumper(ces)
        << "got:      " << ce_dumper(collation);
}

TEST(collation, non_ignorable_110_254)
{
    // 1D409 0061;	
    // (𝐉) MATHEMATICAL BOLD CAPITAL J	[1DB2 1CAD | 0020 0020 | 000B 0002 |]

    uint32_t cps[2] = { 0x1D409, 0x0061 };
    uint32_t const ces[9] = { 0x1DB2, 0x1CAD, 0x0000, 0x0020, 0x0020, 0x0000, 0x000B, 0x0002, 0x0000 };

    auto collation = collate_for_tests(
        cps, cps + 2, boost::text::variable_weighting::non_ignorable);

    EXPECT_EQ(collation.size(), 9);
    EXPECT_TRUE(boost::algorithm::equal(collation.begin(), collation.end(), ces, ces + 9))
        << "from:     " << ce_dumper(cps)
        << "expected: " << ce_dumper(ces)
        << "got:      " << ce_dumper(collation);
}

TEST(collation, non_ignorable_110_255)
{
    // 1D43D 0061;	
    // (𝐽) MATHEMATICAL ITALIC CAPITAL J	[1DB2 1CAD | 0020 0020 | 000B 0002 |]

    uint32_t cps[2] = { 0x1D43D, 0x0061 };
    uint32_t const ces[9] = { 0x1DB2, 0x1CAD, 0x0000, 0x0020, 0x0020, 0x0000, 0x000B, 0x0002, 0x0000 };

    auto collation = collate_for_tests(
        cps, cps + 2, boost::text::variable_weighting::non_ignorable);

    EXPECT_EQ(collation.size(), 9);
    EXPECT_TRUE(boost::algorithm::equal(collation.begin(), collation.end(), ces, ces + 9))
        << "from:     " << ce_dumper(cps)
        << "expected: " << ce_dumper(ces)
        << "got:      " << ce_dumper(collation);
}

TEST(collation, non_ignorable_110_256)
{
    // 1D471 0061;	
    // (𝑱) MATHEMATICAL BOLD ITALIC CAPITAL J	[1DB2 1CAD | 0020 0020 | 000B 0002 |]

    uint32_t cps[2] = { 0x1D471, 0x0061 };
    uint32_t const ces[9] = { 0x1DB2, 0x1CAD, 0x0000, 0x0020, 0x0020, 0x0000, 0x000B, 0x0002, 0x0000 };

    auto collation = collate_for_tests(
        cps, cps + 2, boost::text::variable_weighting::non_ignorable);

    EXPECT_EQ(collation.size(), 9);
    EXPECT_TRUE(boost::algorithm::equal(collation.begin(), collation.end(), ces, ces + 9))
        << "from:     " << ce_dumper(cps)
        << "expected: " << ce_dumper(ces)
        << "got:      " << ce_dumper(collation);
}

TEST(collation, non_ignorable_110_257)
{
    // 1D4A5 0061;	
    // (𝒥) MATHEMATICAL SCRIPT CAPITAL J	[1DB2 1CAD | 0020 0020 | 000B 0002 |]

    uint32_t cps[2] = { 0x1D4A5, 0x0061 };
    uint32_t const ces[9] = { 0x1DB2, 0x1CAD, 0x0000, 0x0020, 0x0020, 0x0000, 0x000B, 0x0002, 0x0000 };

    auto collation = collate_for_tests(
        cps, cps + 2, boost::text::variable_weighting::non_ignorable);

    EXPECT_EQ(collation.size(), 9);
    EXPECT_TRUE(boost::algorithm::equal(collation.begin(), collation.end(), ces, ces + 9))
        << "from:     " << ce_dumper(cps)
        << "expected: " << ce_dumper(ces)
        << "got:      " << ce_dumper(collation);
}

TEST(collation, non_ignorable_110_258)
{
    // 1D4D9 0061;	
    // (𝓙) MATHEMATICAL BOLD SCRIPT CAPITAL J	[1DB2 1CAD | 0020 0020 | 000B 0002 |]

    uint32_t cps[2] = { 0x1D4D9, 0x0061 };
    uint32_t const ces[9] = { 0x1DB2, 0x1CAD, 0x0000, 0x0020, 0x0020, 0x0000, 0x000B, 0x0002, 0x0000 };

    auto collation = collate_for_tests(
        cps, cps + 2, boost::text::variable_weighting::non_ignorable);

    EXPECT_EQ(collation.size(), 9);
    EXPECT_TRUE(boost::algorithm::equal(collation.begin(), collation.end(), ces, ces + 9))
        << "from:     " << ce_dumper(cps)
        << "expected: " << ce_dumper(ces)
        << "got:      " << ce_dumper(collation);
}

TEST(collation, non_ignorable_110_259)
{
    // 1D50D 0061;	
    // (𝔍) MATHEMATICAL FRAKTUR CAPITAL J	[1DB2 1CAD | 0020 0020 | 000B 0002 |]

    uint32_t cps[2] = { 0x1D50D, 0x0061 };
    uint32_t const ces[9] = { 0x1DB2, 0x1CAD, 0x0000, 0x0020, 0x0020, 0x0000, 0x000B, 0x0002, 0x0000 };

    auto collation = collate_for_tests(
        cps, cps + 2, boost::text::variable_weighting::non_ignorable);

    EXPECT_EQ(collation.size(), 9);
    EXPECT_TRUE(boost::algorithm::equal(collation.begin(), collation.end(), ces, ces + 9))
        << "from:     " << ce_dumper(cps)
        << "expected: " << ce_dumper(ces)
        << "got:      " << ce_dumper(collation);
}

TEST(collation, non_ignorable_110_260)
{
    // 1D541 0061;	
    // (𝕁) MATHEMATICAL DOUBLE-STRUCK CAPITAL J	[1DB2 1CAD | 0020 0020 | 000B 0002 |]

    uint32_t cps[2] = { 0x1D541, 0x0061 };
    uint32_t const ces[9] = { 0x1DB2, 0x1CAD, 0x0000, 0x0020, 0x0020, 0x0000, 0x000B, 0x0002, 0x0000 };

    auto collation = collate_for_tests(
        cps, cps + 2, boost::text::variable_weighting::non_ignorable);

    EXPECT_EQ(collation.size(), 9);
    EXPECT_TRUE(boost::algorithm::equal(collation.begin(), collation.end(), ces, ces + 9))
        << "from:     " << ce_dumper(cps)
        << "expected: " << ce_dumper(ces)
        << "got:      " << ce_dumper(collation);
}

TEST(collation, non_ignorable_110_261)
{
    // 1D575 0061;	
    // (𝕵) MATHEMATICAL BOLD FRAKTUR CAPITAL J	[1DB2 1CAD | 0020 0020 | 000B 0002 |]

    uint32_t cps[2] = { 0x1D575, 0x0061 };
    uint32_t const ces[9] = { 0x1DB2, 0x1CAD, 0x0000, 0x0020, 0x0020, 0x0000, 0x000B, 0x0002, 0x0000 };

    auto collation = collate_for_tests(
        cps, cps + 2, boost::text::variable_weighting::non_ignorable);

    EXPECT_EQ(collation.size(), 9);
    EXPECT_TRUE(boost::algorithm::equal(collation.begin(), collation.end(), ces, ces + 9))
        << "from:     " << ce_dumper(cps)
        << "expected: " << ce_dumper(ces)
        << "got:      " << ce_dumper(collation);
}

TEST(collation, non_ignorable_110_262)
{
    // 1D5A9 0061;	
    // (𝖩) MATHEMATICAL SANS-SERIF CAPITAL J	[1DB2 1CAD | 0020 0020 | 000B 0002 |]

    uint32_t cps[2] = { 0x1D5A9, 0x0061 };
    uint32_t const ces[9] = { 0x1DB2, 0x1CAD, 0x0000, 0x0020, 0x0020, 0x0000, 0x000B, 0x0002, 0x0000 };

    auto collation = collate_for_tests(
        cps, cps + 2, boost::text::variable_weighting::non_ignorable);

    EXPECT_EQ(collation.size(), 9);
    EXPECT_TRUE(boost::algorithm::equal(collation.begin(), collation.end(), ces, ces + 9))
        << "from:     " << ce_dumper(cps)
        << "expected: " << ce_dumper(ces)
        << "got:      " << ce_dumper(collation);
}

TEST(collation, non_ignorable_110_263)
{
    // 1D5DD 0061;	
    // (𝗝) MATHEMATICAL SANS-SERIF BOLD CAPITAL J	[1DB2 1CAD | 0020 0020 | 000B 0002 |]

    uint32_t cps[2] = { 0x1D5DD, 0x0061 };
    uint32_t const ces[9] = { 0x1DB2, 0x1CAD, 0x0000, 0x0020, 0x0020, 0x0000, 0x000B, 0x0002, 0x0000 };

    auto collation = collate_for_tests(
        cps, cps + 2, boost::text::variable_weighting::non_ignorable);

    EXPECT_EQ(collation.size(), 9);
    EXPECT_TRUE(boost::algorithm::equal(collation.begin(), collation.end(), ces, ces + 9))
        << "from:     " << ce_dumper(cps)
        << "expected: " << ce_dumper(ces)
        << "got:      " << ce_dumper(collation);
}

TEST(collation, non_ignorable_110_264)
{
    // 1D611 0061;	
    // (𝘑) MATHEMATICAL SANS-SERIF ITALIC CAPITAL J	[1DB2 1CAD | 0020 0020 | 000B 0002 |]

    uint32_t cps[2] = { 0x1D611, 0x0061 };
    uint32_t const ces[9] = { 0x1DB2, 0x1CAD, 0x0000, 0x0020, 0x0020, 0x0000, 0x000B, 0x0002, 0x0000 };

    auto collation = collate_for_tests(
        cps, cps + 2, boost::text::variable_weighting::non_ignorable);

    EXPECT_EQ(collation.size(), 9);
    EXPECT_TRUE(boost::algorithm::equal(collation.begin(), collation.end(), ces, ces + 9))
        << "from:     " << ce_dumper(cps)
        << "expected: " << ce_dumper(ces)
        << "got:      " << ce_dumper(collation);
}

TEST(collation, non_ignorable_110_265)
{
    // 1D645 0061;	
    // (𝙅) MATHEMATICAL SANS-SERIF BOLD ITALIC CAPITAL J	[1DB2 1CAD | 0020 0020 | 000B 0002 |]

    uint32_t cps[2] = { 0x1D645, 0x0061 };
    uint32_t const ces[9] = { 0x1DB2, 0x1CAD, 0x0000, 0x0020, 0x0020, 0x0000, 0x000B, 0x0002, 0x0000 };

    auto collation = collate_for_tests(
        cps, cps + 2, boost::text::variable_weighting::non_ignorable);

    EXPECT_EQ(collation.size(), 9);
    EXPECT_TRUE(boost::algorithm::equal(collation.begin(), collation.end(), ces, ces + 9))
        << "from:     " << ce_dumper(cps)
        << "expected: " << ce_dumper(ces)
        << "got:      " << ce_dumper(collation);
}

TEST(collation, non_ignorable_110_266)
{
    // 1D679 0061;	
    // (𝙹) MATHEMATICAL MONOSPACE CAPITAL J	[1DB2 1CAD | 0020 0020 | 000B 0002 |]

    uint32_t cps[2] = { 0x1D679, 0x0061 };
    uint32_t const ces[9] = { 0x1DB2, 0x1CAD, 0x0000, 0x0020, 0x0020, 0x0000, 0x000B, 0x0002, 0x0000 };

    auto collation = collate_for_tests(
        cps, cps + 2, boost::text::variable_weighting::non_ignorable);

    EXPECT_EQ(collation.size(), 9);
    EXPECT_TRUE(boost::algorithm::equal(collation.begin(), collation.end(), ces, ces + 9))
        << "from:     " << ce_dumper(cps)
        << "expected: " << ce_dumper(ces)
        << "got:      " << ce_dumper(collation);
}

TEST(collation, non_ignorable_110_267)
{
    // 1D409 0041;	
    // (𝐉) MATHEMATICAL BOLD CAPITAL J	[1DB2 1CAD | 0020 0020 | 000B 0008 |]

    uint32_t cps[2] = { 0x1D409, 0x0041 };
    uint32_t const ces[9] = { 0x1DB2, 0x1CAD, 0x0000, 0x0020, 0x0020, 0x0000, 0x000B, 0x0008, 0x0000 };

    auto collation = collate_for_tests(
        cps, cps + 2, boost::text::variable_weighting::non_ignorable);

    EXPECT_EQ(collation.size(), 9);
    EXPECT_TRUE(boost::algorithm::equal(collation.begin(), collation.end(), ces, ces + 9))
        << "from:     " << ce_dumper(cps)
        << "expected: " << ce_dumper(ces)
        << "got:      " << ce_dumper(collation);
}

TEST(collation, non_ignorable_110_268)
{
    // 1D43D 0041;	
    // (𝐽) MATHEMATICAL ITALIC CAPITAL J	[1DB2 1CAD | 0020 0020 | 000B 0008 |]

    uint32_t cps[2] = { 0x1D43D, 0x0041 };
    uint32_t const ces[9] = { 0x1DB2, 0x1CAD, 0x0000, 0x0020, 0x0020, 0x0000, 0x000B, 0x0008, 0x0000 };

    auto collation = collate_for_tests(
        cps, cps + 2, boost::text::variable_weighting::non_ignorable);

    EXPECT_EQ(collation.size(), 9);
    EXPECT_TRUE(boost::algorithm::equal(collation.begin(), collation.end(), ces, ces + 9))
        << "from:     " << ce_dumper(cps)
        << "expected: " << ce_dumper(ces)
        << "got:      " << ce_dumper(collation);
}

TEST(collation, non_ignorable_110_269)
{
    // 1D471 0041;	
    // (𝑱) MATHEMATICAL BOLD ITALIC CAPITAL J	[1DB2 1CAD | 0020 0020 | 000B 0008 |]

    uint32_t cps[2] = { 0x1D471, 0x0041 };
    uint32_t const ces[9] = { 0x1DB2, 0x1CAD, 0x0000, 0x0020, 0x0020, 0x0000, 0x000B, 0x0008, 0x0000 };

    auto collation = collate_for_tests(
        cps, cps + 2, boost::text::variable_weighting::non_ignorable);

    EXPECT_EQ(collation.size(), 9);
    EXPECT_TRUE(boost::algorithm::equal(collation.begin(), collation.end(), ces, ces + 9))
        << "from:     " << ce_dumper(cps)
        << "expected: " << ce_dumper(ces)
        << "got:      " << ce_dumper(collation);
}

TEST(collation, non_ignorable_110_270)
{
    // 1D4A5 0041;	
    // (𝒥) MATHEMATICAL SCRIPT CAPITAL J	[1DB2 1CAD | 0020 0020 | 000B 0008 |]

    uint32_t cps[2] = { 0x1D4A5, 0x0041 };
    uint32_t const ces[9] = { 0x1DB2, 0x1CAD, 0x0000, 0x0020, 0x0020, 0x0000, 0x000B, 0x0008, 0x0000 };

    auto collation = collate_for_tests(
        cps, cps + 2, boost::text::variable_weighting::non_ignorable);

    EXPECT_EQ(collation.size(), 9);
    EXPECT_TRUE(boost::algorithm::equal(collation.begin(), collation.end(), ces, ces + 9))
        << "from:     " << ce_dumper(cps)
        << "expected: " << ce_dumper(ces)
        << "got:      " << ce_dumper(collation);
}

TEST(collation, non_ignorable_110_271)
{
    // 1D4D9 0041;	
    // (𝓙) MATHEMATICAL BOLD SCRIPT CAPITAL J	[1DB2 1CAD | 0020 0020 | 000B 0008 |]

    uint32_t cps[2] = { 0x1D4D9, 0x0041 };
    uint32_t const ces[9] = { 0x1DB2, 0x1CAD, 0x0000, 0x0020, 0x0020, 0x0000, 0x000B, 0x0008, 0x0000 };

    auto collation = collate_for_tests(
        cps, cps + 2, boost::text::variable_weighting::non_ignorable);

    EXPECT_EQ(collation.size(), 9);
    EXPECT_TRUE(boost::algorithm::equal(collation.begin(), collation.end(), ces, ces + 9))
        << "from:     " << ce_dumper(cps)
        << "expected: " << ce_dumper(ces)
        << "got:      " << ce_dumper(collation);
}

TEST(collation, non_ignorable_110_272)
{
    // 1D50D 0041;	
    // (𝔍) MATHEMATICAL FRAKTUR CAPITAL J	[1DB2 1CAD | 0020 0020 | 000B 0008 |]

    uint32_t cps[2] = { 0x1D50D, 0x0041 };
    uint32_t const ces[9] = { 0x1DB2, 0x1CAD, 0x0000, 0x0020, 0x0020, 0x0000, 0x000B, 0x0008, 0x0000 };

    auto collation = collate_for_tests(
        cps, cps + 2, boost::text::variable_weighting::non_ignorable);

    EXPECT_EQ(collation.size(), 9);
    EXPECT_TRUE(boost::algorithm::equal(collation.begin(), collation.end(), ces, ces + 9))
        << "from:     " << ce_dumper(cps)
        << "expected: " << ce_dumper(ces)
        << "got:      " << ce_dumper(collation);
}

TEST(collation, non_ignorable_110_273)
{
    // 1D541 0041;	
    // (𝕁) MATHEMATICAL DOUBLE-STRUCK CAPITAL J	[1DB2 1CAD | 0020 0020 | 000B 0008 |]

    uint32_t cps[2] = { 0x1D541, 0x0041 };
    uint32_t const ces[9] = { 0x1DB2, 0x1CAD, 0x0000, 0x0020, 0x0020, 0x0000, 0x000B, 0x0008, 0x0000 };

    auto collation = collate_for_tests(
        cps, cps + 2, boost::text::variable_weighting::non_ignorable);

    EXPECT_EQ(collation.size(), 9);
    EXPECT_TRUE(boost::algorithm::equal(collation.begin(), collation.end(), ces, ces + 9))
        << "from:     " << ce_dumper(cps)
        << "expected: " << ce_dumper(ces)
        << "got:      " << ce_dumper(collation);
}

TEST(collation, non_ignorable_110_274)
{
    // 1D575 0041;	
    // (𝕵) MATHEMATICAL BOLD FRAKTUR CAPITAL J	[1DB2 1CAD | 0020 0020 | 000B 0008 |]

    uint32_t cps[2] = { 0x1D575, 0x0041 };
    uint32_t const ces[9] = { 0x1DB2, 0x1CAD, 0x0000, 0x0020, 0x0020, 0x0000, 0x000B, 0x0008, 0x0000 };

    auto collation = collate_for_tests(
        cps, cps + 2, boost::text::variable_weighting::non_ignorable);

    EXPECT_EQ(collation.size(), 9);
    EXPECT_TRUE(boost::algorithm::equal(collation.begin(), collation.end(), ces, ces + 9))
        << "from:     " << ce_dumper(cps)
        << "expected: " << ce_dumper(ces)
        << "got:      " << ce_dumper(collation);
}

TEST(collation, non_ignorable_110_275)
{
    // 1D5A9 0041;	
    // (𝖩) MATHEMATICAL SANS-SERIF CAPITAL J	[1DB2 1CAD | 0020 0020 | 000B 0008 |]

    uint32_t cps[2] = { 0x1D5A9, 0x0041 };
    uint32_t const ces[9] = { 0x1DB2, 0x1CAD, 0x0000, 0x0020, 0x0020, 0x0000, 0x000B, 0x0008, 0x0000 };

    auto collation = collate_for_tests(
        cps, cps + 2, boost::text::variable_weighting::non_ignorable);

    EXPECT_EQ(collation.size(), 9);
    EXPECT_TRUE(boost::algorithm::equal(collation.begin(), collation.end(), ces, ces + 9))
        << "from:     " << ce_dumper(cps)
        << "expected: " << ce_dumper(ces)
        << "got:      " << ce_dumper(collation);
}

TEST(collation, non_ignorable_110_276)
{
    // 1D5DD 0041;	
    // (𝗝) MATHEMATICAL SANS-SERIF BOLD CAPITAL J	[1DB2 1CAD | 0020 0020 | 000B 0008 |]

    uint32_t cps[2] = { 0x1D5DD, 0x0041 };
    uint32_t const ces[9] = { 0x1DB2, 0x1CAD, 0x0000, 0x0020, 0x0020, 0x0000, 0x000B, 0x0008, 0x0000 };

    auto collation = collate_for_tests(
        cps, cps + 2, boost::text::variable_weighting::non_ignorable);

    EXPECT_EQ(collation.size(), 9);
    EXPECT_TRUE(boost::algorithm::equal(collation.begin(), collation.end(), ces, ces + 9))
        << "from:     " << ce_dumper(cps)
        << "expected: " << ce_dumper(ces)
        << "got:      " << ce_dumper(collation);
}

TEST(collation, non_ignorable_110_277)
{
    // 1D611 0041;	
    // (𝘑) MATHEMATICAL SANS-SERIF ITALIC CAPITAL J	[1DB2 1CAD | 0020 0020 | 000B 0008 |]

    uint32_t cps[2] = { 0x1D611, 0x0041 };
    uint32_t const ces[9] = { 0x1DB2, 0x1CAD, 0x0000, 0x0020, 0x0020, 0x0000, 0x000B, 0x0008, 0x0000 };

    auto collation = collate_for_tests(
        cps, cps + 2, boost::text::variable_weighting::non_ignorable);

    EXPECT_EQ(collation.size(), 9);
    EXPECT_TRUE(boost::algorithm::equal(collation.begin(), collation.end(), ces, ces + 9))
        << "from:     " << ce_dumper(cps)
        << "expected: " << ce_dumper(ces)
        << "got:      " << ce_dumper(collation);
}

TEST(collation, non_ignorable_110_278)
{
    // 1D645 0041;	
    // (𝙅) MATHEMATICAL SANS-SERIF BOLD ITALIC CAPITAL J	[1DB2 1CAD | 0020 0020 | 000B 0008 |]

    uint32_t cps[2] = { 0x1D645, 0x0041 };
    uint32_t const ces[9] = { 0x1DB2, 0x1CAD, 0x0000, 0x0020, 0x0020, 0x0000, 0x000B, 0x0008, 0x0000 };

    auto collation = collate_for_tests(
        cps, cps + 2, boost::text::variable_weighting::non_ignorable);

    EXPECT_EQ(collation.size(), 9);
    EXPECT_TRUE(boost::algorithm::equal(collation.begin(), collation.end(), ces, ces + 9))
        << "from:     " << ce_dumper(cps)
        << "expected: " << ce_dumper(ces)
        << "got:      " << ce_dumper(collation);
}

TEST(collation, non_ignorable_110_279)
{
    // 1D679 0041;	
    // (𝙹) MATHEMATICAL MONOSPACE CAPITAL J	[1DB2 1CAD | 0020 0020 | 000B 0008 |]

    uint32_t cps[2] = { 0x1D679, 0x0041 };
    uint32_t const ces[9] = { 0x1DB2, 0x1CAD, 0x0000, 0x0020, 0x0020, 0x0000, 0x000B, 0x0008, 0x0000 };

    auto collation = collate_for_tests(
        cps, cps + 2, boost::text::variable_weighting::non_ignorable);

    EXPECT_EQ(collation.size(), 9);
    EXPECT_TRUE(boost::algorithm::equal(collation.begin(), collation.end(), ces, ces + 9))
        << "from:     " << ce_dumper(cps)
        << "expected: " << ce_dumper(ces)
        << "got:      " << ce_dumper(collation);
}

TEST(collation, non_ignorable_110_280)
{
    // 24BF 0061;	
    // (Ⓙ) CIRCLED LATIN CAPITAL LETTER J	[1DB2 1CAD | 0020 0020 | 000C 0002 |]

    uint32_t cps[2] = { 0x24BF, 0x0061 };
    uint32_t const ces[9] = { 0x1DB2, 0x1CAD, 0x0000, 0x0020, 0x0020, 0x0000, 0x000C, 0x0002, 0x0000 };

    auto collation = collate_for_tests(
        cps, cps + 2, boost::text::variable_weighting::non_ignorable);

    EXPECT_EQ(collation.size(), 9);
    EXPECT_TRUE(boost::algorithm::equal(collation.begin(), collation.end(), ces, ces + 9))
        << "from:     " << ce_dumper(cps)
        << "expected: " << ce_dumper(ces)
        << "got:      " << ce_dumper(collation);
}

TEST(collation, non_ignorable_110_281)
{
    // 1F159 0061;	
    // (🅙) NEGATIVE CIRCLED LATIN CAPITAL LETTER J	[1DB2 1CAD | 0020 0020 | 000C 0002 |]

    uint32_t cps[2] = { 0x1F159, 0x0061 };
    uint32_t const ces[9] = { 0x1DB2, 0x1CAD, 0x0000, 0x0020, 0x0020, 0x0000, 0x000C, 0x0002, 0x0000 };

    auto collation = collate_for_tests(
        cps, cps + 2, boost::text::variable_weighting::non_ignorable);

    EXPECT_EQ(collation.size(), 9);
    EXPECT_TRUE(boost::algorithm::equal(collation.begin(), collation.end(), ces, ces + 9))
        << "from:     " << ce_dumper(cps)
        << "expected: " << ce_dumper(ces)
        << "got:      " << ce_dumper(collation);
}

TEST(collation, non_ignorable_110_282)
{
    // 24BF 0041;	
    // (Ⓙ) CIRCLED LATIN CAPITAL LETTER J	[1DB2 1CAD | 0020 0020 | 000C 0008 |]

    uint32_t cps[2] = { 0x24BF, 0x0041 };
    uint32_t const ces[9] = { 0x1DB2, 0x1CAD, 0x0000, 0x0020, 0x0020, 0x0000, 0x000C, 0x0008, 0x0000 };

    auto collation = collate_for_tests(
        cps, cps + 2, boost::text::variable_weighting::non_ignorable);

    EXPECT_EQ(collation.size(), 9);
    EXPECT_TRUE(boost::algorithm::equal(collation.begin(), collation.end(), ces, ces + 9))
        << "from:     " << ce_dumper(cps)
        << "expected: " << ce_dumper(ces)
        << "got:      " << ce_dumper(collation);
}

TEST(collation, non_ignorable_110_283)
{
    // 1F159 0041;	
    // (🅙) NEGATIVE CIRCLED LATIN CAPITAL LETTER J	[1DB2 1CAD | 0020 0020 | 000C 0008 |]

    uint32_t cps[2] = { 0x1F159, 0x0041 };
    uint32_t const ces[9] = { 0x1DB2, 0x1CAD, 0x0000, 0x0020, 0x0020, 0x0000, 0x000C, 0x0008, 0x0000 };

    auto collation = collate_for_tests(
        cps, cps + 2, boost::text::variable_weighting::non_ignorable);

    EXPECT_EQ(collation.size(), 9);
    EXPECT_TRUE(boost::algorithm::equal(collation.begin(), collation.end(), ces, ces + 9))
        << "from:     " << ce_dumper(cps)
        << "expected: " << ce_dumper(ces)
        << "got:      " << ce_dumper(collation);
}

TEST(collation, non_ignorable_110_284)
{
    // 02B2 0061;	
    // (ʲ) MODIFIER LETTER SMALL J	[1DB2 1CAD | 0020 0020 | 0014 0002 |]

    uint32_t cps[2] = { 0x02B2, 0x0061 };
    uint32_t const ces[9] = { 0x1DB2, 0x1CAD, 0x0000, 0x0020, 0x0020, 0x0000, 0x0014, 0x0002, 0x0000 };

    auto collation = collate_for_tests(
        cps, cps + 2, boost::text::variable_weighting::non_ignorable);

    EXPECT_EQ(collation.size(), 9);
    EXPECT_TRUE(boost::algorithm::equal(collation.begin(), collation.end(), ces, ces + 9))
        << "from:     " << ce_dumper(cps)
        << "expected: " << ce_dumper(ces)
        << "got:      " << ce_dumper(collation);
}

TEST(collation, non_ignorable_110_285)
{
    // 02B2 0041;	
    // (ʲ) MODIFIER LETTER SMALL J	[1DB2 1CAD | 0020 0020 | 0014 0008 |]

    uint32_t cps[2] = { 0x02B2, 0x0041 };
    uint32_t const ces[9] = { 0x1DB2, 0x1CAD, 0x0000, 0x0020, 0x0020, 0x0000, 0x0014, 0x0008, 0x0000 };

    auto collation = collate_for_tests(
        cps, cps + 2, boost::text::variable_weighting::non_ignorable);

    EXPECT_EQ(collation.size(), 9);
    EXPECT_TRUE(boost::algorithm::equal(collation.begin(), collation.end(), ces, ces + 9))
        << "from:     " << ce_dumper(cps)
        << "expected: " << ce_dumper(ces)
        << "got:      " << ce_dumper(collation);
}

TEST(collation, non_ignorable_110_286)
{
    // 2C7C 0061;	
    // (ⱼ) LATIN SUBSCRIPT SMALL LETTER J	[1DB2 1CAD | 0020 0020 | 0015 0002 |]

    uint32_t cps[2] = { 0x2C7C, 0x0061 };
    uint32_t const ces[9] = { 0x1DB2, 0x1CAD, 0x0000, 0x0020, 0x0020, 0x0000, 0x0015, 0x0002, 0x0000 };

    auto collation = collate_for_tests(
        cps, cps + 2, boost::text::variable_weighting::non_ignorable);

    EXPECT_EQ(collation.size(), 9);
    EXPECT_TRUE(boost::algorithm::equal(collation.begin(), collation.end(), ces, ces + 9))
        << "from:     " << ce_dumper(cps)
        << "expected: " << ce_dumper(ces)
        << "got:      " << ce_dumper(collation);
}

TEST(collation, non_ignorable_110_287)
{
    // 2C7C 0041;	
    // (ⱼ) LATIN SUBSCRIPT SMALL LETTER J	[1DB2 1CAD | 0020 0020 | 0015 0008 |]

    uint32_t cps[2] = { 0x2C7C, 0x0041 };
    uint32_t const ces[9] = { 0x1DB2, 0x1CAD, 0x0000, 0x0020, 0x0020, 0x0000, 0x0015, 0x0008, 0x0000 };

    auto collation = collate_for_tests(
        cps, cps + 2, boost::text::variable_weighting::non_ignorable);

    EXPECT_EQ(collation.size(), 9);
    EXPECT_TRUE(boost::algorithm::equal(collation.begin(), collation.end(), ces, ces + 9))
        << "from:     " << ce_dumper(cps)
        << "expected: " << ce_dumper(ces)
        << "got:      " << ce_dumper(collation);
}

TEST(collation, non_ignorable_110_288)
{
    // 1D36 0061;	
    // (ᴶ) MODIFIER LETTER CAPITAL J	[1DB2 1CAD | 0020 0020 | 001D 0002 |]

    uint32_t cps[2] = { 0x1D36, 0x0061 };
    uint32_t const ces[9] = { 0x1DB2, 0x1CAD, 0x0000, 0x0020, 0x0020, 0x0000, 0x001D, 0x0002, 0x0000 };

    auto collation = collate_for_tests(
        cps, cps + 2, boost::text::variable_weighting::non_ignorable);

    EXPECT_EQ(collation.size(), 9);
    EXPECT_TRUE(boost::algorithm::equal(collation.begin(), collation.end(), ces, ces + 9))
        << "from:     " << ce_dumper(cps)
        << "expected: " << ce_dumper(ces)
        << "got:      " << ce_dumper(collation);
}

TEST(collation, non_ignorable_110_289)
{
    // 1F139 0061;	
    // (🄹) SQUARED LATIN CAPITAL LETTER J	[1DB2 1CAD | 0020 0020 | 001D 0002 |]

    uint32_t cps[2] = { 0x1F139, 0x0061 };
    uint32_t const ces[9] = { 0x1DB2, 0x1CAD, 0x0000, 0x0020, 0x0020, 0x0000, 0x001D, 0x0002, 0x0000 };

    auto collation = collate_for_tests(
        cps, cps + 2, boost::text::variable_weighting::non_ignorable);

    EXPECT_EQ(collation.size(), 9);
    EXPECT_TRUE(boost::algorithm::equal(collation.begin(), collation.end(), ces, ces + 9))
        << "from:     " << ce_dumper(cps)
        << "expected: " << ce_dumper(ces)
        << "got:      " << ce_dumper(collation);
}

TEST(collation, non_ignorable_110_290)
{
    // 1F179 0061;	
    // (🅹) NEGATIVE SQUARED LATIN CAPITAL LETTER J	[1DB2 1CAD | 0020 0020 | 001D 0002 |]

    uint32_t cps[2] = { 0x1F179, 0x0061 };
    uint32_t const ces[9] = { 0x1DB2, 0x1CAD, 0x0000, 0x0020, 0x0020, 0x0000, 0x001D, 0x0002, 0x0000 };

    auto collation = collate_for_tests(
        cps, cps + 2, boost::text::variable_weighting::non_ignorable);

    EXPECT_EQ(collation.size(), 9);
    EXPECT_TRUE(boost::algorithm::equal(collation.begin(), collation.end(), ces, ces + 9))
        << "from:     " << ce_dumper(cps)
        << "expected: " << ce_dumper(ces)
        << "got:      " << ce_dumper(collation);
}

TEST(collation, non_ignorable_110_291)
{
    // 1D36 0041;	
    // (ᴶ) MODIFIER LETTER CAPITAL J	[1DB2 1CAD | 0020 0020 | 001D 0008 |]

    uint32_t cps[2] = { 0x1D36, 0x0041 };
    uint32_t const ces[9] = { 0x1DB2, 0x1CAD, 0x0000, 0x0020, 0x0020, 0x0000, 0x001D, 0x0008, 0x0000 };

    auto collation = collate_for_tests(
        cps, cps + 2, boost::text::variable_weighting::non_ignorable);

    EXPECT_EQ(collation.size(), 9);
    EXPECT_TRUE(boost::algorithm::equal(collation.begin(), collation.end(), ces, ces + 9))
        << "from:     " << ce_dumper(cps)
        << "expected: " << ce_dumper(ces)
        << "got:      " << ce_dumper(collation);
}

TEST(collation, non_ignorable_110_292)
{
    // 1F139 0041;	
    // (🄹) SQUARED LATIN CAPITAL LETTER J	[1DB2 1CAD | 0020 0020 | 001D 0008 |]

    uint32_t cps[2] = { 0x1F139, 0x0041 };
    uint32_t const ces[9] = { 0x1DB2, 0x1CAD, 0x0000, 0x0020, 0x0020, 0x0000, 0x001D, 0x0008, 0x0000 };

    auto collation = collate_for_tests(
        cps, cps + 2, boost::text::variable_weighting::non_ignorable);

    EXPECT_EQ(collation.size(), 9);
    EXPECT_TRUE(boost::algorithm::equal(collation.begin(), collation.end(), ces, ces + 9))
        << "from:     " << ce_dumper(cps)
        << "expected: " << ce_dumper(ces)
        << "got:      " << ce_dumper(collation);
}

TEST(collation, non_ignorable_110_293)
{
    // 1F179 0041;	
    // (🅹) NEGATIVE SQUARED LATIN CAPITAL LETTER J	[1DB2 1CAD | 0020 0020 | 001D 0008 |]

    uint32_t cps[2] = { 0x1F179, 0x0041 };
    uint32_t const ces[9] = { 0x1DB2, 0x1CAD, 0x0000, 0x0020, 0x0020, 0x0000, 0x001D, 0x0008, 0x0000 };

    auto collation = collate_for_tests(
        cps, cps + 2, boost::text::variable_weighting::non_ignorable);

    EXPECT_EQ(collation.size(), 9);
    EXPECT_TRUE(boost::algorithm::equal(collation.begin(), collation.end(), ces, ces + 9))
        << "from:     " << ce_dumper(cps)
        << "expected: " << ce_dumper(ces)
        << "got:      " << ce_dumper(collation);
}

TEST(collation, non_ignorable_110_294)
{
    // 0135 0061;	
    // (ĵ) LATIN SMALL LETTER J WITH CIRCUMFLEX	[1DB2 1CAD | 0020 0027 0020 | 0002 0002 0002 |]

    uint32_t cps[2] = { 0x0135, 0x0061 };
    uint32_t const ces[11] = { 0x1DB2, 0x1CAD, 0x0000, 0x0020, 0x0027, 0x0020, 0x0000, 0x0002, 0x0002, 0x0002, 0x0000 };

    auto collation = collate_for_tests(
        cps, cps + 2, boost::text::variable_weighting::non_ignorable);

    EXPECT_EQ(collation.size(), 11);
    EXPECT_TRUE(boost::algorithm::equal(collation.begin(), collation.end(), ces, ces + 11))
        << "from:     " << ce_dumper(cps)
        << "expected: " << ce_dumper(ces)
        << "got:      " << ce_dumper(collation);
}

TEST(collation, non_ignorable_110_295)
{
    // 0135 0041;	
    // (ĵ) LATIN SMALL LETTER J WITH CIRCUMFLEX	[1DB2 1CAD | 0020 0027 0020 | 0002 0002 0008 |]

    uint32_t cps[2] = { 0x0135, 0x0041 };
    uint32_t const ces[11] = { 0x1DB2, 0x1CAD, 0x0000, 0x0020, 0x0027, 0x0020, 0x0000, 0x0002, 0x0002, 0x0008, 0x0000 };

    auto collation = collate_for_tests(
        cps, cps + 2, boost::text::variable_weighting::non_ignorable);

    EXPECT_EQ(collation.size(), 11);
    EXPECT_TRUE(boost::algorithm::equal(collation.begin(), collation.end(), ces, ces + 11))
        << "from:     " << ce_dumper(cps)
        << "expected: " << ce_dumper(ces)
        << "got:      " << ce_dumper(collation);
}

TEST(collation, non_ignorable_110_296)
{
    // 0134 0061;	
    // (Ĵ) LATIN CAPITAL LETTER J WITH CIRCUMFLEX	[1DB2 1CAD | 0020 0027 0020 | 0008 0002 0002 |]

    uint32_t cps[2] = { 0x0134, 0x0061 };
    uint32_t const ces[11] = { 0x1DB2, 0x1CAD, 0x0000, 0x0020, 0x0027, 0x0020, 0x0000, 0x0008, 0x0002, 0x0002, 0x0000 };

    auto collation = collate_for_tests(
        cps, cps + 2, boost::text::variable_weighting::non_ignorable);

    EXPECT_EQ(collation.size(), 11);
    EXPECT_TRUE(boost::algorithm::equal(collation.begin(), collation.end(), ces, ces + 11))
        << "from:     " << ce_dumper(cps)
        << "expected: " << ce_dumper(ces)
        << "got:      " << ce_dumper(collation);
}

TEST(collation, non_ignorable_110_297)
{
    // 0134 0041;	
    // (Ĵ) LATIN CAPITAL LETTER J WITH CIRCUMFLEX	[1DB2 1CAD | 0020 0027 0020 | 0008 0002 0008 |]

    uint32_t cps[2] = { 0x0134, 0x0041 };
    uint32_t const ces[11] = { 0x1DB2, 0x1CAD, 0x0000, 0x0020, 0x0027, 0x0020, 0x0000, 0x0008, 0x0002, 0x0008, 0x0000 };

    auto collation = collate_for_tests(
        cps, cps + 2, boost::text::variable_weighting::non_ignorable);

    EXPECT_EQ(collation.size(), 11);
    EXPECT_TRUE(boost::algorithm::equal(collation.begin(), collation.end(), ces, ces + 11))
        << "from:     " << ce_dumper(cps)
        << "expected: " << ce_dumper(ces)
        << "got:      " << ce_dumper(collation);
}

TEST(collation, non_ignorable_110_298)
{
    // 01F0 0061;	
    // (ǰ) LATIN SMALL LETTER J WITH CARON	[1DB2 1CAD | 0020 0028 0020 | 0002 0002 0002 |]

    uint32_t cps[2] = { 0x01F0, 0x0061 };
    uint32_t const ces[11] = { 0x1DB2, 0x1CAD, 0x0000, 0x0020, 0x0028, 0x0020, 0x0000, 0x0002, 0x0002, 0x0002, 0x0000 };

    auto collation = collate_for_tests(
        cps, cps + 2, boost::text::variable_weighting::non_ignorable);

    EXPECT_EQ(collation.size(), 11);
    EXPECT_TRUE(boost::algorithm::equal(collation.begin(), collation.end(), ces, ces + 11))
        << "from:     " << ce_dumper(cps)
        << "expected: " << ce_dumper(ces)
        << "got:      " << ce_dumper(collation);
}

TEST(collation, non_ignorable_110_299)
{
    // 01F0 0041;	
    // (ǰ) LATIN SMALL LETTER J WITH CARON	[1DB2 1CAD | 0020 0028 0020 | 0002 0002 0008 |]

    uint32_t cps[2] = { 0x01F0, 0x0041 };
    uint32_t const ces[11] = { 0x1DB2, 0x1CAD, 0x0000, 0x0020, 0x0028, 0x0020, 0x0000, 0x0002, 0x0002, 0x0008, 0x0000 };

    auto collation = collate_for_tests(
        cps, cps + 2, boost::text::variable_weighting::non_ignorable);

    EXPECT_EQ(collation.size(), 11);
    EXPECT_TRUE(boost::algorithm::equal(collation.begin(), collation.end(), ces, ces + 11))
        << "from:     " << ce_dumper(cps)
        << "expected: " << ce_dumper(ces)
        << "got:      " << ce_dumper(collation);
}

TEST(collation, non_ignorable_110_300)
{
    // 006A 0062;	
    // (j) LATIN SMALL LETTER J	[1DB2 1CC6 | 0020 0020 | 0002 0002 |]

    uint32_t cps[2] = { 0x006A, 0x0062 };
    uint32_t const ces[9] = { 0x1DB2, 0x1CC6, 0x0000, 0x0020, 0x0020, 0x0000, 0x0002, 0x0002, 0x0000 };

    auto collation = collate_for_tests(
        cps, cps + 2, boost::text::variable_weighting::non_ignorable);

    EXPECT_EQ(collation.size(), 9);
    EXPECT_TRUE(boost::algorithm::equal(collation.begin(), collation.end(), ces, ces + 9))
        << "from:     " << ce_dumper(cps)
        << "expected: " << ce_dumper(ces)
        << "got:      " << ce_dumper(collation);
}

TEST(collation, non_ignorable_110_301)
{
    // FF4A 0062;	
    // (ｊ) FULLWIDTH LATIN SMALL LETTER J	[1DB2 1CC6 | 0020 0020 | 0003 0002 |]

    uint32_t cps[2] = { 0xFF4A, 0x0062 };
    uint32_t const ces[9] = { 0x1DB2, 0x1CC6, 0x0000, 0x0020, 0x0020, 0x0000, 0x0003, 0x0002, 0x0000 };

    auto collation = collate_for_tests(
        cps, cps + 2, boost::text::variable_weighting::non_ignorable);

    EXPECT_EQ(collation.size(), 9);
    EXPECT_TRUE(boost::algorithm::equal(collation.begin(), collation.end(), ces, ces + 9))
        << "from:     " << ce_dumper(cps)
        << "expected: " << ce_dumper(ces)
        << "got:      " << ce_dumper(collation);
}

TEST(collation, non_ignorable_110_302)
{
    // 2149 0062;	
    // (ⅉ) DOUBLE-STRUCK ITALIC SMALL J	[1DB2 1CC6 | 0020 0020 | 0005 0002 |]

    uint32_t cps[2] = { 0x2149, 0x0062 };
    uint32_t const ces[9] = { 0x1DB2, 0x1CC6, 0x0000, 0x0020, 0x0020, 0x0000, 0x0005, 0x0002, 0x0000 };

    auto collation = collate_for_tests(
        cps, cps + 2, boost::text::variable_weighting::non_ignorable);

    EXPECT_EQ(collation.size(), 9);
    EXPECT_TRUE(boost::algorithm::equal(collation.begin(), collation.end(), ces, ces + 9))
        << "from:     " << ce_dumper(cps)
        << "expected: " << ce_dumper(ces)
        << "got:      " << ce_dumper(collation);
}

TEST(collation, non_ignorable_110_303)
{
    // 1D423 0062;	
    // (𝐣) MATHEMATICAL BOLD SMALL J	[1DB2 1CC6 | 0020 0020 | 0005 0002 |]

    uint32_t cps[2] = { 0x1D423, 0x0062 };
    uint32_t const ces[9] = { 0x1DB2, 0x1CC6, 0x0000, 0x0020, 0x0020, 0x0000, 0x0005, 0x0002, 0x0000 };

    auto collation = collate_for_tests(
        cps, cps + 2, boost::text::variable_weighting::non_ignorable);

    EXPECT_EQ(collation.size(), 9);
    EXPECT_TRUE(boost::algorithm::equal(collation.begin(), collation.end(), ces, ces + 9))
        << "from:     " << ce_dumper(cps)
        << "expected: " << ce_dumper(ces)
        << "got:      " << ce_dumper(collation);
}

TEST(collation, non_ignorable_110_304)
{
    // 1D457 0062;	
    // (𝑗) MATHEMATICAL ITALIC SMALL J	[1DB2 1CC6 | 0020 0020 | 0005 0002 |]

    uint32_t cps[2] = { 0x1D457, 0x0062 };
    uint32_t const ces[9] = { 0x1DB2, 0x1CC6, 0x0000, 0x0020, 0x0020, 0x0000, 0x0005, 0x0002, 0x0000 };

    auto collation = collate_for_tests(
        cps, cps + 2, boost::text::variable_weighting::non_ignorable);

    EXPECT_EQ(collation.size(), 9);
    EXPECT_TRUE(boost::algorithm::equal(collation.begin(), collation.end(), ces, ces + 9))
        << "from:     " << ce_dumper(cps)
        << "expected: " << ce_dumper(ces)
        << "got:      " << ce_dumper(collation);
}

TEST(collation, non_ignorable_110_305)
{
    // 1D48B 0062;	
    // (𝒋) MATHEMATICAL BOLD ITALIC SMALL J	[1DB2 1CC6 | 0020 0020 | 0005 0002 |]

    uint32_t cps[2] = { 0x1D48B, 0x0062 };
    uint32_t const ces[9] = { 0x1DB2, 0x1CC6, 0x0000, 0x0020, 0x0020, 0x0000, 0x0005, 0x0002, 0x0000 };

    auto collation = collate_for_tests(
        cps, cps + 2, boost::text::variable_weighting::non_ignorable);

    EXPECT_EQ(collation.size(), 9);
    EXPECT_TRUE(boost::algorithm::equal(collation.begin(), collation.end(), ces, ces + 9))
        << "from:     " << ce_dumper(cps)
        << "expected: " << ce_dumper(ces)
        << "got:      " << ce_dumper(collation);
}

TEST(collation, non_ignorable_110_306)
{
    // 1D4BF 0062;	
    // (𝒿) MATHEMATICAL SCRIPT SMALL J	[1DB2 1CC6 | 0020 0020 | 0005 0002 |]

    uint32_t cps[2] = { 0x1D4BF, 0x0062 };
    uint32_t const ces[9] = { 0x1DB2, 0x1CC6, 0x0000, 0x0020, 0x0020, 0x0000, 0x0005, 0x0002, 0x0000 };

    auto collation = collate_for_tests(
        cps, cps + 2, boost::text::variable_weighting::non_ignorable);

    EXPECT_EQ(collation.size(), 9);
    EXPECT_TRUE(boost::algorithm::equal(collation.begin(), collation.end(), ces, ces + 9))
        << "from:     " << ce_dumper(cps)
        << "expected: " << ce_dumper(ces)
        << "got:      " << ce_dumper(collation);
}

TEST(collation, non_ignorable_110_307)
{
    // 1D4F3 0062;	
    // (𝓳) MATHEMATICAL BOLD SCRIPT SMALL J	[1DB2 1CC6 | 0020 0020 | 0005 0002 |]

    uint32_t cps[2] = { 0x1D4F3, 0x0062 };
    uint32_t const ces[9] = { 0x1DB2, 0x1CC6, 0x0000, 0x0020, 0x0020, 0x0000, 0x0005, 0x0002, 0x0000 };

    auto collation = collate_for_tests(
        cps, cps + 2, boost::text::variable_weighting::non_ignorable);

    EXPECT_EQ(collation.size(), 9);
    EXPECT_TRUE(boost::algorithm::equal(collation.begin(), collation.end(), ces, ces + 9))
        << "from:     " << ce_dumper(cps)
        << "expected: " << ce_dumper(ces)
        << "got:      " << ce_dumper(collation);
}

TEST(collation, non_ignorable_110_308)
{
    // 1D527 0062;	
    // (𝔧) MATHEMATICAL FRAKTUR SMALL J	[1DB2 1CC6 | 0020 0020 | 0005 0002 |]

    uint32_t cps[2] = { 0x1D527, 0x0062 };
    uint32_t const ces[9] = { 0x1DB2, 0x1CC6, 0x0000, 0x0020, 0x0020, 0x0000, 0x0005, 0x0002, 0x0000 };

    auto collation = collate_for_tests(
        cps, cps + 2, boost::text::variable_weighting::non_ignorable);

    EXPECT_EQ(collation.size(), 9);
    EXPECT_TRUE(boost::algorithm::equal(collation.begin(), collation.end(), ces, ces + 9))
        << "from:     " << ce_dumper(cps)
        << "expected: " << ce_dumper(ces)
        << "got:      " << ce_dumper(collation);
}

TEST(collation, non_ignorable_110_309)
{
    // 1D55B 0062;	
    // (𝕛) MATHEMATICAL DOUBLE-STRUCK SMALL J	[1DB2 1CC6 | 0020 0020 | 0005 0002 |]

    uint32_t cps[2] = { 0x1D55B, 0x0062 };
    uint32_t const ces[9] = { 0x1DB2, 0x1CC6, 0x0000, 0x0020, 0x0020, 0x0000, 0x0005, 0x0002, 0x0000 };

    auto collation = collate_for_tests(
        cps, cps + 2, boost::text::variable_weighting::non_ignorable);

    EXPECT_EQ(collation.size(), 9);
    EXPECT_TRUE(boost::algorithm::equal(collation.begin(), collation.end(), ces, ces + 9))
        << "from:     " << ce_dumper(cps)
        << "expected: " << ce_dumper(ces)
        << "got:      " << ce_dumper(collation);
}

TEST(collation, non_ignorable_110_310)
{
    // 1D58F 0062;	
    // (𝖏) MATHEMATICAL BOLD FRAKTUR SMALL J	[1DB2 1CC6 | 0020 0020 | 0005 0002 |]

    uint32_t cps[2] = { 0x1D58F, 0x0062 };
    uint32_t const ces[9] = { 0x1DB2, 0x1CC6, 0x0000, 0x0020, 0x0020, 0x0000, 0x0005, 0x0002, 0x0000 };

    auto collation = collate_for_tests(
        cps, cps + 2, boost::text::variable_weighting::non_ignorable);

    EXPECT_EQ(collation.size(), 9);
    EXPECT_TRUE(boost::algorithm::equal(collation.begin(), collation.end(), ces, ces + 9))
        << "from:     " << ce_dumper(cps)
        << "expected: " << ce_dumper(ces)
        << "got:      " << ce_dumper(collation);
}

TEST(collation, non_ignorable_110_311)
{
    // 1D5C3 0062;	
    // (𝗃) MATHEMATICAL SANS-SERIF SMALL J	[1DB2 1CC6 | 0020 0020 | 0005 0002 |]

    uint32_t cps[2] = { 0x1D5C3, 0x0062 };
    uint32_t const ces[9] = { 0x1DB2, 0x1CC6, 0x0000, 0x0020, 0x0020, 0x0000, 0x0005, 0x0002, 0x0000 };

    auto collation = collate_for_tests(
        cps, cps + 2, boost::text::variable_weighting::non_ignorable);

    EXPECT_EQ(collation.size(), 9);
    EXPECT_TRUE(boost::algorithm::equal(collation.begin(), collation.end(), ces, ces + 9))
        << "from:     " << ce_dumper(cps)
        << "expected: " << ce_dumper(ces)
        << "got:      " << ce_dumper(collation);
}

TEST(collation, non_ignorable_110_312)
{
    // 1D5F7 0062;	
    // (𝗷) MATHEMATICAL SANS-SERIF BOLD SMALL J	[1DB2 1CC6 | 0020 0020 | 0005 0002 |]

    uint32_t cps[2] = { 0x1D5F7, 0x0062 };
    uint32_t const ces[9] = { 0x1DB2, 0x1CC6, 0x0000, 0x0020, 0x0020, 0x0000, 0x0005, 0x0002, 0x0000 };

    auto collation = collate_for_tests(
        cps, cps + 2, boost::text::variable_weighting::non_ignorable);

    EXPECT_EQ(collation.size(), 9);
    EXPECT_TRUE(boost::algorithm::equal(collation.begin(), collation.end(), ces, ces + 9))
        << "from:     " << ce_dumper(cps)
        << "expected: " << ce_dumper(ces)
        << "got:      " << ce_dumper(collation);
}

TEST(collation, non_ignorable_110_313)
{
    // 1D62B 0062;	
    // (𝘫) MATHEMATICAL SANS-SERIF ITALIC SMALL J	[1DB2 1CC6 | 0020 0020 | 0005 0002 |]

    uint32_t cps[2] = { 0x1D62B, 0x0062 };
    uint32_t const ces[9] = { 0x1DB2, 0x1CC6, 0x0000, 0x0020, 0x0020, 0x0000, 0x0005, 0x0002, 0x0000 };

    auto collation = collate_for_tests(
        cps, cps + 2, boost::text::variable_weighting::non_ignorable);

    EXPECT_EQ(collation.size(), 9);
    EXPECT_TRUE(boost::algorithm::equal(collation.begin(), collation.end(), ces, ces + 9))
        << "from:     " << ce_dumper(cps)
        << "expected: " << ce_dumper(ces)
        << "got:      " << ce_dumper(collation);
}

TEST(collation, non_ignorable_110_314)
{
    // 1D65F 0062;	
    // (𝙟) MATHEMATICAL SANS-SERIF BOLD ITALIC SMALL J	[1DB2 1CC6 | 0020 0020 | 0005 0002 |]

    uint32_t cps[2] = { 0x1D65F, 0x0062 };
    uint32_t const ces[9] = { 0x1DB2, 0x1CC6, 0x0000, 0x0020, 0x0020, 0x0000, 0x0005, 0x0002, 0x0000 };

    auto collation = collate_for_tests(
        cps, cps + 2, boost::text::variable_weighting::non_ignorable);

    EXPECT_EQ(collation.size(), 9);
    EXPECT_TRUE(boost::algorithm::equal(collation.begin(), collation.end(), ces, ces + 9))
        << "from:     " << ce_dumper(cps)
        << "expected: " << ce_dumper(ces)
        << "got:      " << ce_dumper(collation);
}

TEST(collation, non_ignorable_110_315)
{
    // 1D693 0062;	
    // (𝚓) MATHEMATICAL MONOSPACE SMALL J	[1DB2 1CC6 | 0020 0020 | 0005 0002 |]

    uint32_t cps[2] = { 0x1D693, 0x0062 };
    uint32_t const ces[9] = { 0x1DB2, 0x1CC6, 0x0000, 0x0020, 0x0020, 0x0000, 0x0005, 0x0002, 0x0000 };

    auto collation = collate_for_tests(
        cps, cps + 2, boost::text::variable_weighting::non_ignorable);

    EXPECT_EQ(collation.size(), 9);
    EXPECT_TRUE(boost::algorithm::equal(collation.begin(), collation.end(), ces, ces + 9))
        << "from:     " << ce_dumper(cps)
        << "expected: " << ce_dumper(ces)
        << "got:      " << ce_dumper(collation);
}

TEST(collation, non_ignorable_110_316)
{
    // 24D9 0062;	
    // (ⓙ) CIRCLED LATIN SMALL LETTER J	[1DB2 1CC6 | 0020 0020 | 0006 0002 |]

    uint32_t cps[2] = { 0x24D9, 0x0062 };
    uint32_t const ces[9] = { 0x1DB2, 0x1CC6, 0x0000, 0x0020, 0x0020, 0x0000, 0x0006, 0x0002, 0x0000 };

    auto collation = collate_for_tests(
        cps, cps + 2, boost::text::variable_weighting::non_ignorable);

    EXPECT_EQ(collation.size(), 9);
    EXPECT_TRUE(boost::algorithm::equal(collation.begin(), collation.end(), ces, ces + 9))
        << "from:     " << ce_dumper(cps)
        << "expected: " << ce_dumper(ces)
        << "got:      " << ce_dumper(collation);
}

TEST(collation, non_ignorable_110_317)
{
    // 004A 0062;	
    // (J) LATIN CAPITAL LETTER J	[1DB2 1CC6 | 0020 0020 | 0008 0002 |]

    uint32_t cps[2] = { 0x004A, 0x0062 };
    uint32_t const ces[9] = { 0x1DB2, 0x1CC6, 0x0000, 0x0020, 0x0020, 0x0000, 0x0008, 0x0002, 0x0000 };

    auto collation = collate_for_tests(
        cps, cps + 2, boost::text::variable_weighting::non_ignorable);

    EXPECT_EQ(collation.size(), 9);
    EXPECT_TRUE(boost::algorithm::equal(collation.begin(), collation.end(), ces, ces + 9))
        << "from:     " << ce_dumper(cps)
        << "expected: " << ce_dumper(ces)
        << "got:      " << ce_dumper(collation);
}

TEST(collation, non_ignorable_110_318)
{
    // FF2A 0062;	
    // (Ｊ) FULLWIDTH LATIN CAPITAL LETTER J	[1DB2 1CC6 | 0020 0020 | 0009 0002 |]

    uint32_t cps[2] = { 0xFF2A, 0x0062 };
    uint32_t const ces[9] = { 0x1DB2, 0x1CC6, 0x0000, 0x0020, 0x0020, 0x0000, 0x0009, 0x0002, 0x0000 };

    auto collation = collate_for_tests(
        cps, cps + 2, boost::text::variable_weighting::non_ignorable);

    EXPECT_EQ(collation.size(), 9);
    EXPECT_TRUE(boost::algorithm::equal(collation.begin(), collation.end(), ces, ces + 9))
        << "from:     " << ce_dumper(cps)
        << "expected: " << ce_dumper(ces)
        << "got:      " << ce_dumper(collation);
}

TEST(collation, non_ignorable_110_319)
{
    // 1D409 0062;	
    // (𝐉) MATHEMATICAL BOLD CAPITAL J	[1DB2 1CC6 | 0020 0020 | 000B 0002 |]

    uint32_t cps[2] = { 0x1D409, 0x0062 };
    uint32_t const ces[9] = { 0x1DB2, 0x1CC6, 0x0000, 0x0020, 0x0020, 0x0000, 0x000B, 0x0002, 0x0000 };

    auto collation = collate_for_tests(
        cps, cps + 2, boost::text::variable_weighting::non_ignorable);

    EXPECT_EQ(collation.size(), 9);
    EXPECT_TRUE(boost::algorithm::equal(collation.begin(), collation.end(), ces, ces + 9))
        << "from:     " << ce_dumper(cps)
        << "expected: " << ce_dumper(ces)
        << "got:      " << ce_dumper(collation);
}

TEST(collation, non_ignorable_110_320)
{
    // 1D43D 0062;	
    // (𝐽) MATHEMATICAL ITALIC CAPITAL J	[1DB2 1CC6 | 0020 0020 | 000B 0002 |]

    uint32_t cps[2] = { 0x1D43D, 0x0062 };
    uint32_t const ces[9] = { 0x1DB2, 0x1CC6, 0x0000, 0x0020, 0x0020, 0x0000, 0x000B, 0x0002, 0x0000 };

    auto collation = collate_for_tests(
        cps, cps + 2, boost::text::variable_weighting::non_ignorable);

    EXPECT_EQ(collation.size(), 9);
    EXPECT_TRUE(boost::algorithm::equal(collation.begin(), collation.end(), ces, ces + 9))
        << "from:     " << ce_dumper(cps)
        << "expected: " << ce_dumper(ces)
        << "got:      " << ce_dumper(collation);
}

TEST(collation, non_ignorable_110_321)
{
    // 1D471 0062;	
    // (𝑱) MATHEMATICAL BOLD ITALIC CAPITAL J	[1DB2 1CC6 | 0020 0020 | 000B 0002 |]

    uint32_t cps[2] = { 0x1D471, 0x0062 };
    uint32_t const ces[9] = { 0x1DB2, 0x1CC6, 0x0000, 0x0020, 0x0020, 0x0000, 0x000B, 0x0002, 0x0000 };

    auto collation = collate_for_tests(
        cps, cps + 2, boost::text::variable_weighting::non_ignorable);

    EXPECT_EQ(collation.size(), 9);
    EXPECT_TRUE(boost::algorithm::equal(collation.begin(), collation.end(), ces, ces + 9))
        << "from:     " << ce_dumper(cps)
        << "expected: " << ce_dumper(ces)
        << "got:      " << ce_dumper(collation);
}

TEST(collation, non_ignorable_110_322)
{
    // 1D4A5 0062;	
    // (𝒥) MATHEMATICAL SCRIPT CAPITAL J	[1DB2 1CC6 | 0020 0020 | 000B 0002 |]

    uint32_t cps[2] = { 0x1D4A5, 0x0062 };
    uint32_t const ces[9] = { 0x1DB2, 0x1CC6, 0x0000, 0x0020, 0x0020, 0x0000, 0x000B, 0x0002, 0x0000 };

    auto collation = collate_for_tests(
        cps, cps + 2, boost::text::variable_weighting::non_ignorable);

    EXPECT_EQ(collation.size(), 9);
    EXPECT_TRUE(boost::algorithm::equal(collation.begin(), collation.end(), ces, ces + 9))
        << "from:     " << ce_dumper(cps)
        << "expected: " << ce_dumper(ces)
        << "got:      " << ce_dumper(collation);
}

TEST(collation, non_ignorable_110_323)
{
    // 1D4D9 0062;	
    // (𝓙) MATHEMATICAL BOLD SCRIPT CAPITAL J	[1DB2 1CC6 | 0020 0020 | 000B 0002 |]

    uint32_t cps[2] = { 0x1D4D9, 0x0062 };
    uint32_t const ces[9] = { 0x1DB2, 0x1CC6, 0x0000, 0x0020, 0x0020, 0x0000, 0x000B, 0x0002, 0x0000 };

    auto collation = collate_for_tests(
        cps, cps + 2, boost::text::variable_weighting::non_ignorable);

    EXPECT_EQ(collation.size(), 9);
    EXPECT_TRUE(boost::algorithm::equal(collation.begin(), collation.end(), ces, ces + 9))
        << "from:     " << ce_dumper(cps)
        << "expected: " << ce_dumper(ces)
        << "got:      " << ce_dumper(collation);
}

TEST(collation, non_ignorable_110_324)
{
    // 1D50D 0062;	
    // (𝔍) MATHEMATICAL FRAKTUR CAPITAL J	[1DB2 1CC6 | 0020 0020 | 000B 0002 |]

    uint32_t cps[2] = { 0x1D50D, 0x0062 };
    uint32_t const ces[9] = { 0x1DB2, 0x1CC6, 0x0000, 0x0020, 0x0020, 0x0000, 0x000B, 0x0002, 0x0000 };

    auto collation = collate_for_tests(
        cps, cps + 2, boost::text::variable_weighting::non_ignorable);

    EXPECT_EQ(collation.size(), 9);
    EXPECT_TRUE(boost::algorithm::equal(collation.begin(), collation.end(), ces, ces + 9))
        << "from:     " << ce_dumper(cps)
        << "expected: " << ce_dumper(ces)
        << "got:      " << ce_dumper(collation);
}

TEST(collation, non_ignorable_110_325)
{
    // 1D541 0062;	
    // (𝕁) MATHEMATICAL DOUBLE-STRUCK CAPITAL J	[1DB2 1CC6 | 0020 0020 | 000B 0002 |]

    uint32_t cps[2] = { 0x1D541, 0x0062 };
    uint32_t const ces[9] = { 0x1DB2, 0x1CC6, 0x0000, 0x0020, 0x0020, 0x0000, 0x000B, 0x0002, 0x0000 };

    auto collation = collate_for_tests(
        cps, cps + 2, boost::text::variable_weighting::non_ignorable);

    EXPECT_EQ(collation.size(), 9);
    EXPECT_TRUE(boost::algorithm::equal(collation.begin(), collation.end(), ces, ces + 9))
        << "from:     " << ce_dumper(cps)
        << "expected: " << ce_dumper(ces)
        << "got:      " << ce_dumper(collation);
}

TEST(collation, non_ignorable_110_326)
{
    // 1D575 0062;	
    // (𝕵) MATHEMATICAL BOLD FRAKTUR CAPITAL J	[1DB2 1CC6 | 0020 0020 | 000B 0002 |]

    uint32_t cps[2] = { 0x1D575, 0x0062 };
    uint32_t const ces[9] = { 0x1DB2, 0x1CC6, 0x0000, 0x0020, 0x0020, 0x0000, 0x000B, 0x0002, 0x0000 };

    auto collation = collate_for_tests(
        cps, cps + 2, boost::text::variable_weighting::non_ignorable);

    EXPECT_EQ(collation.size(), 9);
    EXPECT_TRUE(boost::algorithm::equal(collation.begin(), collation.end(), ces, ces + 9))
        << "from:     " << ce_dumper(cps)
        << "expected: " << ce_dumper(ces)
        << "got:      " << ce_dumper(collation);
}

TEST(collation, non_ignorable_110_327)
{
    // 1D5A9 0062;	
    // (𝖩) MATHEMATICAL SANS-SERIF CAPITAL J	[1DB2 1CC6 | 0020 0020 | 000B 0002 |]

    uint32_t cps[2] = { 0x1D5A9, 0x0062 };
    uint32_t const ces[9] = { 0x1DB2, 0x1CC6, 0x0000, 0x0020, 0x0020, 0x0000, 0x000B, 0x0002, 0x0000 };

    auto collation = collate_for_tests(
        cps, cps + 2, boost::text::variable_weighting::non_ignorable);

    EXPECT_EQ(collation.size(), 9);
    EXPECT_TRUE(boost::algorithm::equal(collation.begin(), collation.end(), ces, ces + 9))
        << "from:     " << ce_dumper(cps)
        << "expected: " << ce_dumper(ces)
        << "got:      " << ce_dumper(collation);
}

TEST(collation, non_ignorable_110_328)
{
    // 1D5DD 0062;	
    // (𝗝) MATHEMATICAL SANS-SERIF BOLD CAPITAL J	[1DB2 1CC6 | 0020 0020 | 000B 0002 |]

    uint32_t cps[2] = { 0x1D5DD, 0x0062 };
    uint32_t const ces[9] = { 0x1DB2, 0x1CC6, 0x0000, 0x0020, 0x0020, 0x0000, 0x000B, 0x0002, 0x0000 };

    auto collation = collate_for_tests(
        cps, cps + 2, boost::text::variable_weighting::non_ignorable);

    EXPECT_EQ(collation.size(), 9);
    EXPECT_TRUE(boost::algorithm::equal(collation.begin(), collation.end(), ces, ces + 9))
        << "from:     " << ce_dumper(cps)
        << "expected: " << ce_dumper(ces)
        << "got:      " << ce_dumper(collation);
}

TEST(collation, non_ignorable_110_329)
{
    // 1D611 0062;	
    // (𝘑) MATHEMATICAL SANS-SERIF ITALIC CAPITAL J	[1DB2 1CC6 | 0020 0020 | 000B 0002 |]

    uint32_t cps[2] = { 0x1D611, 0x0062 };
    uint32_t const ces[9] = { 0x1DB2, 0x1CC6, 0x0000, 0x0020, 0x0020, 0x0000, 0x000B, 0x0002, 0x0000 };

    auto collation = collate_for_tests(
        cps, cps + 2, boost::text::variable_weighting::non_ignorable);

    EXPECT_EQ(collation.size(), 9);
    EXPECT_TRUE(boost::algorithm::equal(collation.begin(), collation.end(), ces, ces + 9))
        << "from:     " << ce_dumper(cps)
        << "expected: " << ce_dumper(ces)
        << "got:      " << ce_dumper(collation);
}

TEST(collation, non_ignorable_110_330)
{
    // 1D645 0062;	
    // (𝙅) MATHEMATICAL SANS-SERIF BOLD ITALIC CAPITAL J	[1DB2 1CC6 | 0020 0020 | 000B 0002 |]

    uint32_t cps[2] = { 0x1D645, 0x0062 };
    uint32_t const ces[9] = { 0x1DB2, 0x1CC6, 0x0000, 0x0020, 0x0020, 0x0000, 0x000B, 0x0002, 0x0000 };

    auto collation = collate_for_tests(
        cps, cps + 2, boost::text::variable_weighting::non_ignorable);

    EXPECT_EQ(collation.size(), 9);
    EXPECT_TRUE(boost::algorithm::equal(collation.begin(), collation.end(), ces, ces + 9))
        << "from:     " << ce_dumper(cps)
        << "expected: " << ce_dumper(ces)
        << "got:      " << ce_dumper(collation);
}

TEST(collation, non_ignorable_110_331)
{
    // 1D679 0062;	
    // (𝙹) MATHEMATICAL MONOSPACE CAPITAL J	[1DB2 1CC6 | 0020 0020 | 000B 0002 |]

    uint32_t cps[2] = { 0x1D679, 0x0062 };
    uint32_t const ces[9] = { 0x1DB2, 0x1CC6, 0x0000, 0x0020, 0x0020, 0x0000, 0x000B, 0x0002, 0x0000 };

    auto collation = collate_for_tests(
        cps, cps + 2, boost::text::variable_weighting::non_ignorable);

    EXPECT_EQ(collation.size(), 9);
    EXPECT_TRUE(boost::algorithm::equal(collation.begin(), collation.end(), ces, ces + 9))
        << "from:     " << ce_dumper(cps)
        << "expected: " << ce_dumper(ces)
        << "got:      " << ce_dumper(collation);
}

TEST(collation, non_ignorable_110_332)
{
    // 24BF 0062;	
    // (Ⓙ) CIRCLED LATIN CAPITAL LETTER J	[1DB2 1CC6 | 0020 0020 | 000C 0002 |]

    uint32_t cps[2] = { 0x24BF, 0x0062 };
    uint32_t const ces[9] = { 0x1DB2, 0x1CC6, 0x0000, 0x0020, 0x0020, 0x0000, 0x000C, 0x0002, 0x0000 };

    auto collation = collate_for_tests(
        cps, cps + 2, boost::text::variable_weighting::non_ignorable);

    EXPECT_EQ(collation.size(), 9);
    EXPECT_TRUE(boost::algorithm::equal(collation.begin(), collation.end(), ces, ces + 9))
        << "from:     " << ce_dumper(cps)
        << "expected: " << ce_dumper(ces)
        << "got:      " << ce_dumper(collation);
}

TEST(collation, non_ignorable_110_333)
{
    // 1F159 0062;	
    // (🅙) NEGATIVE CIRCLED LATIN CAPITAL LETTER J	[1DB2 1CC6 | 0020 0020 | 000C 0002 |]

    uint32_t cps[2] = { 0x1F159, 0x0062 };
    uint32_t const ces[9] = { 0x1DB2, 0x1CC6, 0x0000, 0x0020, 0x0020, 0x0000, 0x000C, 0x0002, 0x0000 };

    auto collation = collate_for_tests(
        cps, cps + 2, boost::text::variable_weighting::non_ignorable);

    EXPECT_EQ(collation.size(), 9);
    EXPECT_TRUE(boost::algorithm::equal(collation.begin(), collation.end(), ces, ces + 9))
        << "from:     " << ce_dumper(cps)
        << "expected: " << ce_dumper(ces)
        << "got:      " << ce_dumper(collation);
}

TEST(collation, non_ignorable_110_334)
{
    // 02B2 0062;	
    // (ʲ) MODIFIER LETTER SMALL J	[1DB2 1CC6 | 0020 0020 | 0014 0002 |]

    uint32_t cps[2] = { 0x02B2, 0x0062 };
    uint32_t const ces[9] = { 0x1DB2, 0x1CC6, 0x0000, 0x0020, 0x0020, 0x0000, 0x0014, 0x0002, 0x0000 };

    auto collation = collate_for_tests(
        cps, cps + 2, boost::text::variable_weighting::non_ignorable);

    EXPECT_EQ(collation.size(), 9);
    EXPECT_TRUE(boost::algorithm::equal(collation.begin(), collation.end(), ces, ces + 9))
        << "from:     " << ce_dumper(cps)
        << "expected: " << ce_dumper(ces)
        << "got:      " << ce_dumper(collation);
}

TEST(collation, non_ignorable_110_335)
{
    // 2C7C 0062;	
    // (ⱼ) LATIN SUBSCRIPT SMALL LETTER J	[1DB2 1CC6 | 0020 0020 | 0015 0002 |]

    uint32_t cps[2] = { 0x2C7C, 0x0062 };
    uint32_t const ces[9] = { 0x1DB2, 0x1CC6, 0x0000, 0x0020, 0x0020, 0x0000, 0x0015, 0x0002, 0x0000 };

    auto collation = collate_for_tests(
        cps, cps + 2, boost::text::variable_weighting::non_ignorable);

    EXPECT_EQ(collation.size(), 9);
    EXPECT_TRUE(boost::algorithm::equal(collation.begin(), collation.end(), ces, ces + 9))
        << "from:     " << ce_dumper(cps)
        << "expected: " << ce_dumper(ces)
        << "got:      " << ce_dumper(collation);
}

TEST(collation, non_ignorable_110_336)
{
    // 1D36 0062;	
    // (ᴶ) MODIFIER LETTER CAPITAL J	[1DB2 1CC6 | 0020 0020 | 001D 0002 |]

    uint32_t cps[2] = { 0x1D36, 0x0062 };
    uint32_t const ces[9] = { 0x1DB2, 0x1CC6, 0x0000, 0x0020, 0x0020, 0x0000, 0x001D, 0x0002, 0x0000 };

    auto collation = collate_for_tests(
        cps, cps + 2, boost::text::variable_weighting::non_ignorable);

    EXPECT_EQ(collation.size(), 9);
    EXPECT_TRUE(boost::algorithm::equal(collation.begin(), collation.end(), ces, ces + 9))
        << "from:     " << ce_dumper(cps)
        << "expected: " << ce_dumper(ces)
        << "got:      " << ce_dumper(collation);
}

TEST(collation, non_ignorable_110_337)
{
    // 1F139 0062;	
    // (🄹) SQUARED LATIN CAPITAL LETTER J	[1DB2 1CC6 | 0020 0020 | 001D 0002 |]

    uint32_t cps[2] = { 0x1F139, 0x0062 };
    uint32_t const ces[9] = { 0x1DB2, 0x1CC6, 0x0000, 0x0020, 0x0020, 0x0000, 0x001D, 0x0002, 0x0000 };

    auto collation = collate_for_tests(
        cps, cps + 2, boost::text::variable_weighting::non_ignorable);

    EXPECT_EQ(collation.size(), 9);
    EXPECT_TRUE(boost::algorithm::equal(collation.begin(), collation.end(), ces, ces + 9))
        << "from:     " << ce_dumper(cps)
        << "expected: " << ce_dumper(ces)
        << "got:      " << ce_dumper(collation);
}

TEST(collation, non_ignorable_110_338)
{
    // 1F179 0062;	
    // (🅹) NEGATIVE SQUARED LATIN CAPITAL LETTER J	[1DB2 1CC6 | 0020 0020 | 001D 0002 |]

    uint32_t cps[2] = { 0x1F179, 0x0062 };
    uint32_t const ces[9] = { 0x1DB2, 0x1CC6, 0x0000, 0x0020, 0x0020, 0x0000, 0x001D, 0x0002, 0x0000 };

    auto collation = collate_for_tests(
        cps, cps + 2, boost::text::variable_weighting::non_ignorable);

    EXPECT_EQ(collation.size(), 9);
    EXPECT_TRUE(boost::algorithm::equal(collation.begin(), collation.end(), ces, ces + 9))
        << "from:     " << ce_dumper(cps)
        << "expected: " << ce_dumper(ces)
        << "got:      " << ce_dumper(collation);
}

TEST(collation, non_ignorable_110_339)
{
    // 0135 0062;	
    // (ĵ) LATIN SMALL LETTER J WITH CIRCUMFLEX	[1DB2 1CC6 | 0020 0027 0020 | 0002 0002 0002 |]

    uint32_t cps[2] = { 0x0135, 0x0062 };
    uint32_t const ces[11] = { 0x1DB2, 0x1CC6, 0x0000, 0x0020, 0x0027, 0x0020, 0x0000, 0x0002, 0x0002, 0x0002, 0x0000 };

    auto collation = collate_for_tests(
        cps, cps + 2, boost::text::variable_weighting::non_ignorable);

    EXPECT_EQ(collation.size(), 11);
    EXPECT_TRUE(boost::algorithm::equal(collation.begin(), collation.end(), ces, ces + 11))
        << "from:     " << ce_dumper(cps)
        << "expected: " << ce_dumper(ces)
        << "got:      " << ce_dumper(collation);
}

TEST(collation, non_ignorable_110_340)
{
    // 0134 0062;	
    // (Ĵ) LATIN CAPITAL LETTER J WITH CIRCUMFLEX	[1DB2 1CC6 | 0020 0027 0020 | 0008 0002 0002 |]

    uint32_t cps[2] = { 0x0134, 0x0062 };
    uint32_t const ces[11] = { 0x1DB2, 0x1CC6, 0x0000, 0x0020, 0x0027, 0x0020, 0x0000, 0x0008, 0x0002, 0x0002, 0x0000 };

    auto collation = collate_for_tests(
        cps, cps + 2, boost::text::variable_weighting::non_ignorable);

    EXPECT_EQ(collation.size(), 11);
    EXPECT_TRUE(boost::algorithm::equal(collation.begin(), collation.end(), ces, ces + 11))
        << "from:     " << ce_dumper(cps)
        << "expected: " << ce_dumper(ces)
        << "got:      " << ce_dumper(collation);
}

TEST(collation, non_ignorable_110_341)
{
    // 01F0 0062;	
    // (ǰ) LATIN SMALL LETTER J WITH CARON	[1DB2 1CC6 | 0020 0028 0020 | 0002 0002 0002 |]

    uint32_t cps[2] = { 0x01F0, 0x0062 };
    uint32_t const ces[11] = { 0x1DB2, 0x1CC6, 0x0000, 0x0020, 0x0028, 0x0020, 0x0000, 0x0002, 0x0002, 0x0002, 0x0000 };

    auto collation = collate_for_tests(
        cps, cps + 2, boost::text::variable_weighting::non_ignorable);

    EXPECT_EQ(collation.size(), 11);
    EXPECT_TRUE(boost::algorithm::equal(collation.begin(), collation.end(), ces, ces + 11))
        << "from:     " << ce_dumper(cps)
        << "expected: " << ce_dumper(ces)
        << "got:      " << ce_dumper(collation);
}

TEST(collation, non_ignorable_110_342)
{
    // 0237 0021;	
    // (ȷ) LATIN SMALL LETTER DOTLESS J	[1DB6 0261 | 0020 0020 | 0002 0002 |]

    uint32_t cps[2] = { 0x0237, 0x0021 };
    uint32_t const ces[9] = { 0x1DB6, 0x0261, 0x0000, 0x0020, 0x0020, 0x0000, 0x0002, 0x0002, 0x0000 };

    auto collation = collate_for_tests(
        cps, cps + 2, boost::text::variable_weighting::non_ignorable);

    EXPECT_EQ(collation.size(), 9);
    EXPECT_TRUE(boost::algorithm::equal(collation.begin(), collation.end(), ces, ces + 9))
        << "from:     " << ce_dumper(cps)
        << "expected: " << ce_dumper(ces)
        << "got:      " << ce_dumper(collation);
}

TEST(collation, non_ignorable_110_343)
{
    // 1D6A5 0021;	
    // (𝚥) MATHEMATICAL ITALIC SMALL DOTLESS J	[1DB6 0261 | 0020 0020 | 0005 0002 |]

    uint32_t cps[2] = { 0x1D6A5, 0x0021 };
    uint32_t const ces[9] = { 0x1DB6, 0x0261, 0x0000, 0x0020, 0x0020, 0x0000, 0x0005, 0x0002, 0x0000 };

    auto collation = collate_for_tests(
        cps, cps + 2, boost::text::variable_weighting::non_ignorable);

    EXPECT_EQ(collation.size(), 9);
    EXPECT_TRUE(boost::algorithm::equal(collation.begin(), collation.end(), ces, ces + 9))
        << "from:     " << ce_dumper(cps)
        << "expected: " << ce_dumper(ces)
        << "got:      " << ce_dumper(collation);
}

TEST(collation, non_ignorable_110_344)
{
    // 0237 003F;	
    // (ȷ) LATIN SMALL LETTER DOTLESS J	[1DB6 0267 | 0020 0020 | 0002 0002 |]

    uint32_t cps[2] = { 0x0237, 0x003F };
    uint32_t const ces[9] = { 0x1DB6, 0x0267, 0x0000, 0x0020, 0x0020, 0x0000, 0x0002, 0x0002, 0x0000 };

    auto collation = collate_for_tests(
        cps, cps + 2, boost::text::variable_weighting::non_ignorable);

    EXPECT_EQ(collation.size(), 9);
    EXPECT_TRUE(boost::algorithm::equal(collation.begin(), collation.end(), ces, ces + 9))
        << "from:     " << ce_dumper(cps)
        << "expected: " << ce_dumper(ces)
        << "got:      " << ce_dumper(collation);
}

TEST(collation, non_ignorable_110_345)
{
    // 1D6A5 003F;	
    // (𝚥) MATHEMATICAL ITALIC SMALL DOTLESS J	[1DB6 0267 | 0020 0020 | 0005 0002 |]

    uint32_t cps[2] = { 0x1D6A5, 0x003F };
    uint32_t const ces[9] = { 0x1DB6, 0x0267, 0x0000, 0x0020, 0x0020, 0x0000, 0x0005, 0x0002, 0x0000 };

    auto collation = collate_for_tests(
        cps, cps + 2, boost::text::variable_weighting::non_ignorable);

    EXPECT_EQ(collation.size(), 9);
    EXPECT_TRUE(boost::algorithm::equal(collation.begin(), collation.end(), ces, ces + 9))
        << "from:     " << ce_dumper(cps)
        << "expected: " << ce_dumper(ces)
        << "got:      " << ce_dumper(collation);
}

TEST(collation, non_ignorable_110_346)
{
    // 0237 0061;	
    // (ȷ) LATIN SMALL LETTER DOTLESS J	[1DB6 1CAD | 0020 0020 | 0002 0002 |]

    uint32_t cps[2] = { 0x0237, 0x0061 };
    uint32_t const ces[9] = { 0x1DB6, 0x1CAD, 0x0000, 0x0020, 0x0020, 0x0000, 0x0002, 0x0002, 0x0000 };

    auto collation = collate_for_tests(
        cps, cps + 2, boost::text::variable_weighting::non_ignorable);

    EXPECT_EQ(collation.size(), 9);
    EXPECT_TRUE(boost::algorithm::equal(collation.begin(), collation.end(), ces, ces + 9))
        << "from:     " << ce_dumper(cps)
        << "expected: " << ce_dumper(ces)
        << "got:      " << ce_dumper(collation);
}

TEST(collation, non_ignorable_110_347)
{
    // 0237 0041;	
    // (ȷ) LATIN SMALL LETTER DOTLESS J	[1DB6 1CAD | 0020 0020 | 0002 0008 |]

    uint32_t cps[2] = { 0x0237, 0x0041 };
    uint32_t const ces[9] = { 0x1DB6, 0x1CAD, 0x0000, 0x0020, 0x0020, 0x0000, 0x0002, 0x0008, 0x0000 };

    auto collation = collate_for_tests(
        cps, cps + 2, boost::text::variable_weighting::non_ignorable);

    EXPECT_EQ(collation.size(), 9);
    EXPECT_TRUE(boost::algorithm::equal(collation.begin(), collation.end(), ces, ces + 9))
        << "from:     " << ce_dumper(cps)
        << "expected: " << ce_dumper(ces)
        << "got:      " << ce_dumper(collation);
}

TEST(collation, non_ignorable_110_348)
{
    // 1D6A5 0061;	
    // (𝚥) MATHEMATICAL ITALIC SMALL DOTLESS J	[1DB6 1CAD | 0020 0020 | 0005 0002 |]

    uint32_t cps[2] = { 0x1D6A5, 0x0061 };
    uint32_t const ces[9] = { 0x1DB6, 0x1CAD, 0x0000, 0x0020, 0x0020, 0x0000, 0x0005, 0x0002, 0x0000 };

    auto collation = collate_for_tests(
        cps, cps + 2, boost::text::variable_weighting::non_ignorable);

    EXPECT_EQ(collation.size(), 9);
    EXPECT_TRUE(boost::algorithm::equal(collation.begin(), collation.end(), ces, ces + 9))
        << "from:     " << ce_dumper(cps)
        << "expected: " << ce_dumper(ces)
        << "got:      " << ce_dumper(collation);
}

TEST(collation, non_ignorable_110_349)
{
    // 1D6A5 0041;	
    // (𝚥) MATHEMATICAL ITALIC SMALL DOTLESS J	[1DB6 1CAD | 0020 0020 | 0005 0008 |]

    uint32_t cps[2] = { 0x1D6A5, 0x0041 };
    uint32_t const ces[9] = { 0x1DB6, 0x1CAD, 0x0000, 0x0020, 0x0020, 0x0000, 0x0005, 0x0008, 0x0000 };

    auto collation = collate_for_tests(
        cps, cps + 2, boost::text::variable_weighting::non_ignorable);

    EXPECT_EQ(collation.size(), 9);
    EXPECT_TRUE(boost::algorithm::equal(collation.begin(), collation.end(), ces, ces + 9))
        << "from:     " << ce_dumper(cps)
        << "expected: " << ce_dumper(ces)
        << "got:      " << ce_dumper(collation);
}

TEST(collation, non_ignorable_110_350)
{
    // 0237 0062;	
    // (ȷ) LATIN SMALL LETTER DOTLESS J	[1DB6 1CC6 | 0020 0020 | 0002 0002 |]

    uint32_t cps[2] = { 0x0237, 0x0062 };
    uint32_t const ces[9] = { 0x1DB6, 0x1CC6, 0x0000, 0x0020, 0x0020, 0x0000, 0x0002, 0x0002, 0x0000 };

    auto collation = collate_for_tests(
        cps, cps + 2, boost::text::variable_weighting::non_ignorable);

    EXPECT_EQ(collation.size(), 9);
    EXPECT_TRUE(boost::algorithm::equal(collation.begin(), collation.end(), ces, ces + 9))
        << "from:     " << ce_dumper(cps)
        << "expected: " << ce_dumper(ces)
        << "got:      " << ce_dumper(collation);
}

TEST(collation, non_ignorable_110_351)
{
    // 1D6A5 0062;	
    // (𝚥) MATHEMATICAL ITALIC SMALL DOTLESS J	[1DB6 1CC6 | 0020 0020 | 0005 0002 |]

    uint32_t cps[2] = { 0x1D6A5, 0x0062 };
    uint32_t const ces[9] = { 0x1DB6, 0x1CC6, 0x0000, 0x0020, 0x0020, 0x0000, 0x0005, 0x0002, 0x0000 };

    auto collation = collate_for_tests(
        cps, cps + 2, boost::text::variable_weighting::non_ignorable);

    EXPECT_EQ(collation.size(), 9);
    EXPECT_TRUE(boost::algorithm::equal(collation.begin(), collation.end(), ces, ces + 9))
        << "from:     " << ce_dumper(cps)
        << "expected: " << ce_dumper(ces)
        << "got:      " << ce_dumper(collation);
}

TEST(collation, non_ignorable_110_352)
{
    // 1D0A 0021;	
    // (ᴊ) LATIN LETTER SMALL CAPITAL J	[1DBA 0261 | 0020 0020 | 0002 0002 |]

    uint32_t cps[2] = { 0x1D0A, 0x0021 };
    uint32_t const ces[9] = { 0x1DBA, 0x0261, 0x0000, 0x0020, 0x0020, 0x0000, 0x0002, 0x0002, 0x0000 };

    auto collation = collate_for_tests(
        cps, cps + 2, boost::text::variable_weighting::non_ignorable);

    EXPECT_EQ(collation.size(), 9);
    EXPECT_TRUE(boost::algorithm::equal(collation.begin(), collation.end(), ces, ces + 9))
        << "from:     " << ce_dumper(cps)
        << "expected: " << ce_dumper(ces)
        << "got:      " << ce_dumper(collation);
}

TEST(collation, non_ignorable_110_353)
{
    // 1D0A 003F;	
    // (ᴊ) LATIN LETTER SMALL CAPITAL J	[1DBA 0267 | 0020 0020 | 0002 0002 |]

    uint32_t cps[2] = { 0x1D0A, 0x003F };
    uint32_t const ces[9] = { 0x1DBA, 0x0267, 0x0000, 0x0020, 0x0020, 0x0000, 0x0002, 0x0002, 0x0000 };

    auto collation = collate_for_tests(
        cps, cps + 2, boost::text::variable_weighting::non_ignorable);

    EXPECT_EQ(collation.size(), 9);
    EXPECT_TRUE(boost::algorithm::equal(collation.begin(), collation.end(), ces, ces + 9))
        << "from:     " << ce_dumper(cps)
        << "expected: " << ce_dumper(ces)
        << "got:      " << ce_dumper(collation);
}

TEST(collation, non_ignorable_110_354)
{
    // 1D0A 0061;	
    // (ᴊ) LATIN LETTER SMALL CAPITAL J	[1DBA 1CAD | 0020 0020 | 0002 0002 |]

    uint32_t cps[2] = { 0x1D0A, 0x0061 };
    uint32_t const ces[9] = { 0x1DBA, 0x1CAD, 0x0000, 0x0020, 0x0020, 0x0000, 0x0002, 0x0002, 0x0000 };

    auto collation = collate_for_tests(
        cps, cps + 2, boost::text::variable_weighting::non_ignorable);

    EXPECT_EQ(collation.size(), 9);
    EXPECT_TRUE(boost::algorithm::equal(collation.begin(), collation.end(), ces, ces + 9))
        << "from:     " << ce_dumper(cps)
        << "expected: " << ce_dumper(ces)
        << "got:      " << ce_dumper(collation);
}

TEST(collation, non_ignorable_110_355)
{
    // 1D0A 0041;	
    // (ᴊ) LATIN LETTER SMALL CAPITAL J	[1DBA 1CAD | 0020 0020 | 0002 0008 |]

    uint32_t cps[2] = { 0x1D0A, 0x0041 };
    uint32_t const ces[9] = { 0x1DBA, 0x1CAD, 0x0000, 0x0020, 0x0020, 0x0000, 0x0002, 0x0008, 0x0000 };

    auto collation = collate_for_tests(
        cps, cps + 2, boost::text::variable_weighting::non_ignorable);

    EXPECT_EQ(collation.size(), 9);
    EXPECT_TRUE(boost::algorithm::equal(collation.begin(), collation.end(), ces, ces + 9))
        << "from:     " << ce_dumper(cps)
        << "expected: " << ce_dumper(ces)
        << "got:      " << ce_dumper(collation);
}

TEST(collation, non_ignorable_110_356)
{
    // 1D0A 0062;	
    // (ᴊ) LATIN LETTER SMALL CAPITAL J	[1DBA 1CC6 | 0020 0020 | 0002 0002 |]

    uint32_t cps[2] = { 0x1D0A, 0x0062 };
    uint32_t const ces[9] = { 0x1DBA, 0x1CC6, 0x0000, 0x0020, 0x0020, 0x0000, 0x0002, 0x0002, 0x0000 };

    auto collation = collate_for_tests(
        cps, cps + 2, boost::text::variable_weighting::non_ignorable);

    EXPECT_EQ(collation.size(), 9);
    EXPECT_TRUE(boost::algorithm::equal(collation.begin(), collation.end(), ces, ces + 9))
        << "from:     " << ce_dumper(cps)
        << "expected: " << ce_dumper(ces)
        << "got:      " << ce_dumper(collation);
}

TEST(collation, non_ignorable_110_357)
{
    // 0249 0021;	
    // (ɉ) LATIN SMALL LETTER J WITH STROKE	[1DBB 0261 | 0020 0020 | 0002 0002 |]

    uint32_t cps[2] = { 0x0249, 0x0021 };
    uint32_t const ces[9] = { 0x1DBB, 0x0261, 0x0000, 0x0020, 0x0020, 0x0000, 0x0002, 0x0002, 0x0000 };

    auto collation = collate_for_tests(
        cps, cps + 2, boost::text::variable_weighting::non_ignorable);

    EXPECT_EQ(collation.size(), 9);
    EXPECT_TRUE(boost::algorithm::equal(collation.begin(), collation.end(), ces, ces + 9))
        << "from:     " << ce_dumper(cps)
        << "expected: " << ce_dumper(ces)
        << "got:      " << ce_dumper(collation);
}

TEST(collation, non_ignorable_110_358)
{
    // 0248 0021;	
    // (Ɉ) LATIN CAPITAL LETTER J WITH STROKE	[1DBB 0261 | 0020 0020 | 0008 0002 |]

    uint32_t cps[2] = { 0x0248, 0x0021 };
    uint32_t const ces[9] = { 0x1DBB, 0x0261, 0x0000, 0x0020, 0x0020, 0x0000, 0x0008, 0x0002, 0x0000 };

    auto collation = collate_for_tests(
        cps, cps + 2, boost::text::variable_weighting::non_ignorable);

    EXPECT_EQ(collation.size(), 9);
    EXPECT_TRUE(boost::algorithm::equal(collation.begin(), collation.end(), ces, ces + 9))
        << "from:     " << ce_dumper(cps)
        << "expected: " << ce_dumper(ces)
        << "got:      " << ce_dumper(collation);
}

TEST(collation, non_ignorable_110_359)
{
    // 0249 003F;	
    // (ɉ) LATIN SMALL LETTER J WITH STROKE	[1DBB 0267 | 0020 0020 | 0002 0002 |]

    uint32_t cps[2] = { 0x0249, 0x003F };
    uint32_t const ces[9] = { 0x1DBB, 0x0267, 0x0000, 0x0020, 0x0020, 0x0000, 0x0002, 0x0002, 0x0000 };

    auto collation = collate_for_tests(
        cps, cps + 2, boost::text::variable_weighting::non_ignorable);

    EXPECT_EQ(collation.size(), 9);
    EXPECT_TRUE(boost::algorithm::equal(collation.begin(), collation.end(), ces, ces + 9))
        << "from:     " << ce_dumper(cps)
        << "expected: " << ce_dumper(ces)
        << "got:      " << ce_dumper(collation);
}

TEST(collation, non_ignorable_110_360)
{
    // 0248 003F;	
    // (Ɉ) LATIN CAPITAL LETTER J WITH STROKE	[1DBB 0267 | 0020 0020 | 0008 0002 |]

    uint32_t cps[2] = { 0x0248, 0x003F };
    uint32_t const ces[9] = { 0x1DBB, 0x0267, 0x0000, 0x0020, 0x0020, 0x0000, 0x0008, 0x0002, 0x0000 };

    auto collation = collate_for_tests(
        cps, cps + 2, boost::text::variable_weighting::non_ignorable);

    EXPECT_EQ(collation.size(), 9);
    EXPECT_TRUE(boost::algorithm::equal(collation.begin(), collation.end(), ces, ces + 9))
        << "from:     " << ce_dumper(cps)
        << "expected: " << ce_dumper(ces)
        << "got:      " << ce_dumper(collation);
}

TEST(collation, non_ignorable_110_361)
{
    // 0249 0061;	
    // (ɉ) LATIN SMALL LETTER J WITH STROKE	[1DBB 1CAD | 0020 0020 | 0002 0002 |]

    uint32_t cps[2] = { 0x0249, 0x0061 };
    uint32_t const ces[9] = { 0x1DBB, 0x1CAD, 0x0000, 0x0020, 0x0020, 0x0000, 0x0002, 0x0002, 0x0000 };

    auto collation = collate_for_tests(
        cps, cps + 2, boost::text::variable_weighting::non_ignorable);

    EXPECT_EQ(collation.size(), 9);
    EXPECT_TRUE(boost::algorithm::equal(collation.begin(), collation.end(), ces, ces + 9))
        << "from:     " << ce_dumper(cps)
        << "expected: " << ce_dumper(ces)
        << "got:      " << ce_dumper(collation);
}

TEST(collation, non_ignorable_110_362)
{
    // 0249 0041;	
    // (ɉ) LATIN SMALL LETTER J WITH STROKE	[1DBB 1CAD | 0020 0020 | 0002 0008 |]

    uint32_t cps[2] = { 0x0249, 0x0041 };
    uint32_t const ces[9] = { 0x1DBB, 0x1CAD, 0x0000, 0x0020, 0x0020, 0x0000, 0x0002, 0x0008, 0x0000 };

    auto collation = collate_for_tests(
        cps, cps + 2, boost::text::variable_weighting::non_ignorable);

    EXPECT_EQ(collation.size(), 9);
    EXPECT_TRUE(boost::algorithm::equal(collation.begin(), collation.end(), ces, ces + 9))
        << "from:     " << ce_dumper(cps)
        << "expected: " << ce_dumper(ces)
        << "got:      " << ce_dumper(collation);
}

TEST(collation, non_ignorable_110_363)
{
    // 0248 0061;	
    // (Ɉ) LATIN CAPITAL LETTER J WITH STROKE	[1DBB 1CAD | 0020 0020 | 0008 0002 |]

    uint32_t cps[2] = { 0x0248, 0x0061 };
    uint32_t const ces[9] = { 0x1DBB, 0x1CAD, 0x0000, 0x0020, 0x0020, 0x0000, 0x0008, 0x0002, 0x0000 };

    auto collation = collate_for_tests(
        cps, cps + 2, boost::text::variable_weighting::non_ignorable);

    EXPECT_EQ(collation.size(), 9);
    EXPECT_TRUE(boost::algorithm::equal(collation.begin(), collation.end(), ces, ces + 9))
        << "from:     " << ce_dumper(cps)
        << "expected: " << ce_dumper(ces)
        << "got:      " << ce_dumper(collation);
}

TEST(collation, non_ignorable_110_364)
{
    // 0248 0041;	
    // (Ɉ) LATIN CAPITAL LETTER J WITH STROKE	[1DBB 1CAD | 0020 0020 | 0008 0008 |]

    uint32_t cps[2] = { 0x0248, 0x0041 };
    uint32_t const ces[9] = { 0x1DBB, 0x1CAD, 0x0000, 0x0020, 0x0020, 0x0000, 0x0008, 0x0008, 0x0000 };

    auto collation = collate_for_tests(
        cps, cps + 2, boost::text::variable_weighting::non_ignorable);

    EXPECT_EQ(collation.size(), 9);
    EXPECT_TRUE(boost::algorithm::equal(collation.begin(), collation.end(), ces, ces + 9))
        << "from:     " << ce_dumper(cps)
        << "expected: " << ce_dumper(ces)
        << "got:      " << ce_dumper(collation);
}

TEST(collation, non_ignorable_110_365)
{
    // 0249 0062;	
    // (ɉ) LATIN SMALL LETTER J WITH STROKE	[1DBB 1CC6 | 0020 0020 | 0002 0002 |]

    uint32_t cps[2] = { 0x0249, 0x0062 };
    uint32_t const ces[9] = { 0x1DBB, 0x1CC6, 0x0000, 0x0020, 0x0020, 0x0000, 0x0002, 0x0002, 0x0000 };

    auto collation = collate_for_tests(
        cps, cps + 2, boost::text::variable_weighting::non_ignorable);

    EXPECT_EQ(collation.size(), 9);
    EXPECT_TRUE(boost::algorithm::equal(collation.begin(), collation.end(), ces, ces + 9))
        << "from:     " << ce_dumper(cps)
        << "expected: " << ce_dumper(ces)
        << "got:      " << ce_dumper(collation);
}

TEST(collation, non_ignorable_110_366)
{
    // 0248 0062;	
    // (Ɉ) LATIN CAPITAL LETTER J WITH STROKE	[1DBB 1CC6 | 0020 0020 | 0008 0002 |]

    uint32_t cps[2] = { 0x0248, 0x0062 };
    uint32_t const ces[9] = { 0x1DBB, 0x1CC6, 0x0000, 0x0020, 0x0020, 0x0000, 0x0008, 0x0002, 0x0000 };

    auto collation = collate_for_tests(
        cps, cps + 2, boost::text::variable_weighting::non_ignorable);

    EXPECT_EQ(collation.size(), 9);
    EXPECT_TRUE(boost::algorithm::equal(collation.begin(), collation.end(), ces, ces + 9))
        << "from:     " << ce_dumper(cps)
        << "expected: " << ce_dumper(ces)
        << "got:      " << ce_dumper(collation);
}

TEST(collation, non_ignorable_110_367)
{
    // 029D 0021;	
    // (ʝ) LATIN SMALL LETTER J WITH CROSSED-TAIL	[1DBF 0261 | 0020 0020 | 0002 0002 |]

    uint32_t cps[2] = { 0x029D, 0x0021 };
    uint32_t const ces[9] = { 0x1DBF, 0x0261, 0x0000, 0x0020, 0x0020, 0x0000, 0x0002, 0x0002, 0x0000 };

    auto collation = collate_for_tests(
        cps, cps + 2, boost::text::variable_weighting::non_ignorable);

    EXPECT_EQ(collation.size(), 9);
    EXPECT_TRUE(boost::algorithm::equal(collation.begin(), collation.end(), ces, ces + 9))
        << "from:     " << ce_dumper(cps)
        << "expected: " << ce_dumper(ces)
        << "got:      " << ce_dumper(collation);
}

TEST(collation, non_ignorable_110_368)
{
    // A7B2 0021;	
    // (Ʝ) LATIN CAPITAL LETTER J WITH CROSSED-TAIL	[1DBF 0261 | 0020 0020 | 0008 0002 |]

    uint32_t cps[2] = { 0xA7B2, 0x0021 };
    uint32_t const ces[9] = { 0x1DBF, 0x0261, 0x0000, 0x0020, 0x0020, 0x0000, 0x0008, 0x0002, 0x0000 };

    auto collation = collate_for_tests(
        cps, cps + 2, boost::text::variable_weighting::non_ignorable);

    EXPECT_EQ(collation.size(), 9);
    EXPECT_TRUE(boost::algorithm::equal(collation.begin(), collation.end(), ces, ces + 9))
        << "from:     " << ce_dumper(cps)
        << "expected: " << ce_dumper(ces)
        << "got:      " << ce_dumper(collation);
}

TEST(collation, non_ignorable_110_369)
{
    // 1DA8 0021;	
    // (ᶨ) MODIFIER LETTER SMALL J WITH CROSSED-TAIL	[1DBF 0261 | 0020 0020 | 0014 0002 |]

    uint32_t cps[2] = { 0x1DA8, 0x0021 };
    uint32_t const ces[9] = { 0x1DBF, 0x0261, 0x0000, 0x0020, 0x0020, 0x0000, 0x0014, 0x0002, 0x0000 };

    auto collation = collate_for_tests(
        cps, cps + 2, boost::text::variable_weighting::non_ignorable);

    EXPECT_EQ(collation.size(), 9);
    EXPECT_TRUE(boost::algorithm::equal(collation.begin(), collation.end(), ces, ces + 9))
        << "from:     " << ce_dumper(cps)
        << "expected: " << ce_dumper(ces)
        << "got:      " << ce_dumper(collation);
}

TEST(collation, non_ignorable_110_370)
{
    // 029D 003F;	
    // (ʝ) LATIN SMALL LETTER J WITH CROSSED-TAIL	[1DBF 0267 | 0020 0020 | 0002 0002 |]

    uint32_t cps[2] = { 0x029D, 0x003F };
    uint32_t const ces[9] = { 0x1DBF, 0x0267, 0x0000, 0x0020, 0x0020, 0x0000, 0x0002, 0x0002, 0x0000 };

    auto collation = collate_for_tests(
        cps, cps + 2, boost::text::variable_weighting::non_ignorable);

    EXPECT_EQ(collation.size(), 9);
    EXPECT_TRUE(boost::algorithm::equal(collation.begin(), collation.end(), ces, ces + 9))
        << "from:     " << ce_dumper(cps)
        << "expected: " << ce_dumper(ces)
        << "got:      " << ce_dumper(collation);
}

TEST(collation, non_ignorable_110_371)
{
    // A7B2 003F;	
    // (Ʝ) LATIN CAPITAL LETTER J WITH CROSSED-TAIL	[1DBF 0267 | 0020 0020 | 0008 0002 |]

    uint32_t cps[2] = { 0xA7B2, 0x003F };
    uint32_t const ces[9] = { 0x1DBF, 0x0267, 0x0000, 0x0020, 0x0020, 0x0000, 0x0008, 0x0002, 0x0000 };

    auto collation = collate_for_tests(
        cps, cps + 2, boost::text::variable_weighting::non_ignorable);

    EXPECT_EQ(collation.size(), 9);
    EXPECT_TRUE(boost::algorithm::equal(collation.begin(), collation.end(), ces, ces + 9))
        << "from:     " << ce_dumper(cps)
        << "expected: " << ce_dumper(ces)
        << "got:      " << ce_dumper(collation);
}

TEST(collation, non_ignorable_110_372)
{
    // 1DA8 003F;	
    // (ᶨ) MODIFIER LETTER SMALL J WITH CROSSED-TAIL	[1DBF 0267 | 0020 0020 | 0014 0002 |]

    uint32_t cps[2] = { 0x1DA8, 0x003F };
    uint32_t const ces[9] = { 0x1DBF, 0x0267, 0x0000, 0x0020, 0x0020, 0x0000, 0x0014, 0x0002, 0x0000 };

    auto collation = collate_for_tests(
        cps, cps + 2, boost::text::variable_weighting::non_ignorable);

    EXPECT_EQ(collation.size(), 9);
    EXPECT_TRUE(boost::algorithm::equal(collation.begin(), collation.end(), ces, ces + 9))
        << "from:     " << ce_dumper(cps)
        << "expected: " << ce_dumper(ces)
        << "got:      " << ce_dumper(collation);
}

TEST(collation, non_ignorable_110_373)
{
    // 029D 0061;	
    // (ʝ) LATIN SMALL LETTER J WITH CROSSED-TAIL	[1DBF 1CAD | 0020 0020 | 0002 0002 |]

    uint32_t cps[2] = { 0x029D, 0x0061 };
    uint32_t const ces[9] = { 0x1DBF, 0x1CAD, 0x0000, 0x0020, 0x0020, 0x0000, 0x0002, 0x0002, 0x0000 };

    auto collation = collate_for_tests(
        cps, cps + 2, boost::text::variable_weighting::non_ignorable);

    EXPECT_EQ(collation.size(), 9);
    EXPECT_TRUE(boost::algorithm::equal(collation.begin(), collation.end(), ces, ces + 9))
        << "from:     " << ce_dumper(cps)
        << "expected: " << ce_dumper(ces)
        << "got:      " << ce_dumper(collation);
}

TEST(collation, non_ignorable_110_374)
{
    // 029D 0041;	
    // (ʝ) LATIN SMALL LETTER J WITH CROSSED-TAIL	[1DBF 1CAD | 0020 0020 | 0002 0008 |]

    uint32_t cps[2] = { 0x029D, 0x0041 };
    uint32_t const ces[9] = { 0x1DBF, 0x1CAD, 0x0000, 0x0020, 0x0020, 0x0000, 0x0002, 0x0008, 0x0000 };

    auto collation = collate_for_tests(
        cps, cps + 2, boost::text::variable_weighting::non_ignorable);

    EXPECT_EQ(collation.size(), 9);
    EXPECT_TRUE(boost::algorithm::equal(collation.begin(), collation.end(), ces, ces + 9))
        << "from:     " << ce_dumper(cps)
        << "expected: " << ce_dumper(ces)
        << "got:      " << ce_dumper(collation);
}

TEST(collation, non_ignorable_110_375)
{
    // A7B2 0061;	
    // (Ʝ) LATIN CAPITAL LETTER J WITH CROSSED-TAIL	[1DBF 1CAD | 0020 0020 | 0008 0002 |]

    uint32_t cps[2] = { 0xA7B2, 0x0061 };
    uint32_t const ces[9] = { 0x1DBF, 0x1CAD, 0x0000, 0x0020, 0x0020, 0x0000, 0x0008, 0x0002, 0x0000 };

    auto collation = collate_for_tests(
        cps, cps + 2, boost::text::variable_weighting::non_ignorable);

    EXPECT_EQ(collation.size(), 9);
    EXPECT_TRUE(boost::algorithm::equal(collation.begin(), collation.end(), ces, ces + 9))
        << "from:     " << ce_dumper(cps)
        << "expected: " << ce_dumper(ces)
        << "got:      " << ce_dumper(collation);
}

TEST(collation, non_ignorable_110_376)
{
    // A7B2 0041;	
    // (Ʝ) LATIN CAPITAL LETTER J WITH CROSSED-TAIL	[1DBF 1CAD | 0020 0020 | 0008 0008 |]

    uint32_t cps[2] = { 0xA7B2, 0x0041 };
    uint32_t const ces[9] = { 0x1DBF, 0x1CAD, 0x0000, 0x0020, 0x0020, 0x0000, 0x0008, 0x0008, 0x0000 };

    auto collation = collate_for_tests(
        cps, cps + 2, boost::text::variable_weighting::non_ignorable);

    EXPECT_EQ(collation.size(), 9);
    EXPECT_TRUE(boost::algorithm::equal(collation.begin(), collation.end(), ces, ces + 9))
        << "from:     " << ce_dumper(cps)
        << "expected: " << ce_dumper(ces)
        << "got:      " << ce_dumper(collation);
}

TEST(collation, non_ignorable_110_377)
{
    // 1DA8 0061;	
    // (ᶨ) MODIFIER LETTER SMALL J WITH CROSSED-TAIL	[1DBF 1CAD | 0020 0020 | 0014 0002 |]

    uint32_t cps[2] = { 0x1DA8, 0x0061 };
    uint32_t const ces[9] = { 0x1DBF, 0x1CAD, 0x0000, 0x0020, 0x0020, 0x0000, 0x0014, 0x0002, 0x0000 };

    auto collation = collate_for_tests(
        cps, cps + 2, boost::text::variable_weighting::non_ignorable);

    EXPECT_EQ(collation.size(), 9);
    EXPECT_TRUE(boost::algorithm::equal(collation.begin(), collation.end(), ces, ces + 9))
        << "from:     " << ce_dumper(cps)
        << "expected: " << ce_dumper(ces)
        << "got:      " << ce_dumper(collation);
}

TEST(collation, non_ignorable_110_378)
{
    // 1DA8 0041;	
    // (ᶨ) MODIFIER LETTER SMALL J WITH CROSSED-TAIL	[1DBF 1CAD | 0020 0020 | 0014 0008 |]

    uint32_t cps[2] = { 0x1DA8, 0x0041 };
    uint32_t const ces[9] = { 0x1DBF, 0x1CAD, 0x0000, 0x0020, 0x0020, 0x0000, 0x0014, 0x0008, 0x0000 };

    auto collation = collate_for_tests(
        cps, cps + 2, boost::text::variable_weighting::non_ignorable);

    EXPECT_EQ(collation.size(), 9);
    EXPECT_TRUE(boost::algorithm::equal(collation.begin(), collation.end(), ces, ces + 9))
        << "from:     " << ce_dumper(cps)
        << "expected: " << ce_dumper(ces)
        << "got:      " << ce_dumper(collation);
}

TEST(collation, non_ignorable_110_379)
{
    // 029D 0062;	
    // (ʝ) LATIN SMALL LETTER J WITH CROSSED-TAIL	[1DBF 1CC6 | 0020 0020 | 0002 0002 |]

    uint32_t cps[2] = { 0x029D, 0x0062 };
    uint32_t const ces[9] = { 0x1DBF, 0x1CC6, 0x0000, 0x0020, 0x0020, 0x0000, 0x0002, 0x0002, 0x0000 };

    auto collation = collate_for_tests(
        cps, cps + 2, boost::text::variable_weighting::non_ignorable);

    EXPECT_EQ(collation.size(), 9);
    EXPECT_TRUE(boost::algorithm::equal(collation.begin(), collation.end(), ces, ces + 9))
        << "from:     " << ce_dumper(cps)
        << "expected: " << ce_dumper(ces)
        << "got:      " << ce_dumper(collation);
}

TEST(collation, non_ignorable_110_380)
{
    // A7B2 0062;	
    // (Ʝ) LATIN CAPITAL LETTER J WITH CROSSED-TAIL	[1DBF 1CC6 | 0020 0020 | 0008 0002 |]

    uint32_t cps[2] = { 0xA7B2, 0x0062 };
    uint32_t const ces[9] = { 0x1DBF, 0x1CC6, 0x0000, 0x0020, 0x0020, 0x0000, 0x0008, 0x0002, 0x0000 };

    auto collation = collate_for_tests(
        cps, cps + 2, boost::text::variable_weighting::non_ignorable);

    EXPECT_EQ(collation.size(), 9);
    EXPECT_TRUE(boost::algorithm::equal(collation.begin(), collation.end(), ces, ces + 9))
        << "from:     " << ce_dumper(cps)
        << "expected: " << ce_dumper(ces)
        << "got:      " << ce_dumper(collation);
}

TEST(collation, non_ignorable_110_381)
{
    // 1DA8 0062;	
    // (ᶨ) MODIFIER LETTER SMALL J WITH CROSSED-TAIL	[1DBF 1CC6 | 0020 0020 | 0014 0002 |]

    uint32_t cps[2] = { 0x1DA8, 0x0062 };
    uint32_t const ces[9] = { 0x1DBF, 0x1CC6, 0x0000, 0x0020, 0x0020, 0x0000, 0x0014, 0x0002, 0x0000 };

    auto collation = collate_for_tests(
        cps, cps + 2, boost::text::variable_weighting::non_ignorable);

    EXPECT_EQ(collation.size(), 9);
    EXPECT_TRUE(boost::algorithm::equal(collation.begin(), collation.end(), ces, ces + 9))
        << "from:     " << ce_dumper(cps)
        << "expected: " << ce_dumper(ces)
        << "got:      " << ce_dumper(collation);
}

TEST(collation, non_ignorable_110_382)
{
    // 025F 0021;	
    // (ɟ) LATIN SMALL LETTER DOTLESS J WITH STROKE	[1DC3 0261 | 0020 0020 | 0002 0002 |]

    uint32_t cps[2] = { 0x025F, 0x0021 };
    uint32_t const ces[9] = { 0x1DC3, 0x0261, 0x0000, 0x0020, 0x0020, 0x0000, 0x0002, 0x0002, 0x0000 };

    auto collation = collate_for_tests(
        cps, cps + 2, boost::text::variable_weighting::non_ignorable);

    EXPECT_EQ(collation.size(), 9);
    EXPECT_TRUE(boost::algorithm::equal(collation.begin(), collation.end(), ces, ces + 9))
        << "from:     " << ce_dumper(cps)
        << "expected: " << ce_dumper(ces)
        << "got:      " << ce_dumper(collation);
}

TEST(collation, non_ignorable_110_383)
{
    // 1DA1 0021;	
    // (ᶡ) MODIFIER LETTER SMALL DOTLESS J WITH STROKE	[1DC3 0261 | 0020 0020 | 0014 0002 |]

    uint32_t cps[2] = { 0x1DA1, 0x0021 };
    uint32_t const ces[9] = { 0x1DC3, 0x0261, 0x0000, 0x0020, 0x0020, 0x0000, 0x0014, 0x0002, 0x0000 };

    auto collation = collate_for_tests(
        cps, cps + 2, boost::text::variable_weighting::non_ignorable);

    EXPECT_EQ(collation.size(), 9);
    EXPECT_TRUE(boost::algorithm::equal(collation.begin(), collation.end(), ces, ces + 9))
        << "from:     " << ce_dumper(cps)
        << "expected: " << ce_dumper(ces)
        << "got:      " << ce_dumper(collation);
}

TEST(collation, non_ignorable_110_384)
{
    // 025F 003F;	
    // (ɟ) LATIN SMALL LETTER DOTLESS J WITH STROKE	[1DC3 0267 | 0020 0020 | 0002 0002 |]

    uint32_t cps[2] = { 0x025F, 0x003F };
    uint32_t const ces[9] = { 0x1DC3, 0x0267, 0x0000, 0x0020, 0x0020, 0x0000, 0x0002, 0x0002, 0x0000 };

    auto collation = collate_for_tests(
        cps, cps + 2, boost::text::variable_weighting::non_ignorable);

    EXPECT_EQ(collation.size(), 9);
    EXPECT_TRUE(boost::algorithm::equal(collation.begin(), collation.end(), ces, ces + 9))
        << "from:     " << ce_dumper(cps)
        << "expected: " << ce_dumper(ces)
        << "got:      " << ce_dumper(collation);
}

TEST(collation, non_ignorable_110_385)
{
    // 1DA1 003F;	
    // (ᶡ) MODIFIER LETTER SMALL DOTLESS J WITH STROKE	[1DC3 0267 | 0020 0020 | 0014 0002 |]

    uint32_t cps[2] = { 0x1DA1, 0x003F };
    uint32_t const ces[9] = { 0x1DC3, 0x0267, 0x0000, 0x0020, 0x0020, 0x0000, 0x0014, 0x0002, 0x0000 };

    auto collation = collate_for_tests(
        cps, cps + 2, boost::text::variable_weighting::non_ignorable);

    EXPECT_EQ(collation.size(), 9);
    EXPECT_TRUE(boost::algorithm::equal(collation.begin(), collation.end(), ces, ces + 9))
        << "from:     " << ce_dumper(cps)
        << "expected: " << ce_dumper(ces)
        << "got:      " << ce_dumper(collation);
}

TEST(collation, non_ignorable_110_386)
{
    // 025F 0061;	
    // (ɟ) LATIN SMALL LETTER DOTLESS J WITH STROKE	[1DC3 1CAD | 0020 0020 | 0002 0002 |]

    uint32_t cps[2] = { 0x025F, 0x0061 };
    uint32_t const ces[9] = { 0x1DC3, 0x1CAD, 0x0000, 0x0020, 0x0020, 0x0000, 0x0002, 0x0002, 0x0000 };

    auto collation = collate_for_tests(
        cps, cps + 2, boost::text::variable_weighting::non_ignorable);

    EXPECT_EQ(collation.size(), 9);
    EXPECT_TRUE(boost::algorithm::equal(collation.begin(), collation.end(), ces, ces + 9))
        << "from:     " << ce_dumper(cps)
        << "expected: " << ce_dumper(ces)
        << "got:      " << ce_dumper(collation);
}

TEST(collation, non_ignorable_110_387)
{
    // 025F 0041;	
    // (ɟ) LATIN SMALL LETTER DOTLESS J WITH STROKE	[1DC3 1CAD | 0020 0020 | 0002 0008 |]

    uint32_t cps[2] = { 0x025F, 0x0041 };
    uint32_t const ces[9] = { 0x1DC3, 0x1CAD, 0x0000, 0x0020, 0x0020, 0x0000, 0x0002, 0x0008, 0x0000 };

    auto collation = collate_for_tests(
        cps, cps + 2, boost::text::variable_weighting::non_ignorable);

    EXPECT_EQ(collation.size(), 9);
    EXPECT_TRUE(boost::algorithm::equal(collation.begin(), collation.end(), ces, ces + 9))
        << "from:     " << ce_dumper(cps)
        << "expected: " << ce_dumper(ces)
        << "got:      " << ce_dumper(collation);
}

TEST(collation, non_ignorable_110_388)
{
    // 1DA1 0061;	
    // (ᶡ) MODIFIER LETTER SMALL DOTLESS J WITH STROKE	[1DC3 1CAD | 0020 0020 | 0014 0002 |]

    uint32_t cps[2] = { 0x1DA1, 0x0061 };
    uint32_t const ces[9] = { 0x1DC3, 0x1CAD, 0x0000, 0x0020, 0x0020, 0x0000, 0x0014, 0x0002, 0x0000 };

    auto collation = collate_for_tests(
        cps, cps + 2, boost::text::variable_weighting::non_ignorable);

    EXPECT_EQ(collation.size(), 9);
    EXPECT_TRUE(boost::algorithm::equal(collation.begin(), collation.end(), ces, ces + 9))
        << "from:     " << ce_dumper(cps)
        << "expected: " << ce_dumper(ces)
        << "got:      " << ce_dumper(collation);
}

TEST(collation, non_ignorable_110_389)
{
    // 1DA1 0041;	
    // (ᶡ) MODIFIER LETTER SMALL DOTLESS J WITH STROKE	[1DC3 1CAD | 0020 0020 | 0014 0008 |]

    uint32_t cps[2] = { 0x1DA1, 0x0041 };
    uint32_t const ces[9] = { 0x1DC3, 0x1CAD, 0x0000, 0x0020, 0x0020, 0x0000, 0x0014, 0x0008, 0x0000 };

    auto collation = collate_for_tests(
        cps, cps + 2, boost::text::variable_weighting::non_ignorable);

    EXPECT_EQ(collation.size(), 9);
    EXPECT_TRUE(boost::algorithm::equal(collation.begin(), collation.end(), ces, ces + 9))
        << "from:     " << ce_dumper(cps)
        << "expected: " << ce_dumper(ces)
        << "got:      " << ce_dumper(collation);
}

TEST(collation, non_ignorable_110_390)
{
    // 025F 0062;	
    // (ɟ) LATIN SMALL LETTER DOTLESS J WITH STROKE	[1DC3 1CC6 | 0020 0020 | 0002 0002 |]

    uint32_t cps[2] = { 0x025F, 0x0062 };
    uint32_t const ces[9] = { 0x1DC3, 0x1CC6, 0x0000, 0x0020, 0x0020, 0x0000, 0x0002, 0x0002, 0x0000 };

    auto collation = collate_for_tests(
        cps, cps + 2, boost::text::variable_weighting::non_ignorable);

    EXPECT_EQ(collation.size(), 9);
    EXPECT_TRUE(boost::algorithm::equal(collation.begin(), collation.end(), ces, ces + 9))
        << "from:     " << ce_dumper(cps)
        << "expected: " << ce_dumper(ces)
        << "got:      " << ce_dumper(collation);
}

TEST(collation, non_ignorable_110_391)
{
    // 1DA1 0062;	
    // (ᶡ) MODIFIER LETTER SMALL DOTLESS J WITH STROKE	[1DC3 1CC6 | 0020 0020 | 0014 0002 |]

    uint32_t cps[2] = { 0x1DA1, 0x0062 };
    uint32_t const ces[9] = { 0x1DC3, 0x1CC6, 0x0000, 0x0020, 0x0020, 0x0000, 0x0014, 0x0002, 0x0000 };

    auto collation = collate_for_tests(
        cps, cps + 2, boost::text::variable_weighting::non_ignorable);

    EXPECT_EQ(collation.size(), 9);
    EXPECT_TRUE(boost::algorithm::equal(collation.begin(), collation.end(), ces, ces + 9))
        << "from:     " << ce_dumper(cps)
        << "expected: " << ce_dumper(ces)
        << "got:      " << ce_dumper(collation);
}

TEST(collation, non_ignorable_110_392)
{
    // 0284 0021;	
    // (ʄ) LATIN SMALL LETTER DOTLESS J WITH STROKE AND HOOK	[1DC7 0261 | 0020 0020 | 0002 0002 |]

    uint32_t cps[2] = { 0x0284, 0x0021 };
    uint32_t const ces[9] = { 0x1DC7, 0x0261, 0x0000, 0x0020, 0x0020, 0x0000, 0x0002, 0x0002, 0x0000 };

    auto collation = collate_for_tests(
        cps, cps + 2, boost::text::variable_weighting::non_ignorable);

    EXPECT_EQ(collation.size(), 9);
    EXPECT_TRUE(boost::algorithm::equal(collation.begin(), collation.end(), ces, ces + 9))
        << "from:     " << ce_dumper(cps)
        << "expected: " << ce_dumper(ces)
        << "got:      " << ce_dumper(collation);
}

TEST(collation, non_ignorable_110_393)
{
    // 0284 003F;	
    // (ʄ) LATIN SMALL LETTER DOTLESS J WITH STROKE AND HOOK	[1DC7 0267 | 0020 0020 | 0002 0002 |]

    uint32_t cps[2] = { 0x0284, 0x003F };
    uint32_t const ces[9] = { 0x1DC7, 0x0267, 0x0000, 0x0020, 0x0020, 0x0000, 0x0002, 0x0002, 0x0000 };

    auto collation = collate_for_tests(
        cps, cps + 2, boost::text::variable_weighting::non_ignorable);

    EXPECT_EQ(collation.size(), 9);
    EXPECT_TRUE(boost::algorithm::equal(collation.begin(), collation.end(), ces, ces + 9))
        << "from:     " << ce_dumper(cps)
        << "expected: " << ce_dumper(ces)
        << "got:      " << ce_dumper(collation);
}

TEST(collation, non_ignorable_110_394)
{
    // 0284 0061;	
    // (ʄ) LATIN SMALL LETTER DOTLESS J WITH STROKE AND HOOK	[1DC7 1CAD | 0020 0020 | 0002 0002 |]

    uint32_t cps[2] = { 0x0284, 0x0061 };
    uint32_t const ces[9] = { 0x1DC7, 0x1CAD, 0x0000, 0x0020, 0x0020, 0x0000, 0x0002, 0x0002, 0x0000 };

    auto collation = collate_for_tests(
        cps, cps + 2, boost::text::variable_weighting::non_ignorable);

    EXPECT_EQ(collation.size(), 9);
    EXPECT_TRUE(boost::algorithm::equal(collation.begin(), collation.end(), ces, ces + 9))
        << "from:     " << ce_dumper(cps)
        << "expected: " << ce_dumper(ces)
        << "got:      " << ce_dumper(collation);
}

TEST(collation, non_ignorable_110_395)
{
    // 0284 0041;	
    // (ʄ) LATIN SMALL LETTER DOTLESS J WITH STROKE AND HOOK	[1DC7 1CAD | 0020 0020 | 0002 0008 |]

    uint32_t cps[2] = { 0x0284, 0x0041 };
    uint32_t const ces[9] = { 0x1DC7, 0x1CAD, 0x0000, 0x0020, 0x0020, 0x0000, 0x0002, 0x0008, 0x0000 };

    auto collation = collate_for_tests(
        cps, cps + 2, boost::text::variable_weighting::non_ignorable);

    EXPECT_EQ(collation.size(), 9);
    EXPECT_TRUE(boost::algorithm::equal(collation.begin(), collation.end(), ces, ces + 9))
        << "from:     " << ce_dumper(cps)
        << "expected: " << ce_dumper(ces)
        << "got:      " << ce_dumper(collation);
}

TEST(collation, non_ignorable_110_396)
{
    // 0284 0062;	
    // (ʄ) LATIN SMALL LETTER DOTLESS J WITH STROKE AND HOOK	[1DC7 1CC6 | 0020 0020 | 0002 0002 |]

    uint32_t cps[2] = { 0x0284, 0x0062 };
    uint32_t const ces[9] = { 0x1DC7, 0x1CC6, 0x0000, 0x0020, 0x0020, 0x0000, 0x0002, 0x0002, 0x0000 };

    auto collation = collate_for_tests(
        cps, cps + 2, boost::text::variable_weighting::non_ignorable);

    EXPECT_EQ(collation.size(), 9);
    EXPECT_TRUE(boost::algorithm::equal(collation.begin(), collation.end(), ces, ces + 9))
        << "from:     " << ce_dumper(cps)
        << "expected: " << ce_dumper(ces)
        << "got:      " << ce_dumper(collation);
}

TEST(collation, non_ignorable_110_397)
{
    // 006B 0301 0334;	
    // (ḱ) LATIN SMALL LETTER K, COMBINING ACUTE ACCENT	[1DCB | 0020 004A 0024 | 0002 0002 0002 |]

    uint32_t cps[3] = { 0x006B, 0x0301, 0x0334 };
    uint32_t const ces[10] = { 0x1DCB, 0x0000, 0x0020, 0x004A, 0x0024, 0x0000, 0x0002, 0x0002, 0x0002, 0x0000 };

    auto collation = collate_for_tests(
        cps, cps + 3, boost::text::variable_weighting::non_ignorable);

    EXPECT_EQ(collation.size(), 10);
    EXPECT_TRUE(boost::algorithm::equal(collation.begin(), collation.end(), ces, ces + 10))
        << "from:     " << ce_dumper(cps)
        << "expected: " << ce_dumper(ces)
        << "got:      " << ce_dumper(collation);
}

TEST(collation, non_ignorable_110_398)
{
    // 006B 0334 0301;	
    // (k̴) LATIN SMALL LETTER K, COMBINING TILDE OVERLAY	[1DCB | 0020 004A 0024 | 0002 0002 0002 |]

    uint32_t cps[3] = { 0x006B, 0x0334, 0x0301 };
    uint32_t const ces[10] = { 0x1DCB, 0x0000, 0x0020, 0x004A, 0x0024, 0x0000, 0x0002, 0x0002, 0x0002, 0x0000 };

    auto collation = collate_for_tests(
        cps, cps + 3, boost::text::variable_weighting::non_ignorable);

    EXPECT_EQ(collation.size(), 10);
    EXPECT_TRUE(boost::algorithm::equal(collation.begin(), collation.end(), ces, ces + 10))
        << "from:     " << ce_dumper(cps)
        << "expected: " << ce_dumper(ces)
        << "got:      " << ce_dumper(collation);
}

TEST(collation, non_ignorable_110_399)
{
    // 006B 0334 0341;	
    // (k̴) LATIN SMALL LETTER K, COMBINING TILDE OVERLAY	[1DCB | 0020 004A 0024 | 0002 0002 0002 |]

    uint32_t cps[3] = { 0x006B, 0x0334, 0x0341 };
    uint32_t const ces[10] = { 0x1DCB, 0x0000, 0x0020, 0x004A, 0x0024, 0x0000, 0x0002, 0x0002, 0x0002, 0x0000 };

    auto collation = collate_for_tests(
        cps, cps + 3, boost::text::variable_weighting::non_ignorable);

    EXPECT_EQ(collation.size(), 10);
    EXPECT_TRUE(boost::algorithm::equal(collation.begin(), collation.end(), ces, ces + 10))
        << "from:     " << ce_dumper(cps)
        << "expected: " << ce_dumper(ces)
        << "got:      " << ce_dumper(collation);
}

TEST(collation, non_ignorable_110_400)
{
    // 1E31 0334;	
    // (ḱ) LATIN SMALL LETTER K WITH ACUTE	[1DCB | 0020 004A 0024 | 0002 0002 0002 |]

    uint32_t cps[2] = { 0x1E31, 0x0334 };
    uint32_t const ces[10] = { 0x1DCB, 0x0000, 0x0020, 0x004A, 0x0024, 0x0000, 0x0002, 0x0002, 0x0002, 0x0000 };

    auto collation = collate_for_tests(
        cps, cps + 2, boost::text::variable_weighting::non_ignorable);

    EXPECT_EQ(collation.size(), 10);
    EXPECT_TRUE(boost::algorithm::equal(collation.begin(), collation.end(), ces, ces + 10))
        << "from:     " << ce_dumper(cps)
        << "expected: " << ce_dumper(ces)
        << "got:      " << ce_dumper(collation);
}

TEST(collation, non_ignorable_110_401)
{
    // 004B 0334 0301;	
    // (K̴) LATIN CAPITAL LETTER K, COMBINING TILDE OVERLAY	[1DCB | 0020 004A 0024 | 0008 0002 0002 |]

    uint32_t cps[3] = { 0x004B, 0x0334, 0x0301 };
    uint32_t const ces[10] = { 0x1DCB, 0x0000, 0x0020, 0x004A, 0x0024, 0x0000, 0x0008, 0x0002, 0x0002, 0x0000 };

    auto collation = collate_for_tests(
        cps, cps + 3, boost::text::variable_weighting::non_ignorable);

    EXPECT_EQ(collation.size(), 10);
    EXPECT_TRUE(boost::algorithm::equal(collation.begin(), collation.end(), ces, ces + 10))
        << "from:     " << ce_dumper(cps)
        << "expected: " << ce_dumper(ces)
        << "got:      " << ce_dumper(collation);
}

TEST(collation, non_ignorable_110_402)
{
    // 1E30 0334;	
    // (Ḱ) LATIN CAPITAL LETTER K WITH ACUTE	[1DCB | 0020 004A 0024 | 0008 0002 0002 |]

    uint32_t cps[2] = { 0x1E30, 0x0334 };
    uint32_t const ces[10] = { 0x1DCB, 0x0000, 0x0020, 0x004A, 0x0024, 0x0000, 0x0008, 0x0002, 0x0002, 0x0000 };

    auto collation = collate_for_tests(
        cps, cps + 2, boost::text::variable_weighting::non_ignorable);

    EXPECT_EQ(collation.size(), 10);
    EXPECT_TRUE(boost::algorithm::equal(collation.begin(), collation.end(), ces, ces + 10))
        << "from:     " << ce_dumper(cps)
        << "expected: " << ce_dumper(ces)
        << "got:      " << ce_dumper(collation);
}

TEST(collation, non_ignorable_110_403)
{
    // 212A 0301 0334;	
    // (Ḱ) KELVIN SIGN, COMBINING ACUTE ACCENT	[1DCB | 0020 004A 0024 | 0008 0002 0002 |]

    uint32_t cps[3] = { 0x212A, 0x0301, 0x0334 };
    uint32_t const ces[10] = { 0x1DCB, 0x0000, 0x0020, 0x004A, 0x0024, 0x0000, 0x0008, 0x0002, 0x0002, 0x0000 };

    auto collation = collate_for_tests(
        cps, cps + 3, boost::text::variable_weighting::non_ignorable);

    EXPECT_EQ(collation.size(), 10);
    EXPECT_TRUE(boost::algorithm::equal(collation.begin(), collation.end(), ces, ces + 10))
        << "from:     " << ce_dumper(cps)
        << "expected: " << ce_dumper(ces)
        << "got:      " << ce_dumper(collation);
}

TEST(collation, non_ignorable_110_404)
{
    // 212A 0341 0334;	
    // (Ḱ) KELVIN SIGN, COMBINING ACUTE TONE MARK	[1DCB | 0020 004A 0024 | 0008 0002 0002 |]

    uint32_t cps[3] = { 0x212A, 0x0341, 0x0334 };
    uint32_t const ces[10] = { 0x1DCB, 0x0000, 0x0020, 0x004A, 0x0024, 0x0000, 0x0008, 0x0002, 0x0002, 0x0000 };

    auto collation = collate_for_tests(
        cps, cps + 3, boost::text::variable_weighting::non_ignorable);

    EXPECT_EQ(collation.size(), 10);
    EXPECT_TRUE(boost::algorithm::equal(collation.begin(), collation.end(), ces, ces + 10))
        << "from:     " << ce_dumper(cps)
        << "expected: " << ce_dumper(ces)
        << "got:      " << ce_dumper(collation);
}

TEST(collation, non_ignorable_110_405)
{
    // 006B 030C 0334;	
    // (ǩ) LATIN SMALL LETTER K, COMBINING CARON	[1DCB | 0020 004A 0028 | 0002 0002 0002 |]

    uint32_t cps[3] = { 0x006B, 0x030C, 0x0334 };
    uint32_t const ces[10] = { 0x1DCB, 0x0000, 0x0020, 0x004A, 0x0028, 0x0000, 0x0002, 0x0002, 0x0002, 0x0000 };

    auto collation = collate_for_tests(
        cps, cps + 3, boost::text::variable_weighting::non_ignorable);

    EXPECT_EQ(collation.size(), 10);
    EXPECT_TRUE(boost::algorithm::equal(collation.begin(), collation.end(), ces, ces + 10))
        << "from:     " << ce_dumper(cps)
        << "expected: " << ce_dumper(ces)
        << "got:      " << ce_dumper(collation);
}

TEST(collation, non_ignorable_110_406)
{
    // 006B 0334 030C;	
    // (k̴) LATIN SMALL LETTER K, COMBINING TILDE OVERLAY	[1DCB | 0020 004A 0028 | 0002 0002 0002 |]

    uint32_t cps[3] = { 0x006B, 0x0334, 0x030C };
    uint32_t const ces[10] = { 0x1DCB, 0x0000, 0x0020, 0x004A, 0x0028, 0x0000, 0x0002, 0x0002, 0x0002, 0x0000 };

    auto collation = collate_for_tests(
        cps, cps + 3, boost::text::variable_weighting::non_ignorable);

    EXPECT_EQ(collation.size(), 10);
    EXPECT_TRUE(boost::algorithm::equal(collation.begin(), collation.end(), ces, ces + 10))
        << "from:     " << ce_dumper(cps)
        << "expected: " << ce_dumper(ces)
        << "got:      " << ce_dumper(collation);
}

TEST(collation, non_ignorable_110_407)
{
    // 01E9 0334;	
    // (ǩ) LATIN SMALL LETTER K WITH CARON	[1DCB | 0020 004A 0028 | 0002 0002 0002 |]

    uint32_t cps[2] = { 0x01E9, 0x0334 };
    uint32_t const ces[10] = { 0x1DCB, 0x0000, 0x0020, 0x004A, 0x0028, 0x0000, 0x0002, 0x0002, 0x0002, 0x0000 };

    auto collation = collate_for_tests(
        cps, cps + 2, boost::text::variable_weighting::non_ignorable);

    EXPECT_EQ(collation.size(), 10);
    EXPECT_TRUE(boost::algorithm::equal(collation.begin(), collation.end(), ces, ces + 10))
        << "from:     " << ce_dumper(cps)
        << "expected: " << ce_dumper(ces)
        << "got:      " << ce_dumper(collation);
}

TEST(collation, non_ignorable_110_408)
{
    // 004B 030C 0334;	
    // (Ǩ) LATIN CAPITAL LETTER K, COMBINING CARON	[1DCB | 0020 004A 0028 | 0008 0002 0002 |]

    uint32_t cps[3] = { 0x004B, 0x030C, 0x0334 };
    uint32_t const ces[10] = { 0x1DCB, 0x0000, 0x0020, 0x004A, 0x0028, 0x0000, 0x0008, 0x0002, 0x0002, 0x0000 };

    auto collation = collate_for_tests(
        cps, cps + 3, boost::text::variable_weighting::non_ignorable);

    EXPECT_EQ(collation.size(), 10);
    EXPECT_TRUE(boost::algorithm::equal(collation.begin(), collation.end(), ces, ces + 10))
        << "from:     " << ce_dumper(cps)
        << "expected: " << ce_dumper(ces)
        << "got:      " << ce_dumper(collation);
}

TEST(collation, non_ignorable_110_409)
{
    // 004B 0334 030C;	
    // (K̴) LATIN CAPITAL LETTER K, COMBINING TILDE OVERLAY	[1DCB | 0020 004A 0028 | 0008 0002 0002 |]

    uint32_t cps[3] = { 0x004B, 0x0334, 0x030C };
    uint32_t const ces[10] = { 0x1DCB, 0x0000, 0x0020, 0x004A, 0x0028, 0x0000, 0x0008, 0x0002, 0x0002, 0x0000 };

    auto collation = collate_for_tests(
        cps, cps + 3, boost::text::variable_weighting::non_ignorable);

    EXPECT_EQ(collation.size(), 10);
    EXPECT_TRUE(boost::algorithm::equal(collation.begin(), collation.end(), ces, ces + 10))
        << "from:     " << ce_dumper(cps)
        << "expected: " << ce_dumper(ces)
        << "got:      " << ce_dumper(collation);
}

TEST(collation, non_ignorable_110_410)
{
    // 01E8 0334;	
    // (Ǩ) LATIN CAPITAL LETTER K WITH CARON	[1DCB | 0020 004A 0028 | 0008 0002 0002 |]

    uint32_t cps[2] = { 0x01E8, 0x0334 };
    uint32_t const ces[10] = { 0x1DCB, 0x0000, 0x0020, 0x004A, 0x0028, 0x0000, 0x0008, 0x0002, 0x0002, 0x0000 };

    auto collation = collate_for_tests(
        cps, cps + 2, boost::text::variable_weighting::non_ignorable);

    EXPECT_EQ(collation.size(), 10);
    EXPECT_TRUE(boost::algorithm::equal(collation.begin(), collation.end(), ces, ces + 10))
        << "from:     " << ce_dumper(cps)
        << "expected: " << ce_dumper(ces)
        << "got:      " << ce_dumper(collation);
}

TEST(collation, non_ignorable_110_411)
{
    // 212A 0334 030C;	
    // (K̴) KELVIN SIGN, COMBINING TILDE OVERLAY	[1DCB | 0020 004A 0028 | 0008 0002 0002 |]

    uint32_t cps[3] = { 0x212A, 0x0334, 0x030C };
    uint32_t const ces[10] = { 0x1DCB, 0x0000, 0x0020, 0x004A, 0x0028, 0x0000, 0x0008, 0x0002, 0x0002, 0x0000 };

    auto collation = collate_for_tests(
        cps, cps + 3, boost::text::variable_weighting::non_ignorable);

    EXPECT_EQ(collation.size(), 10);
    EXPECT_TRUE(boost::algorithm::equal(collation.begin(), collation.end(), ces, ces + 10))
        << "from:     " << ce_dumper(cps)
        << "expected: " << ce_dumper(ces)
        << "got:      " << ce_dumper(collation);
}

TEST(collation, non_ignorable_110_412)
{
    // 006B 0327 0334;	
    // (ķ) LATIN SMALL LETTER K, COMBINING CEDILLA	[1DCB | 0020 004A 0030 | 0002 0002 0002 |]

    uint32_t cps[3] = { 0x006B, 0x0327, 0x0334 };
    uint32_t const ces[10] = { 0x1DCB, 0x0000, 0x0020, 0x004A, 0x0030, 0x0000, 0x0002, 0x0002, 0x0002, 0x0000 };

    auto collation = collate_for_tests(
        cps, cps + 3, boost::text::variable_weighting::non_ignorable);

    EXPECT_EQ(collation.size(), 10);
    EXPECT_TRUE(boost::algorithm::equal(collation.begin(), collation.end(), ces, ces + 10))
        << "from:     " << ce_dumper(cps)
        << "expected: " << ce_dumper(ces)
        << "got:      " << ce_dumper(collation);
}

TEST(collation, non_ignorable_110_413)
{
    // 006B 0334 0327;	
    // (k̴) LATIN SMALL LETTER K, COMBINING TILDE OVERLAY	[1DCB | 0020 004A 0030 | 0002 0002 0002 |]

    uint32_t cps[3] = { 0x006B, 0x0334, 0x0327 };
    uint32_t const ces[10] = { 0x1DCB, 0x0000, 0x0020, 0x004A, 0x0030, 0x0000, 0x0002, 0x0002, 0x0002, 0x0000 };

    auto collation = collate_for_tests(
        cps, cps + 3, boost::text::variable_weighting::non_ignorable);

    EXPECT_EQ(collation.size(), 10);
    EXPECT_TRUE(boost::algorithm::equal(collation.begin(), collation.end(), ces, ces + 10))
        << "from:     " << ce_dumper(cps)
        << "expected: " << ce_dumper(ces)
        << "got:      " << ce_dumper(collation);
}

TEST(collation, non_ignorable_110_414)
{
    // 0137 0334;	
    // (ķ) LATIN SMALL LETTER K WITH CEDILLA	[1DCB | 0020 004A 0030 | 0002 0002 0002 |]

    uint32_t cps[2] = { 0x0137, 0x0334 };
    uint32_t const ces[10] = { 0x1DCB, 0x0000, 0x0020, 0x004A, 0x0030, 0x0000, 0x0002, 0x0002, 0x0002, 0x0000 };

    auto collation = collate_for_tests(
        cps, cps + 2, boost::text::variable_weighting::non_ignorable);

    EXPECT_EQ(collation.size(), 10);
    EXPECT_TRUE(boost::algorithm::equal(collation.begin(), collation.end(), ces, ces + 10))
        << "from:     " << ce_dumper(cps)
        << "expected: " << ce_dumper(ces)
        << "got:      " << ce_dumper(collation);
}

TEST(collation, non_ignorable_110_415)
{
    // 004B 0327 0334;	
    // (Ķ) LATIN CAPITAL LETTER K, COMBINING CEDILLA	[1DCB | 0020 004A 0030 | 0008 0002 0002 |]

    uint32_t cps[3] = { 0x004B, 0x0327, 0x0334 };
    uint32_t const ces[10] = { 0x1DCB, 0x0000, 0x0020, 0x004A, 0x0030, 0x0000, 0x0008, 0x0002, 0x0002, 0x0000 };

    auto collation = collate_for_tests(
        cps, cps + 3, boost::text::variable_weighting::non_ignorable);

    EXPECT_EQ(collation.size(), 10);
    EXPECT_TRUE(boost::algorithm::equal(collation.begin(), collation.end(), ces, ces + 10))
        << "from:     " << ce_dumper(cps)
        << "expected: " << ce_dumper(ces)
        << "got:      " << ce_dumper(collation);
}

TEST(collation, non_ignorable_110_416)
{
    // 0136 0334;	
    // (Ķ) LATIN CAPITAL LETTER K WITH CEDILLA	[1DCB | 0020 004A 0030 | 0008 0002 0002 |]

    uint32_t cps[2] = { 0x0136, 0x0334 };
    uint32_t const ces[10] = { 0x1DCB, 0x0000, 0x0020, 0x004A, 0x0030, 0x0000, 0x0008, 0x0002, 0x0002, 0x0000 };

    auto collation = collate_for_tests(
        cps, cps + 2, boost::text::variable_weighting::non_ignorable);

    EXPECT_EQ(collation.size(), 10);
    EXPECT_TRUE(boost::algorithm::equal(collation.begin(), collation.end(), ces, ces + 10))
        << "from:     " << ce_dumper(cps)
        << "expected: " << ce_dumper(ces)
        << "got:      " << ce_dumper(collation);
}

TEST(collation, non_ignorable_110_417)
{
    // 212A 0327 0334;	
    // (Ķ) KELVIN SIGN, COMBINING CEDILLA	[1DCB | 0020 004A 0030 | 0008 0002 0002 |]

    uint32_t cps[3] = { 0x212A, 0x0327, 0x0334 };
    uint32_t const ces[10] = { 0x1DCB, 0x0000, 0x0020, 0x004A, 0x0030, 0x0000, 0x0008, 0x0002, 0x0002, 0x0000 };

    auto collation = collate_for_tests(
        cps, cps + 3, boost::text::variable_weighting::non_ignorable);

    EXPECT_EQ(collation.size(), 10);
    EXPECT_TRUE(boost::algorithm::equal(collation.begin(), collation.end(), ces, ces + 10))
        << "from:     " << ce_dumper(cps)
        << "expected: " << ce_dumper(ces)
        << "got:      " << ce_dumper(collation);
}

TEST(collation, non_ignorable_110_418)
{
    // 212A 0334 0327;	
    // (K̴) KELVIN SIGN, COMBINING TILDE OVERLAY	[1DCB | 0020 004A 0030 | 0008 0002 0002 |]

    uint32_t cps[3] = { 0x212A, 0x0334, 0x0327 };
    uint32_t const ces[10] = { 0x1DCB, 0x0000, 0x0020, 0x004A, 0x0030, 0x0000, 0x0008, 0x0002, 0x0002, 0x0000 };

    auto collation = collate_for_tests(
        cps, cps + 3, boost::text::variable_weighting::non_ignorable);

    EXPECT_EQ(collation.size(), 10);
    EXPECT_TRUE(boost::algorithm::equal(collation.begin(), collation.end(), ces, ces + 10))
        << "from:     " << ce_dumper(cps)
        << "expected: " << ce_dumper(ces)
        << "got:      " << ce_dumper(collation);
}

TEST(collation, non_ignorable_110_419)
{
    // 006B 0323 0334;	
    // (ḳ) LATIN SMALL LETTER K, COMBINING DOT BELOW	[1DCB | 0020 004A 0042 | 0002 0002 0002 |]

    uint32_t cps[3] = { 0x006B, 0x0323, 0x0334 };
    uint32_t const ces[10] = { 0x1DCB, 0x0000, 0x0020, 0x004A, 0x0042, 0x0000, 0x0002, 0x0002, 0x0002, 0x0000 };

    auto collation = collate_for_tests(
        cps, cps + 3, boost::text::variable_weighting::non_ignorable);

    EXPECT_EQ(collation.size(), 10);
    EXPECT_TRUE(boost::algorithm::equal(collation.begin(), collation.end(), ces, ces + 10))
        << "from:     " << ce_dumper(cps)
        << "expected: " << ce_dumper(ces)
        << "got:      " << ce_dumper(collation);
}

TEST(collation, non_ignorable_110_420)
{
    // 006B 0334 0323;	
    // (k̴) LATIN SMALL LETTER K, COMBINING TILDE OVERLAY	[1DCB | 0020 004A 0042 | 0002 0002 0002 |]

    uint32_t cps[3] = { 0x006B, 0x0334, 0x0323 };
    uint32_t const ces[10] = { 0x1DCB, 0x0000, 0x0020, 0x004A, 0x0042, 0x0000, 0x0002, 0x0002, 0x0002, 0x0000 };

    auto collation = collate_for_tests(
        cps, cps + 3, boost::text::variable_weighting::non_ignorable);

    EXPECT_EQ(collation.size(), 10);
    EXPECT_TRUE(boost::algorithm::equal(collation.begin(), collation.end(), ces, ces + 10))
        << "from:     " << ce_dumper(cps)
        << "expected: " << ce_dumper(ces)
        << "got:      " << ce_dumper(collation);
}

TEST(collation, non_ignorable_110_421)
{
    // 1E33 0334;	
    // (ḳ) LATIN SMALL LETTER K WITH DOT BELOW	[1DCB | 0020 004A 0042 | 0002 0002 0002 |]

    uint32_t cps[2] = { 0x1E33, 0x0334 };
    uint32_t const ces[10] = { 0x1DCB, 0x0000, 0x0020, 0x004A, 0x0042, 0x0000, 0x0002, 0x0002, 0x0002, 0x0000 };

    auto collation = collate_for_tests(
        cps, cps + 2, boost::text::variable_weighting::non_ignorable);

    EXPECT_EQ(collation.size(), 10);
    EXPECT_TRUE(boost::algorithm::equal(collation.begin(), collation.end(), ces, ces + 10))
        << "from:     " << ce_dumper(cps)
        << "expected: " << ce_dumper(ces)
        << "got:      " << ce_dumper(collation);
}

TEST(collation, non_ignorable_110_422)
{
    // 004B 0334 0323;	
    // (K̴) LATIN CAPITAL LETTER K, COMBINING TILDE OVERLAY	[1DCB | 0020 004A 0042 | 0008 0002 0002 |]

    uint32_t cps[3] = { 0x004B, 0x0334, 0x0323 };
    uint32_t const ces[10] = { 0x1DCB, 0x0000, 0x0020, 0x004A, 0x0042, 0x0000, 0x0008, 0x0002, 0x0002, 0x0000 };

    auto collation = collate_for_tests(
        cps, cps + 3, boost::text::variable_weighting::non_ignorable);

    EXPECT_EQ(collation.size(), 10);
    EXPECT_TRUE(boost::algorithm::equal(collation.begin(), collation.end(), ces, ces + 10))
        << "from:     " << ce_dumper(cps)
        << "expected: " << ce_dumper(ces)
        << "got:      " << ce_dumper(collation);
}

TEST(collation, non_ignorable_110_423)
{
    // 1E32 0334;	
    // (Ḳ) LATIN CAPITAL LETTER K WITH DOT BELOW	[1DCB | 0020 004A 0042 | 0008 0002 0002 |]

    uint32_t cps[2] = { 0x1E32, 0x0334 };
    uint32_t const ces[10] = { 0x1DCB, 0x0000, 0x0020, 0x004A, 0x0042, 0x0000, 0x0008, 0x0002, 0x0002, 0x0000 };

    auto collation = collate_for_tests(
        cps, cps + 2, boost::text::variable_weighting::non_ignorable);

    EXPECT_EQ(collation.size(), 10);
    EXPECT_TRUE(boost::algorithm::equal(collation.begin(), collation.end(), ces, ces + 10))
        << "from:     " << ce_dumper(cps)
        << "expected: " << ce_dumper(ces)
        << "got:      " << ce_dumper(collation);
}

TEST(collation, non_ignorable_110_424)
{
    // 212A 0323 0334;	
    // (Ḳ) KELVIN SIGN, COMBINING DOT BELOW	[1DCB | 0020 004A 0042 | 0008 0002 0002 |]

    uint32_t cps[3] = { 0x212A, 0x0323, 0x0334 };
    uint32_t const ces[10] = { 0x1DCB, 0x0000, 0x0020, 0x004A, 0x0042, 0x0000, 0x0008, 0x0002, 0x0002, 0x0000 };

    auto collation = collate_for_tests(
        cps, cps + 3, boost::text::variable_weighting::non_ignorable);

    EXPECT_EQ(collation.size(), 10);
    EXPECT_TRUE(boost::algorithm::equal(collation.begin(), collation.end(), ces, ces + 10))
        << "from:     " << ce_dumper(cps)
        << "expected: " << ce_dumper(ces)
        << "got:      " << ce_dumper(collation);
}

TEST(collation, non_ignorable_110_425)
{
    // 212A 0334 0323;	
    // (K̴) KELVIN SIGN, COMBINING TILDE OVERLAY	[1DCB | 0020 004A 0042 | 0008 0002 0002 |]

    uint32_t cps[3] = { 0x212A, 0x0334, 0x0323 };
    uint32_t const ces[10] = { 0x1DCB, 0x0000, 0x0020, 0x004A, 0x0042, 0x0000, 0x0008, 0x0002, 0x0002, 0x0000 };

    auto collation = collate_for_tests(
        cps, cps + 3, boost::text::variable_weighting::non_ignorable);

    EXPECT_EQ(collation.size(), 10);
    EXPECT_TRUE(boost::algorithm::equal(collation.begin(), collation.end(), ces, ces + 10))
        << "from:     " << ce_dumper(cps)
        << "expected: " << ce_dumper(ces)
        << "got:      " << ce_dumper(collation);
}

TEST(collation, non_ignorable_110_426)
{
    // 006B 0331 0334;	
    // (ḵ) LATIN SMALL LETTER K, COMBINING MACRON BELOW	[1DCB | 0020 004A 0049 | 0002 0002 0002 |]

    uint32_t cps[3] = { 0x006B, 0x0331, 0x0334 };
    uint32_t const ces[10] = { 0x1DCB, 0x0000, 0x0020, 0x004A, 0x0049, 0x0000, 0x0002, 0x0002, 0x0002, 0x0000 };

    auto collation = collate_for_tests(
        cps, cps + 3, boost::text::variable_weighting::non_ignorable);

    EXPECT_EQ(collation.size(), 10);
    EXPECT_TRUE(boost::algorithm::equal(collation.begin(), collation.end(), ces, ces + 10))
        << "from:     " << ce_dumper(cps)
        << "expected: " << ce_dumper(ces)
        << "got:      " << ce_dumper(collation);
}

TEST(collation, non_ignorable_110_427)
{
    // 006B 0334 0331;	
    // (k̴) LATIN SMALL LETTER K, COMBINING TILDE OVERLAY	[1DCB | 0020 004A 0049 | 0002 0002 0002 |]

    uint32_t cps[3] = { 0x006B, 0x0334, 0x0331 };
    uint32_t const ces[10] = { 0x1DCB, 0x0000, 0x0020, 0x004A, 0x0049, 0x0000, 0x0002, 0x0002, 0x0002, 0x0000 };

    auto collation = collate_for_tests(
        cps, cps + 3, boost::text::variable_weighting::non_ignorable);

    EXPECT_EQ(collation.size(), 10);
    EXPECT_TRUE(boost::algorithm::equal(collation.begin(), collation.end(), ces, ces + 10))
        << "from:     " << ce_dumper(cps)
        << "expected: " << ce_dumper(ces)
        << "got:      " << ce_dumper(collation);
}

TEST(collation, non_ignorable_110_428)
{
    // 1E35 0334;	
    // (ḵ) LATIN SMALL LETTER K WITH LINE BELOW	[1DCB | 0020 004A 0049 | 0002 0002 0002 |]

    uint32_t cps[2] = { 0x1E35, 0x0334 };
    uint32_t const ces[10] = { 0x1DCB, 0x0000, 0x0020, 0x004A, 0x0049, 0x0000, 0x0002, 0x0002, 0x0002, 0x0000 };

    auto collation = collate_for_tests(
        cps, cps + 2, boost::text::variable_weighting::non_ignorable);

    EXPECT_EQ(collation.size(), 10);
    EXPECT_TRUE(boost::algorithm::equal(collation.begin(), collation.end(), ces, ces + 10))
        << "from:     " << ce_dumper(cps)
        << "expected: " << ce_dumper(ces)
        << "got:      " << ce_dumper(collation);
}

TEST(collation, non_ignorable_110_429)
{
    // 004B 0334 0331;	
    // (K̴) LATIN CAPITAL LETTER K, COMBINING TILDE OVERLAY	[1DCB | 0020 004A 0049 | 0008 0002 0002 |]

    uint32_t cps[3] = { 0x004B, 0x0334, 0x0331 };
    uint32_t const ces[10] = { 0x1DCB, 0x0000, 0x0020, 0x004A, 0x0049, 0x0000, 0x0008, 0x0002, 0x0002, 0x0000 };

    auto collation = collate_for_tests(
        cps, cps + 3, boost::text::variable_weighting::non_ignorable);

    EXPECT_EQ(collation.size(), 10);
    EXPECT_TRUE(boost::algorithm::equal(collation.begin(), collation.end(), ces, ces + 10))
        << "from:     " << ce_dumper(cps)
        << "expected: " << ce_dumper(ces)
        << "got:      " << ce_dumper(collation);
}

TEST(collation, non_ignorable_110_430)
{
    // 1E34 0334;	
    // (Ḵ) LATIN CAPITAL LETTER K WITH LINE BELOW	[1DCB | 0020 004A 0049 | 0008 0002 0002 |]

    uint32_t cps[2] = { 0x1E34, 0x0334 };
    uint32_t const ces[10] = { 0x1DCB, 0x0000, 0x0020, 0x004A, 0x0049, 0x0000, 0x0008, 0x0002, 0x0002, 0x0000 };

    auto collation = collate_for_tests(
        cps, cps + 2, boost::text::variable_weighting::non_ignorable);

    EXPECT_EQ(collation.size(), 10);
    EXPECT_TRUE(boost::algorithm::equal(collation.begin(), collation.end(), ces, ces + 10))
        << "from:     " << ce_dumper(cps)
        << "expected: " << ce_dumper(ces)
        << "got:      " << ce_dumper(collation);
}

TEST(collation, non_ignorable_110_431)
{
    // 212A 0331 0334;	
    // (Ḵ) KELVIN SIGN, COMBINING MACRON BELOW	[1DCB | 0020 004A 0049 | 0008 0002 0002 |]

    uint32_t cps[3] = { 0x212A, 0x0331, 0x0334 };
    uint32_t const ces[10] = { 0x1DCB, 0x0000, 0x0020, 0x004A, 0x0049, 0x0000, 0x0008, 0x0002, 0x0002, 0x0000 };

    auto collation = collate_for_tests(
        cps, cps + 3, boost::text::variable_weighting::non_ignorable);

    EXPECT_EQ(collation.size(), 10);
    EXPECT_TRUE(boost::algorithm::equal(collation.begin(), collation.end(), ces, ces + 10))
        << "from:     " << ce_dumper(cps)
        << "expected: " << ce_dumper(ces)
        << "got:      " << ce_dumper(collation);
}

TEST(collation, non_ignorable_110_432)
{
    // 212A 0334 0331;	
    // (K̴) KELVIN SIGN, COMBINING TILDE OVERLAY	[1DCB | 0020 004A 0049 | 0008 0002 0002 |]

    uint32_t cps[3] = { 0x212A, 0x0334, 0x0331 };
    uint32_t const ces[10] = { 0x1DCB, 0x0000, 0x0020, 0x004A, 0x0049, 0x0000, 0x0008, 0x0002, 0x0002, 0x0000 };

    auto collation = collate_for_tests(
        cps, cps + 3, boost::text::variable_weighting::non_ignorable);

    EXPECT_EQ(collation.size(), 10);
    EXPECT_TRUE(boost::algorithm::equal(collation.begin(), collation.end(), ces, ces + 10))
        << "from:     " << ce_dumper(cps)
        << "expected: " << ce_dumper(ces)
        << "got:      " << ce_dumper(collation);
}

TEST(collation, non_ignorable_110_433)
{
    // 0334 1DDC;	
    // (ᷜ) COMBINING LATIN SMALL LETTER K	[1DCB | 004A 0020 | 0002 0004 |]

    uint32_t cps[2] = { 0x0334, 0x1DDC };
    uint32_t const ces[8] = { 0x1DCB, 0x0000, 0x004A, 0x0020, 0x0000, 0x0002, 0x0004, 0x0000 };

    auto collation = collate_for_tests(
        cps, cps + 2, boost::text::variable_weighting::non_ignorable);

    EXPECT_EQ(collation.size(), 8);
    EXPECT_TRUE(boost::algorithm::equal(collation.begin(), collation.end(), ces, ces + 8))
        << "from:     " << ce_dumper(cps)
        << "expected: " << ce_dumper(ces)
        << "got:      " << ce_dumper(collation);
}

TEST(collation, non_ignorable_110_434)
{
    // 1DDC 0334;	
    // (ᷜ) COMBINING LATIN SMALL LETTER K	[1DCB | 004A 0020 | 0002 0004 |]

    uint32_t cps[2] = { 0x1DDC, 0x0334 };
    uint32_t const ces[8] = { 0x1DCB, 0x0000, 0x004A, 0x0020, 0x0000, 0x0002, 0x0004, 0x0000 };

    auto collation = collate_for_tests(
        cps, cps + 2, boost::text::variable_weighting::non_ignorable);

    EXPECT_EQ(collation.size(), 8);
    EXPECT_TRUE(boost::algorithm::equal(collation.begin(), collation.end(), ces, ces + 8))
        << "from:     " << ce_dumper(cps)
        << "expected: " << ce_dumper(ces)
        << "got:      " << ce_dumper(collation);
}

TEST(collation, non_ignorable_110_435)
{
    // 006B 0021;	
    // (k) LATIN SMALL LETTER K	[1DCB 0261 | 0020 0020 | 0002 0002 |]

    uint32_t cps[2] = { 0x006B, 0x0021 };
    uint32_t const ces[9] = { 0x1DCB, 0x0261, 0x0000, 0x0020, 0x0020, 0x0000, 0x0002, 0x0002, 0x0000 };

    auto collation = collate_for_tests(
        cps, cps + 2, boost::text::variable_weighting::non_ignorable);

    EXPECT_EQ(collation.size(), 9);
    EXPECT_TRUE(boost::algorithm::equal(collation.begin(), collation.end(), ces, ces + 9))
        << "from:     " << ce_dumper(cps)
        << "expected: " << ce_dumper(ces)
        << "got:      " << ce_dumper(collation);
}

TEST(collation, non_ignorable_110_436)
{
    // FF4B 0021;	
    // (ｋ) FULLWIDTH LATIN SMALL LETTER K	[1DCB 0261 | 0020 0020 | 0003 0002 |]

    uint32_t cps[2] = { 0xFF4B, 0x0021 };
    uint32_t const ces[9] = { 0x1DCB, 0x0261, 0x0000, 0x0020, 0x0020, 0x0000, 0x0003, 0x0002, 0x0000 };

    auto collation = collate_for_tests(
        cps, cps + 2, boost::text::variable_weighting::non_ignorable);

    EXPECT_EQ(collation.size(), 9);
    EXPECT_TRUE(boost::algorithm::equal(collation.begin(), collation.end(), ces, ces + 9))
        << "from:     " << ce_dumper(cps)
        << "expected: " << ce_dumper(ces)
        << "got:      " << ce_dumper(collation);
}

TEST(collation, non_ignorable_110_437)
{
    // 1DDC 0021;	
    // (ᷜ) COMBINING LATIN SMALL LETTER K	[1DCB 0261 | 0020 0020 | 0004 0002 |]

    uint32_t cps[2] = { 0x1DDC, 0x0021 };
    uint32_t const ces[9] = { 0x1DCB, 0x0261, 0x0000, 0x0020, 0x0020, 0x0000, 0x0004, 0x0002, 0x0000 };

    auto collation = collate_for_tests(
        cps, cps + 2, boost::text::variable_weighting::non_ignorable);

    EXPECT_EQ(collation.size(), 9);
    EXPECT_TRUE(boost::algorithm::equal(collation.begin(), collation.end(), ces, ces + 9))
        << "from:     " << ce_dumper(cps)
        << "expected: " << ce_dumper(ces)
        << "got:      " << ce_dumper(collation);
}

TEST(collation, non_ignorable_110_438)
{
    // 1D424 0021;	
    // (𝐤) MATHEMATICAL BOLD SMALL K	[1DCB 0261 | 0020 0020 | 0005 0002 |]

    uint32_t cps[2] = { 0x1D424, 0x0021 };
    uint32_t const ces[9] = { 0x1DCB, 0x0261, 0x0000, 0x0020, 0x0020, 0x0000, 0x0005, 0x0002, 0x0000 };

    auto collation = collate_for_tests(
        cps, cps + 2, boost::text::variable_weighting::non_ignorable);

    EXPECT_EQ(collation.size(), 9);
    EXPECT_TRUE(boost::algorithm::equal(collation.begin(), collation.end(), ces, ces + 9))
        << "from:     " << ce_dumper(cps)
        << "expected: " << ce_dumper(ces)
        << "got:      " << ce_dumper(collation);
}

TEST(collation, non_ignorable_110_439)
{
    // 1D458 0021;	
    // (𝑘) MATHEMATICAL ITALIC SMALL K	[1DCB 0261 | 0020 0020 | 0005 0002 |]

    uint32_t cps[2] = { 0x1D458, 0x0021 };
    uint32_t const ces[9] = { 0x1DCB, 0x0261, 0x0000, 0x0020, 0x0020, 0x0000, 0x0005, 0x0002, 0x0000 };

    auto collation = collate_for_tests(
        cps, cps + 2, boost::text::variable_weighting::non_ignorable);

    EXPECT_EQ(collation.size(), 9);
    EXPECT_TRUE(boost::algorithm::equal(collation.begin(), collation.end(), ces, ces + 9))
        << "from:     " << ce_dumper(cps)
        << "expected: " << ce_dumper(ces)
        << "got:      " << ce_dumper(collation);
}

TEST(collation, non_ignorable_110_440)
{
    // 1D48C 0021;	
    // (𝒌) MATHEMATICAL BOLD ITALIC SMALL K	[1DCB 0261 | 0020 0020 | 0005 0002 |]

    uint32_t cps[2] = { 0x1D48C, 0x0021 };
    uint32_t const ces[9] = { 0x1DCB, 0x0261, 0x0000, 0x0020, 0x0020, 0x0000, 0x0005, 0x0002, 0x0000 };

    auto collation = collate_for_tests(
        cps, cps + 2, boost::text::variable_weighting::non_ignorable);

    EXPECT_EQ(collation.size(), 9);
    EXPECT_TRUE(boost::algorithm::equal(collation.begin(), collation.end(), ces, ces + 9))
        << "from:     " << ce_dumper(cps)
        << "expected: " << ce_dumper(ces)
        << "got:      " << ce_dumper(collation);
}

TEST(collation, non_ignorable_110_441)
{
    // 1D4C0 0021;	
    // (𝓀) MATHEMATICAL SCRIPT SMALL K	[1DCB 0261 | 0020 0020 | 0005 0002 |]

    uint32_t cps[2] = { 0x1D4C0, 0x0021 };
    uint32_t const ces[9] = { 0x1DCB, 0x0261, 0x0000, 0x0020, 0x0020, 0x0000, 0x0005, 0x0002, 0x0000 };

    auto collation = collate_for_tests(
        cps, cps + 2, boost::text::variable_weighting::non_ignorable);

    EXPECT_EQ(collation.size(), 9);
    EXPECT_TRUE(boost::algorithm::equal(collation.begin(), collation.end(), ces, ces + 9))
        << "from:     " << ce_dumper(cps)
        << "expected: " << ce_dumper(ces)
        << "got:      " << ce_dumper(collation);
}

TEST(collation, non_ignorable_110_442)
{
    // 1D4F4 0021;	
    // (𝓴) MATHEMATICAL BOLD SCRIPT SMALL K	[1DCB 0261 | 0020 0020 | 0005 0002 |]

    uint32_t cps[2] = { 0x1D4F4, 0x0021 };
    uint32_t const ces[9] = { 0x1DCB, 0x0261, 0x0000, 0x0020, 0x0020, 0x0000, 0x0005, 0x0002, 0x0000 };

    auto collation = collate_for_tests(
        cps, cps + 2, boost::text::variable_weighting::non_ignorable);

    EXPECT_EQ(collation.size(), 9);
    EXPECT_TRUE(boost::algorithm::equal(collation.begin(), collation.end(), ces, ces + 9))
        << "from:     " << ce_dumper(cps)
        << "expected: " << ce_dumper(ces)
        << "got:      " << ce_dumper(collation);
}

TEST(collation, non_ignorable_110_443)
{
    // 1D528 0021;	
    // (𝔨) MATHEMATICAL FRAKTUR SMALL K	[1DCB 0261 | 0020 0020 | 0005 0002 |]

    uint32_t cps[2] = { 0x1D528, 0x0021 };
    uint32_t const ces[9] = { 0x1DCB, 0x0261, 0x0000, 0x0020, 0x0020, 0x0000, 0x0005, 0x0002, 0x0000 };

    auto collation = collate_for_tests(
        cps, cps + 2, boost::text::variable_weighting::non_ignorable);

    EXPECT_EQ(collation.size(), 9);
    EXPECT_TRUE(boost::algorithm::equal(collation.begin(), collation.end(), ces, ces + 9))
        << "from:     " << ce_dumper(cps)
        << "expected: " << ce_dumper(ces)
        << "got:      " << ce_dumper(collation);
}

TEST(collation, non_ignorable_110_444)
{
    // 1D55C 0021;	
    // (𝕜) MATHEMATICAL DOUBLE-STRUCK SMALL K	[1DCB 0261 | 0020 0020 | 0005 0002 |]

    uint32_t cps[2] = { 0x1D55C, 0x0021 };
    uint32_t const ces[9] = { 0x1DCB, 0x0261, 0x0000, 0x0020, 0x0020, 0x0000, 0x0005, 0x0002, 0x0000 };

    auto collation = collate_for_tests(
        cps, cps + 2, boost::text::variable_weighting::non_ignorable);

    EXPECT_EQ(collation.size(), 9);
    EXPECT_TRUE(boost::algorithm::equal(collation.begin(), collation.end(), ces, ces + 9))
        << "from:     " << ce_dumper(cps)
        << "expected: " << ce_dumper(ces)
        << "got:      " << ce_dumper(collation);
}

TEST(collation, non_ignorable_110_445)
{
    // 1D590 0021;	
    // (𝖐) MATHEMATICAL BOLD FRAKTUR SMALL K	[1DCB 0261 | 0020 0020 | 0005 0002 |]

    uint32_t cps[2] = { 0x1D590, 0x0021 };
    uint32_t const ces[9] = { 0x1DCB, 0x0261, 0x0000, 0x0020, 0x0020, 0x0000, 0x0005, 0x0002, 0x0000 };

    auto collation = collate_for_tests(
        cps, cps + 2, boost::text::variable_weighting::non_ignorable);

    EXPECT_EQ(collation.size(), 9);
    EXPECT_TRUE(boost::algorithm::equal(collation.begin(), collation.end(), ces, ces + 9))
        << "from:     " << ce_dumper(cps)
        << "expected: " << ce_dumper(ces)
        << "got:      " << ce_dumper(collation);
}

TEST(collation, non_ignorable_110_446)
{
    // 1D5C4 0021;	
    // (𝗄) MATHEMATICAL SANS-SERIF SMALL K	[1DCB 0261 | 0020 0020 | 0005 0002 |]

    uint32_t cps[2] = { 0x1D5C4, 0x0021 };
    uint32_t const ces[9] = { 0x1DCB, 0x0261, 0x0000, 0x0020, 0x0020, 0x0000, 0x0005, 0x0002, 0x0000 };

    auto collation = collate_for_tests(
        cps, cps + 2, boost::text::variable_weighting::non_ignorable);

    EXPECT_EQ(collation.size(), 9);
    EXPECT_TRUE(boost::algorithm::equal(collation.begin(), collation.end(), ces, ces + 9))
        << "from:     " << ce_dumper(cps)
        << "expected: " << ce_dumper(ces)
        << "got:      " << ce_dumper(collation);
}

TEST(collation, non_ignorable_110_447)
{
    // 1D5F8 0021;	
    // (𝗸) MATHEMATICAL SANS-SERIF BOLD SMALL K	[1DCB 0261 | 0020 0020 | 0005 0002 |]

    uint32_t cps[2] = { 0x1D5F8, 0x0021 };
    uint32_t const ces[9] = { 0x1DCB, 0x0261, 0x0000, 0x0020, 0x0020, 0x0000, 0x0005, 0x0002, 0x0000 };

    auto collation = collate_for_tests(
        cps, cps + 2, boost::text::variable_weighting::non_ignorable);

    EXPECT_EQ(collation.size(), 9);
    EXPECT_TRUE(boost::algorithm::equal(collation.begin(), collation.end(), ces, ces + 9))
        << "from:     " << ce_dumper(cps)
        << "expected: " << ce_dumper(ces)
        << "got:      " << ce_dumper(collation);
}

TEST(collation, non_ignorable_110_448)
{
    // 1D62C 0021;	
    // (𝘬) MATHEMATICAL SANS-SERIF ITALIC SMALL K	[1DCB 0261 | 0020 0020 | 0005 0002 |]

    uint32_t cps[2] = { 0x1D62C, 0x0021 };
    uint32_t const ces[9] = { 0x1DCB, 0x0261, 0x0000, 0x0020, 0x0020, 0x0000, 0x0005, 0x0002, 0x0000 };

    auto collation = collate_for_tests(
        cps, cps + 2, boost::text::variable_weighting::non_ignorable);

    EXPECT_EQ(collation.size(), 9);
    EXPECT_TRUE(boost::algorithm::equal(collation.begin(), collation.end(), ces, ces + 9))
        << "from:     " << ce_dumper(cps)
        << "expected: " << ce_dumper(ces)
        << "got:      " << ce_dumper(collation);
}

TEST(collation, non_ignorable_110_449)
{
    // 1D660 0021;	
    // (𝙠) MATHEMATICAL SANS-SERIF BOLD ITALIC SMALL K	[1DCB 0261 | 0020 0020 | 0005 0002 |]

    uint32_t cps[2] = { 0x1D660, 0x0021 };
    uint32_t const ces[9] = { 0x1DCB, 0x0261, 0x0000, 0x0020, 0x0020, 0x0000, 0x0005, 0x0002, 0x0000 };

    auto collation = collate_for_tests(
        cps, cps + 2, boost::text::variable_weighting::non_ignorable);

    EXPECT_EQ(collation.size(), 9);
    EXPECT_TRUE(boost::algorithm::equal(collation.begin(), collation.end(), ces, ces + 9))
        << "from:     " << ce_dumper(cps)
        << "expected: " << ce_dumper(ces)
        << "got:      " << ce_dumper(collation);
}

TEST(collation, non_ignorable_110_450)
{
    // 1D694 0021;	
    // (𝚔) MATHEMATICAL MONOSPACE SMALL K	[1DCB 0261 | 0020 0020 | 0005 0002 |]

    uint32_t cps[2] = { 0x1D694, 0x0021 };
    uint32_t const ces[9] = { 0x1DCB, 0x0261, 0x0000, 0x0020, 0x0020, 0x0000, 0x0005, 0x0002, 0x0000 };

    auto collation = collate_for_tests(
        cps, cps + 2, boost::text::variable_weighting::non_ignorable);

    EXPECT_EQ(collation.size(), 9);
    EXPECT_TRUE(boost::algorithm::equal(collation.begin(), collation.end(), ces, ces + 9))
        << "from:     " << ce_dumper(cps)
        << "expected: " << ce_dumper(ces)
        << "got:      " << ce_dumper(collation);
}

TEST(collation, non_ignorable_110_451)
{
    // 24DA 0021;	
    // (ⓚ) CIRCLED LATIN SMALL LETTER K	[1DCB 0261 | 0020 0020 | 0006 0002 |]

    uint32_t cps[2] = { 0x24DA, 0x0021 };
    uint32_t const ces[9] = { 0x1DCB, 0x0261, 0x0000, 0x0020, 0x0020, 0x0000, 0x0006, 0x0002, 0x0000 };

    auto collation = collate_for_tests(
        cps, cps + 2, boost::text::variable_weighting::non_ignorable);

    EXPECT_EQ(collation.size(), 9);
    EXPECT_TRUE(boost::algorithm::equal(collation.begin(), collation.end(), ces, ces + 9))
        << "from:     " << ce_dumper(cps)
        << "expected: " << ce_dumper(ces)
        << "got:      " << ce_dumper(collation);
}

TEST(collation, non_ignorable_110_452)
{
    // 004B 0021;	
    // (K) LATIN CAPITAL LETTER K	[1DCB 0261 | 0020 0020 | 0008 0002 |]

    uint32_t cps[2] = { 0x004B, 0x0021 };
    uint32_t const ces[9] = { 0x1DCB, 0x0261, 0x0000, 0x0020, 0x0020, 0x0000, 0x0008, 0x0002, 0x0000 };

    auto collation = collate_for_tests(
        cps, cps + 2, boost::text::variable_weighting::non_ignorable);

    EXPECT_EQ(collation.size(), 9);
    EXPECT_TRUE(boost::algorithm::equal(collation.begin(), collation.end(), ces, ces + 9))
        << "from:     " << ce_dumper(cps)
        << "expected: " << ce_dumper(ces)
        << "got:      " << ce_dumper(collation);
}

TEST(collation, non_ignorable_110_453)
{
    // 212A 0021;	
    // (K) KELVIN SIGN	[1DCB 0261 | 0020 0020 | 0008 0002 |]

    uint32_t cps[2] = { 0x212A, 0x0021 };
    uint32_t const ces[9] = { 0x1DCB, 0x0261, 0x0000, 0x0020, 0x0020, 0x0000, 0x0008, 0x0002, 0x0000 };

    auto collation = collate_for_tests(
        cps, cps + 2, boost::text::variable_weighting::non_ignorable);

    EXPECT_EQ(collation.size(), 9);
    EXPECT_TRUE(boost::algorithm::equal(collation.begin(), collation.end(), ces, ces + 9))
        << "from:     " << ce_dumper(cps)
        << "expected: " << ce_dumper(ces)
        << "got:      " << ce_dumper(collation);
}

TEST(collation, non_ignorable_110_454)
{
    // FF2B 0021;	
    // (Ｋ) FULLWIDTH LATIN CAPITAL LETTER K	[1DCB 0261 | 0020 0020 | 0009 0002 |]

    uint32_t cps[2] = { 0xFF2B, 0x0021 };
    uint32_t const ces[9] = { 0x1DCB, 0x0261, 0x0000, 0x0020, 0x0020, 0x0000, 0x0009, 0x0002, 0x0000 };

    auto collation = collate_for_tests(
        cps, cps + 2, boost::text::variable_weighting::non_ignorable);

    EXPECT_EQ(collation.size(), 9);
    EXPECT_TRUE(boost::algorithm::equal(collation.begin(), collation.end(), ces, ces + 9))
        << "from:     " << ce_dumper(cps)
        << "expected: " << ce_dumper(ces)
        << "got:      " << ce_dumper(collation);
}

TEST(collation, non_ignorable_110_455)
{
    // 1D40A 0021;	
    // (𝐊) MATHEMATICAL BOLD CAPITAL K	[1DCB 0261 | 0020 0020 | 000B 0002 |]

    uint32_t cps[2] = { 0x1D40A, 0x0021 };
    uint32_t const ces[9] = { 0x1DCB, 0x0261, 0x0000, 0x0020, 0x0020, 0x0000, 0x000B, 0x0002, 0x0000 };

    auto collation = collate_for_tests(
        cps, cps + 2, boost::text::variable_weighting::non_ignorable);

    EXPECT_EQ(collation.size(), 9);
    EXPECT_TRUE(boost::algorithm::equal(collation.begin(), collation.end(), ces, ces + 9))
        << "from:     " << ce_dumper(cps)
        << "expected: " << ce_dumper(ces)
        << "got:      " << ce_dumper(collation);
}

TEST(collation, non_ignorable_110_456)
{
    // 1D43E 0021;	
    // (𝐾) MATHEMATICAL ITALIC CAPITAL K	[1DCB 0261 | 0020 0020 | 000B 0002 |]

    uint32_t cps[2] = { 0x1D43E, 0x0021 };
    uint32_t const ces[9] = { 0x1DCB, 0x0261, 0x0000, 0x0020, 0x0020, 0x0000, 0x000B, 0x0002, 0x0000 };

    auto collation = collate_for_tests(
        cps, cps + 2, boost::text::variable_weighting::non_ignorable);

    EXPECT_EQ(collation.size(), 9);
    EXPECT_TRUE(boost::algorithm::equal(collation.begin(), collation.end(), ces, ces + 9))
        << "from:     " << ce_dumper(cps)
        << "expected: " << ce_dumper(ces)
        << "got:      " << ce_dumper(collation);
}

TEST(collation, non_ignorable_110_457)
{
    // 1D472 0021;	
    // (𝑲) MATHEMATICAL BOLD ITALIC CAPITAL K	[1DCB 0261 | 0020 0020 | 000B 0002 |]

    uint32_t cps[2] = { 0x1D472, 0x0021 };
    uint32_t const ces[9] = { 0x1DCB, 0x0261, 0x0000, 0x0020, 0x0020, 0x0000, 0x000B, 0x0002, 0x0000 };

    auto collation = collate_for_tests(
        cps, cps + 2, boost::text::variable_weighting::non_ignorable);

    EXPECT_EQ(collation.size(), 9);
    EXPECT_TRUE(boost::algorithm::equal(collation.begin(), collation.end(), ces, ces + 9))
        << "from:     " << ce_dumper(cps)
        << "expected: " << ce_dumper(ces)
        << "got:      " << ce_dumper(collation);
}

TEST(collation, non_ignorable_110_458)
{
    // 1D4A6 0021;	
    // (𝒦) MATHEMATICAL SCRIPT CAPITAL K	[1DCB 0261 | 0020 0020 | 000B 0002 |]

    uint32_t cps[2] = { 0x1D4A6, 0x0021 };
    uint32_t const ces[9] = { 0x1DCB, 0x0261, 0x0000, 0x0020, 0x0020, 0x0000, 0x000B, 0x0002, 0x0000 };

    auto collation = collate_for_tests(
        cps, cps + 2, boost::text::variable_weighting::non_ignorable);

    EXPECT_EQ(collation.size(), 9);
    EXPECT_TRUE(boost::algorithm::equal(collation.begin(), collation.end(), ces, ces + 9))
        << "from:     " << ce_dumper(cps)
        << "expected: " << ce_dumper(ces)
        << "got:      " << ce_dumper(collation);
}

TEST(collation, non_ignorable_110_459)
{
    // 1D4DA 0021;	
    // (𝓚) MATHEMATICAL BOLD SCRIPT CAPITAL K	[1DCB 0261 | 0020 0020 | 000B 0002 |]

    uint32_t cps[2] = { 0x1D4DA, 0x0021 };
    uint32_t const ces[9] = { 0x1DCB, 0x0261, 0x0000, 0x0020, 0x0020, 0x0000, 0x000B, 0x0002, 0x0000 };

    auto collation = collate_for_tests(
        cps, cps + 2, boost::text::variable_weighting::non_ignorable);

    EXPECT_EQ(collation.size(), 9);
    EXPECT_TRUE(boost::algorithm::equal(collation.begin(), collation.end(), ces, ces + 9))
        << "from:     " << ce_dumper(cps)
        << "expected: " << ce_dumper(ces)
        << "got:      " << ce_dumper(collation);
}

TEST(collation, non_ignorable_110_460)
{
    // 1D50E 0021;	
    // (𝔎) MATHEMATICAL FRAKTUR CAPITAL K	[1DCB 0261 | 0020 0020 | 000B 0002 |]

    uint32_t cps[2] = { 0x1D50E, 0x0021 };
    uint32_t const ces[9] = { 0x1DCB, 0x0261, 0x0000, 0x0020, 0x0020, 0x0000, 0x000B, 0x0002, 0x0000 };

    auto collation = collate_for_tests(
        cps, cps + 2, boost::text::variable_weighting::non_ignorable);

    EXPECT_EQ(collation.size(), 9);
    EXPECT_TRUE(boost::algorithm::equal(collation.begin(), collation.end(), ces, ces + 9))
        << "from:     " << ce_dumper(cps)
        << "expected: " << ce_dumper(ces)
        << "got:      " << ce_dumper(collation);
}

TEST(collation, non_ignorable_110_461)
{
    // 1D542 0021;	
    // (𝕂) MATHEMATICAL DOUBLE-STRUCK CAPITAL K	[1DCB 0261 | 0020 0020 | 000B 0002 |]

    uint32_t cps[2] = { 0x1D542, 0x0021 };
    uint32_t const ces[9] = { 0x1DCB, 0x0261, 0x0000, 0x0020, 0x0020, 0x0000, 0x000B, 0x0002, 0x0000 };

    auto collation = collate_for_tests(
        cps, cps + 2, boost::text::variable_weighting::non_ignorable);

    EXPECT_EQ(collation.size(), 9);
    EXPECT_TRUE(boost::algorithm::equal(collation.begin(), collation.end(), ces, ces + 9))
        << "from:     " << ce_dumper(cps)
        << "expected: " << ce_dumper(ces)
        << "got:      " << ce_dumper(collation);
}

TEST(collation, non_ignorable_110_462)
{
    // 1D576 0021;	
    // (𝕶) MATHEMATICAL BOLD FRAKTUR CAPITAL K	[1DCB 0261 | 0020 0020 | 000B 0002 |]

    uint32_t cps[2] = { 0x1D576, 0x0021 };
    uint32_t const ces[9] = { 0x1DCB, 0x0261, 0x0000, 0x0020, 0x0020, 0x0000, 0x000B, 0x0002, 0x0000 };

    auto collation = collate_for_tests(
        cps, cps + 2, boost::text::variable_weighting::non_ignorable);

    EXPECT_EQ(collation.size(), 9);
    EXPECT_TRUE(boost::algorithm::equal(collation.begin(), collation.end(), ces, ces + 9))
        << "from:     " << ce_dumper(cps)
        << "expected: " << ce_dumper(ces)
        << "got:      " << ce_dumper(collation);
}

TEST(collation, non_ignorable_110_463)
{
    // 1D5AA 0021;	
    // (𝖪) MATHEMATICAL SANS-SERIF CAPITAL K	[1DCB 0261 | 0020 0020 | 000B 0002 |]

    uint32_t cps[2] = { 0x1D5AA, 0x0021 };
    uint32_t const ces[9] = { 0x1DCB, 0x0261, 0x0000, 0x0020, 0x0020, 0x0000, 0x000B, 0x0002, 0x0000 };

    auto collation = collate_for_tests(
        cps, cps + 2, boost::text::variable_weighting::non_ignorable);

    EXPECT_EQ(collation.size(), 9);
    EXPECT_TRUE(boost::algorithm::equal(collation.begin(), collation.end(), ces, ces + 9))
        << "from:     " << ce_dumper(cps)
        << "expected: " << ce_dumper(ces)
        << "got:      " << ce_dumper(collation);
}

TEST(collation, non_ignorable_110_464)
{
    // 1D5DE 0021;	
    // (𝗞) MATHEMATICAL SANS-SERIF BOLD CAPITAL K	[1DCB 0261 | 0020 0020 | 000B 0002 |]

    uint32_t cps[2] = { 0x1D5DE, 0x0021 };
    uint32_t const ces[9] = { 0x1DCB, 0x0261, 0x0000, 0x0020, 0x0020, 0x0000, 0x000B, 0x0002, 0x0000 };

    auto collation = collate_for_tests(
        cps, cps + 2, boost::text::variable_weighting::non_ignorable);

    EXPECT_EQ(collation.size(), 9);
    EXPECT_TRUE(boost::algorithm::equal(collation.begin(), collation.end(), ces, ces + 9))
        << "from:     " << ce_dumper(cps)
        << "expected: " << ce_dumper(ces)
        << "got:      " << ce_dumper(collation);
}

TEST(collation, non_ignorable_110_465)
{
    // 1D612 0021;	
    // (𝘒) MATHEMATICAL SANS-SERIF ITALIC CAPITAL K	[1DCB 0261 | 0020 0020 | 000B 0002 |]

    uint32_t cps[2] = { 0x1D612, 0x0021 };
    uint32_t const ces[9] = { 0x1DCB, 0x0261, 0x0000, 0x0020, 0x0020, 0x0000, 0x000B, 0x0002, 0x0000 };

    auto collation = collate_for_tests(
        cps, cps + 2, boost::text::variable_weighting::non_ignorable);

    EXPECT_EQ(collation.size(), 9);
    EXPECT_TRUE(boost::algorithm::equal(collation.begin(), collation.end(), ces, ces + 9))
        << "from:     " << ce_dumper(cps)
        << "expected: " << ce_dumper(ces)
        << "got:      " << ce_dumper(collation);
}

TEST(collation, non_ignorable_110_466)
{
    // 1D646 0021;	
    // (𝙆) MATHEMATICAL SANS-SERIF BOLD ITALIC CAPITAL K	[1DCB 0261 | 0020 0020 | 000B 0002 |]

    uint32_t cps[2] = { 0x1D646, 0x0021 };
    uint32_t const ces[9] = { 0x1DCB, 0x0261, 0x0000, 0x0020, 0x0020, 0x0000, 0x000B, 0x0002, 0x0000 };

    auto collation = collate_for_tests(
        cps, cps + 2, boost::text::variable_weighting::non_ignorable);

    EXPECT_EQ(collation.size(), 9);
    EXPECT_TRUE(boost::algorithm::equal(collation.begin(), collation.end(), ces, ces + 9))
        << "from:     " << ce_dumper(cps)
        << "expected: " << ce_dumper(ces)
        << "got:      " << ce_dumper(collation);
}

TEST(collation, non_ignorable_110_467)
{
    // 1D67A 0021;	
    // (𝙺) MATHEMATICAL MONOSPACE CAPITAL K	[1DCB 0261 | 0020 0020 | 000B 0002 |]

    uint32_t cps[2] = { 0x1D67A, 0x0021 };
    uint32_t const ces[9] = { 0x1DCB, 0x0261, 0x0000, 0x0020, 0x0020, 0x0000, 0x000B, 0x0002, 0x0000 };

    auto collation = collate_for_tests(
        cps, cps + 2, boost::text::variable_weighting::non_ignorable);

    EXPECT_EQ(collation.size(), 9);
    EXPECT_TRUE(boost::algorithm::equal(collation.begin(), collation.end(), ces, ces + 9))
        << "from:     " << ce_dumper(cps)
        << "expected: " << ce_dumper(ces)
        << "got:      " << ce_dumper(collation);
}

TEST(collation, non_ignorable_110_468)
{
    // 24C0 0021;	
    // (Ⓚ) CIRCLED LATIN CAPITAL LETTER K	[1DCB 0261 | 0020 0020 | 000C 0002 |]

    uint32_t cps[2] = { 0x24C0, 0x0021 };
    uint32_t const ces[9] = { 0x1DCB, 0x0261, 0x0000, 0x0020, 0x0020, 0x0000, 0x000C, 0x0002, 0x0000 };

    auto collation = collate_for_tests(
        cps, cps + 2, boost::text::variable_weighting::non_ignorable);

    EXPECT_EQ(collation.size(), 9);
    EXPECT_TRUE(boost::algorithm::equal(collation.begin(), collation.end(), ces, ces + 9))
        << "from:     " << ce_dumper(cps)
        << "expected: " << ce_dumper(ces)
        << "got:      " << ce_dumper(collation);
}

TEST(collation, non_ignorable_110_469)
{
    // 1F15A 0021;	
    // (🅚) NEGATIVE CIRCLED LATIN CAPITAL LETTER K	[1DCB 0261 | 0020 0020 | 000C 0002 |]

    uint32_t cps[2] = { 0x1F15A, 0x0021 };
    uint32_t const ces[9] = { 0x1DCB, 0x0261, 0x0000, 0x0020, 0x0020, 0x0000, 0x000C, 0x0002, 0x0000 };

    auto collation = collate_for_tests(
        cps, cps + 2, boost::text::variable_weighting::non_ignorable);

    EXPECT_EQ(collation.size(), 9);
    EXPECT_TRUE(boost::algorithm::equal(collation.begin(), collation.end(), ces, ces + 9))
        << "from:     " << ce_dumper(cps)
        << "expected: " << ce_dumper(ces)
        << "got:      " << ce_dumper(collation);
}

TEST(collation, non_ignorable_110_470)
{
    // 1D4F 0021;	
    // (ᵏ) MODIFIER LETTER SMALL K	[1DCB 0261 | 0020 0020 | 0014 0002 |]

    uint32_t cps[2] = { 0x1D4F, 0x0021 };
    uint32_t const ces[9] = { 0x1DCB, 0x0261, 0x0000, 0x0020, 0x0020, 0x0000, 0x0014, 0x0002, 0x0000 };

    auto collation = collate_for_tests(
        cps, cps + 2, boost::text::variable_weighting::non_ignorable);

    EXPECT_EQ(collation.size(), 9);
    EXPECT_TRUE(boost::algorithm::equal(collation.begin(), collation.end(), ces, ces + 9))
        << "from:     " << ce_dumper(cps)
        << "expected: " << ce_dumper(ces)
        << "got:      " << ce_dumper(collation);
}

TEST(collation, non_ignorable_110_471)
{
    // 2096 0021;	
    // (ₖ) LATIN SUBSCRIPT SMALL LETTER K	[1DCB 0261 | 0020 0020 | 0015 0002 |]

    uint32_t cps[2] = { 0x2096, 0x0021 };
    uint32_t const ces[9] = { 0x1DCB, 0x0261, 0x0000, 0x0020, 0x0020, 0x0000, 0x0015, 0x0002, 0x0000 };

    auto collation = collate_for_tests(
        cps, cps + 2, boost::text::variable_weighting::non_ignorable);

    EXPECT_EQ(collation.size(), 9);
    EXPECT_TRUE(boost::algorithm::equal(collation.begin(), collation.end(), ces, ces + 9))
        << "from:     " << ce_dumper(cps)
        << "expected: " << ce_dumper(ces)
        << "got:      " << ce_dumper(collation);
}

TEST(collation, non_ignorable_110_472)
{
    // 1D37 0021;	
    // (ᴷ) MODIFIER LETTER CAPITAL K	[1DCB 0261 | 0020 0020 | 001D 0002 |]

    uint32_t cps[2] = { 0x1D37, 0x0021 };
    uint32_t const ces[9] = { 0x1DCB, 0x0261, 0x0000, 0x0020, 0x0020, 0x0000, 0x001D, 0x0002, 0x0000 };

    auto collation = collate_for_tests(
        cps, cps + 2, boost::text::variable_weighting::non_ignorable);

    EXPECT_EQ(collation.size(), 9);
    EXPECT_TRUE(boost::algorithm::equal(collation.begin(), collation.end(), ces, ces + 9))
        << "from:     " << ce_dumper(cps)
        << "expected: " << ce_dumper(ces)
        << "got:      " << ce_dumper(collation);
}

TEST(collation, non_ignorable_110_473)
{
    // 1F13A 0021;	
    // (🄺) SQUARED LATIN CAPITAL LETTER K	[1DCB 0261 | 0020 0020 | 001D 0002 |]

    uint32_t cps[2] = { 0x1F13A, 0x0021 };
    uint32_t const ces[9] = { 0x1DCB, 0x0261, 0x0000, 0x0020, 0x0020, 0x0000, 0x001D, 0x0002, 0x0000 };

    auto collation = collate_for_tests(
        cps, cps + 2, boost::text::variable_weighting::non_ignorable);

    EXPECT_EQ(collation.size(), 9);
    EXPECT_TRUE(boost::algorithm::equal(collation.begin(), collation.end(), ces, ces + 9))
        << "from:     " << ce_dumper(cps)
        << "expected: " << ce_dumper(ces)
        << "got:      " << ce_dumper(collation);
}

TEST(collation, non_ignorable_110_474)
{
    // 1F17A 0021;	
    // (🅺) NEGATIVE SQUARED LATIN CAPITAL LETTER K	[1DCB 0261 | 0020 0020 | 001D 0002 |]

    uint32_t cps[2] = { 0x1F17A, 0x0021 };
    uint32_t const ces[9] = { 0x1DCB, 0x0261, 0x0000, 0x0020, 0x0020, 0x0000, 0x001D, 0x0002, 0x0000 };

    auto collation = collate_for_tests(
        cps, cps + 2, boost::text::variable_weighting::non_ignorable);

    EXPECT_EQ(collation.size(), 9);
    EXPECT_TRUE(boost::algorithm::equal(collation.begin(), collation.end(), ces, ces + 9))
        << "from:     " << ce_dumper(cps)
        << "expected: " << ce_dumper(ces)
        << "got:      " << ce_dumper(collation);
}

TEST(collation, non_ignorable_110_475)
{
    // 1E31 0021;	
    // (ḱ) LATIN SMALL LETTER K WITH ACUTE	[1DCB 0261 | 0020 0024 0020 | 0002 0002 0002 |]

    uint32_t cps[2] = { 0x1E31, 0x0021 };
    uint32_t const ces[11] = { 0x1DCB, 0x0261, 0x0000, 0x0020, 0x0024, 0x0020, 0x0000, 0x0002, 0x0002, 0x0002, 0x0000 };

    auto collation = collate_for_tests(
        cps, cps + 2, boost::text::variable_weighting::non_ignorable);

    EXPECT_EQ(collation.size(), 11);
    EXPECT_TRUE(boost::algorithm::equal(collation.begin(), collation.end(), ces, ces + 11))
        << "from:     " << ce_dumper(cps)
        << "expected: " << ce_dumper(ces)
        << "got:      " << ce_dumper(collation);
}

TEST(collation, non_ignorable_110_476)
{
    // 1E30 0021;	
    // (Ḱ) LATIN CAPITAL LETTER K WITH ACUTE	[1DCB 0261 | 0020 0024 0020 | 0008 0002 0002 |]

    uint32_t cps[2] = { 0x1E30, 0x0021 };
    uint32_t const ces[11] = { 0x1DCB, 0x0261, 0x0000, 0x0020, 0x0024, 0x0020, 0x0000, 0x0008, 0x0002, 0x0002, 0x0000 };

    auto collation = collate_for_tests(
        cps, cps + 2, boost::text::variable_weighting::non_ignorable);

    EXPECT_EQ(collation.size(), 11);
    EXPECT_TRUE(boost::algorithm::equal(collation.begin(), collation.end(), ces, ces + 11))
        << "from:     " << ce_dumper(cps)
        << "expected: " << ce_dumper(ces)
        << "got:      " << ce_dumper(collation);
}

TEST(collation, non_ignorable_110_477)
{
    // 01E9 0021;	
    // (ǩ) LATIN SMALL LETTER K WITH CARON	[1DCB 0261 | 0020 0028 0020 | 0002 0002 0002 |]

    uint32_t cps[2] = { 0x01E9, 0x0021 };
    uint32_t const ces[11] = { 0x1DCB, 0x0261, 0x0000, 0x0020, 0x0028, 0x0020, 0x0000, 0x0002, 0x0002, 0x0002, 0x0000 };

    auto collation = collate_for_tests(
        cps, cps + 2, boost::text::variable_weighting::non_ignorable);

    EXPECT_EQ(collation.size(), 11);
    EXPECT_TRUE(boost::algorithm::equal(collation.begin(), collation.end(), ces, ces + 11))
        << "from:     " << ce_dumper(cps)
        << "expected: " << ce_dumper(ces)
        << "got:      " << ce_dumper(collation);
}

TEST(collation, non_ignorable_110_478)
{
    // 01E8 0021;	
    // (Ǩ) LATIN CAPITAL LETTER K WITH CARON	[1DCB 0261 | 0020 0028 0020 | 0008 0002 0002 |]

    uint32_t cps[2] = { 0x01E8, 0x0021 };
    uint32_t const ces[11] = { 0x1DCB, 0x0261, 0x0000, 0x0020, 0x0028, 0x0020, 0x0000, 0x0008, 0x0002, 0x0002, 0x0000 };

    auto collation = collate_for_tests(
        cps, cps + 2, boost::text::variable_weighting::non_ignorable);

    EXPECT_EQ(collation.size(), 11);
    EXPECT_TRUE(boost::algorithm::equal(collation.begin(), collation.end(), ces, ces + 11))
        << "from:     " << ce_dumper(cps)
        << "expected: " << ce_dumper(ces)
        << "got:      " << ce_dumper(collation);
}

TEST(collation, non_ignorable_110_479)
{
    // 0137 0021;	
    // (ķ) LATIN SMALL LETTER K WITH CEDILLA	[1DCB 0261 | 0020 0030 0020 | 0002 0002 0002 |]

    uint32_t cps[2] = { 0x0137, 0x0021 };
    uint32_t const ces[11] = { 0x1DCB, 0x0261, 0x0000, 0x0020, 0x0030, 0x0020, 0x0000, 0x0002, 0x0002, 0x0002, 0x0000 };

    auto collation = collate_for_tests(
        cps, cps + 2, boost::text::variable_weighting::non_ignorable);

    EXPECT_EQ(collation.size(), 11);
    EXPECT_TRUE(boost::algorithm::equal(collation.begin(), collation.end(), ces, ces + 11))
        << "from:     " << ce_dumper(cps)
        << "expected: " << ce_dumper(ces)
        << "got:      " << ce_dumper(collation);
}

TEST(collation, non_ignorable_110_480)
{
    // 0136 0021;	
    // (Ķ) LATIN CAPITAL LETTER K WITH CEDILLA	[1DCB 0261 | 0020 0030 0020 | 0008 0002 0002 |]

    uint32_t cps[2] = { 0x0136, 0x0021 };
    uint32_t const ces[11] = { 0x1DCB, 0x0261, 0x0000, 0x0020, 0x0030, 0x0020, 0x0000, 0x0008, 0x0002, 0x0002, 0x0000 };

    auto collation = collate_for_tests(
        cps, cps + 2, boost::text::variable_weighting::non_ignorable);

    EXPECT_EQ(collation.size(), 11);
    EXPECT_TRUE(boost::algorithm::equal(collation.begin(), collation.end(), ces, ces + 11))
        << "from:     " << ce_dumper(cps)
        << "expected: " << ce_dumper(ces)
        << "got:      " << ce_dumper(collation);
}

TEST(collation, non_ignorable_110_481)
{
    // A7A3 0021;	
    // (ꞣ) LATIN SMALL LETTER K WITH OBLIQUE STROKE	[1DCB 0261 | 0020 0035 0020 | 0004 0004 0002 |]

    uint32_t cps[2] = { 0xA7A3, 0x0021 };
    uint32_t const ces[11] = { 0x1DCB, 0x0261, 0x0000, 0x0020, 0x0035, 0x0020, 0x0000, 0x0004, 0x0004, 0x0002, 0x0000 };

    auto collation = collate_for_tests(
        cps, cps + 2, boost::text::variable_weighting::non_ignorable);

    EXPECT_EQ(collation.size(), 11);
    EXPECT_TRUE(boost::algorithm::equal(collation.begin(), collation.end(), ces, ces + 11))
        << "from:     " << ce_dumper(cps)
        << "expected: " << ce_dumper(ces)
        << "got:      " << ce_dumper(collation);
}

TEST(collation, non_ignorable_110_482)
{
    // A7A2 0021;	
    // (Ꞣ) LATIN CAPITAL LETTER K WITH OBLIQUE STROKE	[1DCB 0261 | 0020 0035 0020 | 000A 0004 0002 |]

    uint32_t cps[2] = { 0xA7A2, 0x0021 };
    uint32_t const ces[11] = { 0x1DCB, 0x0261, 0x0000, 0x0020, 0x0035, 0x0020, 0x0000, 0x000A, 0x0004, 0x0002, 0x0000 };

    auto collation = collate_for_tests(
        cps, cps + 2, boost::text::variable_weighting::non_ignorable);

    EXPECT_EQ(collation.size(), 11);
    EXPECT_TRUE(boost::algorithm::equal(collation.begin(), collation.end(), ces, ces + 11))
        << "from:     " << ce_dumper(cps)
        << "expected: " << ce_dumper(ces)
        << "got:      " << ce_dumper(collation);
}

TEST(collation, non_ignorable_110_483)
{
    // 1E33 0021;	
    // (ḳ) LATIN SMALL LETTER K WITH DOT BELOW	[1DCB 0261 | 0020 0042 0020 | 0002 0002 0002 |]

    uint32_t cps[2] = { 0x1E33, 0x0021 };
    uint32_t const ces[11] = { 0x1DCB, 0x0261, 0x0000, 0x0020, 0x0042, 0x0020, 0x0000, 0x0002, 0x0002, 0x0002, 0x0000 };

    auto collation = collate_for_tests(
        cps, cps + 2, boost::text::variable_weighting::non_ignorable);

    EXPECT_EQ(collation.size(), 11);
    EXPECT_TRUE(boost::algorithm::equal(collation.begin(), collation.end(), ces, ces + 11))
        << "from:     " << ce_dumper(cps)
        << "expected: " << ce_dumper(ces)
        << "got:      " << ce_dumper(collation);
}

TEST(collation, non_ignorable_110_484)
{
    // 1E32 0021;	
    // (Ḳ) LATIN CAPITAL LETTER K WITH DOT BELOW	[1DCB 0261 | 0020 0042 0020 | 0008 0002 0002 |]

    uint32_t cps[2] = { 0x1E32, 0x0021 };
    uint32_t const ces[11] = { 0x1DCB, 0x0261, 0x0000, 0x0020, 0x0042, 0x0020, 0x0000, 0x0008, 0x0002, 0x0002, 0x0000 };

    auto collation = collate_for_tests(
        cps, cps + 2, boost::text::variable_weighting::non_ignorable);

    EXPECT_EQ(collation.size(), 11);
    EXPECT_TRUE(boost::algorithm::equal(collation.begin(), collation.end(), ces, ces + 11))
        << "from:     " << ce_dumper(cps)
        << "expected: " << ce_dumper(ces)
        << "got:      " << ce_dumper(collation);
}

TEST(collation, non_ignorable_110_485)
{
    // 1E35 0021;	
    // (ḵ) LATIN SMALL LETTER K WITH LINE BELOW	[1DCB 0261 | 0020 0049 0020 | 0002 0002 0002 |]

    uint32_t cps[2] = { 0x1E35, 0x0021 };
    uint32_t const ces[11] = { 0x1DCB, 0x0261, 0x0000, 0x0020, 0x0049, 0x0020, 0x0000, 0x0002, 0x0002, 0x0002, 0x0000 };

    auto collation = collate_for_tests(
        cps, cps + 2, boost::text::variable_weighting::non_ignorable);

    EXPECT_EQ(collation.size(), 11);
    EXPECT_TRUE(boost::algorithm::equal(collation.begin(), collation.end(), ces, ces + 11))
        << "from:     " << ce_dumper(cps)
        << "expected: " << ce_dumper(ces)
        << "got:      " << ce_dumper(collation);
}

TEST(collation, non_ignorable_110_486)
{
    // 1E34 0021;	
    // (Ḵ) LATIN CAPITAL LETTER K WITH LINE BELOW	[1DCB 0261 | 0020 0049 0020 | 0008 0002 0002 |]

    uint32_t cps[2] = { 0x1E34, 0x0021 };
    uint32_t const ces[11] = { 0x1DCB, 0x0261, 0x0000, 0x0020, 0x0049, 0x0020, 0x0000, 0x0008, 0x0002, 0x0002, 0x0000 };

    auto collation = collate_for_tests(
        cps, cps + 2, boost::text::variable_weighting::non_ignorable);

    EXPECT_EQ(collation.size(), 11);
    EXPECT_TRUE(boost::algorithm::equal(collation.begin(), collation.end(), ces, ces + 11))
        << "from:     " << ce_dumper(cps)
        << "expected: " << ce_dumper(ces)
        << "got:      " << ce_dumper(collation);
}

TEST(collation, non_ignorable_110_487)
{
    // 006B 003F;	
    // (k) LATIN SMALL LETTER K	[1DCB 0267 | 0020 0020 | 0002 0002 |]

    uint32_t cps[2] = { 0x006B, 0x003F };
    uint32_t const ces[9] = { 0x1DCB, 0x0267, 0x0000, 0x0020, 0x0020, 0x0000, 0x0002, 0x0002, 0x0000 };

    auto collation = collate_for_tests(
        cps, cps + 2, boost::text::variable_weighting::non_ignorable);

    EXPECT_EQ(collation.size(), 9);
    EXPECT_TRUE(boost::algorithm::equal(collation.begin(), collation.end(), ces, ces + 9))
        << "from:     " << ce_dumper(cps)
        << "expected: " << ce_dumper(ces)
        << "got:      " << ce_dumper(collation);
}

TEST(collation, non_ignorable_110_488)
{
    // FF4B 003F;	
    // (ｋ) FULLWIDTH LATIN SMALL LETTER K	[1DCB 0267 | 0020 0020 | 0003 0002 |]

    uint32_t cps[2] = { 0xFF4B, 0x003F };
    uint32_t const ces[9] = { 0x1DCB, 0x0267, 0x0000, 0x0020, 0x0020, 0x0000, 0x0003, 0x0002, 0x0000 };

    auto collation = collate_for_tests(
        cps, cps + 2, boost::text::variable_weighting::non_ignorable);

    EXPECT_EQ(collation.size(), 9);
    EXPECT_TRUE(boost::algorithm::equal(collation.begin(), collation.end(), ces, ces + 9))
        << "from:     " << ce_dumper(cps)
        << "expected: " << ce_dumper(ces)
        << "got:      " << ce_dumper(collation);
}

TEST(collation, non_ignorable_110_489)
{
    // 1DDC 003F;	
    // (ᷜ) COMBINING LATIN SMALL LETTER K	[1DCB 0267 | 0020 0020 | 0004 0002 |]

    uint32_t cps[2] = { 0x1DDC, 0x003F };
    uint32_t const ces[9] = { 0x1DCB, 0x0267, 0x0000, 0x0020, 0x0020, 0x0000, 0x0004, 0x0002, 0x0000 };

    auto collation = collate_for_tests(
        cps, cps + 2, boost::text::variable_weighting::non_ignorable);

    EXPECT_EQ(collation.size(), 9);
    EXPECT_TRUE(boost::algorithm::equal(collation.begin(), collation.end(), ces, ces + 9))
        << "from:     " << ce_dumper(cps)
        << "expected: " << ce_dumper(ces)
        << "got:      " << ce_dumper(collation);
}

TEST(collation, non_ignorable_110_490)
{
    // 1D424 003F;	
    // (𝐤) MATHEMATICAL BOLD SMALL K	[1DCB 0267 | 0020 0020 | 0005 0002 |]

    uint32_t cps[2] = { 0x1D424, 0x003F };
    uint32_t const ces[9] = { 0x1DCB, 0x0267, 0x0000, 0x0020, 0x0020, 0x0000, 0x0005, 0x0002, 0x0000 };

    auto collation = collate_for_tests(
        cps, cps + 2, boost::text::variable_weighting::non_ignorable);

    EXPECT_EQ(collation.size(), 9);
    EXPECT_TRUE(boost::algorithm::equal(collation.begin(), collation.end(), ces, ces + 9))
        << "from:     " << ce_dumper(cps)
        << "expected: " << ce_dumper(ces)
        << "got:      " << ce_dumper(collation);
}

TEST(collation, non_ignorable_110_491)
{
    // 1D458 003F;	
    // (𝑘) MATHEMATICAL ITALIC SMALL K	[1DCB 0267 | 0020 0020 | 0005 0002 |]

    uint32_t cps[2] = { 0x1D458, 0x003F };
    uint32_t const ces[9] = { 0x1DCB, 0x0267, 0x0000, 0x0020, 0x0020, 0x0000, 0x0005, 0x0002, 0x0000 };

    auto collation = collate_for_tests(
        cps, cps + 2, boost::text::variable_weighting::non_ignorable);

    EXPECT_EQ(collation.size(), 9);
    EXPECT_TRUE(boost::algorithm::equal(collation.begin(), collation.end(), ces, ces + 9))
        << "from:     " << ce_dumper(cps)
        << "expected: " << ce_dumper(ces)
        << "got:      " << ce_dumper(collation);
}

TEST(collation, non_ignorable_110_492)
{
    // 1D48C 003F;	
    // (𝒌) MATHEMATICAL BOLD ITALIC SMALL K	[1DCB 0267 | 0020 0020 | 0005 0002 |]

    uint32_t cps[2] = { 0x1D48C, 0x003F };
    uint32_t const ces[9] = { 0x1DCB, 0x0267, 0x0000, 0x0020, 0x0020, 0x0000, 0x0005, 0x0002, 0x0000 };

    auto collation = collate_for_tests(
        cps, cps + 2, boost::text::variable_weighting::non_ignorable);

    EXPECT_EQ(collation.size(), 9);
    EXPECT_TRUE(boost::algorithm::equal(collation.begin(), collation.end(), ces, ces + 9))
        << "from:     " << ce_dumper(cps)
        << "expected: " << ce_dumper(ces)
        << "got:      " << ce_dumper(collation);
}

TEST(collation, non_ignorable_110_493)
{
    // 1D4C0 003F;	
    // (𝓀) MATHEMATICAL SCRIPT SMALL K	[1DCB 0267 | 0020 0020 | 0005 0002 |]

    uint32_t cps[2] = { 0x1D4C0, 0x003F };
    uint32_t const ces[9] = { 0x1DCB, 0x0267, 0x0000, 0x0020, 0x0020, 0x0000, 0x0005, 0x0002, 0x0000 };

    auto collation = collate_for_tests(
        cps, cps + 2, boost::text::variable_weighting::non_ignorable);

    EXPECT_EQ(collation.size(), 9);
    EXPECT_TRUE(boost::algorithm::equal(collation.begin(), collation.end(), ces, ces + 9))
        << "from:     " << ce_dumper(cps)
        << "expected: " << ce_dumper(ces)
        << "got:      " << ce_dumper(collation);
}

TEST(collation, non_ignorable_110_494)
{
    // 1D4F4 003F;	
    // (𝓴) MATHEMATICAL BOLD SCRIPT SMALL K	[1DCB 0267 | 0020 0020 | 0005 0002 |]

    uint32_t cps[2] = { 0x1D4F4, 0x003F };
    uint32_t const ces[9] = { 0x1DCB, 0x0267, 0x0000, 0x0020, 0x0020, 0x0000, 0x0005, 0x0002, 0x0000 };

    auto collation = collate_for_tests(
        cps, cps + 2, boost::text::variable_weighting::non_ignorable);

    EXPECT_EQ(collation.size(), 9);
    EXPECT_TRUE(boost::algorithm::equal(collation.begin(), collation.end(), ces, ces + 9))
        << "from:     " << ce_dumper(cps)
        << "expected: " << ce_dumper(ces)
        << "got:      " << ce_dumper(collation);
}

TEST(collation, non_ignorable_110_495)
{
    // 1D528 003F;	
    // (𝔨) MATHEMATICAL FRAKTUR SMALL K	[1DCB 0267 | 0020 0020 | 0005 0002 |]

    uint32_t cps[2] = { 0x1D528, 0x003F };
    uint32_t const ces[9] = { 0x1DCB, 0x0267, 0x0000, 0x0020, 0x0020, 0x0000, 0x0005, 0x0002, 0x0000 };

    auto collation = collate_for_tests(
        cps, cps + 2, boost::text::variable_weighting::non_ignorable);

    EXPECT_EQ(collation.size(), 9);
    EXPECT_TRUE(boost::algorithm::equal(collation.begin(), collation.end(), ces, ces + 9))
        << "from:     " << ce_dumper(cps)
        << "expected: " << ce_dumper(ces)
        << "got:      " << ce_dumper(collation);
}

TEST(collation, non_ignorable_110_496)
{
    // 1D55C 003F;	
    // (𝕜) MATHEMATICAL DOUBLE-STRUCK SMALL K	[1DCB 0267 | 0020 0020 | 0005 0002 |]

    uint32_t cps[2] = { 0x1D55C, 0x003F };
    uint32_t const ces[9] = { 0x1DCB, 0x0267, 0x0000, 0x0020, 0x0020, 0x0000, 0x0005, 0x0002, 0x0000 };

    auto collation = collate_for_tests(
        cps, cps + 2, boost::text::variable_weighting::non_ignorable);

    EXPECT_EQ(collation.size(), 9);
    EXPECT_TRUE(boost::algorithm::equal(collation.begin(), collation.end(), ces, ces + 9))
        << "from:     " << ce_dumper(cps)
        << "expected: " << ce_dumper(ces)
        << "got:      " << ce_dumper(collation);
}

TEST(collation, non_ignorable_110_497)
{
    // 1D590 003F;	
    // (𝖐) MATHEMATICAL BOLD FRAKTUR SMALL K	[1DCB 0267 | 0020 0020 | 0005 0002 |]

    uint32_t cps[2] = { 0x1D590, 0x003F };
    uint32_t const ces[9] = { 0x1DCB, 0x0267, 0x0000, 0x0020, 0x0020, 0x0000, 0x0005, 0x0002, 0x0000 };

    auto collation = collate_for_tests(
        cps, cps + 2, boost::text::variable_weighting::non_ignorable);

    EXPECT_EQ(collation.size(), 9);
    EXPECT_TRUE(boost::algorithm::equal(collation.begin(), collation.end(), ces, ces + 9))
        << "from:     " << ce_dumper(cps)
        << "expected: " << ce_dumper(ces)
        << "got:      " << ce_dumper(collation);
}

TEST(collation, non_ignorable_110_498)
{
    // 1D5C4 003F;	
    // (𝗄) MATHEMATICAL SANS-SERIF SMALL K	[1DCB 0267 | 0020 0020 | 0005 0002 |]

    uint32_t cps[2] = { 0x1D5C4, 0x003F };
    uint32_t const ces[9] = { 0x1DCB, 0x0267, 0x0000, 0x0020, 0x0020, 0x0000, 0x0005, 0x0002, 0x0000 };

    auto collation = collate_for_tests(
        cps, cps + 2, boost::text::variable_weighting::non_ignorable);

    EXPECT_EQ(collation.size(), 9);
    EXPECT_TRUE(boost::algorithm::equal(collation.begin(), collation.end(), ces, ces + 9))
        << "from:     " << ce_dumper(cps)
        << "expected: " << ce_dumper(ces)
        << "got:      " << ce_dumper(collation);
}

TEST(collation, non_ignorable_110_499)
{
    // 1D5F8 003F;	
    // (𝗸) MATHEMATICAL SANS-SERIF BOLD SMALL K	[1DCB 0267 | 0020 0020 | 0005 0002 |]

    uint32_t cps[2] = { 0x1D5F8, 0x003F };
    uint32_t const ces[9] = { 0x1DCB, 0x0267, 0x0000, 0x0020, 0x0020, 0x0000, 0x0005, 0x0002, 0x0000 };

    auto collation = collate_for_tests(
        cps, cps + 2, boost::text::variable_weighting::non_ignorable);

    EXPECT_EQ(collation.size(), 9);
    EXPECT_TRUE(boost::algorithm::equal(collation.begin(), collation.end(), ces, ces + 9))
        << "from:     " << ce_dumper(cps)
        << "expected: " << ce_dumper(ces)
        << "got:      " << ce_dumper(collation);
}

